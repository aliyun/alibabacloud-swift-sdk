import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AbolishApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class AbolishApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AbolishApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbolishApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AbolishApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAccessControlListEntryRequest : Tea.TeaModel {
    public var aclEntrys: String?

    public var aclId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntrys != nil {
            map["AclEntrys"] = self.aclEntrys!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntrys") {
            self.aclEntrys = dict["AclEntrys"] as! String
        }
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class AddAccessControlListEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddAccessControlListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAccessControlListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAccessControlListEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddIpControlPolicyItemRequest : Tea.TeaModel {
    public var appId: String?

    public var cidrIp: String?

    public var ipControlId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cidrIp != nil {
            map["CidrIp"] = self.cidrIp!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CidrIp") {
            self.cidrIp = dict["CidrIp"] as! String
        }
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class AddIpControlPolicyItemResponseBody : Tea.TeaModel {
    public var policyItemId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyItemId != nil {
            map["PolicyItemId"] = self.policyItemId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyItemId") {
            self.policyItemId = dict["PolicyItemId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddIpControlPolicyItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddIpControlPolicyItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddIpControlPolicyItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTrafficSpecialControlRequest : Tea.TeaModel {
    public var securityToken: String?

    public var specialKey: String?

    public var specialType: String?

    public var trafficControlId: String?

    public var trafficValue: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.specialKey != nil {
            map["SpecialKey"] = self.specialKey!
        }
        if self.specialType != nil {
            map["SpecialType"] = self.specialType!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        if self.trafficValue != nil {
            map["TrafficValue"] = self.trafficValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SpecialKey") {
            self.specialKey = dict["SpecialKey"] as! String
        }
        if dict.keys.contains("SpecialType") {
            self.specialType = dict["SpecialType"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
        if dict.keys.contains("TrafficValue") {
            self.trafficValue = dict["TrafficValue"] as! Int32
        }
    }
}

public class AddTrafficSpecialControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddTrafficSpecialControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTrafficSpecialControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTrafficSpecialControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachPluginRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiIds: String?

    public var groupId: String?

    public var pluginId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class AttachPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchAbolishApisRequest : Tea.TeaModel {
    public class Api : Tea.TeaModel {
        public var apiUid: String?

        public var groupId: String?

        public var stageId: String?

        public var stageName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiUid != nil {
                map["ApiUid"] = self.apiUid!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.stageId != nil {
                map["StageId"] = self.stageId!
            }
            if self.stageName != nil {
                map["StageName"] = self.stageName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiUid") {
                self.apiUid = dict["ApiUid"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("StageId") {
                self.stageId = dict["StageId"] as! String
            }
            if dict.keys.contains("StageName") {
                self.stageName = dict["StageName"] as! String
            }
        }
    }
    public var api: [BatchAbolishApisRequest.Api]?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.api != nil {
            var tmp : [Any] = []
            for k in self.api! {
                tmp.append(k.toMap())
            }
            map["Api"] = tmp
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Api") {
            self.api = dict["Api"] as! [BatchAbolishApisRequest.Api]
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchAbolishApisResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchAbolishApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchAbolishApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchAbolishApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchDeployApisRequest : Tea.TeaModel {
    public class Api : Tea.TeaModel {
        public var apiUid: String?

        public var groupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiUid != nil {
                map["ApiUid"] = self.apiUid!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiUid") {
                self.apiUid = dict["ApiUid"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
        }
    }
    public var api: [BatchDeployApisRequest.Api]?

    public var description_: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.api != nil {
            var tmp : [Any] = []
            for k in self.api! {
                tmp.append(k.toMap())
            }
            map["Api"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Api") {
            self.api = dict["Api"] as! [BatchDeployApisRequest.Api]
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class BatchDeployApisResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchDeployApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchDeployApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchDeployApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAccessControlListRequest : Tea.TeaModel {
    public var aclName: String?

    public var addressIPVersion: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclName") {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("AddressIPVersion") {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateAccessControlListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAccessControlListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAccessControlListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAccessControlListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApiRequest : Tea.TeaModel {
    public var allowSignatureMethod: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendEnable: Bool?

    public var backendId: String?

    public var constantParameters: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: String?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var openIdConnectConfig: String?

    public var requestConfig: String?

    public var requestParameters: String?

    public var resultBodyModel: String?

    public var resultDescriptions: String?

    public var resultSample: String?

    public var resultType: String?

    public var securityToken: String?

    public var serviceConfig: String?

    public var serviceParameters: String?

    public var serviceParametersMap: String?

    public var systemParameters: String?

    public var visibility: String?

    public var webSocketApiType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendEnable != nil {
            map["BackendEnable"] = self.backendEnable!
        }
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples!
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters!
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions!
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig!
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters!
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap!
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.webSocketApiType != nil {
            map["WebSocketApiType"] = self.webSocketApiType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendEnable") {
            self.backendEnable = dict["BackendEnable"] as! Bool
        }
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("ConstantParameters") {
            self.constantParameters = dict["ConstantParameters"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") {
            self.errorCodeSamples = dict["ErrorCodeSamples"] as! String
        }
        if dict.keys.contains("FailResultSample") {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") {
            self.openIdConnectConfig = dict["OpenIdConnectConfig"] as! String
        }
        if dict.keys.contains("RequestConfig") {
            self.requestConfig = dict["RequestConfig"] as! String
        }
        if dict.keys.contains("RequestParameters") {
            self.requestParameters = dict["RequestParameters"] as! String
        }
        if dict.keys.contains("ResultBodyModel") {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultDescriptions") {
            self.resultDescriptions = dict["ResultDescriptions"] as! String
        }
        if dict.keys.contains("ResultSample") {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("ServiceConfig") {
            self.serviceConfig = dict["ServiceConfig"] as! String
        }
        if dict.keys.contains("ServiceParameters") {
            self.serviceParameters = dict["ServiceParameters"] as! String
        }
        if dict.keys.contains("ServiceParametersMap") {
            self.serviceParametersMap = dict["ServiceParametersMap"] as! String
        }
        if dict.keys.contains("SystemParameters") {
            self.systemParameters = dict["SystemParameters"] as! String
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WebSocketApiType") {
            self.webSocketApiType = dict["WebSocketApiType"] as! String
        }
    }
}

public class CreateApiResponseBody : Tea.TeaModel {
    public var apiId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApiGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var basePath: String?

    public var description_: String?

    public var groupName: String?

    public var instanceId: String?

    public var securityToken: String?

    public var tag: [CreateApiGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateApiGroupRequest.Tag]
        }
    }
}

public class CreateApiGroupResponseBody : Tea.TeaModel {
    public var basePath: String?

    public var description_: String?

    public var groupId: String?

    public var groupName: String?

    public var instanceId: String?

    public var instanceType: String?

    public var requestId: String?

    public var subDomain: String?

    public var tagStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.tagStatus != nil {
            map["TagStatus"] = self.tagStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("TagStatus") {
            self.tagStatus = dict["TagStatus"] as! Bool
        }
    }
}

public class CreateApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApiStageVariableRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public var stageId: String?

    public var stageRouteModel: String?

    public var supportRoute: Bool?

    public var variableName: String?

    public var variableValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageId != nil {
            map["StageId"] = self.stageId!
        }
        if self.stageRouteModel != nil {
            map["StageRouteModel"] = self.stageRouteModel!
        }
        if self.supportRoute != nil {
            map["SupportRoute"] = self.supportRoute!
        }
        if self.variableName != nil {
            map["VariableName"] = self.variableName!
        }
        if self.variableValue != nil {
            map["VariableValue"] = self.variableValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageId") {
            self.stageId = dict["StageId"] as! String
        }
        if dict.keys.contains("StageRouteModel") {
            self.stageRouteModel = dict["StageRouteModel"] as! String
        }
        if dict.keys.contains("SupportRoute") {
            self.supportRoute = dict["SupportRoute"] as! Bool
        }
        if dict.keys.contains("VariableName") {
            self.variableName = dict["VariableName"] as! String
        }
        if dict.keys.contains("VariableValue") {
            self.variableValue = dict["VariableValue"] as! String
        }
    }
}

public class CreateApiStageVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateApiStageVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApiStageVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApiStageVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAppRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appCode: String?

    public var appKey: String?

    public var appName: String?

    public var appSecret: String?

    public var description_: String?

    public var securityToken: String?

    public var source: String?

    public var tag: [CreateAppRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCode != nil {
            map["AppCode"] = self.appCode!
        }
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appSecret != nil {
            map["AppSecret"] = self.appSecret!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCode") {
            self.appCode = dict["AppCode"] as! String
        }
        if dict.keys.contains("AppKey") {
            self.appKey = dict["AppKey"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppSecret") {
            self.appSecret = dict["AppSecret"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateAppRequest.Tag]
        }
    }
}

public class CreateAppResponseBody : Tea.TeaModel {
    public var appId: Int64?

    public var requestId: String?

    public var tagStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagStatus != nil {
            map["TagStatus"] = self.tagStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagStatus") {
            self.tagStatus = dict["TagStatus"] as! Bool
        }
    }
}

public class CreateAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBackendRequest : Tea.TeaModel {
    public var backendName: String?

    public var backendType: String?

    public var createEventBridgeServiceLinkedRole: Bool?

    public var description_: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.createEventBridgeServiceLinkedRole != nil {
            map["CreateEventBridgeServiceLinkedRole"] = self.createEventBridgeServiceLinkedRole!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendName") {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("BackendType") {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("CreateEventBridgeServiceLinkedRole") {
            self.createEventBridgeServiceLinkedRole = dict["CreateEventBridgeServiceLinkedRole"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateBackendResponseBody : Tea.TeaModel {
    public var backendId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBackendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBackendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBackendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBackendModelRequest : Tea.TeaModel {
    public var backendId: String?

    public var backendModelData: String?

    public var backendType: String?

    public var description_: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.backendModelData != nil {
            map["BackendModelData"] = self.backendModelData!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("BackendModelData") {
            self.backendModelData = dict["BackendModelData"] as! String
        }
        if dict.keys.contains("BackendType") {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class CreateBackendModelResponseBody : Tea.TeaModel {
    public var backendModelId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendModelId != nil {
            map["BackendModelId"] = self.backendModelId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendModelId") {
            self.backendModelId = dict["BackendModelId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBackendModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBackendModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBackendModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDatasetRequest : Tea.TeaModel {
    public var datasetName: String?

    public var datasetType: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetName != nil {
            map["DatasetName"] = self.datasetName!
        }
        if self.datasetType != nil {
            map["DatasetType"] = self.datasetType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetName") {
            self.datasetName = dict["DatasetName"] as! String
        }
        if dict.keys.contains("DatasetType") {
            self.datasetType = dict["DatasetType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateDatasetResponseBody : Tea.TeaModel {
    public var datasetId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDatasetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDatasetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDatasetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDatasetItemRequest : Tea.TeaModel {
    public var datasetId: String?

    public var description_: String?

    public var expiredTime: String?

    public var securityToken: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class CreateDatasetItemResponseBody : Tea.TeaModel {
    public var datasetItemId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetItemId != nil {
            map["DatasetItemId"] = self.datasetItemId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetItemId") {
            self.datasetItemId = dict["DatasetItemId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDatasetItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDatasetItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDatasetItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoPay: Bool?

    public var chargeType: String?

    public var duration: Int32?

    public var httpsPolicy: String?

    public var instanceName: String?

    public var instanceSpec: String?

    public var pricingCycle: String?

    public var tag: [CreateInstanceRequest.Tag]?

    public var token: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.httpsPolicy != nil {
            map["HttpsPolicy"] = self.httpsPolicy!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceSpec != nil {
            map["InstanceSpec"] = self.instanceSpec!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("HttpsPolicy") {
            self.httpsPolicy = dict["HttpsPolicy"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceSpec") {
            self.instanceSpec = dict["InstanceSpec"] as! String
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateInstanceRequest.Tag]
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public var tagStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagStatus != nil {
            map["TagStatus"] = self.tagStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagStatus") {
            self.tagStatus = dict["TagStatus"] as! Bool
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIntranetDomainRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateIntranetDomainResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIntranetDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIntranetDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIntranetDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIpControlRequest : Tea.TeaModel {
    public class IpControlPolicys : Tea.TeaModel {
        public var appId: String?

        public var cidrIp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.cidrIp != nil {
                map["CidrIp"] = self.cidrIp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CidrIp") {
                self.cidrIp = dict["CidrIp"] as! String
            }
        }
    }
    public var description_: String?

    public var ipControlName: String?

    public var ipControlPolicys: [CreateIpControlRequest.IpControlPolicys]?

    public var ipControlType: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipControlName != nil {
            map["IpControlName"] = self.ipControlName!
        }
        if self.ipControlPolicys != nil {
            var tmp : [Any] = []
            for k in self.ipControlPolicys! {
                tmp.append(k.toMap())
            }
            map["IpControlPolicys"] = tmp
        }
        if self.ipControlType != nil {
            map["IpControlType"] = self.ipControlType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpControlName") {
            self.ipControlName = dict["IpControlName"] as! String
        }
        if dict.keys.contains("IpControlPolicys") {
            self.ipControlPolicys = dict["IpControlPolicys"] as! [CreateIpControlRequest.IpControlPolicys]
        }
        if dict.keys.contains("IpControlType") {
            self.ipControlType = dict["IpControlType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateIpControlResponseBody : Tea.TeaModel {
    public var ipControlId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIpControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIpControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLogConfigRequest : Tea.TeaModel {
    public var logType: String?

    public var securityToken: String?

    public var slsLogStore: String?

    public var slsProject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logType != nil {
            map["LogType"] = self.logType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.slsLogStore != nil {
            map["SlsLogStore"] = self.slsLogStore!
        }
        if self.slsProject != nil {
            map["SlsProject"] = self.slsProject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogType") {
            self.logType = dict["LogType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SlsLogStore") {
            self.slsLogStore = dict["SlsLogStore"] as! String
        }
        if dict.keys.contains("SlsProject") {
            self.slsProject = dict["SlsProject"] as! String
        }
    }
}

public class CreateLogConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateModelRequest : Tea.TeaModel {
    public var description_: String?

    public var groupId: String?

    public var modelName: String?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelName") {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
    }
}

public class CreateModelResponseBody : Tea.TeaModel {
    public var createdTime: String?

    public var description_: String?

    public var groupId: String?

    public var modelId: String?

    public var modelName: String?

    public var modelRef: String?

    public var modifiedTime: String?

    public var regionId: String?

    public var requestId: String?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelId != nil {
            map["ModelId"] = self.modelId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.modelRef != nil {
            map["ModelRef"] = self.modelRef!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelId") {
            self.modelId = dict["ModelId"] as! String
        }
        if dict.keys.contains("ModelName") {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("ModelRef") {
            self.modelRef = dict["ModelRef"] as! String
        }
        if dict.keys.contains("ModifiedTime") {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
    }
}

public class CreateModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMonitorGroupRequest : Tea.TeaModel {
    public var auth: String?

    public var groupId: String?

    public var rawMonitorGroupId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auth != nil {
            map["Auth"] = self.auth!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.rawMonitorGroupId != nil {
            map["RawMonitorGroupId"] = self.rawMonitorGroupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Auth") {
            self.auth = dict["Auth"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RawMonitorGroupId") {
            self.rawMonitorGroupId = dict["RawMonitorGroupId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class CreateMonitorGroupResponseBody : Tea.TeaModel {
    public var monitorGroupId: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorGroupId != nil {
            map["MonitorGroupId"] = self.monitorGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorGroupId") {
            self.monitorGroupId = dict["MonitorGroupId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateMonitorGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMonitorGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMonitorGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePluginRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var description_: String?

    public var pluginData: String?

    public var pluginName: String?

    public var pluginType: String?

    public var securityToken: String?

    public var tag: [CreatePluginRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.pluginData != nil {
            map["PluginData"] = self.pluginData!
        }
        if self.pluginName != nil {
            map["PluginName"] = self.pluginName!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("PluginData") {
            self.pluginData = dict["PluginData"] as! String
        }
        if dict.keys.contains("PluginName") {
            self.pluginName = dict["PluginName"] as! String
        }
        if dict.keys.contains("PluginType") {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreatePluginRequest.Tag]
        }
    }
}

public class CreatePluginResponseBody : Tea.TeaModel {
    public var pluginId: String?

    public var requestId: String?

    public var tagStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagStatus != nil {
            map["TagStatus"] = self.tagStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagStatus") {
            self.tagStatus = dict["TagStatus"] as! Bool
        }
    }
}

public class CreatePluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSignatureRequest : Tea.TeaModel {
    public var securityToken: String?

    public var signatureKey: String?

    public var signatureName: String?

    public var signatureSecret: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureKey != nil {
            map["SignatureKey"] = self.signatureKey!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        if self.signatureSecret != nil {
            map["SignatureSecret"] = self.signatureSecret!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureKey") {
            self.signatureKey = dict["SignatureKey"] as! String
        }
        if dict.keys.contains("SignatureName") {
            self.signatureName = dict["SignatureName"] as! String
        }
        if dict.keys.contains("SignatureSecret") {
            self.signatureSecret = dict["SignatureSecret"] as! String
        }
    }
}

public class CreateSignatureResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var signatureId: String?

    public var signatureName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SignatureId") {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("SignatureName") {
            self.signatureName = dict["SignatureName"] as! String
        }
    }
}

public class CreateSignatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSignatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSignatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTrafficControlRequest : Tea.TeaModel {
    public var apiDefault: Int32?

    public var appDefault: Int32?

    public var description_: String?

    public var securityToken: String?

    public var trafficControlName: String?

    public var trafficControlUnit: String?

    public var userDefault: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDefault != nil {
            map["ApiDefault"] = self.apiDefault!
        }
        if self.appDefault != nil {
            map["AppDefault"] = self.appDefault!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlName != nil {
            map["TrafficControlName"] = self.trafficControlName!
        }
        if self.trafficControlUnit != nil {
            map["TrafficControlUnit"] = self.trafficControlUnit!
        }
        if self.userDefault != nil {
            map["UserDefault"] = self.userDefault!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDefault") {
            self.apiDefault = dict["ApiDefault"] as! Int32
        }
        if dict.keys.contains("AppDefault") {
            self.appDefault = dict["AppDefault"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlName") {
            self.trafficControlName = dict["TrafficControlName"] as! String
        }
        if dict.keys.contains("TrafficControlUnit") {
            self.trafficControlUnit = dict["TrafficControlUnit"] as! String
        }
        if dict.keys.contains("UserDefault") {
            self.userDefault = dict["UserDefault"] as! Int32
        }
    }
}

public class CreateTrafficControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class CreateTrafficControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTrafficControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTrafficControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAccessControlListRequest : Tea.TeaModel {
    public var aclId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteAccessControlListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAccessControlListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAccessControlListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAccessControlListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAllTrafficSpecialControlRequest : Tea.TeaModel {
    public var securityToken: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class DeleteAllTrafficSpecialControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAllTrafficSpecialControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAllTrafficSpecialControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAllTrafficSpecialControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApiGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupId: String?

    public var securityToken: String?

    public var tag: [DeleteApiGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DeleteApiGroupRequest.Tag]
        }
    }
}

public class DeleteApiGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApiStageVariableRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public var stageId: String?

    public var variableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageId != nil {
            map["StageId"] = self.stageId!
        }
        if self.variableName != nil {
            map["VariableName"] = self.variableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageId") {
            self.stageId = dict["StageId"] as! String
        }
        if dict.keys.contains("VariableName") {
            self.variableName = dict["VariableName"] as! String
        }
    }
}

public class DeleteApiStageVariableResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApiStageVariableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApiStageVariableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteApiStageVariableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAppRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appId: Int64?

    public var securityToken: String?

    public var tag: [DeleteAppRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DeleteAppRequest.Tag]
        }
    }
}

public class DeleteAppResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBackendRequest : Tea.TeaModel {
    public var backendId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteBackendResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBackendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBackendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBackendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBackendModelRequest : Tea.TeaModel {
    public var backendId: String?

    public var backendModelId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.backendModelId != nil {
            map["BackendModelId"] = self.backendModelId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("BackendModelId") {
            self.backendModelId = dict["BackendModelId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DeleteBackendModelResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBackendModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBackendModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBackendModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDatasetRequest : Tea.TeaModel {
    public var datasetId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteDatasetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDatasetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDatasetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDatasetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDatasetItemRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetItemId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetItemId != nil {
            map["DatasetItemId"] = self.datasetItemId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetItemId") {
            self.datasetItemId = dict["DatasetItemId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteDatasetItemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDatasetItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDatasetItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDatasetItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainCertificateRequest : Tea.TeaModel {
    public var certificateId: String?

    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateId") {
            self.certificateId = dict["CertificateId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteDomainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDomainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var instanceId: String?

    public var tag: [DeleteInstanceRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DeleteInstanceRequest.Tag]
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIpControlRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteIpControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIpControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIpControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLogConfigRequest : Tea.TeaModel {
    public var logType: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logType != nil {
            map["LogType"] = self.logType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogType") {
            self.logType = dict["LogType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteLogConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteModelRequest : Tea.TeaModel {
    public var groupId: String?

    public var modelName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelName") {
            self.modelName = dict["ModelName"] as! String
        }
    }
}

public class DeleteModelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMonitorGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var rawMonitorGroupId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.rawMonitorGroupId != nil {
            map["RawMonitorGroupId"] = self.rawMonitorGroupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RawMonitorGroupId") {
            self.rawMonitorGroupId = dict["RawMonitorGroupId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteMonitorGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMonitorGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMonitorGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMonitorGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePluginRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pluginId: String?

    public var securityToken: String?

    public var tag: [DeletePluginRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DeletePluginRequest.Tag]
        }
    }
}

public class DeletePluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSignatureRequest : Tea.TeaModel {
    public var securityToken: String?

    public var signatureId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") {
            self.signatureId = dict["SignatureId"] as! String
        }
    }
}

public class DeleteSignatureResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSignatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSignatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSignatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTrafficControlRequest : Tea.TeaModel {
    public var securityToken: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class DeleteTrafficControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTrafficControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTrafficControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTrafficSpecialControlRequest : Tea.TeaModel {
    public var securityToken: String?

    public var specialKey: String?

    public var specialType: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.specialKey != nil {
            map["SpecialKey"] = self.specialKey!
        }
        if self.specialType != nil {
            map["SpecialType"] = self.specialType!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SpecialKey") {
            self.specialKey = dict["SpecialKey"] as! String
        }
        if dict.keys.contains("SpecialType") {
            self.specialType = dict["SpecialType"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class DeleteTrafficSpecialControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTrafficSpecialControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTrafficSpecialControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTrafficSpecialControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeployApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var description_: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DeployApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeployApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeployApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAbolishApiTaskRequest : Tea.TeaModel {
    public var operationUid: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationUid != nil {
            map["OperationUid"] = self.operationUid!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationUid") {
            self.operationUid = dict["OperationUid"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAbolishApiTaskResponseBody : Tea.TeaModel {
    public class ApiAbolishResults : Tea.TeaModel {
        public class ApiAbolishResult : Tea.TeaModel {
            public var abolishStatus: String?

            public var apiName: String?

            public var apiUid: String?

            public var errorMsg: String?

            public var groupId: String?

            public var groupName: String?

            public var stageId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abolishStatus != nil {
                    map["AbolishStatus"] = self.abolishStatus!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbolishStatus") {
                    self.abolishStatus = dict["AbolishStatus"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiUid") {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("StageId") {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var apiAbolishResult: [DescribeAbolishApiTaskResponseBody.ApiAbolishResults.ApiAbolishResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiAbolishResult != nil {
                var tmp : [Any] = []
                for k in self.apiAbolishResult! {
                    tmp.append(k.toMap())
                }
                map["ApiAbolishResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiAbolishResult") {
                self.apiAbolishResult = dict["ApiAbolishResult"] as! [DescribeAbolishApiTaskResponseBody.ApiAbolishResults.ApiAbolishResult]
            }
        }
    }
    public var apiAbolishResults: DescribeAbolishApiTaskResponseBody.ApiAbolishResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiAbolishResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiAbolishResults != nil {
            map["ApiAbolishResults"] = self.apiAbolishResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiAbolishResults") {
            var model = DescribeAbolishApiTaskResponseBody.ApiAbolishResults()
            model.fromMap(dict["ApiAbolishResults"] as! [String: Any])
            self.apiAbolishResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAbolishApiTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAbolishApiTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAbolishApiTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccessControlListAttributeRequest : Tea.TeaModel {
    public var aclId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAccessControlListAttributeResponseBody : Tea.TeaModel {
    public class AclEntrys : Tea.TeaModel {
        public class AclEntry : Tea.TeaModel {
            public var aclEntryComment: String?

            public var aclEntryIp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclEntryComment != nil {
                    map["AclEntryComment"] = self.aclEntryComment!
                }
                if self.aclEntryIp != nil {
                    map["AclEntryIp"] = self.aclEntryIp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AclEntryComment") {
                    self.aclEntryComment = dict["AclEntryComment"] as! String
                }
                if dict.keys.contains("AclEntryIp") {
                    self.aclEntryIp = dict["AclEntryIp"] as! String
                }
            }
        }
        public var aclEntry: [DescribeAccessControlListAttributeResponseBody.AclEntrys.AclEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclEntry != nil {
                var tmp : [Any] = []
                for k in self.aclEntry! {
                    tmp.append(k.toMap())
                }
                map["AclEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclEntry") {
                self.aclEntry = dict["AclEntry"] as! [DescribeAccessControlListAttributeResponseBody.AclEntrys.AclEntry]
            }
        }
    }
    public var aclEntrys: DescribeAccessControlListAttributeResponseBody.AclEntrys?

    public var aclId: String?

    public var aclName: String?

    public var isUsed: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aclEntrys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntrys != nil {
            map["AclEntrys"] = self.aclEntrys?.toMap()
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.isUsed != nil {
            map["IsUsed"] = self.isUsed!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntrys") {
            var model = DescribeAccessControlListAttributeResponseBody.AclEntrys()
            model.fromMap(dict["AclEntrys"] as! [String: Any])
            self.aclEntrys = model
        }
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclName") {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("IsUsed") {
            self.isUsed = dict["IsUsed"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAccessControlListAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccessControlListAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAccessControlListAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccessControlListsRequest : Tea.TeaModel {
    public var aclName: String?

    public var addressIPVersion: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclName") {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("AddressIPVersion") {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAccessControlListsResponseBody : Tea.TeaModel {
    public class Acls : Tea.TeaModel {
        public class Acl : Tea.TeaModel {
            public var aclId: String?

            public var aclName: String?

            public var addressIPVersion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclId != nil {
                    map["AclId"] = self.aclId!
                }
                if self.aclName != nil {
                    map["AclName"] = self.aclName!
                }
                if self.addressIPVersion != nil {
                    map["AddressIPVersion"] = self.addressIPVersion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AclId") {
                    self.aclId = dict["AclId"] as! String
                }
                if dict.keys.contains("AclName") {
                    self.aclName = dict["AclName"] as! String
                }
                if dict.keys.contains("AddressIPVersion") {
                    self.addressIPVersion = dict["AddressIPVersion"] as! String
                }
            }
        }
        public var acl: [DescribeAccessControlListsResponseBody.Acls.Acl]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acl != nil {
                var tmp : [Any] = []
                for k in self.acl! {
                    tmp.append(k.toMap())
                }
                map["Acl"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Acl") {
                self.acl = dict["Acl"] as! [DescribeAccessControlListsResponseBody.Acls.Acl]
            }
        }
    }
    public var acls: DescribeAccessControlListsResponseBody.Acls?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.acls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acls != nil {
            map["Acls"] = self.acls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Acls") {
            var model = DescribeAccessControlListsResponseBody.Acls()
            model.fromMap(dict["Acls"] as! [String: Any])
            self.acls = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAccessControlListsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccessControlListsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAccessControlListsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApiResponseBody : Tea.TeaModel {
    public class BackendConfig : Tea.TeaModel {
        public var backendId: String?

        public var backendName: String?

        public var backendType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendId != nil {
                map["BackendId"] = self.backendId!
            }
            if self.backendName != nil {
                map["BackendName"] = self.backendName!
            }
            if self.backendType != nil {
                map["BackendType"] = self.backendType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendId") {
                self.backendId = dict["BackendId"] as! String
            }
            if dict.keys.contains("BackendName") {
                self.backendName = dict["BackendName"] as! String
            }
            if dict.keys.contains("BackendType") {
                self.backendType = dict["BackendType"] as! String
            }
        }
    }
    public class ConstantParameters : Tea.TeaModel {
        public class ConstantParameter : Tea.TeaModel {
            public var constantValue: String?

            public var description_: String?

            public var location: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.constantValue != nil {
                    map["ConstantValue"] = self.constantValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConstantValue") {
                    self.constantValue = dict["ConstantValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var constantParameter: [DescribeApiResponseBody.ConstantParameters.ConstantParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.constantParameter != nil {
                var tmp : [Any] = []
                for k in self.constantParameter! {
                    tmp.append(k.toMap())
                }
                map["ConstantParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConstantParameter") {
                self.constantParameter = dict["ConstantParameter"] as! [DescribeApiResponseBody.ConstantParameters.ConstantParameter]
            }
        }
    }
    public class CustomSystemParameters : Tea.TeaModel {
        public class CustomSystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var customSystemParameter: [DescribeApiResponseBody.CustomSystemParameters.CustomSystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customSystemParameter != nil {
                var tmp : [Any] = []
                for k in self.customSystemParameter! {
                    tmp.append(k.toMap())
                }
                map["CustomSystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomSystemParameter") {
                self.customSystemParameter = dict["CustomSystemParameter"] as! [DescribeApiResponseBody.CustomSystemParameters.CustomSystemParameter]
            }
        }
    }
    public class DeployedInfos : Tea.TeaModel {
        public class DeployedInfo : Tea.TeaModel {
            public var deployedStatus: String?

            public var effectiveVersion: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deployedStatus != nil {
                    map["DeployedStatus"] = self.deployedStatus!
                }
                if self.effectiveVersion != nil {
                    map["EffectiveVersion"] = self.effectiveVersion!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeployedStatus") {
                    self.deployedStatus = dict["DeployedStatus"] as! String
                }
                if dict.keys.contains("EffectiveVersion") {
                    self.effectiveVersion = dict["EffectiveVersion"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var deployedInfo: [DescribeApiResponseBody.DeployedInfos.DeployedInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployedInfo != nil {
                var tmp : [Any] = []
                for k in self.deployedInfo! {
                    tmp.append(k.toMap())
                }
                map["DeployedInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeployedInfo") {
                self.deployedInfo = dict["DeployedInfo"] as! [DescribeApiResponseBody.DeployedInfos.DeployedInfo]
            }
        }
    }
    public class ErrorCodeSamples : Tea.TeaModel {
        public class ErrorCodeSample : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var message: String?

            public var model: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.model != nil {
                    map["Model"] = self.model!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Model") {
                    self.model = dict["Model"] as! String
                }
            }
        }
        public var errorCodeSample: [DescribeApiResponseBody.ErrorCodeSamples.ErrorCodeSample]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCodeSample != nil {
                var tmp : [Any] = []
                for k in self.errorCodeSample! {
                    tmp.append(k.toMap())
                }
                map["ErrorCodeSample"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCodeSample") {
                self.errorCodeSample = dict["ErrorCodeSample"] as! [DescribeApiResponseBody.ErrorCodeSamples.ErrorCodeSample]
            }
        }
    }
    public class OpenIdConnectConfig : Tea.TeaModel {
        public var idTokenParamName: String?

        public var openIdApiType: String?

        public var publicKey: String?

        public var publicKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.idTokenParamName != nil {
                map["IdTokenParamName"] = self.idTokenParamName!
            }
            if self.openIdApiType != nil {
                map["OpenIdApiType"] = self.openIdApiType!
            }
            if self.publicKey != nil {
                map["PublicKey"] = self.publicKey!
            }
            if self.publicKeyId != nil {
                map["PublicKeyId"] = self.publicKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdTokenParamName") {
                self.idTokenParamName = dict["IdTokenParamName"] as! String
            }
            if dict.keys.contains("OpenIdApiType") {
                self.openIdApiType = dict["OpenIdApiType"] as! String
            }
            if dict.keys.contains("PublicKey") {
                self.publicKey = dict["PublicKey"] as! String
            }
            if dict.keys.contains("PublicKeyId") {
                self.publicKeyId = dict["PublicKeyId"] as! String
            }
        }
    }
    public class RequestConfig : Tea.TeaModel {
        public var bodyFormat: String?

        public var bodyModel: String?

        public var postBodyDescription: String?

        public var requestHttpMethod: String?

        public var requestMode: String?

        public var requestPath: String?

        public var requestProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bodyFormat != nil {
                map["BodyFormat"] = self.bodyFormat!
            }
            if self.bodyModel != nil {
                map["BodyModel"] = self.bodyModel!
            }
            if self.postBodyDescription != nil {
                map["PostBodyDescription"] = self.postBodyDescription!
            }
            if self.requestHttpMethod != nil {
                map["RequestHttpMethod"] = self.requestHttpMethod!
            }
            if self.requestMode != nil {
                map["RequestMode"] = self.requestMode!
            }
            if self.requestPath != nil {
                map["RequestPath"] = self.requestPath!
            }
            if self.requestProtocol != nil {
                map["RequestProtocol"] = self.requestProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BodyFormat") {
                self.bodyFormat = dict["BodyFormat"] as! String
            }
            if dict.keys.contains("BodyModel") {
                self.bodyModel = dict["BodyModel"] as! String
            }
            if dict.keys.contains("PostBodyDescription") {
                self.postBodyDescription = dict["PostBodyDescription"] as! String
            }
            if dict.keys.contains("RequestHttpMethod") {
                self.requestHttpMethod = dict["RequestHttpMethod"] as! String
            }
            if dict.keys.contains("RequestMode") {
                self.requestMode = dict["RequestMode"] as! String
            }
            if dict.keys.contains("RequestPath") {
                self.requestPath = dict["RequestPath"] as! String
            }
            if dict.keys.contains("RequestProtocol") {
                self.requestProtocol = dict["RequestProtocol"] as! String
            }
        }
    }
    public class RequestParameters : Tea.TeaModel {
        public class RequestParameter : Tea.TeaModel {
            public var apiParameterName: String?

            public var arrayItemsType: String?

            public var defaultValue: String?

            public var demoValue: String?

            public var description_: String?

            public var docOrder: Int32?

            public var docShow: String?

            public var enumValue: String?

            public var jsonScheme: String?

            public var location: String?

            public var maxLength: Int64?

            public var maxValue: Int64?

            public var minLength: Int64?

            public var minValue: Int64?

            public var parameterType: String?

            public var regularExpression: String?

            public var required_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiParameterName != nil {
                    map["ApiParameterName"] = self.apiParameterName!
                }
                if self.arrayItemsType != nil {
                    map["ArrayItemsType"] = self.arrayItemsType!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.docOrder != nil {
                    map["DocOrder"] = self.docOrder!
                }
                if self.docShow != nil {
                    map["DocShow"] = self.docShow!
                }
                if self.enumValue != nil {
                    map["EnumValue"] = self.enumValue!
                }
                if self.jsonScheme != nil {
                    map["JsonScheme"] = self.jsonScheme!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.maxLength != nil {
                    map["MaxLength"] = self.maxLength!
                }
                if self.maxValue != nil {
                    map["MaxValue"] = self.maxValue!
                }
                if self.minLength != nil {
                    map["MinLength"] = self.minLength!
                }
                if self.minValue != nil {
                    map["MinValue"] = self.minValue!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.regularExpression != nil {
                    map["RegularExpression"] = self.regularExpression!
                }
                if self.required_ != nil {
                    map["Required"] = self.required_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiParameterName") {
                    self.apiParameterName = dict["ApiParameterName"] as! String
                }
                if dict.keys.contains("ArrayItemsType") {
                    self.arrayItemsType = dict["ArrayItemsType"] as! String
                }
                if dict.keys.contains("DefaultValue") {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocOrder") {
                    self.docOrder = dict["DocOrder"] as! Int32
                }
                if dict.keys.contains("DocShow") {
                    self.docShow = dict["DocShow"] as! String
                }
                if dict.keys.contains("EnumValue") {
                    self.enumValue = dict["EnumValue"] as! String
                }
                if dict.keys.contains("JsonScheme") {
                    self.jsonScheme = dict["JsonScheme"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("MaxLength") {
                    self.maxLength = dict["MaxLength"] as! Int64
                }
                if dict.keys.contains("MaxValue") {
                    self.maxValue = dict["MaxValue"] as! Int64
                }
                if dict.keys.contains("MinLength") {
                    self.minLength = dict["MinLength"] as! Int64
                }
                if dict.keys.contains("MinValue") {
                    self.minValue = dict["MinValue"] as! Int64
                }
                if dict.keys.contains("ParameterType") {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("RegularExpression") {
                    self.regularExpression = dict["RegularExpression"] as! String
                }
                if dict.keys.contains("Required") {
                    self.required_ = dict["Required"] as! String
                }
            }
        }
        public var requestParameter: [DescribeApiResponseBody.RequestParameters.RequestParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestParameter != nil {
                var tmp : [Any] = []
                for k in self.requestParameter! {
                    tmp.append(k.toMap())
                }
                map["RequestParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestParameter") {
                self.requestParameter = dict["RequestParameter"] as! [DescribeApiResponseBody.RequestParameters.RequestParameter]
            }
        }
    }
    public class ResultDescriptions : Tea.TeaModel {
        public class ResultDescription : Tea.TeaModel {
            public var description_: String?

            public var hasChild: Bool?

            public var id: String?

            public var key: String?

            public var mandatory: Bool?

            public var name: String?

            public var pid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hasChild != nil {
                    map["HasChild"] = self.hasChild!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mandatory != nil {
                    map["Mandatory"] = self.mandatory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HasChild") {
                    self.hasChild = dict["HasChild"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Mandatory") {
                    self.mandatory = dict["Mandatory"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pid") {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var resultDescription: [DescribeApiResponseBody.ResultDescriptions.ResultDescription]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultDescription != nil {
                var tmp : [Any] = []
                for k in self.resultDescription! {
                    tmp.append(k.toMap())
                }
                map["ResultDescription"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultDescription") {
                self.resultDescription = dict["ResultDescription"] as! [DescribeApiResponseBody.ResultDescriptions.ResultDescription]
            }
        }
    }
    public class ServiceConfig : Tea.TeaModel {
        public class EventBridgeConfig : Tea.TeaModel {
            public var eventBridgeRegionId: String?

            public var eventBus: String?

            public var eventSource: String?

            public var roleArn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventBridgeRegionId != nil {
                    map["EventBridgeRegionId"] = self.eventBridgeRegionId!
                }
                if self.eventBus != nil {
                    map["EventBus"] = self.eventBus!
                }
                if self.eventSource != nil {
                    map["EventSource"] = self.eventSource!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventBridgeRegionId") {
                    self.eventBridgeRegionId = dict["EventBridgeRegionId"] as! String
                }
                if dict.keys.contains("EventBus") {
                    self.eventBus = dict["EventBus"] as! String
                }
                if dict.keys.contains("EventSource") {
                    self.eventSource = dict["EventSource"] as! String
                }
                if dict.keys.contains("RoleArn") {
                    self.roleArn = dict["RoleArn"] as! String
                }
            }
        }
        public class FunctionComputeConfig : Tea.TeaModel {
            public var contentTypeCatagory: String?

            public var contentTypeValue: String?

            public var fcBaseUrl: String?

            public var fcType: String?

            public var functionName: String?

            public var method: String?

            public var onlyBusinessPath: Bool?

            public var path: String?

            public var qualifier: String?

            public var regionId: String?

            public var roleArn: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentTypeCatagory != nil {
                    map["ContentTypeCatagory"] = self.contentTypeCatagory!
                }
                if self.contentTypeValue != nil {
                    map["ContentTypeValue"] = self.contentTypeValue!
                }
                if self.fcBaseUrl != nil {
                    map["FcBaseUrl"] = self.fcBaseUrl!
                }
                if self.fcType != nil {
                    map["FcType"] = self.fcType!
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.onlyBusinessPath != nil {
                    map["OnlyBusinessPath"] = self.onlyBusinessPath!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.qualifier != nil {
                    map["Qualifier"] = self.qualifier!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentTypeCatagory") {
                    self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
                }
                if dict.keys.contains("ContentTypeValue") {
                    self.contentTypeValue = dict["ContentTypeValue"] as! String
                }
                if dict.keys.contains("FcBaseUrl") {
                    self.fcBaseUrl = dict["FcBaseUrl"] as! String
                }
                if dict.keys.contains("FcType") {
                    self.fcType = dict["FcType"] as! String
                }
                if dict.keys.contains("FunctionName") {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("OnlyBusinessPath") {
                    self.onlyBusinessPath = dict["OnlyBusinessPath"] as! Bool
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Qualifier") {
                    self.qualifier = dict["Qualifier"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RoleArn") {
                    self.roleArn = dict["RoleArn"] as! String
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public class MockHeaders : Tea.TeaModel {
            public class MockHeader : Tea.TeaModel {
                public var headerName: String?

                public var headerValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerName != nil {
                        map["HeaderName"] = self.headerName!
                    }
                    if self.headerValue != nil {
                        map["HeaderValue"] = self.headerValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderName") {
                        self.headerName = dict["HeaderName"] as! String
                    }
                    if dict.keys.contains("HeaderValue") {
                        self.headerValue = dict["HeaderValue"] as! String
                    }
                }
            }
            public var mockHeader: [DescribeApiResponseBody.ServiceConfig.MockHeaders.MockHeader]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mockHeader != nil {
                    var tmp : [Any] = []
                    for k in self.mockHeader! {
                        tmp.append(k.toMap())
                    }
                    map["MockHeader"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MockHeader") {
                    self.mockHeader = dict["MockHeader"] as! [DescribeApiResponseBody.ServiceConfig.MockHeaders.MockHeader]
                }
            }
        }
        public class OssConfig : Tea.TeaModel {
            public var action: String?

            public var bucketName: String?

            public var key: String?

            public var ossRegionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.bucketName != nil {
                    map["BucketName"] = self.bucketName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.ossRegionId != nil {
                    map["OssRegionId"] = self.ossRegionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("BucketName") {
                    self.bucketName = dict["BucketName"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("OssRegionId") {
                    self.ossRegionId = dict["OssRegionId"] as! String
                }
            }
        }
        public class VpcConfig : Tea.TeaModel {
            public var instanceId: String?

            public var name: String?

            public var port: Int32?

            public var vpcId: String?

            public var vpcScheme: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcScheme != nil {
                    map["VpcScheme"] = self.vpcScheme!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcScheme") {
                    self.vpcScheme = dict["VpcScheme"] as! String
                }
            }
        }
        public var aoneAppName: String?

        public var contentTypeCatagory: String?

        public var contentTypeValue: String?

        public var eventBridgeConfig: DescribeApiResponseBody.ServiceConfig.EventBridgeConfig?

        public var functionComputeConfig: DescribeApiResponseBody.ServiceConfig.FunctionComputeConfig?

        public var mock: String?

        public var mockHeaders: DescribeApiResponseBody.ServiceConfig.MockHeaders?

        public var mockResult: String?

        public var mockStatusCode: Int32?

        public var ossConfig: DescribeApiResponseBody.ServiceConfig.OssConfig?

        public var serviceAddress: String?

        public var serviceHttpMethod: String?

        public var servicePath: String?

        public var serviceProtocol: String?

        public var serviceTimeout: Int32?

        public var serviceVpcEnable: String?

        public var vpcConfig: DescribeApiResponseBody.ServiceConfig.VpcConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.eventBridgeConfig?.validate()
            try self.functionComputeConfig?.validate()
            try self.mockHeaders?.validate()
            try self.ossConfig?.validate()
            try self.vpcConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aoneAppName != nil {
                map["AoneAppName"] = self.aoneAppName!
            }
            if self.contentTypeCatagory != nil {
                map["ContentTypeCatagory"] = self.contentTypeCatagory!
            }
            if self.contentTypeValue != nil {
                map["ContentTypeValue"] = self.contentTypeValue!
            }
            if self.eventBridgeConfig != nil {
                map["EventBridgeConfig"] = self.eventBridgeConfig?.toMap()
            }
            if self.functionComputeConfig != nil {
                map["FunctionComputeConfig"] = self.functionComputeConfig?.toMap()
            }
            if self.mock != nil {
                map["Mock"] = self.mock!
            }
            if self.mockHeaders != nil {
                map["MockHeaders"] = self.mockHeaders?.toMap()
            }
            if self.mockResult != nil {
                map["MockResult"] = self.mockResult!
            }
            if self.mockStatusCode != nil {
                map["MockStatusCode"] = self.mockStatusCode!
            }
            if self.ossConfig != nil {
                map["OssConfig"] = self.ossConfig?.toMap()
            }
            if self.serviceAddress != nil {
                map["ServiceAddress"] = self.serviceAddress!
            }
            if self.serviceHttpMethod != nil {
                map["ServiceHttpMethod"] = self.serviceHttpMethod!
            }
            if self.servicePath != nil {
                map["ServicePath"] = self.servicePath!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceTimeout != nil {
                map["ServiceTimeout"] = self.serviceTimeout!
            }
            if self.serviceVpcEnable != nil {
                map["ServiceVpcEnable"] = self.serviceVpcEnable!
            }
            if self.vpcConfig != nil {
                map["VpcConfig"] = self.vpcConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AoneAppName") {
                self.aoneAppName = dict["AoneAppName"] as! String
            }
            if dict.keys.contains("ContentTypeCatagory") {
                self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
            }
            if dict.keys.contains("ContentTypeValue") {
                self.contentTypeValue = dict["ContentTypeValue"] as! String
            }
            if dict.keys.contains("EventBridgeConfig") {
                var model = DescribeApiResponseBody.ServiceConfig.EventBridgeConfig()
                model.fromMap(dict["EventBridgeConfig"] as! [String: Any])
                self.eventBridgeConfig = model
            }
            if dict.keys.contains("FunctionComputeConfig") {
                var model = DescribeApiResponseBody.ServiceConfig.FunctionComputeConfig()
                model.fromMap(dict["FunctionComputeConfig"] as! [String: Any])
                self.functionComputeConfig = model
            }
            if dict.keys.contains("Mock") {
                self.mock = dict["Mock"] as! String
            }
            if dict.keys.contains("MockHeaders") {
                var model = DescribeApiResponseBody.ServiceConfig.MockHeaders()
                model.fromMap(dict["MockHeaders"] as! [String: Any])
                self.mockHeaders = model
            }
            if dict.keys.contains("MockResult") {
                self.mockResult = dict["MockResult"] as! String
            }
            if dict.keys.contains("MockStatusCode") {
                self.mockStatusCode = dict["MockStatusCode"] as! Int32
            }
            if dict.keys.contains("OssConfig") {
                var model = DescribeApiResponseBody.ServiceConfig.OssConfig()
                model.fromMap(dict["OssConfig"] as! [String: Any])
                self.ossConfig = model
            }
            if dict.keys.contains("ServiceAddress") {
                self.serviceAddress = dict["ServiceAddress"] as! String
            }
            if dict.keys.contains("ServiceHttpMethod") {
                self.serviceHttpMethod = dict["ServiceHttpMethod"] as! String
            }
            if dict.keys.contains("ServicePath") {
                self.servicePath = dict["ServicePath"] as! String
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("ServiceTimeout") {
                self.serviceTimeout = dict["ServiceTimeout"] as! Int32
            }
            if dict.keys.contains("ServiceVpcEnable") {
                self.serviceVpcEnable = dict["ServiceVpcEnable"] as! String
            }
            if dict.keys.contains("VpcConfig") {
                var model = DescribeApiResponseBody.ServiceConfig.VpcConfig()
                model.fromMap(dict["VpcConfig"] as! [String: Any])
                self.vpcConfig = model
            }
        }
    }
    public class ServiceParameters : Tea.TeaModel {
        public class ServiceParameter : Tea.TeaModel {
            public var location: String?

            public var parameterType: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterType") {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameter: [DescribeApiResponseBody.ServiceParameters.ServiceParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameter != nil {
                var tmp : [Any] = []
                for k in self.serviceParameter! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameter") {
                self.serviceParameter = dict["ServiceParameter"] as! [DescribeApiResponseBody.ServiceParameters.ServiceParameter]
            }
        }
    }
    public class ServiceParametersMap : Tea.TeaModel {
        public class ServiceParameterMap : Tea.TeaModel {
            public var requestParameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestParameterName != nil {
                    map["RequestParameterName"] = self.requestParameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestParameterName") {
                    self.requestParameterName = dict["RequestParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameterMap: [DescribeApiResponseBody.ServiceParametersMap.ServiceParameterMap]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameterMap != nil {
                var tmp : [Any] = []
                for k in self.serviceParameterMap! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameterMap"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameterMap") {
                self.serviceParameterMap = dict["ServiceParameterMap"] as! [DescribeApiResponseBody.ServiceParametersMap.ServiceParameterMap]
            }
        }
    }
    public class SystemParameters : Tea.TeaModel {
        public class SystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var systemParameter: [DescribeApiResponseBody.SystemParameters.SystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemParameter != nil {
                var tmp : [Any] = []
                for k in self.systemParameter! {
                    tmp.append(k.toMap())
                }
                map["SystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemParameter") {
                self.systemParameter = dict["SystemParameter"] as! [DescribeApiResponseBody.SystemParameters.SystemParameter]
            }
        }
    }
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendConfig: DescribeApiResponseBody.BackendConfig?

    public var backendEnable: Bool?

    public var constantParameters: DescribeApiResponseBody.ConstantParameters?

    public var createdTime: String?

    public var customSystemParameters: DescribeApiResponseBody.CustomSystemParameters?

    public var deployedInfos: DescribeApiResponseBody.DeployedInfos?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: DescribeApiResponseBody.ErrorCodeSamples?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var groupName: String?

    public var mock: String?

    public var mockResult: String?

    public var modifiedTime: String?

    public var openIdConnectConfig: DescribeApiResponseBody.OpenIdConnectConfig?

    public var regionId: String?

    public var requestConfig: DescribeApiResponseBody.RequestConfig?

    public var requestId: String?

    public var requestParameters: DescribeApiResponseBody.RequestParameters?

    public var resultBodyModel: String?

    public var resultDescriptions: DescribeApiResponseBody.ResultDescriptions?

    public var resultSample: String?

    public var resultType: String?

    public var serviceConfig: DescribeApiResponseBody.ServiceConfig?

    public var serviceParameters: DescribeApiResponseBody.ServiceParameters?

    public var serviceParametersMap: DescribeApiResponseBody.ServiceParametersMap?

    public var systemParameters: DescribeApiResponseBody.SystemParameters?

    public var visibility: String?

    public var webSocketApiType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendConfig?.validate()
        try self.constantParameters?.validate()
        try self.customSystemParameters?.validate()
        try self.deployedInfos?.validate()
        try self.errorCodeSamples?.validate()
        try self.openIdConnectConfig?.validate()
        try self.requestConfig?.validate()
        try self.requestParameters?.validate()
        try self.resultDescriptions?.validate()
        try self.serviceConfig?.validate()
        try self.serviceParameters?.validate()
        try self.serviceParametersMap?.validate()
        try self.systemParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendConfig != nil {
            map["BackendConfig"] = self.backendConfig?.toMap()
        }
        if self.backendEnable != nil {
            map["BackendEnable"] = self.backendEnable!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters?.toMap()
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.customSystemParameters != nil {
            map["CustomSystemParameters"] = self.customSystemParameters?.toMap()
        }
        if self.deployedInfos != nil {
            map["DeployedInfos"] = self.deployedInfos?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples?.toMap()
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.mock != nil {
            map["Mock"] = self.mock!
        }
        if self.mockResult != nil {
            map["MockResult"] = self.mockResult!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters?.toMap()
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions?.toMap()
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig?.toMap()
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters?.toMap()
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap?.toMap()
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.webSocketApiType != nil {
            map["WebSocketApiType"] = self.webSocketApiType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendConfig") {
            var model = DescribeApiResponseBody.BackendConfig()
            model.fromMap(dict["BackendConfig"] as! [String: Any])
            self.backendConfig = model
        }
        if dict.keys.contains("BackendEnable") {
            self.backendEnable = dict["BackendEnable"] as! Bool
        }
        if dict.keys.contains("ConstantParameters") {
            var model = DescribeApiResponseBody.ConstantParameters()
            model.fromMap(dict["ConstantParameters"] as! [String: Any])
            self.constantParameters = model
        }
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("CustomSystemParameters") {
            var model = DescribeApiResponseBody.CustomSystemParameters()
            model.fromMap(dict["CustomSystemParameters"] as! [String: Any])
            self.customSystemParameters = model
        }
        if dict.keys.contains("DeployedInfos") {
            var model = DescribeApiResponseBody.DeployedInfos()
            model.fromMap(dict["DeployedInfos"] as! [String: Any])
            self.deployedInfos = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") {
            var model = DescribeApiResponseBody.ErrorCodeSamples()
            model.fromMap(dict["ErrorCodeSamples"] as! [String: Any])
            self.errorCodeSamples = model
        }
        if dict.keys.contains("FailResultSample") {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("Mock") {
            self.mock = dict["Mock"] as! String
        }
        if dict.keys.contains("MockResult") {
            self.mockResult = dict["MockResult"] as! String
        }
        if dict.keys.contains("ModifiedTime") {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") {
            var model = DescribeApiResponseBody.OpenIdConnectConfig()
            model.fromMap(dict["OpenIdConnectConfig"] as! [String: Any])
            self.openIdConnectConfig = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestConfig") {
            var model = DescribeApiResponseBody.RequestConfig()
            model.fromMap(dict["RequestConfig"] as! [String: Any])
            self.requestConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestParameters") {
            var model = DescribeApiResponseBody.RequestParameters()
            model.fromMap(dict["RequestParameters"] as! [String: Any])
            self.requestParameters = model
        }
        if dict.keys.contains("ResultBodyModel") {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultDescriptions") {
            var model = DescribeApiResponseBody.ResultDescriptions()
            model.fromMap(dict["ResultDescriptions"] as! [String: Any])
            self.resultDescriptions = model
        }
        if dict.keys.contains("ResultSample") {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("ServiceConfig") {
            var model = DescribeApiResponseBody.ServiceConfig()
            model.fromMap(dict["ServiceConfig"] as! [String: Any])
            self.serviceConfig = model
        }
        if dict.keys.contains("ServiceParameters") {
            var model = DescribeApiResponseBody.ServiceParameters()
            model.fromMap(dict["ServiceParameters"] as! [String: Any])
            self.serviceParameters = model
        }
        if dict.keys.contains("ServiceParametersMap") {
            var model = DescribeApiResponseBody.ServiceParametersMap()
            model.fromMap(dict["ServiceParametersMap"] as! [String: Any])
            self.serviceParametersMap = model
        }
        if dict.keys.contains("SystemParameters") {
            var model = DescribeApiResponseBody.SystemParameters()
            model.fromMap(dict["SystemParameters"] as! [String: Any])
            self.systemParameters = model
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WebSocketApiType") {
            self.webSocketApiType = dict["WebSocketApiType"] as! String
        }
    }
}

public class DescribeApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiDocRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiDocResponseBody : Tea.TeaModel {
    public class ErrorCodeSamples : Tea.TeaModel {
        public class ErrorCodeSample : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var errorCodeSample: [DescribeApiDocResponseBody.ErrorCodeSamples.ErrorCodeSample]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCodeSample != nil {
                var tmp : [Any] = []
                for k in self.errorCodeSample! {
                    tmp.append(k.toMap())
                }
                map["ErrorCodeSample"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCodeSample") {
                self.errorCodeSample = dict["ErrorCodeSample"] as! [DescribeApiDocResponseBody.ErrorCodeSamples.ErrorCodeSample]
            }
        }
    }
    public class RequestConfig : Tea.TeaModel {
        public var bodyFormat: String?

        public var postBodyDescription: String?

        public var requestHttpMethod: String?

        public var requestMode: String?

        public var requestPath: String?

        public var requestProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bodyFormat != nil {
                map["BodyFormat"] = self.bodyFormat!
            }
            if self.postBodyDescription != nil {
                map["PostBodyDescription"] = self.postBodyDescription!
            }
            if self.requestHttpMethod != nil {
                map["RequestHttpMethod"] = self.requestHttpMethod!
            }
            if self.requestMode != nil {
                map["RequestMode"] = self.requestMode!
            }
            if self.requestPath != nil {
                map["RequestPath"] = self.requestPath!
            }
            if self.requestProtocol != nil {
                map["RequestProtocol"] = self.requestProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BodyFormat") {
                self.bodyFormat = dict["BodyFormat"] as! String
            }
            if dict.keys.contains("PostBodyDescription") {
                self.postBodyDescription = dict["PostBodyDescription"] as! String
            }
            if dict.keys.contains("RequestHttpMethod") {
                self.requestHttpMethod = dict["RequestHttpMethod"] as! String
            }
            if dict.keys.contains("RequestMode") {
                self.requestMode = dict["RequestMode"] as! String
            }
            if dict.keys.contains("RequestPath") {
                self.requestPath = dict["RequestPath"] as! String
            }
            if dict.keys.contains("RequestProtocol") {
                self.requestProtocol = dict["RequestProtocol"] as! String
            }
        }
    }
    public class RequestParameters : Tea.TeaModel {
        public class RequestParameter : Tea.TeaModel {
            public var apiParameterName: String?

            public var arrayItemsType: String?

            public var defaultValue: String?

            public var demoValue: String?

            public var description_: String?

            public var docOrder: Int32?

            public var docShow: String?

            public var enumValue: String?

            public var jsonScheme: String?

            public var location: String?

            public var maxLength: Int64?

            public var maxValue: Int64?

            public var minLength: Int64?

            public var minValue: Int64?

            public var parameterType: String?

            public var regularExpression: String?

            public var required_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiParameterName != nil {
                    map["ApiParameterName"] = self.apiParameterName!
                }
                if self.arrayItemsType != nil {
                    map["ArrayItemsType"] = self.arrayItemsType!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.docOrder != nil {
                    map["DocOrder"] = self.docOrder!
                }
                if self.docShow != nil {
                    map["DocShow"] = self.docShow!
                }
                if self.enumValue != nil {
                    map["EnumValue"] = self.enumValue!
                }
                if self.jsonScheme != nil {
                    map["JsonScheme"] = self.jsonScheme!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.maxLength != nil {
                    map["MaxLength"] = self.maxLength!
                }
                if self.maxValue != nil {
                    map["MaxValue"] = self.maxValue!
                }
                if self.minLength != nil {
                    map["MinLength"] = self.minLength!
                }
                if self.minValue != nil {
                    map["MinValue"] = self.minValue!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.regularExpression != nil {
                    map["RegularExpression"] = self.regularExpression!
                }
                if self.required_ != nil {
                    map["Required"] = self.required_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiParameterName") {
                    self.apiParameterName = dict["ApiParameterName"] as! String
                }
                if dict.keys.contains("ArrayItemsType") {
                    self.arrayItemsType = dict["ArrayItemsType"] as! String
                }
                if dict.keys.contains("DefaultValue") {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocOrder") {
                    self.docOrder = dict["DocOrder"] as! Int32
                }
                if dict.keys.contains("DocShow") {
                    self.docShow = dict["DocShow"] as! String
                }
                if dict.keys.contains("EnumValue") {
                    self.enumValue = dict["EnumValue"] as! String
                }
                if dict.keys.contains("JsonScheme") {
                    self.jsonScheme = dict["JsonScheme"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("MaxLength") {
                    self.maxLength = dict["MaxLength"] as! Int64
                }
                if dict.keys.contains("MaxValue") {
                    self.maxValue = dict["MaxValue"] as! Int64
                }
                if dict.keys.contains("MinLength") {
                    self.minLength = dict["MinLength"] as! Int64
                }
                if dict.keys.contains("MinValue") {
                    self.minValue = dict["MinValue"] as! Int64
                }
                if dict.keys.contains("ParameterType") {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("RegularExpression") {
                    self.regularExpression = dict["RegularExpression"] as! String
                }
                if dict.keys.contains("Required") {
                    self.required_ = dict["Required"] as! String
                }
            }
        }
        public var requestParameter: [DescribeApiDocResponseBody.RequestParameters.RequestParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestParameter != nil {
                var tmp : [Any] = []
                for k in self.requestParameter! {
                    tmp.append(k.toMap())
                }
                map["RequestParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestParameter") {
                self.requestParameter = dict["RequestParameter"] as! [DescribeApiDocResponseBody.RequestParameters.RequestParameter]
            }
        }
    }
    public class ResultDescriptions : Tea.TeaModel {
        public class ResultDescription : Tea.TeaModel {
            public var description_: String?

            public var hasChild: Bool?

            public var id: String?

            public var key: String?

            public var mandatory: Bool?

            public var name: String?

            public var pid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hasChild != nil {
                    map["HasChild"] = self.hasChild!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mandatory != nil {
                    map["Mandatory"] = self.mandatory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HasChild") {
                    self.hasChild = dict["HasChild"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Mandatory") {
                    self.mandatory = dict["Mandatory"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pid") {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var resultDescription: [DescribeApiDocResponseBody.ResultDescriptions.ResultDescription]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultDescription != nil {
                var tmp : [Any] = []
                for k in self.resultDescription! {
                    tmp.append(k.toMap())
                }
                map["ResultDescription"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultDescription") {
                self.resultDescription = dict["ResultDescription"] as! [DescribeApiDocResponseBody.ResultDescriptions.ResultDescription]
            }
        }
    }
    public var apiId: String?

    public var apiName: String?

    public var authType: String?

    public var deployedTime: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: DescribeApiDocResponseBody.ErrorCodeSamples?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var groupName: String?

    public var regionId: String?

    public var requestConfig: DescribeApiDocResponseBody.RequestConfig?

    public var requestId: String?

    public var requestParameters: DescribeApiDocResponseBody.RequestParameters?

    public var resultDescriptions: DescribeApiDocResponseBody.ResultDescriptions?

    public var resultSample: String?

    public var resultType: String?

    public var stageName: String?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorCodeSamples?.validate()
        try self.requestConfig?.validate()
        try self.requestParameters?.validate()
        try self.resultDescriptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.deployedTime != nil {
            map["DeployedTime"] = self.deployedTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples?.toMap()
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters?.toMap()
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions?.toMap()
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AuthType") {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("DeployedTime") {
            self.deployedTime = dict["DeployedTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") {
            var model = DescribeApiDocResponseBody.ErrorCodeSamples()
            model.fromMap(dict["ErrorCodeSamples"] as! [String: Any])
            self.errorCodeSamples = model
        }
        if dict.keys.contains("FailResultSample") {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestConfig") {
            var model = DescribeApiDocResponseBody.RequestConfig()
            model.fromMap(dict["RequestConfig"] as! [String: Any])
            self.requestConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestParameters") {
            var model = DescribeApiDocResponseBody.RequestParameters()
            model.fromMap(dict["RequestParameters"] as! [String: Any])
            self.requestParameters = model
        }
        if dict.keys.contains("ResultDescriptions") {
            var model = DescribeApiDocResponseBody.ResultDescriptions()
            model.fromMap(dict["ResultDescriptions"] as! [String: Any])
            self.resultDescriptions = model
        }
        if dict.keys.contains("ResultSample") {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class DescribeApiDocResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiDocResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiDocResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var groupId: String?

    public var securityToken: String?

    public var tag: [DescribeApiGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeApiGroupRequest.Tag]
        }
    }
}

public class DescribeApiGroupResponseBody : Tea.TeaModel {
    public class CustomDomains : Tea.TeaModel {
        public class DomainItem : Tea.TeaModel {
            public var bindStageName: String?

            public var certificateId: String?

            public var certificateName: String?

            public var customDomainType: String?

            public var domainBindingStatus: String?

            public var domainCNAMEStatus: String?

            public var domainLegalStatus: String?

            public var domainName: String?

            public var domainRemark: String?

            public var domainWebSocketStatus: String?

            public var isHttpRedirectToHttps: Bool?

            public var wildcardDomainPatterns: String?

            public var wssEnable: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bindStageName != nil {
                    map["BindStageName"] = self.bindStageName!
                }
                if self.certificateId != nil {
                    map["CertificateId"] = self.certificateId!
                }
                if self.certificateName != nil {
                    map["CertificateName"] = self.certificateName!
                }
                if self.customDomainType != nil {
                    map["CustomDomainType"] = self.customDomainType!
                }
                if self.domainBindingStatus != nil {
                    map["DomainBindingStatus"] = self.domainBindingStatus!
                }
                if self.domainCNAMEStatus != nil {
                    map["DomainCNAMEStatus"] = self.domainCNAMEStatus!
                }
                if self.domainLegalStatus != nil {
                    map["DomainLegalStatus"] = self.domainLegalStatus!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.domainRemark != nil {
                    map["DomainRemark"] = self.domainRemark!
                }
                if self.domainWebSocketStatus != nil {
                    map["DomainWebSocketStatus"] = self.domainWebSocketStatus!
                }
                if self.isHttpRedirectToHttps != nil {
                    map["IsHttpRedirectToHttps"] = self.isHttpRedirectToHttps!
                }
                if self.wildcardDomainPatterns != nil {
                    map["WildcardDomainPatterns"] = self.wildcardDomainPatterns!
                }
                if self.wssEnable != nil {
                    map["WssEnable"] = self.wssEnable!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BindStageName") {
                    self.bindStageName = dict["BindStageName"] as! String
                }
                if dict.keys.contains("CertificateId") {
                    self.certificateId = dict["CertificateId"] as! String
                }
                if dict.keys.contains("CertificateName") {
                    self.certificateName = dict["CertificateName"] as! String
                }
                if dict.keys.contains("CustomDomainType") {
                    self.customDomainType = dict["CustomDomainType"] as! String
                }
                if dict.keys.contains("DomainBindingStatus") {
                    self.domainBindingStatus = dict["DomainBindingStatus"] as! String
                }
                if dict.keys.contains("DomainCNAMEStatus") {
                    self.domainCNAMEStatus = dict["DomainCNAMEStatus"] as! String
                }
                if dict.keys.contains("DomainLegalStatus") {
                    self.domainLegalStatus = dict["DomainLegalStatus"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("DomainRemark") {
                    self.domainRemark = dict["DomainRemark"] as! String
                }
                if dict.keys.contains("DomainWebSocketStatus") {
                    self.domainWebSocketStatus = dict["DomainWebSocketStatus"] as! String
                }
                if dict.keys.contains("IsHttpRedirectToHttps") {
                    self.isHttpRedirectToHttps = dict["IsHttpRedirectToHttps"] as! Bool
                }
                if dict.keys.contains("WildcardDomainPatterns") {
                    self.wildcardDomainPatterns = dict["WildcardDomainPatterns"] as! String
                }
                if dict.keys.contains("WssEnable") {
                    self.wssEnable = dict["WssEnable"] as! String
                }
            }
        }
        public var domainItem: [DescribeApiGroupResponseBody.CustomDomains.DomainItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainItem != nil {
                var tmp : [Any] = []
                for k in self.domainItem! {
                    tmp.append(k.toMap())
                }
                map["DomainItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainItem") {
                self.domainItem = dict["DomainItem"] as! [DescribeApiGroupResponseBody.CustomDomains.DomainItem]
            }
        }
    }
    public class StageItems : Tea.TeaModel {
        public class StageInfo : Tea.TeaModel {
            public var description_: String?

            public var stageId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("StageId") {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var stageInfo: [DescribeApiGroupResponseBody.StageItems.StageInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.stageInfo != nil {
                var tmp : [Any] = []
                for k in self.stageInfo! {
                    tmp.append(k.toMap())
                }
                map["StageInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StageInfo") {
                self.stageInfo = dict["StageInfo"] as! [DescribeApiGroupResponseBody.StageItems.StageInfo]
            }
        }
    }
    public var basePath: String?

    public var billingStatus: String?

    public var classicVpcSubDomain: String?

    public var cloudMarketCommodity: Bool?

    public var cmsMonitorGroup: String?

    public var compatibleFlags: String?

    public var createdTime: String?

    public var customDomains: DescribeApiGroupResponseBody.CustomDomains?

    public var customTraceConfig: String?

    public var customerConfigs: String?

    public var defaultDomain: String?

    public var description_: String?

    public var groupId: String?

    public var groupName: String?

    public var httpsPolicy: String?

    public var illegalStatus: String?

    public var instanceId: String?

    public var instanceType: String?

    public var instanceVipList: String?

    public var ipv6Status: String?

    public var modifiedTime: String?

    public var passthroughHeaders: String?

    public var regionId: String?

    public var requestId: String?

    public var rpcPattern: String?

    public var stageItems: DescribeApiGroupResponseBody.StageItems?

    public var status: String?

    public var subDomain: String?

    public var trafficLimit: Int32?

    public var userLogConfig: String?

    public var vpcDomain: String?

    public var vpcSlbIntranetDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customDomains?.validate()
        try self.stageItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.billingStatus != nil {
            map["BillingStatus"] = self.billingStatus!
        }
        if self.classicVpcSubDomain != nil {
            map["ClassicVpcSubDomain"] = self.classicVpcSubDomain!
        }
        if self.cloudMarketCommodity != nil {
            map["CloudMarketCommodity"] = self.cloudMarketCommodity!
        }
        if self.cmsMonitorGroup != nil {
            map["CmsMonitorGroup"] = self.cmsMonitorGroup!
        }
        if self.compatibleFlags != nil {
            map["CompatibleFlags"] = self.compatibleFlags!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.customDomains != nil {
            map["CustomDomains"] = self.customDomains?.toMap()
        }
        if self.customTraceConfig != nil {
            map["CustomTraceConfig"] = self.customTraceConfig!
        }
        if self.customerConfigs != nil {
            map["CustomerConfigs"] = self.customerConfigs!
        }
        if self.defaultDomain != nil {
            map["DefaultDomain"] = self.defaultDomain!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.httpsPolicy != nil {
            map["HttpsPolicy"] = self.httpsPolicy!
        }
        if self.illegalStatus != nil {
            map["IllegalStatus"] = self.illegalStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceVipList != nil {
            map["InstanceVipList"] = self.instanceVipList!
        }
        if self.ipv6Status != nil {
            map["Ipv6Status"] = self.ipv6Status!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.passthroughHeaders != nil {
            map["PassthroughHeaders"] = self.passthroughHeaders!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rpcPattern != nil {
            map["RpcPattern"] = self.rpcPattern!
        }
        if self.stageItems != nil {
            map["StageItems"] = self.stageItems?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        if self.trafficLimit != nil {
            map["TrafficLimit"] = self.trafficLimit!
        }
        if self.userLogConfig != nil {
            map["UserLogConfig"] = self.userLogConfig!
        }
        if self.vpcDomain != nil {
            map["VpcDomain"] = self.vpcDomain!
        }
        if self.vpcSlbIntranetDomain != nil {
            map["VpcSlbIntranetDomain"] = self.vpcSlbIntranetDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("BillingStatus") {
            self.billingStatus = dict["BillingStatus"] as! String
        }
        if dict.keys.contains("ClassicVpcSubDomain") {
            self.classicVpcSubDomain = dict["ClassicVpcSubDomain"] as! String
        }
        if dict.keys.contains("CloudMarketCommodity") {
            self.cloudMarketCommodity = dict["CloudMarketCommodity"] as! Bool
        }
        if dict.keys.contains("CmsMonitorGroup") {
            self.cmsMonitorGroup = dict["CmsMonitorGroup"] as! String
        }
        if dict.keys.contains("CompatibleFlags") {
            self.compatibleFlags = dict["CompatibleFlags"] as! String
        }
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("CustomDomains") {
            var model = DescribeApiGroupResponseBody.CustomDomains()
            model.fromMap(dict["CustomDomains"] as! [String: Any])
            self.customDomains = model
        }
        if dict.keys.contains("CustomTraceConfig") {
            self.customTraceConfig = dict["CustomTraceConfig"] as! String
        }
        if dict.keys.contains("CustomerConfigs") {
            self.customerConfigs = dict["CustomerConfigs"] as! String
        }
        if dict.keys.contains("DefaultDomain") {
            self.defaultDomain = dict["DefaultDomain"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HttpsPolicy") {
            self.httpsPolicy = dict["HttpsPolicy"] as! String
        }
        if dict.keys.contains("IllegalStatus") {
            self.illegalStatus = dict["IllegalStatus"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceVipList") {
            self.instanceVipList = dict["InstanceVipList"] as! String
        }
        if dict.keys.contains("Ipv6Status") {
            self.ipv6Status = dict["Ipv6Status"] as! String
        }
        if dict.keys.contains("ModifiedTime") {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("PassthroughHeaders") {
            self.passthroughHeaders = dict["PassthroughHeaders"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RpcPattern") {
            self.rpcPattern = dict["RpcPattern"] as! String
        }
        if dict.keys.contains("StageItems") {
            var model = DescribeApiGroupResponseBody.StageItems()
            model.fromMap(dict["StageItems"] as! [String: Any])
            self.stageItems = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
        if dict.keys.contains("TrafficLimit") {
            self.trafficLimit = dict["TrafficLimit"] as! Int32
        }
        if dict.keys.contains("UserLogConfig") {
            self.userLogConfig = dict["UserLogConfig"] as! String
        }
        if dict.keys.contains("VpcDomain") {
            self.vpcDomain = dict["VpcDomain"] as! String
        }
        if dict.keys.contains("VpcSlbIntranetDomain") {
            self.vpcSlbIntranetDomain = dict["VpcSlbIntranetDomain"] as! String
        }
    }
}

public class DescribeApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiGroupVpcWhitelistRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApiGroupVpcWhitelistResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vpcIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpcIds != nil {
            map["VpcIds"] = self.vpcIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpcIds") {
            self.vpcIds = dict["VpcIds"] as! String
        }
    }
}

public class DescribeApiGroupVpcWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiGroupVpcWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiGroupVpcWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var enableTagAuth: Bool?

    public var groupId: String?

    public var groupName: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var sort: String?

    public var tag: [DescribeApiGroupsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableTagAuth != nil {
            map["EnableTagAuth"] = self.enableTagAuth!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sort != nil {
            map["Sort"] = self.sort!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableTagAuth") {
            self.enableTagAuth = dict["EnableTagAuth"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Sort") {
            self.sort = dict["Sort"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeApiGroupsRequest.Tag]
        }
    }
}

public class DescribeApiGroupsResponseBody : Tea.TeaModel {
    public class ApiGroupAttributes : Tea.TeaModel {
        public class ApiGroupAttribute : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class TagInfo : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagInfo: [DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute.Tags.TagInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagInfo != nil {
                        var tmp : [Any] = []
                        for k in self.tagInfo! {
                            tmp.append(k.toMap())
                        }
                        map["TagInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagInfo") {
                        self.tagInfo = dict["TagInfo"] as! [DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute.Tags.TagInfo]
                    }
                }
            }
            public var basePath: String?

            public var billingStatus: String?

            public var createdTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var httpsPolicy: String?

            public var illegalStatus: String?

            public var instanceId: String?

            public var instanceType: String?

            public var modifiedTime: String?

            public var regionId: String?

            public var subDomain: String?

            public var tags: DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute.Tags?

            public var trafficLimit: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.basePath != nil {
                    map["BasePath"] = self.basePath!
                }
                if self.billingStatus != nil {
                    map["BillingStatus"] = self.billingStatus!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.httpsPolicy != nil {
                    map["HttpsPolicy"] = self.httpsPolicy!
                }
                if self.illegalStatus != nil {
                    map["IllegalStatus"] = self.illegalStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.subDomain != nil {
                    map["SubDomain"] = self.subDomain!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.trafficLimit != nil {
                    map["TrafficLimit"] = self.trafficLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BasePath") {
                    self.basePath = dict["BasePath"] as! String
                }
                if dict.keys.contains("BillingStatus") {
                    self.billingStatus = dict["BillingStatus"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HttpsPolicy") {
                    self.httpsPolicy = dict["HttpsPolicy"] as! String
                }
                if dict.keys.contains("IllegalStatus") {
                    self.illegalStatus = dict["IllegalStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SubDomain") {
                    self.subDomain = dict["SubDomain"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TrafficLimit") {
                    self.trafficLimit = dict["TrafficLimit"] as! Int32
                }
            }
        }
        public var apiGroupAttribute: [DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiGroupAttribute != nil {
                var tmp : [Any] = []
                for k in self.apiGroupAttribute! {
                    tmp.append(k.toMap())
                }
                map["ApiGroupAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiGroupAttribute") {
                self.apiGroupAttribute = dict["ApiGroupAttribute"] as! [DescribeApiGroupsResponseBody.ApiGroupAttributes.ApiGroupAttribute]
            }
        }
    }
    public var apiGroupAttributes: DescribeApiGroupsResponseBody.ApiGroupAttributes?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiGroupAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiGroupAttributes != nil {
            map["ApiGroupAttributes"] = self.apiGroupAttributes?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiGroupAttributes") {
            var model = DescribeApiGroupsResponseBody.ApiGroupAttributes()
            model.fromMap(dict["ApiGroupAttributes"] as! [String: Any])
            self.apiGroupAttributes = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiHistoriesRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiName: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiHistoriesResponseBody : Tea.TeaModel {
    public class ApiHisItems : Tea.TeaModel {
        public class ApiHisItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var deployedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var historyVersion: String?

            public var regionId: String?

            public var stageName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.deployedTime != nil {
                    map["DeployedTime"] = self.deployedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.historyVersion != nil {
                    map["HistoryVersion"] = self.historyVersion!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("DeployedTime") {
                    self.deployedTime = dict["DeployedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HistoryVersion") {
                    self.historyVersion = dict["HistoryVersion"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var apiHisItem: [DescribeApiHistoriesResponseBody.ApiHisItems.ApiHisItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiHisItem != nil {
                var tmp : [Any] = []
                for k in self.apiHisItem! {
                    tmp.append(k.toMap())
                }
                map["ApiHisItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiHisItem") {
                self.apiHisItem = dict["ApiHisItem"] as! [DescribeApiHistoriesResponseBody.ApiHisItems.ApiHisItem]
            }
        }
    }
    public var apiHisItems: DescribeApiHistoriesResponseBody.ApiHisItems?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiHisItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiHisItems != nil {
            map["ApiHisItems"] = self.apiHisItems?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiHisItems") {
            var model = DescribeApiHistoriesResponseBody.ApiHisItems()
            model.fromMap(dict["ApiHisItems"] as! [String: Any])
            self.apiHisItems = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiHistoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiHistoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiHistoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiHistoryRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var historyVersion: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.historyVersion != nil {
            map["HistoryVersion"] = self.historyVersion!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HistoryVersion") {
            self.historyVersion = dict["HistoryVersion"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiHistoryResponseBody : Tea.TeaModel {
    public class BackendConfig : Tea.TeaModel {
        public var backendId: String?

        public var backendName: String?

        public var backendType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendId != nil {
                map["BackendId"] = self.backendId!
            }
            if self.backendName != nil {
                map["BackendName"] = self.backendName!
            }
            if self.backendType != nil {
                map["BackendType"] = self.backendType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendId") {
                self.backendId = dict["BackendId"] as! String
            }
            if dict.keys.contains("BackendName") {
                self.backendName = dict["BackendName"] as! String
            }
            if dict.keys.contains("BackendType") {
                self.backendType = dict["BackendType"] as! String
            }
        }
    }
    public class ConstantParameters : Tea.TeaModel {
        public class ConstantParameter : Tea.TeaModel {
            public var constantValue: String?

            public var description_: String?

            public var location: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.constantValue != nil {
                    map["ConstantValue"] = self.constantValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConstantValue") {
                    self.constantValue = dict["ConstantValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var constantParameter: [DescribeApiHistoryResponseBody.ConstantParameters.ConstantParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.constantParameter != nil {
                var tmp : [Any] = []
                for k in self.constantParameter! {
                    tmp.append(k.toMap())
                }
                map["ConstantParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConstantParameter") {
                self.constantParameter = dict["ConstantParameter"] as! [DescribeApiHistoryResponseBody.ConstantParameters.ConstantParameter]
            }
        }
    }
    public class CustomSystemParameters : Tea.TeaModel {
        public class CustomSystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var customSystemParameter: [DescribeApiHistoryResponseBody.CustomSystemParameters.CustomSystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customSystemParameter != nil {
                var tmp : [Any] = []
                for k in self.customSystemParameter! {
                    tmp.append(k.toMap())
                }
                map["CustomSystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomSystemParameter") {
                self.customSystemParameter = dict["CustomSystemParameter"] as! [DescribeApiHistoryResponseBody.CustomSystemParameters.CustomSystemParameter]
            }
        }
    }
    public class ErrorCodeSamples : Tea.TeaModel {
        public class ErrorCodeSample : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var errorCodeSample: [DescribeApiHistoryResponseBody.ErrorCodeSamples.ErrorCodeSample]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCodeSample != nil {
                var tmp : [Any] = []
                for k in self.errorCodeSample! {
                    tmp.append(k.toMap())
                }
                map["ErrorCodeSample"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCodeSample") {
                self.errorCodeSample = dict["ErrorCodeSample"] as! [DescribeApiHistoryResponseBody.ErrorCodeSamples.ErrorCodeSample]
            }
        }
    }
    public class OpenIdConnectConfig : Tea.TeaModel {
        public var idTokenParamName: String?

        public var openIdApiType: String?

        public var publicKey: String?

        public var publicKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.idTokenParamName != nil {
                map["IdTokenParamName"] = self.idTokenParamName!
            }
            if self.openIdApiType != nil {
                map["OpenIdApiType"] = self.openIdApiType!
            }
            if self.publicKey != nil {
                map["PublicKey"] = self.publicKey!
            }
            if self.publicKeyId != nil {
                map["PublicKeyId"] = self.publicKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdTokenParamName") {
                self.idTokenParamName = dict["IdTokenParamName"] as! String
            }
            if dict.keys.contains("OpenIdApiType") {
                self.openIdApiType = dict["OpenIdApiType"] as! String
            }
            if dict.keys.contains("PublicKey") {
                self.publicKey = dict["PublicKey"] as! String
            }
            if dict.keys.contains("PublicKeyId") {
                self.publicKeyId = dict["PublicKeyId"] as! String
            }
        }
    }
    public class RequestConfig : Tea.TeaModel {
        public var bodyFormat: String?

        public var bodyModel: String?

        public var postBodyDescription: String?

        public var requestHttpMethod: String?

        public var requestMode: String?

        public var requestPath: String?

        public var requestProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bodyFormat != nil {
                map["BodyFormat"] = self.bodyFormat!
            }
            if self.bodyModel != nil {
                map["BodyModel"] = self.bodyModel!
            }
            if self.postBodyDescription != nil {
                map["PostBodyDescription"] = self.postBodyDescription!
            }
            if self.requestHttpMethod != nil {
                map["RequestHttpMethod"] = self.requestHttpMethod!
            }
            if self.requestMode != nil {
                map["RequestMode"] = self.requestMode!
            }
            if self.requestPath != nil {
                map["RequestPath"] = self.requestPath!
            }
            if self.requestProtocol != nil {
                map["RequestProtocol"] = self.requestProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BodyFormat") {
                self.bodyFormat = dict["BodyFormat"] as! String
            }
            if dict.keys.contains("BodyModel") {
                self.bodyModel = dict["BodyModel"] as! String
            }
            if dict.keys.contains("PostBodyDescription") {
                self.postBodyDescription = dict["PostBodyDescription"] as! String
            }
            if dict.keys.contains("RequestHttpMethod") {
                self.requestHttpMethod = dict["RequestHttpMethod"] as! String
            }
            if dict.keys.contains("RequestMode") {
                self.requestMode = dict["RequestMode"] as! String
            }
            if dict.keys.contains("RequestPath") {
                self.requestPath = dict["RequestPath"] as! String
            }
            if dict.keys.contains("RequestProtocol") {
                self.requestProtocol = dict["RequestProtocol"] as! String
            }
        }
    }
    public class RequestParameters : Tea.TeaModel {
        public class RequestParameter : Tea.TeaModel {
            public var apiParameterName: String?

            public var arrayItemsType: String?

            public var defaultValue: String?

            public var demoValue: String?

            public var description_: String?

            public var docOrder: Int32?

            public var docShow: String?

            public var enumValue: String?

            public var jsonScheme: String?

            public var location: String?

            public var maxLength: Int64?

            public var maxValue: Int64?

            public var minLength: Int64?

            public var minValue: Int64?

            public var parameterType: String?

            public var regularExpression: String?

            public var required_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiParameterName != nil {
                    map["ApiParameterName"] = self.apiParameterName!
                }
                if self.arrayItemsType != nil {
                    map["ArrayItemsType"] = self.arrayItemsType!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.docOrder != nil {
                    map["DocOrder"] = self.docOrder!
                }
                if self.docShow != nil {
                    map["DocShow"] = self.docShow!
                }
                if self.enumValue != nil {
                    map["EnumValue"] = self.enumValue!
                }
                if self.jsonScheme != nil {
                    map["JsonScheme"] = self.jsonScheme!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.maxLength != nil {
                    map["MaxLength"] = self.maxLength!
                }
                if self.maxValue != nil {
                    map["MaxValue"] = self.maxValue!
                }
                if self.minLength != nil {
                    map["MinLength"] = self.minLength!
                }
                if self.minValue != nil {
                    map["MinValue"] = self.minValue!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.regularExpression != nil {
                    map["RegularExpression"] = self.regularExpression!
                }
                if self.required_ != nil {
                    map["Required"] = self.required_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiParameterName") {
                    self.apiParameterName = dict["ApiParameterName"] as! String
                }
                if dict.keys.contains("ArrayItemsType") {
                    self.arrayItemsType = dict["ArrayItemsType"] as! String
                }
                if dict.keys.contains("DefaultValue") {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocOrder") {
                    self.docOrder = dict["DocOrder"] as! Int32
                }
                if dict.keys.contains("DocShow") {
                    self.docShow = dict["DocShow"] as! String
                }
                if dict.keys.contains("EnumValue") {
                    self.enumValue = dict["EnumValue"] as! String
                }
                if dict.keys.contains("JsonScheme") {
                    self.jsonScheme = dict["JsonScheme"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("MaxLength") {
                    self.maxLength = dict["MaxLength"] as! Int64
                }
                if dict.keys.contains("MaxValue") {
                    self.maxValue = dict["MaxValue"] as! Int64
                }
                if dict.keys.contains("MinLength") {
                    self.minLength = dict["MinLength"] as! Int64
                }
                if dict.keys.contains("MinValue") {
                    self.minValue = dict["MinValue"] as! Int64
                }
                if dict.keys.contains("ParameterType") {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("RegularExpression") {
                    self.regularExpression = dict["RegularExpression"] as! String
                }
                if dict.keys.contains("Required") {
                    self.required_ = dict["Required"] as! String
                }
            }
        }
        public var requestParameter: [DescribeApiHistoryResponseBody.RequestParameters.RequestParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestParameter != nil {
                var tmp : [Any] = []
                for k in self.requestParameter! {
                    tmp.append(k.toMap())
                }
                map["RequestParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestParameter") {
                self.requestParameter = dict["RequestParameter"] as! [DescribeApiHistoryResponseBody.RequestParameters.RequestParameter]
            }
        }
    }
    public class ResultDescriptions : Tea.TeaModel {
        public class ResultDescription : Tea.TeaModel {
            public var description_: String?

            public var hasChild: Bool?

            public var id: String?

            public var key: String?

            public var mandatory: Bool?

            public var name: String?

            public var pid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hasChild != nil {
                    map["HasChild"] = self.hasChild!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mandatory != nil {
                    map["Mandatory"] = self.mandatory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HasChild") {
                    self.hasChild = dict["HasChild"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Mandatory") {
                    self.mandatory = dict["Mandatory"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pid") {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var resultDescription: [DescribeApiHistoryResponseBody.ResultDescriptions.ResultDescription]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultDescription != nil {
                var tmp : [Any] = []
                for k in self.resultDescription! {
                    tmp.append(k.toMap())
                }
                map["ResultDescription"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultDescription") {
                self.resultDescription = dict["ResultDescription"] as! [DescribeApiHistoryResponseBody.ResultDescriptions.ResultDescription]
            }
        }
    }
    public class ServiceConfig : Tea.TeaModel {
        public class EventBridgeConfig : Tea.TeaModel {
            public var eventBridgeRegionId: String?

            public var eventBus: String?

            public var eventSource: String?

            public var roleArn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventBridgeRegionId != nil {
                    map["EventBridgeRegionId"] = self.eventBridgeRegionId!
                }
                if self.eventBus != nil {
                    map["EventBus"] = self.eventBus!
                }
                if self.eventSource != nil {
                    map["EventSource"] = self.eventSource!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventBridgeRegionId") {
                    self.eventBridgeRegionId = dict["EventBridgeRegionId"] as! String
                }
                if dict.keys.contains("EventBus") {
                    self.eventBus = dict["EventBus"] as! String
                }
                if dict.keys.contains("EventSource") {
                    self.eventSource = dict["EventSource"] as! String
                }
                if dict.keys.contains("RoleArn") {
                    self.roleArn = dict["RoleArn"] as! String
                }
            }
        }
        public class FunctionComputeConfig : Tea.TeaModel {
            public var contentTypeCatagory: String?

            public var contentTypeValue: String?

            public var fcBaseUrl: String?

            public var fcType: String?

            public var functionName: String?

            public var method: String?

            public var onlyBusinessPath: Bool?

            public var path: String?

            public var qualifier: String?

            public var regionId: String?

            public var roleArn: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentTypeCatagory != nil {
                    map["ContentTypeCatagory"] = self.contentTypeCatagory!
                }
                if self.contentTypeValue != nil {
                    map["ContentTypeValue"] = self.contentTypeValue!
                }
                if self.fcBaseUrl != nil {
                    map["FcBaseUrl"] = self.fcBaseUrl!
                }
                if self.fcType != nil {
                    map["FcType"] = self.fcType!
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.onlyBusinessPath != nil {
                    map["OnlyBusinessPath"] = self.onlyBusinessPath!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.qualifier != nil {
                    map["Qualifier"] = self.qualifier!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentTypeCatagory") {
                    self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
                }
                if dict.keys.contains("ContentTypeValue") {
                    self.contentTypeValue = dict["ContentTypeValue"] as! String
                }
                if dict.keys.contains("FcBaseUrl") {
                    self.fcBaseUrl = dict["FcBaseUrl"] as! String
                }
                if dict.keys.contains("FcType") {
                    self.fcType = dict["FcType"] as! String
                }
                if dict.keys.contains("FunctionName") {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("OnlyBusinessPath") {
                    self.onlyBusinessPath = dict["OnlyBusinessPath"] as! Bool
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Qualifier") {
                    self.qualifier = dict["Qualifier"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RoleArn") {
                    self.roleArn = dict["RoleArn"] as! String
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public class MockHeaders : Tea.TeaModel {
            public class MockHeader : Tea.TeaModel {
                public var headerName: String?

                public var headerValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerName != nil {
                        map["HeaderName"] = self.headerName!
                    }
                    if self.headerValue != nil {
                        map["HeaderValue"] = self.headerValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderName") {
                        self.headerName = dict["HeaderName"] as! String
                    }
                    if dict.keys.contains("HeaderValue") {
                        self.headerValue = dict["HeaderValue"] as! String
                    }
                }
            }
            public var mockHeader: [DescribeApiHistoryResponseBody.ServiceConfig.MockHeaders.MockHeader]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mockHeader != nil {
                    var tmp : [Any] = []
                    for k in self.mockHeader! {
                        tmp.append(k.toMap())
                    }
                    map["MockHeader"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MockHeader") {
                    self.mockHeader = dict["MockHeader"] as! [DescribeApiHistoryResponseBody.ServiceConfig.MockHeaders.MockHeader]
                }
            }
        }
        public class OssConfig : Tea.TeaModel {
            public var action: String?

            public var bucketName: String?

            public var key: String?

            public var ossRegionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.bucketName != nil {
                    map["BucketName"] = self.bucketName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.ossRegionId != nil {
                    map["OssRegionId"] = self.ossRegionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("BucketName") {
                    self.bucketName = dict["BucketName"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("OssRegionId") {
                    self.ossRegionId = dict["OssRegionId"] as! String
                }
            }
        }
        public class VpcConfig : Tea.TeaModel {
            public var instanceId: String?

            public var name: String?

            public var port: Int32?

            public var vpcId: String?

            public var vpcScheme: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcScheme != nil {
                    map["VpcScheme"] = self.vpcScheme!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcScheme") {
                    self.vpcScheme = dict["VpcScheme"] as! String
                }
            }
        }
        public var contentTypeCatagory: String?

        public var contentTypeValue: String?

        public var eventBridgeConfig: DescribeApiHistoryResponseBody.ServiceConfig.EventBridgeConfig?

        public var functionComputeConfig: DescribeApiHistoryResponseBody.ServiceConfig.FunctionComputeConfig?

        public var mock: String?

        public var mockHeaders: DescribeApiHistoryResponseBody.ServiceConfig.MockHeaders?

        public var mockResult: String?

        public var mockStatusCode: Int32?

        public var ossConfig: DescribeApiHistoryResponseBody.ServiceConfig.OssConfig?

        public var serviceAddress: String?

        public var serviceHttpMethod: String?

        public var servicePath: String?

        public var serviceProtocol: String?

        public var serviceTimeout: Int32?

        public var serviceVpcEnable: String?

        public var vpcConfig: DescribeApiHistoryResponseBody.ServiceConfig.VpcConfig?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.eventBridgeConfig?.validate()
            try self.functionComputeConfig?.validate()
            try self.mockHeaders?.validate()
            try self.ossConfig?.validate()
            try self.vpcConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contentTypeCatagory != nil {
                map["ContentTypeCatagory"] = self.contentTypeCatagory!
            }
            if self.contentTypeValue != nil {
                map["ContentTypeValue"] = self.contentTypeValue!
            }
            if self.eventBridgeConfig != nil {
                map["EventBridgeConfig"] = self.eventBridgeConfig?.toMap()
            }
            if self.functionComputeConfig != nil {
                map["FunctionComputeConfig"] = self.functionComputeConfig?.toMap()
            }
            if self.mock != nil {
                map["Mock"] = self.mock!
            }
            if self.mockHeaders != nil {
                map["MockHeaders"] = self.mockHeaders?.toMap()
            }
            if self.mockResult != nil {
                map["MockResult"] = self.mockResult!
            }
            if self.mockStatusCode != nil {
                map["MockStatusCode"] = self.mockStatusCode!
            }
            if self.ossConfig != nil {
                map["OssConfig"] = self.ossConfig?.toMap()
            }
            if self.serviceAddress != nil {
                map["ServiceAddress"] = self.serviceAddress!
            }
            if self.serviceHttpMethod != nil {
                map["ServiceHttpMethod"] = self.serviceHttpMethod!
            }
            if self.servicePath != nil {
                map["ServicePath"] = self.servicePath!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceTimeout != nil {
                map["ServiceTimeout"] = self.serviceTimeout!
            }
            if self.serviceVpcEnable != nil {
                map["ServiceVpcEnable"] = self.serviceVpcEnable!
            }
            if self.vpcConfig != nil {
                map["VpcConfig"] = self.vpcConfig?.toMap()
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContentTypeCatagory") {
                self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
            }
            if dict.keys.contains("ContentTypeValue") {
                self.contentTypeValue = dict["ContentTypeValue"] as! String
            }
            if dict.keys.contains("EventBridgeConfig") {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.EventBridgeConfig()
                model.fromMap(dict["EventBridgeConfig"] as! [String: Any])
                self.eventBridgeConfig = model
            }
            if dict.keys.contains("FunctionComputeConfig") {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.FunctionComputeConfig()
                model.fromMap(dict["FunctionComputeConfig"] as! [String: Any])
                self.functionComputeConfig = model
            }
            if dict.keys.contains("Mock") {
                self.mock = dict["Mock"] as! String
            }
            if dict.keys.contains("MockHeaders") {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.MockHeaders()
                model.fromMap(dict["MockHeaders"] as! [String: Any])
                self.mockHeaders = model
            }
            if dict.keys.contains("MockResult") {
                self.mockResult = dict["MockResult"] as! String
            }
            if dict.keys.contains("MockStatusCode") {
                self.mockStatusCode = dict["MockStatusCode"] as! Int32
            }
            if dict.keys.contains("OssConfig") {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.OssConfig()
                model.fromMap(dict["OssConfig"] as! [String: Any])
                self.ossConfig = model
            }
            if dict.keys.contains("ServiceAddress") {
                self.serviceAddress = dict["ServiceAddress"] as! String
            }
            if dict.keys.contains("ServiceHttpMethod") {
                self.serviceHttpMethod = dict["ServiceHttpMethod"] as! String
            }
            if dict.keys.contains("ServicePath") {
                self.servicePath = dict["ServicePath"] as! String
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("ServiceTimeout") {
                self.serviceTimeout = dict["ServiceTimeout"] as! Int32
            }
            if dict.keys.contains("ServiceVpcEnable") {
                self.serviceVpcEnable = dict["ServiceVpcEnable"] as! String
            }
            if dict.keys.contains("VpcConfig") {
                var model = DescribeApiHistoryResponseBody.ServiceConfig.VpcConfig()
                model.fromMap(dict["VpcConfig"] as! [String: Any])
                self.vpcConfig = model
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public class ServiceParameters : Tea.TeaModel {
        public class ServiceParameter : Tea.TeaModel {
            public var location: String?

            public var parameterType: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterType") {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameter: [DescribeApiHistoryResponseBody.ServiceParameters.ServiceParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameter != nil {
                var tmp : [Any] = []
                for k in self.serviceParameter! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameter") {
                self.serviceParameter = dict["ServiceParameter"] as! [DescribeApiHistoryResponseBody.ServiceParameters.ServiceParameter]
            }
        }
    }
    public class ServiceParametersMap : Tea.TeaModel {
        public class ServiceParameterMap : Tea.TeaModel {
            public var requestParameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestParameterName != nil {
                    map["RequestParameterName"] = self.requestParameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestParameterName") {
                    self.requestParameterName = dict["RequestParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameterMap: [DescribeApiHistoryResponseBody.ServiceParametersMap.ServiceParameterMap]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameterMap != nil {
                var tmp : [Any] = []
                for k in self.serviceParameterMap! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameterMap"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameterMap") {
                self.serviceParameterMap = dict["ServiceParameterMap"] as! [DescribeApiHistoryResponseBody.ServiceParametersMap.ServiceParameterMap]
            }
        }
    }
    public class SystemParameters : Tea.TeaModel {
        public class SystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var systemParameter: [DescribeApiHistoryResponseBody.SystemParameters.SystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemParameter != nil {
                var tmp : [Any] = []
                for k in self.systemParameter! {
                    tmp.append(k.toMap())
                }
                map["SystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemParameter") {
                self.systemParameter = dict["SystemParameter"] as! [DescribeApiHistoryResponseBody.SystemParameters.SystemParameter]
            }
        }
    }
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendConfig: DescribeApiHistoryResponseBody.BackendConfig?

    public var backendEnable: Bool?

    public var constantParameters: DescribeApiHistoryResponseBody.ConstantParameters?

    public var customSystemParameters: DescribeApiHistoryResponseBody.CustomSystemParameters?

    public var deployedTime: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: DescribeApiHistoryResponseBody.ErrorCodeSamples?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var groupName: String?

    public var historyVersion: String?

    public var openIdConnectConfig: DescribeApiHistoryResponseBody.OpenIdConnectConfig?

    public var regionId: String?

    public var requestConfig: DescribeApiHistoryResponseBody.RequestConfig?

    public var requestId: String?

    public var requestParameters: DescribeApiHistoryResponseBody.RequestParameters?

    public var resultBodyModel: String?

    public var resultDescriptions: DescribeApiHistoryResponseBody.ResultDescriptions?

    public var resultSample: String?

    public var resultType: String?

    public var serviceConfig: DescribeApiHistoryResponseBody.ServiceConfig?

    public var serviceParameters: DescribeApiHistoryResponseBody.ServiceParameters?

    public var serviceParametersMap: DescribeApiHistoryResponseBody.ServiceParametersMap?

    public var stageName: String?

    public var status: String?

    public var systemParameters: DescribeApiHistoryResponseBody.SystemParameters?

    public var visibility: String?

    public var webSocketApiType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendConfig?.validate()
        try self.constantParameters?.validate()
        try self.customSystemParameters?.validate()
        try self.errorCodeSamples?.validate()
        try self.openIdConnectConfig?.validate()
        try self.requestConfig?.validate()
        try self.requestParameters?.validate()
        try self.resultDescriptions?.validate()
        try self.serviceConfig?.validate()
        try self.serviceParameters?.validate()
        try self.serviceParametersMap?.validate()
        try self.systemParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendConfig != nil {
            map["BackendConfig"] = self.backendConfig?.toMap()
        }
        if self.backendEnable != nil {
            map["BackendEnable"] = self.backendEnable!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters?.toMap()
        }
        if self.customSystemParameters != nil {
            map["CustomSystemParameters"] = self.customSystemParameters?.toMap()
        }
        if self.deployedTime != nil {
            map["DeployedTime"] = self.deployedTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples?.toMap()
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.historyVersion != nil {
            map["HistoryVersion"] = self.historyVersion!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters?.toMap()
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions?.toMap()
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig?.toMap()
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters?.toMap()
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap?.toMap()
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.webSocketApiType != nil {
            map["WebSocketApiType"] = self.webSocketApiType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendConfig") {
            var model = DescribeApiHistoryResponseBody.BackendConfig()
            model.fromMap(dict["BackendConfig"] as! [String: Any])
            self.backendConfig = model
        }
        if dict.keys.contains("BackendEnable") {
            self.backendEnable = dict["BackendEnable"] as! Bool
        }
        if dict.keys.contains("ConstantParameters") {
            var model = DescribeApiHistoryResponseBody.ConstantParameters()
            model.fromMap(dict["ConstantParameters"] as! [String: Any])
            self.constantParameters = model
        }
        if dict.keys.contains("CustomSystemParameters") {
            var model = DescribeApiHistoryResponseBody.CustomSystemParameters()
            model.fromMap(dict["CustomSystemParameters"] as! [String: Any])
            self.customSystemParameters = model
        }
        if dict.keys.contains("DeployedTime") {
            self.deployedTime = dict["DeployedTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") {
            var model = DescribeApiHistoryResponseBody.ErrorCodeSamples()
            model.fromMap(dict["ErrorCodeSamples"] as! [String: Any])
            self.errorCodeSamples = model
        }
        if dict.keys.contains("FailResultSample") {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("HistoryVersion") {
            self.historyVersion = dict["HistoryVersion"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") {
            var model = DescribeApiHistoryResponseBody.OpenIdConnectConfig()
            model.fromMap(dict["OpenIdConnectConfig"] as! [String: Any])
            self.openIdConnectConfig = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestConfig") {
            var model = DescribeApiHistoryResponseBody.RequestConfig()
            model.fromMap(dict["RequestConfig"] as! [String: Any])
            self.requestConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestParameters") {
            var model = DescribeApiHistoryResponseBody.RequestParameters()
            model.fromMap(dict["RequestParameters"] as! [String: Any])
            self.requestParameters = model
        }
        if dict.keys.contains("ResultBodyModel") {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultDescriptions") {
            var model = DescribeApiHistoryResponseBody.ResultDescriptions()
            model.fromMap(dict["ResultDescriptions"] as! [String: Any])
            self.resultDescriptions = model
        }
        if dict.keys.contains("ResultSample") {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("ServiceConfig") {
            var model = DescribeApiHistoryResponseBody.ServiceConfig()
            model.fromMap(dict["ServiceConfig"] as! [String: Any])
            self.serviceConfig = model
        }
        if dict.keys.contains("ServiceParameters") {
            var model = DescribeApiHistoryResponseBody.ServiceParameters()
            model.fromMap(dict["ServiceParameters"] as! [String: Any])
            self.serviceParameters = model
        }
        if dict.keys.contains("ServiceParametersMap") {
            var model = DescribeApiHistoryResponseBody.ServiceParametersMap()
            model.fromMap(dict["ServiceParametersMap"] as! [String: Any])
            self.serviceParametersMap = model
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("SystemParameters") {
            var model = DescribeApiHistoryResponseBody.SystemParameters()
            model.fromMap(dict["SystemParameters"] as! [String: Any])
            self.systemParameters = model
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WebSocketApiType") {
            self.webSocketApiType = dict["WebSocketApiType"] as! String
        }
    }
}

public class DescribeApiHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiIpControlsRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiIpControlsResponseBody : Tea.TeaModel {
    public class ApiIpControls : Tea.TeaModel {
        public class ApiIpControlItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var ipControlId: String?

            public var ipControlName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.ipControlId != nil {
                    map["IpControlId"] = self.ipControlId!
                }
                if self.ipControlName != nil {
                    map["IpControlName"] = self.ipControlName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("IpControlId") {
                    self.ipControlId = dict["IpControlId"] as! String
                }
                if dict.keys.contains("IpControlName") {
                    self.ipControlName = dict["IpControlName"] as! String
                }
            }
        }
        public var apiIpControlItem: [DescribeApiIpControlsResponseBody.ApiIpControls.ApiIpControlItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiIpControlItem != nil {
                var tmp : [Any] = []
                for k in self.apiIpControlItem! {
                    tmp.append(k.toMap())
                }
                map["ApiIpControlItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiIpControlItem") {
                self.apiIpControlItem = dict["ApiIpControlItem"] as! [DescribeApiIpControlsResponseBody.ApiIpControls.ApiIpControlItem]
            }
        }
    }
    public var apiIpControls: DescribeApiIpControlsResponseBody.ApiIpControls?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiIpControls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIpControls != nil {
            map["ApiIpControls"] = self.apiIpControls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIpControls") {
            var model = DescribeApiIpControlsResponseBody.ApiIpControls()
            model.fromMap(dict["ApiIpControls"] as! [String: Any])
            self.apiIpControls = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiIpControlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiIpControlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiIpControlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiLatencyDataRequest : Tea.TeaModel {
    public var apiId: String?

    public var endTime: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeApiLatencyDataResponseBody : Tea.TeaModel {
    public class CallLatencys : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiLatencyDataResponseBody.CallLatencys.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") {
                self.monitorItem = dict["MonitorItem"] as! [DescribeApiLatencyDataResponseBody.CallLatencys.MonitorItem]
            }
        }
    }
    public var callLatencys: DescribeApiLatencyDataResponseBody.CallLatencys?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.callLatencys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callLatencys != nil {
            map["CallLatencys"] = self.callLatencys?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallLatencys") {
            var model = DescribeApiLatencyDataResponseBody.CallLatencys()
            model.fromMap(dict["CallLatencys"] as! [String: Any])
            self.callLatencys = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApiLatencyDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiLatencyDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiLatencyDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiMarketAttributesRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApiMarketAttributesResponseBody : Tea.TeaModel {
    public var apiId: String?

    public var marketChargingMode: String?

    public var needCharging: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.marketChargingMode != nil {
            map["MarketChargingMode"] = self.marketChargingMode!
        }
        if self.needCharging != nil {
            map["NeedCharging"] = self.needCharging!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("MarketChargingMode") {
            self.marketChargingMode = dict["MarketChargingMode"] as! String
        }
        if dict.keys.contains("NeedCharging") {
            self.needCharging = dict["NeedCharging"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApiMarketAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiMarketAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiMarketAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiQpsDataRequest : Tea.TeaModel {
    public var apiId: String?

    public var endTime: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeApiQpsDataResponseBody : Tea.TeaModel {
    public class CallFails : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiQpsDataResponseBody.CallFails.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") {
                self.monitorItem = dict["MonitorItem"] as! [DescribeApiQpsDataResponseBody.CallFails.MonitorItem]
            }
        }
    }
    public class CallSuccesses : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiQpsDataResponseBody.CallSuccesses.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") {
                self.monitorItem = dict["MonitorItem"] as! [DescribeApiQpsDataResponseBody.CallSuccesses.MonitorItem]
            }
        }
    }
    public var callFails: DescribeApiQpsDataResponseBody.CallFails?

    public var callSuccesses: DescribeApiQpsDataResponseBody.CallSuccesses?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.callFails?.validate()
        try self.callSuccesses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callFails != nil {
            map["CallFails"] = self.callFails?.toMap()
        }
        if self.callSuccesses != nil {
            map["CallSuccesses"] = self.callSuccesses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallFails") {
            var model = DescribeApiQpsDataResponseBody.CallFails()
            model.fromMap(dict["CallFails"] as! [String: Any])
            self.callFails = model
        }
        if dict.keys.contains("CallSuccesses") {
            var model = DescribeApiQpsDataResponseBody.CallSuccesses()
            model.fromMap(dict["CallSuccesses"] as! [String: Any])
            self.callSuccesses = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApiQpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiQpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiQpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiSignaturesRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiSignaturesResponseBody : Tea.TeaModel {
    public class ApiSignatures : Tea.TeaModel {
        public class ApiSignatureItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var signatureId: String?

            public var signatureName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.signatureId != nil {
                    map["SignatureId"] = self.signatureId!
                }
                if self.signatureName != nil {
                    map["SignatureName"] = self.signatureName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("SignatureId") {
                    self.signatureId = dict["SignatureId"] as! String
                }
                if dict.keys.contains("SignatureName") {
                    self.signatureName = dict["SignatureName"] as! String
                }
            }
        }
        public var apiSignatureItem: [DescribeApiSignaturesResponseBody.ApiSignatures.ApiSignatureItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiSignatureItem != nil {
                var tmp : [Any] = []
                for k in self.apiSignatureItem! {
                    tmp.append(k.toMap())
                }
                map["ApiSignatureItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiSignatureItem") {
                self.apiSignatureItem = dict["ApiSignatureItem"] as! [DescribeApiSignaturesResponseBody.ApiSignatures.ApiSignatureItem]
            }
        }
    }
    public var apiSignatures: DescribeApiSignaturesResponseBody.ApiSignatures?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiSignatures?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiSignatures != nil {
            map["ApiSignatures"] = self.apiSignatures?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiSignatures") {
            var model = DescribeApiSignaturesResponseBody.ApiSignatures()
            model.fromMap(dict["ApiSignatures"] as! [String: Any])
            self.apiSignatures = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiSignaturesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiSignaturesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiSignaturesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiTrafficControlsRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApiTrafficControlsResponseBody : Tea.TeaModel {
    public class ApiTrafficControls : Tea.TeaModel {
        public class ApiTrafficControlItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var trafficControlId: String?

            public var trafficControlName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.trafficControlId != nil {
                    map["TrafficControlId"] = self.trafficControlId!
                }
                if self.trafficControlName != nil {
                    map["TrafficControlName"] = self.trafficControlName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("TrafficControlId") {
                    self.trafficControlId = dict["TrafficControlId"] as! String
                }
                if dict.keys.contains("TrafficControlName") {
                    self.trafficControlName = dict["TrafficControlName"] as! String
                }
            }
        }
        public var apiTrafficControlItem: [DescribeApiTrafficControlsResponseBody.ApiTrafficControls.ApiTrafficControlItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiTrafficControlItem != nil {
                var tmp : [Any] = []
                for k in self.apiTrafficControlItem! {
                    tmp.append(k.toMap())
                }
                map["ApiTrafficControlItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiTrafficControlItem") {
                self.apiTrafficControlItem = dict["ApiTrafficControlItem"] as! [DescribeApiTrafficControlsResponseBody.ApiTrafficControls.ApiTrafficControlItem]
            }
        }
    }
    public var apiTrafficControls: DescribeApiTrafficControlsResponseBody.ApiTrafficControls?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiTrafficControls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiTrafficControls != nil {
            map["ApiTrafficControls"] = self.apiTrafficControls?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiTrafficControls") {
            var model = DescribeApiTrafficControlsResponseBody.ApiTrafficControls()
            model.fromMap(dict["ApiTrafficControls"] as! [String: Any])
            self.apiTrafficControls = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApiTrafficControlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiTrafficControlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiTrafficControlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApiTrafficDataRequest : Tea.TeaModel {
    public var apiId: String?

    public var endTime: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeApiTrafficDataResponseBody : Tea.TeaModel {
    public class CallDownloads : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiTrafficDataResponseBody.CallDownloads.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") {
                self.monitorItem = dict["MonitorItem"] as! [DescribeApiTrafficDataResponseBody.CallDownloads.MonitorItem]
            }
        }
    }
    public class CallUploads : Tea.TeaModel {
        public class MonitorItem : Tea.TeaModel {
            public var itemTime: String?

            public var itemValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemTime != nil {
                    map["ItemTime"] = self.itemTime!
                }
                if self.itemValue != nil {
                    map["ItemValue"] = self.itemValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemTime") {
                    self.itemTime = dict["ItemTime"] as! String
                }
                if dict.keys.contains("ItemValue") {
                    self.itemValue = dict["ItemValue"] as! String
                }
            }
        }
        public var monitorItem: [DescribeApiTrafficDataResponseBody.CallUploads.MonitorItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitorItem != nil {
                var tmp : [Any] = []
                for k in self.monitorItem! {
                    tmp.append(k.toMap())
                }
                map["MonitorItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MonitorItem") {
                self.monitorItem = dict["MonitorItem"] as! [DescribeApiTrafficDataResponseBody.CallUploads.MonitorItem]
            }
        }
    }
    public var callDownloads: DescribeApiTrafficDataResponseBody.CallDownloads?

    public var callUploads: DescribeApiTrafficDataResponseBody.CallUploads?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.callDownloads?.validate()
        try self.callUploads?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callDownloads != nil {
            map["CallDownloads"] = self.callDownloads?.toMap()
        }
        if self.callUploads != nil {
            map["CallUploads"] = self.callUploads?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallDownloads") {
            var model = DescribeApiTrafficDataResponseBody.CallDownloads()
            model.fromMap(dict["CallDownloads"] as! [String: Any])
            self.callDownloads = model
        }
        if dict.keys.contains("CallUploads") {
            var model = DescribeApiTrafficDataResponseBody.CallUploads()
            model.fromMap(dict["CallUploads"] as! [String: Any])
            self.callUploads = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeApiTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApiTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApiTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var apiId: String?

    public var apiMethod: String?

    public var apiName: String?

    public var apiPath: String?

    public var catalogId: String?

    public var enableTagAuth: Bool?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public var tag: [DescribeApisRequest.Tag]?

    public var unDeployed: Bool?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiMethod != nil {
            map["ApiMethod"] = self.apiMethod!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.apiPath != nil {
            map["ApiPath"] = self.apiPath!
        }
        if self.catalogId != nil {
            map["CatalogId"] = self.catalogId!
        }
        if self.enableTagAuth != nil {
            map["EnableTagAuth"] = self.enableTagAuth!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.unDeployed != nil {
            map["UnDeployed"] = self.unDeployed!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiMethod") {
            self.apiMethod = dict["ApiMethod"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("ApiPath") {
            self.apiPath = dict["ApiPath"] as! String
        }
        if dict.keys.contains("CatalogId") {
            self.catalogId = dict["CatalogId"] as! String
        }
        if dict.keys.contains("EnableTagAuth") {
            self.enableTagAuth = dict["EnableTagAuth"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeApisRequest.Tag]
        }
        if dict.keys.contains("UnDeployed") {
            self.unDeployed = dict["UnDeployed"] as! Bool
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class DescribeApisResponseBody : Tea.TeaModel {
    public class ApiSummarys : Tea.TeaModel {
        public class ApiSummary : Tea.TeaModel {
            public class DeployedInfos : Tea.TeaModel {
                public class DeployedInfo : Tea.TeaModel {
                    public var deployedStatus: String?

                    public var effectiveVersion: String?

                    public var stageName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.deployedStatus != nil {
                            map["DeployedStatus"] = self.deployedStatus!
                        }
                        if self.effectiveVersion != nil {
                            map["EffectiveVersion"] = self.effectiveVersion!
                        }
                        if self.stageName != nil {
                            map["StageName"] = self.stageName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DeployedStatus") {
                            self.deployedStatus = dict["DeployedStatus"] as! String
                        }
                        if dict.keys.contains("EffectiveVersion") {
                            self.effectiveVersion = dict["EffectiveVersion"] as! String
                        }
                        if dict.keys.contains("StageName") {
                            self.stageName = dict["StageName"] as! String
                        }
                    }
                }
                public var deployedInfo: [DescribeApisResponseBody.ApiSummarys.ApiSummary.DeployedInfos.DeployedInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.deployedInfo != nil {
                        var tmp : [Any] = []
                        for k in self.deployedInfo! {
                            tmp.append(k.toMap())
                        }
                        map["DeployedInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DeployedInfo") {
                        self.deployedInfo = dict["DeployedInfo"] as! [DescribeApisResponseBody.ApiSummarys.ApiSummary.DeployedInfos.DeployedInfo]
                    }
                }
            }
            public var apiId: String?

            public var apiMethod: String?

            public var apiName: String?

            public var apiPath: String?

            public var createdTime: String?

            public var deployedInfos: DescribeApisResponseBody.ApiSummarys.ApiSummary.DeployedInfos?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var modifiedTime: String?

            public var regionId: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.deployedInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiMethod != nil {
                    map["ApiMethod"] = self.apiMethod!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.deployedInfos != nil {
                    map["DeployedInfos"] = self.deployedInfos?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiMethod") {
                    self.apiMethod = dict["ApiMethod"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("DeployedInfos") {
                    var model = DescribeApisResponseBody.ApiSummarys.ApiSummary.DeployedInfos()
                    model.fromMap(dict["DeployedInfos"] as! [String: Any])
                    self.deployedInfos = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Visibility") {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var apiSummary: [DescribeApisResponseBody.ApiSummarys.ApiSummary]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiSummary != nil {
                var tmp : [Any] = []
                for k in self.apiSummary! {
                    tmp.append(k.toMap())
                }
                map["ApiSummary"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiSummary") {
                self.apiSummary = dict["ApiSummary"] as! [DescribeApisResponseBody.ApiSummarys.ApiSummary]
            }
        }
    }
    public var apiSummarys: DescribeApisResponseBody.ApiSummarys?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiSummarys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiSummarys != nil {
            map["ApiSummarys"] = self.apiSummarys?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiSummarys") {
            var model = DescribeApisResponseBody.ApiSummarys()
            model.fromMap(dict["ApiSummarys"] as! [String: Any])
            self.apiSummarys = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisByAppRequest : Tea.TeaModel {
    public var apiName: String?

    public var apiUid: String?

    public var appId: Int64?

    public var description_: String?

    public var method: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var path: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.apiUid != nil {
            map["ApiUid"] = self.apiUid!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("ApiUid") {
            self.apiUid = dict["ApiUid"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Method") {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApisByAppResponseBody : Tea.TeaModel {
    public class AppApiRelationInfos : Tea.TeaModel {
        public class AppApiRelationInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var authVaildTime: String?

            public var authorizationSource: String?

            public var createdTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var method: String?

            public var operator_: String?

            public var path: String?

            public var regionId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.authVaildTime != nil {
                    map["AuthVaildTime"] = self.authVaildTime!
                }
                if self.authorizationSource != nil {
                    map["AuthorizationSource"] = self.authorizationSource!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("AuthVaildTime") {
                    self.authVaildTime = dict["AuthVaildTime"] as! String
                }
                if dict.keys.contains("AuthorizationSource") {
                    self.authorizationSource = dict["AuthorizationSource"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var appApiRelationInfo: [DescribeApisByAppResponseBody.AppApiRelationInfos.AppApiRelationInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appApiRelationInfo != nil {
                var tmp : [Any] = []
                for k in self.appApiRelationInfo! {
                    tmp.append(k.toMap())
                }
                map["AppApiRelationInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppApiRelationInfo") {
                self.appApiRelationInfo = dict["AppApiRelationInfo"] as! [DescribeApisByAppResponseBody.AppApiRelationInfos.AppApiRelationInfo]
            }
        }
    }
    public var appApiRelationInfos: DescribeApisByAppResponseBody.AppApiRelationInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appApiRelationInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appApiRelationInfos != nil {
            map["AppApiRelationInfos"] = self.appApiRelationInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppApiRelationInfos") {
            var model = DescribeApisByAppResponseBody.AppApiRelationInfos()
            model.fromMap(dict["AppApiRelationInfos"] as! [String: Any])
            self.appApiRelationInfos = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisByAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisByAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApisByAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisByBackendRequest : Tea.TeaModel {
    public var backendId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeApisByBackendResponseBody : Tea.TeaModel {
    public class ApiInfoList : Tea.TeaModel {
        public class ApiInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var method: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiInfo: [DescribeApisByBackendResponseBody.ApiInfoList.ApiInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInfo != nil {
                var tmp : [Any] = []
                for k in self.apiInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiInfo") {
                self.apiInfo = dict["ApiInfo"] as! [DescribeApisByBackendResponseBody.ApiInfoList.ApiInfo]
            }
        }
    }
    public var apiInfoList: DescribeApisByBackendResponseBody.ApiInfoList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiInfoList != nil {
            map["ApiInfoList"] = self.apiInfoList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiInfoList") {
            var model = DescribeApisByBackendResponseBody.ApiInfoList()
            model.fromMap(dict["ApiInfoList"] as! [String: Any])
            self.apiInfoList = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisByBackendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisByBackendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApisByBackendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisByIpControlRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeApisByIpControlResponseBody : Tea.TeaModel {
    public class ApiInfos : Tea.TeaModel {
        public class ApiInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var apiInfo: [DescribeApisByIpControlResponseBody.ApiInfos.ApiInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInfo != nil {
                var tmp : [Any] = []
                for k in self.apiInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiInfo") {
                self.apiInfo = dict["ApiInfo"] as! [DescribeApisByIpControlResponseBody.ApiInfos.ApiInfo]
            }
        }
    }
    public var apiInfos: DescribeApisByIpControlResponseBody.ApiInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiInfos != nil {
            map["ApiInfos"] = self.apiInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiInfos") {
            var model = DescribeApisByIpControlResponseBody.ApiInfos()
            model.fromMap(dict["ApiInfos"] as! [String: Any])
            self.apiInfos = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisByIpControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisByIpControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApisByIpControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisBySignatureRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var signatureId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") {
            self.signatureId = dict["SignatureId"] as! String
        }
    }
}

public class DescribeApisBySignatureResponseBody : Tea.TeaModel {
    public class ApiInfos : Tea.TeaModel {
        public class ApiInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var apiInfo: [DescribeApisBySignatureResponseBody.ApiInfos.ApiInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInfo != nil {
                var tmp : [Any] = []
                for k in self.apiInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiInfo") {
                self.apiInfo = dict["ApiInfo"] as! [DescribeApisBySignatureResponseBody.ApiInfos.ApiInfo]
            }
        }
    }
    public var apiInfos: DescribeApisBySignatureResponseBody.ApiInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiInfos != nil {
            map["ApiInfos"] = self.apiInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiInfos") {
            var model = DescribeApisBySignatureResponseBody.ApiInfos()
            model.fromMap(dict["ApiInfos"] as! [String: Any])
            self.apiInfos = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisBySignatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisBySignatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApisBySignatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApisByTrafficControlRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class DescribeApisByTrafficControlResponseBody : Tea.TeaModel {
    public class ApiInfos : Tea.TeaModel {
        public class ApiInfo : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var boundTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("BoundTime") {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var apiInfo: [DescribeApisByTrafficControlResponseBody.ApiInfos.ApiInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInfo != nil {
                var tmp : [Any] = []
                for k in self.apiInfo! {
                    tmp.append(k.toMap())
                }
                map["ApiInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiInfo") {
                self.apiInfo = dict["ApiInfo"] as! [DescribeApisByTrafficControlResponseBody.ApiInfos.ApiInfo]
            }
        }
    }
    public var apiInfos: DescribeApisByTrafficControlResponseBody.ApiInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiInfos != nil {
            map["ApiInfos"] = self.apiInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiInfos") {
            var model = DescribeApisByTrafficControlResponseBody.ApiInfos()
            model.fromMap(dict["ApiInfos"] as! [String: Any])
            self.apiInfos = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeApisByTrafficControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApisByTrafficControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApisByTrafficControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppRequest : Tea.TeaModel {
    public var appId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAppResponseBody : Tea.TeaModel {
    public var appId: Int64?

    public var appName: String?

    public var createdTime: String?

    public var description_: String?

    public var modifiedTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ModifiedTime") {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppAttributesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appCode: String?

    public var appId: Int64?

    public var appKey: String?

    public var appName: String?

    public var enableTagAuth: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var sort: String?

    public var tag: [DescribeAppAttributesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCode != nil {
            map["AppCode"] = self.appCode!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.enableTagAuth != nil {
            map["EnableTagAuth"] = self.enableTagAuth!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sort != nil {
            map["Sort"] = self.sort!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCode") {
            self.appCode = dict["AppCode"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppKey") {
            self.appKey = dict["AppKey"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("EnableTagAuth") {
            self.enableTagAuth = dict["EnableTagAuth"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Sort") {
            self.sort = dict["Sort"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeAppAttributesRequest.Tag]
        }
    }
}

public class DescribeAppAttributesResponseBody : Tea.TeaModel {
    public class Apps : Tea.TeaModel {
        public class AppAttribute : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class TagInfo : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagInfo: [DescribeAppAttributesResponseBody.Apps.AppAttribute.Tags.TagInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagInfo != nil {
                        var tmp : [Any] = []
                        for k in self.tagInfo! {
                            tmp.append(k.toMap())
                        }
                        map["TagInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagInfo") {
                        self.tagInfo = dict["TagInfo"] as! [DescribeAppAttributesResponseBody.Apps.AppAttribute.Tags.TagInfo]
                    }
                }
            }
            public var appId: Int64?

            public var appName: String?

            public var createdTime: String?

            public var description_: String?

            public var modifiedTime: String?

            public var tags: DescribeAppAttributesResponseBody.Apps.AppAttribute.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeAppAttributesResponseBody.Apps.AppAttribute.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var appAttribute: [DescribeAppAttributesResponseBody.Apps.AppAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appAttribute != nil {
                var tmp : [Any] = []
                for k in self.appAttribute! {
                    tmp.append(k.toMap())
                }
                map["AppAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppAttribute") {
                self.appAttribute = dict["AppAttribute"] as! [DescribeAppAttributesResponseBody.Apps.AppAttribute]
            }
        }
    }
    public var apps: DescribeAppAttributesResponseBody.Apps?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apps?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apps != nil {
            map["Apps"] = self.apps?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Apps") {
            var model = DescribeAppAttributesResponseBody.Apps()
            model.fromMap(dict["Apps"] as! [String: Any])
            self.apps = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAppAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAppAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppSecurityRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appId: Int64?

    public var securityToken: String?

    public var tag: [DescribeAppSecurityRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeAppSecurityRequest.Tag]
        }
    }
}

public class DescribeAppSecurityResponseBody : Tea.TeaModel {
    public var appCode: String?

    public var appKey: String?

    public var appSecret: String?

    public var createdTime: String?

    public var modifiedTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCode != nil {
            map["AppCode"] = self.appCode!
        }
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.appSecret != nil {
            map["AppSecret"] = self.appSecret!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.modifiedTime != nil {
            map["ModifiedTime"] = self.modifiedTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCode") {
            self.appCode = dict["AppCode"] as! String
        }
        if dict.keys.contains("AppKey") {
            self.appKey = dict["AppKey"] as! String
        }
        if dict.keys.contains("AppSecret") {
            self.appSecret = dict["AppSecret"] as! String
        }
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! String
        }
        if dict.keys.contains("ModifiedTime") {
            self.modifiedTime = dict["ModifiedTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAppSecurityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppSecurityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAppSecurityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppsRequest : Tea.TeaModel {
    public var appId: Int64?

    public var appOwner: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appOwner != nil {
            map["AppOwner"] = self.appOwner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppOwner") {
            self.appOwner = dict["AppOwner"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAppsResponseBody : Tea.TeaModel {
    public class Apps : Tea.TeaModel {
        public class AppItem : Tea.TeaModel {
            public var appId: Int64?

            public var appName: String?

            public var description_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
            }
        }
        public var appItem: [DescribeAppsResponseBody.Apps.AppItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appItem != nil {
                var tmp : [Any] = []
                for k in self.appItem! {
                    tmp.append(k.toMap())
                }
                map["AppItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppItem") {
                self.appItem = dict["AppItem"] as! [DescribeAppsResponseBody.Apps.AppItem]
            }
        }
    }
    public var apps: DescribeAppsResponseBody.Apps?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apps?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apps != nil {
            map["Apps"] = self.apps?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Apps") {
            var model = DescribeAppsResponseBody.Apps()
            model.fromMap(dict["Apps"] as! [String: Any])
            self.apps = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuthorizedApisRequest : Tea.TeaModel {
    public var appId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeAuthorizedApisResponseBody : Tea.TeaModel {
    public class AuthorizedApis : Tea.TeaModel {
        public class AuthorizedApi : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var authVaildTime: String?

            public var authorizationSource: String?

            public var authorizedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var operator_: String?

            public var regionId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.authVaildTime != nil {
                    map["AuthVaildTime"] = self.authVaildTime!
                }
                if self.authorizationSource != nil {
                    map["AuthorizationSource"] = self.authorizationSource!
                }
                if self.authorizedTime != nil {
                    map["AuthorizedTime"] = self.authorizedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("AuthVaildTime") {
                    self.authVaildTime = dict["AuthVaildTime"] as! String
                }
                if dict.keys.contains("AuthorizationSource") {
                    self.authorizationSource = dict["AuthorizationSource"] as! String
                }
                if dict.keys.contains("AuthorizedTime") {
                    self.authorizedTime = dict["AuthorizedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var authorizedApi: [DescribeAuthorizedApisResponseBody.AuthorizedApis.AuthorizedApi]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedApi != nil {
                var tmp : [Any] = []
                for k in self.authorizedApi! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedApi"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedApi") {
                self.authorizedApi = dict["AuthorizedApi"] as! [DescribeAuthorizedApisResponseBody.AuthorizedApis.AuthorizedApi]
            }
        }
    }
    public var authorizedApis: DescribeAuthorizedApisResponseBody.AuthorizedApis?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorizedApis?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizedApis != nil {
            map["AuthorizedApis"] = self.authorizedApis?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizedApis") {
            var model = DescribeAuthorizedApisResponseBody.AuthorizedApis()
            model.fromMap(dict["AuthorizedApis"] as! [String: Any])
            self.authorizedApis = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAuthorizedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuthorizedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuthorizedApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAuthorizedAppsRequest : Tea.TeaModel {
    public var apiId: String?

    public var appId: Int64?

    public var appName: String?

    public var appOwnerId: Int64?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appOwnerId != nil {
            map["AppOwnerId"] = self.appOwnerId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppOwnerId") {
            self.appOwnerId = dict["AppOwnerId"] as! Int64
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeAuthorizedAppsResponseBody : Tea.TeaModel {
    public class AuthorizedApps : Tea.TeaModel {
        public class AuthorizedApp : Tea.TeaModel {
            public var appId: Int64?

            public var appName: String?

            public var authVaildTime: String?

            public var authorizationSource: String?

            public var authorizedTime: String?

            public var description_: String?

            public var operator_: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.authVaildTime != nil {
                    map["AuthVaildTime"] = self.authVaildTime!
                }
                if self.authorizationSource != nil {
                    map["AuthorizationSource"] = self.authorizationSource!
                }
                if self.authorizedTime != nil {
                    map["AuthorizedTime"] = self.authorizedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.operator_ != nil {
                    map["Operator"] = self.operator_!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! Int64
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("AuthVaildTime") {
                    self.authVaildTime = dict["AuthVaildTime"] as! String
                }
                if dict.keys.contains("AuthorizationSource") {
                    self.authorizationSource = dict["AuthorizationSource"] as! String
                }
                if dict.keys.contains("AuthorizedTime") {
                    self.authorizedTime = dict["AuthorizedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Operator") {
                    self.operator_ = dict["Operator"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var authorizedApp: [DescribeAuthorizedAppsResponseBody.AuthorizedApps.AuthorizedApp]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authorizedApp != nil {
                var tmp : [Any] = []
                for k in self.authorizedApp! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedApp"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AuthorizedApp") {
                self.authorizedApp = dict["AuthorizedApp"] as! [DescribeAuthorizedAppsResponseBody.AuthorizedApps.AuthorizedApp]
            }
        }
    }
    public var authorizedApps: DescribeAuthorizedAppsResponseBody.AuthorizedApps?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authorizedApps?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizedApps != nil {
            map["AuthorizedApps"] = self.authorizedApps?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizedApps") {
            var model = DescribeAuthorizedAppsResponseBody.AuthorizedApps()
            model.fromMap(dict["AuthorizedApps"] as! [String: Any])
            self.authorizedApps = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAuthorizedAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuthorizedAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAuthorizedAppsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackendInfoRequest : Tea.TeaModel {
    public var backendId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeBackendInfoResponseBody : Tea.TeaModel {
    public class BackendInfo : Tea.TeaModel {
        public class BackendModels : Tea.TeaModel {
            public class BackendConfig : Tea.TeaModel {
                public class EventBridgeConfig : Tea.TeaModel {
                    public var eventBridgeRegionId: String?

                    public var eventBus: String?

                    public var eventSource: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.eventBridgeRegionId != nil {
                            map["EventBridgeRegionId"] = self.eventBridgeRegionId!
                        }
                        if self.eventBus != nil {
                            map["EventBus"] = self.eventBus!
                        }
                        if self.eventSource != nil {
                            map["EventSource"] = self.eventSource!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EventBridgeRegionId") {
                            self.eventBridgeRegionId = dict["EventBridgeRegionId"] as! String
                        }
                        if dict.keys.contains("EventBus") {
                            self.eventBus = dict["EventBus"] as! String
                        }
                        if dict.keys.contains("EventSource") {
                            self.eventSource = dict["EventSource"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class FunctionComputeConfig : Tea.TeaModel {
                    public var fcBaseUrl: String?

                    public var fcRegionId: String?

                    public var fcType: String?

                    public var functionName: String?

                    public var onlyBusinessPath: Bool?

                    public var qualifier: String?

                    public var roleArn: String?

                    public var serviceName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fcBaseUrl != nil {
                            map["FcBaseUrl"] = self.fcBaseUrl!
                        }
                        if self.fcRegionId != nil {
                            map["FcRegionId"] = self.fcRegionId!
                        }
                        if self.fcType != nil {
                            map["FcType"] = self.fcType!
                        }
                        if self.functionName != nil {
                            map["FunctionName"] = self.functionName!
                        }
                        if self.onlyBusinessPath != nil {
                            map["OnlyBusinessPath"] = self.onlyBusinessPath!
                        }
                        if self.qualifier != nil {
                            map["Qualifier"] = self.qualifier!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        if self.serviceName != nil {
                            map["ServiceName"] = self.serviceName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FcBaseUrl") {
                            self.fcBaseUrl = dict["FcBaseUrl"] as! String
                        }
                        if dict.keys.contains("FcRegionId") {
                            self.fcRegionId = dict["FcRegionId"] as! String
                        }
                        if dict.keys.contains("FcType") {
                            self.fcType = dict["FcType"] as! String
                        }
                        if dict.keys.contains("FunctionName") {
                            self.functionName = dict["FunctionName"] as! String
                        }
                        if dict.keys.contains("OnlyBusinessPath") {
                            self.onlyBusinessPath = dict["OnlyBusinessPath"] as! Bool
                        }
                        if dict.keys.contains("Qualifier") {
                            self.qualifier = dict["Qualifier"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                        if dict.keys.contains("ServiceName") {
                            self.serviceName = dict["ServiceName"] as! String
                        }
                    }
                }
                public class MockConfig : Tea.TeaModel {
                    public class MockHeaders : Tea.TeaModel {
                        public var headerName: String?

                        public var headerValue: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.headerName != nil {
                                map["HeaderName"] = self.headerName!
                            }
                            if self.headerValue != nil {
                                map["HeaderValue"] = self.headerValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("HeaderName") {
                                self.headerName = dict["HeaderName"] as! String
                            }
                            if dict.keys.contains("HeaderValue") {
                                self.headerValue = dict["HeaderValue"] as! String
                            }
                        }
                    }
                    public var mockHeaders: [DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.MockConfig.MockHeaders]?

                    public var mockResult: String?

                    public var mockStatusCode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.mockHeaders != nil {
                            var tmp : [Any] = []
                            for k in self.mockHeaders! {
                                tmp.append(k.toMap())
                            }
                            map["MockHeaders"] = tmp
                        }
                        if self.mockResult != nil {
                            map["MockResult"] = self.mockResult!
                        }
                        if self.mockStatusCode != nil {
                            map["MockStatusCode"] = self.mockStatusCode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MockHeaders") {
                            self.mockHeaders = dict["MockHeaders"] as! [DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.MockConfig.MockHeaders]
                        }
                        if dict.keys.contains("MockResult") {
                            self.mockResult = dict["MockResult"] as! String
                        }
                        if dict.keys.contains("MockStatusCode") {
                            self.mockStatusCode = dict["MockStatusCode"] as! String
                        }
                    }
                }
                public class OssConfig : Tea.TeaModel {
                    public var bucketName: String?

                    public var ossRegionId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucketName != nil {
                            map["BucketName"] = self.bucketName!
                        }
                        if self.ossRegionId != nil {
                            map["OssRegionId"] = self.ossRegionId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BucketName") {
                            self.bucketName = dict["BucketName"] as! String
                        }
                        if dict.keys.contains("OssRegionId") {
                            self.ossRegionId = dict["OssRegionId"] as! String
                        }
                    }
                }
                public class VpcConfig : Tea.TeaModel {
                    public var instanceId: String?

                    public var name: String?

                    public var port: Int64?

                    public var vpcAccessId: String?

                    public var vpcId: String?

                    public var vpcScheme: String?

                    public var vpcTargetHostName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.vpcAccessId != nil {
                            map["VpcAccessId"] = self.vpcAccessId!
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        if self.vpcScheme != nil {
                            map["VpcScheme"] = self.vpcScheme!
                        }
                        if self.vpcTargetHostName != nil {
                            map["VpcTargetHostName"] = self.vpcTargetHostName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int64
                        }
                        if dict.keys.contains("VpcAccessId") {
                            self.vpcAccessId = dict["VpcAccessId"] as! String
                        }
                        if dict.keys.contains("VpcId") {
                            self.vpcId = dict["VpcId"] as! String
                        }
                        if dict.keys.contains("VpcScheme") {
                            self.vpcScheme = dict["VpcScheme"] as! String
                        }
                        if dict.keys.contains("VpcTargetHostName") {
                            self.vpcTargetHostName = dict["VpcTargetHostName"] as! String
                        }
                    }
                }
                public var eventBridgeConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.EventBridgeConfig?

                public var functionComputeConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.FunctionComputeConfig?

                public var mockConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.MockConfig?

                public var ossConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.OssConfig?

                public var serviceAddress: String?

                public var type: String?

                public var vpcConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.VpcConfig?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.eventBridgeConfig?.validate()
                    try self.functionComputeConfig?.validate()
                    try self.mockConfig?.validate()
                    try self.ossConfig?.validate()
                    try self.vpcConfig?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventBridgeConfig != nil {
                        map["EventBridgeConfig"] = self.eventBridgeConfig?.toMap()
                    }
                    if self.functionComputeConfig != nil {
                        map["FunctionComputeConfig"] = self.functionComputeConfig?.toMap()
                    }
                    if self.mockConfig != nil {
                        map["MockConfig"] = self.mockConfig?.toMap()
                    }
                    if self.ossConfig != nil {
                        map["OssConfig"] = self.ossConfig?.toMap()
                    }
                    if self.serviceAddress != nil {
                        map["ServiceAddress"] = self.serviceAddress!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.vpcConfig != nil {
                        map["VpcConfig"] = self.vpcConfig?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EventBridgeConfig") {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.EventBridgeConfig()
                        model.fromMap(dict["EventBridgeConfig"] as! [String: Any])
                        self.eventBridgeConfig = model
                    }
                    if dict.keys.contains("FunctionComputeConfig") {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.FunctionComputeConfig()
                        model.fromMap(dict["FunctionComputeConfig"] as! [String: Any])
                        self.functionComputeConfig = model
                    }
                    if dict.keys.contains("MockConfig") {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.MockConfig()
                        model.fromMap(dict["MockConfig"] as! [String: Any])
                        self.mockConfig = model
                    }
                    if dict.keys.contains("OssConfig") {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.OssConfig()
                        model.fromMap(dict["OssConfig"] as! [String: Any])
                        self.ossConfig = model
                    }
                    if dict.keys.contains("ServiceAddress") {
                        self.serviceAddress = dict["ServiceAddress"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("VpcConfig") {
                        var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig.VpcConfig()
                        model.fromMap(dict["VpcConfig"] as! [String: Any])
                        self.vpcConfig = model
                    }
                }
            }
            public var backendConfig: DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig?

            public var backendModelId: String?

            public var description_: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var stageModeId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.backendConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backendConfig != nil {
                    map["BackendConfig"] = self.backendConfig?.toMap()
                }
                if self.backendModelId != nil {
                    map["BackendModelId"] = self.backendModelId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.stageModeId != nil {
                    map["StageModeId"] = self.stageModeId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BackendConfig") {
                    var model = DescribeBackendInfoResponseBody.BackendInfo.BackendModels.BackendConfig()
                    model.fromMap(dict["BackendConfig"] as! [String: Any])
                    self.backendConfig = model
                }
                if dict.keys.contains("BackendModelId") {
                    self.backendModelId = dict["BackendModelId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("StageModeId") {
                    self.stageModeId = dict["StageModeId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var backendId: String?

        public var backendModels: [DescribeBackendInfoResponseBody.BackendInfo.BackendModels]?

        public var backendName: String?

        public var backendType: String?

        public var createdTime: String?

        public var description_: String?

        public var modifiedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendId != nil {
                map["BackendId"] = self.backendId!
            }
            if self.backendModels != nil {
                var tmp : [Any] = []
                for k in self.backendModels! {
                    tmp.append(k.toMap())
                }
                map["BackendModels"] = tmp
            }
            if self.backendName != nil {
                map["BackendName"] = self.backendName!
            }
            if self.backendType != nil {
                map["BackendType"] = self.backendType!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendId") {
                self.backendId = dict["BackendId"] as! String
            }
            if dict.keys.contains("BackendModels") {
                self.backendModels = dict["BackendModels"] as! [DescribeBackendInfoResponseBody.BackendInfo.BackendModels]
            }
            if dict.keys.contains("BackendName") {
                self.backendName = dict["BackendName"] as! String
            }
            if dict.keys.contains("BackendType") {
                self.backendType = dict["BackendType"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
        }
    }
    public var backendInfo: DescribeBackendInfoResponseBody.BackendInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.backendInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendInfo != nil {
            map["BackendInfo"] = self.backendInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendInfo") {
            var model = DescribeBackendInfoResponseBody.BackendInfo()
            model.fromMap(dict["BackendInfo"] as! [String: Any])
            self.backendInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBackendInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackendInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBackendInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBackendListRequest : Tea.TeaModel {
    public var backendName: String?

    public var backendType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendName") {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("BackendType") {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeBackendListResponseBody : Tea.TeaModel {
    public class BackendInfoList : Tea.TeaModel {
        public var backendId: String?

        public var backendName: String?

        public var backendType: String?

        public var createdTime: String?

        public var description_: String?

        public var modifiedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backendId != nil {
                map["BackendId"] = self.backendId!
            }
            if self.backendName != nil {
                map["BackendName"] = self.backendName!
            }
            if self.backendType != nil {
                map["BackendType"] = self.backendType!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BackendId") {
                self.backendId = dict["BackendId"] as! String
            }
            if dict.keys.contains("BackendName") {
                self.backendName = dict["BackendName"] as! String
            }
            if dict.keys.contains("BackendType") {
                self.backendType = dict["BackendType"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
        }
    }
    public var backendInfoList: [DescribeBackendListResponseBody.BackendInfoList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendInfoList != nil {
            var tmp : [Any] = []
            for k in self.backendInfoList! {
                tmp.append(k.toMap())
            }
            map["BackendInfoList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendInfoList") {
            self.backendInfoList = dict["BackendInfoList"] as! [DescribeBackendListResponseBody.BackendInfoList]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeBackendListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackendListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBackendListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDatasetInfoRequest : Tea.TeaModel {
    public var datasetId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeDatasetInfoResponseBody : Tea.TeaModel {
    public class DatasetInfo : Tea.TeaModel {
        public var createdTime: String?

        public var datasetId: String?

        public var datasetName: String?

        public var datasetType: String?

        public var modifiedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.datasetId != nil {
                map["DatasetId"] = self.datasetId!
            }
            if self.datasetName != nil {
                map["DatasetName"] = self.datasetName!
            }
            if self.datasetType != nil {
                map["DatasetType"] = self.datasetType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("DatasetId") {
                self.datasetId = dict["DatasetId"] as! String
            }
            if dict.keys.contains("DatasetName") {
                self.datasetName = dict["DatasetName"] as! String
            }
            if dict.keys.contains("DatasetType") {
                self.datasetType = dict["DatasetType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
        }
    }
    public var datasetInfo: DescribeDatasetInfoResponseBody.DatasetInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.datasetInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetInfo != nil {
            map["DatasetInfo"] = self.datasetInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetInfo") {
            var model = DescribeDatasetInfoResponseBody.DatasetInfo()
            model.fromMap(dict["DatasetInfo"] as! [String: Any])
            self.datasetInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDatasetInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatasetInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDatasetInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDatasetItemInfoRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetItemId: String?

    public var securityToken: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetItemId != nil {
            map["DatasetItemId"] = self.datasetItemId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetItemId") {
            self.datasetItemId = dict["DatasetItemId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeDatasetItemInfoResponseBody : Tea.TeaModel {
    public class DatasetItemInfo : Tea.TeaModel {
        public var createdTime: String?

        public var datasetId: String?

        public var datasetItemId: String?

        public var description_: String?

        public var expiredTime: String?

        public var modifiedTime: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.datasetId != nil {
                map["DatasetId"] = self.datasetId!
            }
            if self.datasetItemId != nil {
                map["DatasetItemId"] = self.datasetItemId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("DatasetId") {
                self.datasetId = dict["DatasetId"] as! String
            }
            if dict.keys.contains("DatasetItemId") {
                self.datasetItemId = dict["DatasetItemId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var datasetItemInfo: DescribeDatasetItemInfoResponseBody.DatasetItemInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.datasetItemInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetItemInfo != nil {
            map["DatasetItemInfo"] = self.datasetItemInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetItemInfo") {
            var model = DescribeDatasetItemInfoResponseBody.DatasetItemInfo()
            model.fromMap(dict["DatasetItemInfo"] as! [String: Any])
            self.datasetItemInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDatasetItemInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatasetItemInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDatasetItemInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDatasetItemListRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetItemIds: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetItemIds != nil {
            map["DatasetItemIds"] = self.datasetItemIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetItemIds") {
            self.datasetItemIds = dict["DatasetItemIds"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeDatasetItemListResponseBody : Tea.TeaModel {
    public class DatasetItemInfoList : Tea.TeaModel {
        public var createdTime: String?

        public var datasetId: String?

        public var datasetItemId: String?

        public var description_: String?

        public var expiredTime: String?

        public var modifiedTime: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.datasetId != nil {
                map["DatasetId"] = self.datasetId!
            }
            if self.datasetItemId != nil {
                map["DatasetItemId"] = self.datasetItemId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("DatasetId") {
                self.datasetId = dict["DatasetId"] as! String
            }
            if dict.keys.contains("DatasetItemId") {
                self.datasetItemId = dict["DatasetItemId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var datasetItemInfoList: [DescribeDatasetItemListResponseBody.DatasetItemInfoList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetItemInfoList != nil {
            var tmp : [Any] = []
            for k in self.datasetItemInfoList! {
                tmp.append(k.toMap())
            }
            map["DatasetItemInfoList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetItemInfoList") {
            self.datasetItemInfoList = dict["DatasetItemInfoList"] as! [DescribeDatasetItemListResponseBody.DatasetItemInfoList]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDatasetItemListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatasetItemListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDatasetItemListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDatasetListRequest : Tea.TeaModel {
    public var datasetIds: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetIds != nil {
            map["DatasetIds"] = self.datasetIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetIds") {
            self.datasetIds = dict["DatasetIds"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeDatasetListResponseBody : Tea.TeaModel {
    public class DatasetInfoList : Tea.TeaModel {
        public var createdTime: String?

        public var datasetId: String?

        public var datasetName: String?

        public var datasetType: String?

        public var modifiedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.datasetId != nil {
                map["DatasetId"] = self.datasetId!
            }
            if self.datasetName != nil {
                map["DatasetName"] = self.datasetName!
            }
            if self.datasetType != nil {
                map["DatasetType"] = self.datasetType!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("DatasetId") {
                self.datasetId = dict["DatasetId"] as! String
            }
            if dict.keys.contains("DatasetName") {
                self.datasetName = dict["DatasetName"] as! String
            }
            if dict.keys.contains("DatasetType") {
                self.datasetType = dict["DatasetType"] as! String
            }
            if dict.keys.contains("ModifiedTime") {
                self.modifiedTime = dict["ModifiedTime"] as! String
            }
        }
    }
    public var datasetInfoList: [DescribeDatasetListResponseBody.DatasetInfoList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetInfoList != nil {
            var tmp : [Any] = []
            for k in self.datasetInfoList! {
                tmp.append(k.toMap())
            }
            map["DatasetInfoList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetInfoList") {
            self.datasetInfoList = dict["DatasetInfoList"] as! [DescribeDatasetListResponseBody.DatasetInfoList]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDatasetListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDatasetListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDatasetListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeployApiTaskRequest : Tea.TeaModel {
    public var operationUid: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationUid != nil {
            map["OperationUid"] = self.operationUid!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationUid") {
            self.operationUid = dict["OperationUid"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeDeployApiTaskResponseBody : Tea.TeaModel {
    public class DeployedResults : Tea.TeaModel {
        public class DeployedResult : Tea.TeaModel {
            public var apiUid: String?

            public var deployedStatus: String?

            public var errorMsg: String?

            public var groupId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.deployedStatus != nil {
                    map["DeployedStatus"] = self.deployedStatus!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiUid") {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("DeployedStatus") {
                    self.deployedStatus = dict["DeployedStatus"] as! String
                }
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var deployedResult: [DescribeDeployApiTaskResponseBody.DeployedResults.DeployedResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployedResult != nil {
                var tmp : [Any] = []
                for k in self.deployedResult! {
                    tmp.append(k.toMap())
                }
                map["DeployedResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeployedResult") {
                self.deployedResult = dict["DeployedResult"] as! [DescribeDeployApiTaskResponseBody.DeployedResults.DeployedResult]
            }
        }
    }
    public var deployedResults: DescribeDeployApiTaskResponseBody.DeployedResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployedResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployedResults != nil {
            map["DeployedResults"] = self.deployedResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeployedResults") {
            var model = DescribeDeployApiTaskResponseBody.DeployedResults()
            model.fromMap(dict["DeployedResults"] as! [String: Any])
            self.deployedResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDeployApiTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeployApiTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDeployApiTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeployedApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeDeployedApiResponseBody : Tea.TeaModel {
    public class ConstantParameters : Tea.TeaModel {
        public class ConstantParameter : Tea.TeaModel {
            public var constantValue: String?

            public var description_: String?

            public var location: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.constantValue != nil {
                    map["ConstantValue"] = self.constantValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConstantValue") {
                    self.constantValue = dict["ConstantValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var constantParameter: [DescribeDeployedApiResponseBody.ConstantParameters.ConstantParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.constantParameter != nil {
                var tmp : [Any] = []
                for k in self.constantParameter! {
                    tmp.append(k.toMap())
                }
                map["ConstantParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConstantParameter") {
                self.constantParameter = dict["ConstantParameter"] as! [DescribeDeployedApiResponseBody.ConstantParameters.ConstantParameter]
            }
        }
    }
    public class CustomSystemParameters : Tea.TeaModel {
        public class CustomSystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var customSystemParameter: [DescribeDeployedApiResponseBody.CustomSystemParameters.CustomSystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customSystemParameter != nil {
                var tmp : [Any] = []
                for k in self.customSystemParameter! {
                    tmp.append(k.toMap())
                }
                map["CustomSystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomSystemParameter") {
                self.customSystemParameter = dict["CustomSystemParameter"] as! [DescribeDeployedApiResponseBody.CustomSystemParameters.CustomSystemParameter]
            }
        }
    }
    public class ErrorCodeSamples : Tea.TeaModel {
        public class ErrorCodeSample : Tea.TeaModel {
            public var code: String?

            public var description_: String?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var errorCodeSample: [DescribeDeployedApiResponseBody.ErrorCodeSamples.ErrorCodeSample]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCodeSample != nil {
                var tmp : [Any] = []
                for k in self.errorCodeSample! {
                    tmp.append(k.toMap())
                }
                map["ErrorCodeSample"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCodeSample") {
                self.errorCodeSample = dict["ErrorCodeSample"] as! [DescribeDeployedApiResponseBody.ErrorCodeSamples.ErrorCodeSample]
            }
        }
    }
    public class OpenIdConnectConfig : Tea.TeaModel {
        public var idTokenParamName: String?

        public var openIdApiType: String?

        public var publicKey: String?

        public var publicKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.idTokenParamName != nil {
                map["IdTokenParamName"] = self.idTokenParamName!
            }
            if self.openIdApiType != nil {
                map["OpenIdApiType"] = self.openIdApiType!
            }
            if self.publicKey != nil {
                map["PublicKey"] = self.publicKey!
            }
            if self.publicKeyId != nil {
                map["PublicKeyId"] = self.publicKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IdTokenParamName") {
                self.idTokenParamName = dict["IdTokenParamName"] as! String
            }
            if dict.keys.contains("OpenIdApiType") {
                self.openIdApiType = dict["OpenIdApiType"] as! String
            }
            if dict.keys.contains("PublicKey") {
                self.publicKey = dict["PublicKey"] as! String
            }
            if dict.keys.contains("PublicKeyId") {
                self.publicKeyId = dict["PublicKeyId"] as! String
            }
        }
    }
    public class RequestConfig : Tea.TeaModel {
        public var bodyFormat: String?

        public var bodyModel: String?

        public var postBodyDescription: String?

        public var requestHttpMethod: String?

        public var requestMode: String?

        public var requestPath: String?

        public var requestProtocol: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bodyFormat != nil {
                map["BodyFormat"] = self.bodyFormat!
            }
            if self.bodyModel != nil {
                map["BodyModel"] = self.bodyModel!
            }
            if self.postBodyDescription != nil {
                map["PostBodyDescription"] = self.postBodyDescription!
            }
            if self.requestHttpMethod != nil {
                map["RequestHttpMethod"] = self.requestHttpMethod!
            }
            if self.requestMode != nil {
                map["RequestMode"] = self.requestMode!
            }
            if self.requestPath != nil {
                map["RequestPath"] = self.requestPath!
            }
            if self.requestProtocol != nil {
                map["RequestProtocol"] = self.requestProtocol!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BodyFormat") {
                self.bodyFormat = dict["BodyFormat"] as! String
            }
            if dict.keys.contains("BodyModel") {
                self.bodyModel = dict["BodyModel"] as! String
            }
            if dict.keys.contains("PostBodyDescription") {
                self.postBodyDescription = dict["PostBodyDescription"] as! String
            }
            if dict.keys.contains("RequestHttpMethod") {
                self.requestHttpMethod = dict["RequestHttpMethod"] as! String
            }
            if dict.keys.contains("RequestMode") {
                self.requestMode = dict["RequestMode"] as! String
            }
            if dict.keys.contains("RequestPath") {
                self.requestPath = dict["RequestPath"] as! String
            }
            if dict.keys.contains("RequestProtocol") {
                self.requestProtocol = dict["RequestProtocol"] as! String
            }
        }
    }
    public class RequestParameters : Tea.TeaModel {
        public class RequestParameter : Tea.TeaModel {
            public var apiParameterName: String?

            public var arrayItemsType: String?

            public var defaultValue: String?

            public var demoValue: String?

            public var description_: String?

            public var docOrder: Int32?

            public var docShow: String?

            public var enumValue: String?

            public var jsonScheme: String?

            public var location: String?

            public var maxLength: Int64?

            public var maxValue: Int64?

            public var minLength: Int64?

            public var minValue: Int64?

            public var parameterType: String?

            public var regularExpression: String?

            public var required_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiParameterName != nil {
                    map["ApiParameterName"] = self.apiParameterName!
                }
                if self.arrayItemsType != nil {
                    map["ArrayItemsType"] = self.arrayItemsType!
                }
                if self.defaultValue != nil {
                    map["DefaultValue"] = self.defaultValue!
                }
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.docOrder != nil {
                    map["DocOrder"] = self.docOrder!
                }
                if self.docShow != nil {
                    map["DocShow"] = self.docShow!
                }
                if self.enumValue != nil {
                    map["EnumValue"] = self.enumValue!
                }
                if self.jsonScheme != nil {
                    map["JsonScheme"] = self.jsonScheme!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.maxLength != nil {
                    map["MaxLength"] = self.maxLength!
                }
                if self.maxValue != nil {
                    map["MaxValue"] = self.maxValue!
                }
                if self.minLength != nil {
                    map["MinLength"] = self.minLength!
                }
                if self.minValue != nil {
                    map["MinValue"] = self.minValue!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.regularExpression != nil {
                    map["RegularExpression"] = self.regularExpression!
                }
                if self.required_ != nil {
                    map["Required"] = self.required_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiParameterName") {
                    self.apiParameterName = dict["ApiParameterName"] as! String
                }
                if dict.keys.contains("ArrayItemsType") {
                    self.arrayItemsType = dict["ArrayItemsType"] as! String
                }
                if dict.keys.contains("DefaultValue") {
                    self.defaultValue = dict["DefaultValue"] as! String
                }
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocOrder") {
                    self.docOrder = dict["DocOrder"] as! Int32
                }
                if dict.keys.contains("DocShow") {
                    self.docShow = dict["DocShow"] as! String
                }
                if dict.keys.contains("EnumValue") {
                    self.enumValue = dict["EnumValue"] as! String
                }
                if dict.keys.contains("JsonScheme") {
                    self.jsonScheme = dict["JsonScheme"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("MaxLength") {
                    self.maxLength = dict["MaxLength"] as! Int64
                }
                if dict.keys.contains("MaxValue") {
                    self.maxValue = dict["MaxValue"] as! Int64
                }
                if dict.keys.contains("MinLength") {
                    self.minLength = dict["MinLength"] as! Int64
                }
                if dict.keys.contains("MinValue") {
                    self.minValue = dict["MinValue"] as! Int64
                }
                if dict.keys.contains("ParameterType") {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("RegularExpression") {
                    self.regularExpression = dict["RegularExpression"] as! String
                }
                if dict.keys.contains("Required") {
                    self.required_ = dict["Required"] as! String
                }
            }
        }
        public var requestParameter: [DescribeDeployedApiResponseBody.RequestParameters.RequestParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestParameter != nil {
                var tmp : [Any] = []
                for k in self.requestParameter! {
                    tmp.append(k.toMap())
                }
                map["RequestParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestParameter") {
                self.requestParameter = dict["RequestParameter"] as! [DescribeDeployedApiResponseBody.RequestParameters.RequestParameter]
            }
        }
    }
    public class ResultDescriptions : Tea.TeaModel {
        public class ResultDescription : Tea.TeaModel {
            public var description_: String?

            public var hasChild: Bool?

            public var id: String?

            public var key: String?

            public var mandatory: Bool?

            public var name: String?

            public var pid: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hasChild != nil {
                    map["HasChild"] = self.hasChild!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mandatory != nil {
                    map["Mandatory"] = self.mandatory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pid != nil {
                    map["Pid"] = self.pid!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HasChild") {
                    self.hasChild = dict["HasChild"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Mandatory") {
                    self.mandatory = dict["Mandatory"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pid") {
                    self.pid = dict["Pid"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var resultDescription: [DescribeDeployedApiResponseBody.ResultDescriptions.ResultDescription]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resultDescription != nil {
                var tmp : [Any] = []
                for k in self.resultDescription! {
                    tmp.append(k.toMap())
                }
                map["ResultDescription"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResultDescription") {
                self.resultDescription = dict["ResultDescription"] as! [DescribeDeployedApiResponseBody.ResultDescriptions.ResultDescription]
            }
        }
    }
    public class ServiceConfig : Tea.TeaModel {
        public class FunctionComputeConfig : Tea.TeaModel {
            public var contentTypeCatagory: String?

            public var contentTypeValue: String?

            public var fcBaseUrl: String?

            public var fcType: String?

            public var functionName: String?

            public var method: String?

            public var onlyBusinessPath: Bool?

            public var path: String?

            public var qualifier: String?

            public var regionId: String?

            public var roleArn: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contentTypeCatagory != nil {
                    map["ContentTypeCatagory"] = self.contentTypeCatagory!
                }
                if self.contentTypeValue != nil {
                    map["ContentTypeValue"] = self.contentTypeValue!
                }
                if self.fcBaseUrl != nil {
                    map["FcBaseUrl"] = self.fcBaseUrl!
                }
                if self.fcType != nil {
                    map["FcType"] = self.fcType!
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.onlyBusinessPath != nil {
                    map["OnlyBusinessPath"] = self.onlyBusinessPath!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.qualifier != nil {
                    map["Qualifier"] = self.qualifier!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContentTypeCatagory") {
                    self.contentTypeCatagory = dict["ContentTypeCatagory"] as! String
                }
                if dict.keys.contains("ContentTypeValue") {
                    self.contentTypeValue = dict["ContentTypeValue"] as! String
                }
                if dict.keys.contains("FcBaseUrl") {
                    self.fcBaseUrl = dict["FcBaseUrl"] as! String
                }
                if dict.keys.contains("FcType") {
                    self.fcType = dict["FcType"] as! String
                }
                if dict.keys.contains("FunctionName") {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("OnlyBusinessPath") {
                    self.onlyBusinessPath = dict["OnlyBusinessPath"] as! Bool
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("Qualifier") {
                    self.qualifier = dict["Qualifier"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RoleArn") {
                    self.roleArn = dict["RoleArn"] as! String
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public class MockHeaders : Tea.TeaModel {
            public class MockHeader : Tea.TeaModel {
                public var headerName: String?

                public var headerValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.headerName != nil {
                        map["HeaderName"] = self.headerName!
                    }
                    if self.headerValue != nil {
                        map["HeaderValue"] = self.headerValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeaderName") {
                        self.headerName = dict["HeaderName"] as! String
                    }
                    if dict.keys.contains("HeaderValue") {
                        self.headerValue = dict["HeaderValue"] as! String
                    }
                }
            }
            public var mockHeader: [DescribeDeployedApiResponseBody.ServiceConfig.MockHeaders.MockHeader]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mockHeader != nil {
                    var tmp : [Any] = []
                    for k in self.mockHeader! {
                        tmp.append(k.toMap())
                    }
                    map["MockHeader"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MockHeader") {
                    self.mockHeader = dict["MockHeader"] as! [DescribeDeployedApiResponseBody.ServiceConfig.MockHeaders.MockHeader]
                }
            }
        }
        public class VpcConfig : Tea.TeaModel {
            public var instanceId: String?

            public var name: String?

            public var port: Int32?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var functionComputeConfig: DescribeDeployedApiResponseBody.ServiceConfig.FunctionComputeConfig?

        public var mock: String?

        public var mockHeaders: DescribeDeployedApiResponseBody.ServiceConfig.MockHeaders?

        public var mockResult: String?

        public var mockStatusCode: Int32?

        public var serviceAddress: String?

        public var serviceHttpMethod: String?

        public var servicePath: String?

        public var serviceProtocol: String?

        public var serviceTimeout: Int32?

        public var serviceVpcEnable: String?

        public var vpcConfig: DescribeDeployedApiResponseBody.ServiceConfig.VpcConfig?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.functionComputeConfig?.validate()
            try self.mockHeaders?.validate()
            try self.vpcConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.functionComputeConfig != nil {
                map["FunctionComputeConfig"] = self.functionComputeConfig?.toMap()
            }
            if self.mock != nil {
                map["Mock"] = self.mock!
            }
            if self.mockHeaders != nil {
                map["MockHeaders"] = self.mockHeaders?.toMap()
            }
            if self.mockResult != nil {
                map["MockResult"] = self.mockResult!
            }
            if self.mockStatusCode != nil {
                map["MockStatusCode"] = self.mockStatusCode!
            }
            if self.serviceAddress != nil {
                map["ServiceAddress"] = self.serviceAddress!
            }
            if self.serviceHttpMethod != nil {
                map["ServiceHttpMethod"] = self.serviceHttpMethod!
            }
            if self.servicePath != nil {
                map["ServicePath"] = self.servicePath!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceTimeout != nil {
                map["ServiceTimeout"] = self.serviceTimeout!
            }
            if self.serviceVpcEnable != nil {
                map["ServiceVpcEnable"] = self.serviceVpcEnable!
            }
            if self.vpcConfig != nil {
                map["VpcConfig"] = self.vpcConfig?.toMap()
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FunctionComputeConfig") {
                var model = DescribeDeployedApiResponseBody.ServiceConfig.FunctionComputeConfig()
                model.fromMap(dict["FunctionComputeConfig"] as! [String: Any])
                self.functionComputeConfig = model
            }
            if dict.keys.contains("Mock") {
                self.mock = dict["Mock"] as! String
            }
            if dict.keys.contains("MockHeaders") {
                var model = DescribeDeployedApiResponseBody.ServiceConfig.MockHeaders()
                model.fromMap(dict["MockHeaders"] as! [String: Any])
                self.mockHeaders = model
            }
            if dict.keys.contains("MockResult") {
                self.mockResult = dict["MockResult"] as! String
            }
            if dict.keys.contains("MockStatusCode") {
                self.mockStatusCode = dict["MockStatusCode"] as! Int32
            }
            if dict.keys.contains("ServiceAddress") {
                self.serviceAddress = dict["ServiceAddress"] as! String
            }
            if dict.keys.contains("ServiceHttpMethod") {
                self.serviceHttpMethod = dict["ServiceHttpMethod"] as! String
            }
            if dict.keys.contains("ServicePath") {
                self.servicePath = dict["ServicePath"] as! String
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("ServiceTimeout") {
                self.serviceTimeout = dict["ServiceTimeout"] as! Int32
            }
            if dict.keys.contains("ServiceVpcEnable") {
                self.serviceVpcEnable = dict["ServiceVpcEnable"] as! String
            }
            if dict.keys.contains("VpcConfig") {
                var model = DescribeDeployedApiResponseBody.ServiceConfig.VpcConfig()
                model.fromMap(dict["VpcConfig"] as! [String: Any])
                self.vpcConfig = model
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public class ServiceParameters : Tea.TeaModel {
        public class ServiceParameter : Tea.TeaModel {
            public var location: String?

            public var parameterType: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterType != nil {
                    map["ParameterType"] = self.parameterType!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterType") {
                    self.parameterType = dict["ParameterType"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameter: [DescribeDeployedApiResponseBody.ServiceParameters.ServiceParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameter != nil {
                var tmp : [Any] = []
                for k in self.serviceParameter! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameter") {
                self.serviceParameter = dict["ServiceParameter"] as! [DescribeDeployedApiResponseBody.ServiceParameters.ServiceParameter]
            }
        }
    }
    public class ServiceParametersMap : Tea.TeaModel {
        public class ServiceParameterMap : Tea.TeaModel {
            public var requestParameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.requestParameterName != nil {
                    map["RequestParameterName"] = self.requestParameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RequestParameterName") {
                    self.requestParameterName = dict["RequestParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var serviceParameterMap: [DescribeDeployedApiResponseBody.ServiceParametersMap.ServiceParameterMap]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceParameterMap != nil {
                var tmp : [Any] = []
                for k in self.serviceParameterMap! {
                    tmp.append(k.toMap())
                }
                map["ServiceParameterMap"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceParameterMap") {
                self.serviceParameterMap = dict["ServiceParameterMap"] as! [DescribeDeployedApiResponseBody.ServiceParametersMap.ServiceParameterMap]
            }
        }
    }
    public class SystemParameters : Tea.TeaModel {
        public class SystemParameter : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var location: String?

            public var parameterName: String?

            public var serviceParameterName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.parameterName != nil {
                    map["ParameterName"] = self.parameterName!
                }
                if self.serviceParameterName != nil {
                    map["ServiceParameterName"] = self.serviceParameterName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("ParameterName") {
                    self.parameterName = dict["ParameterName"] as! String
                }
                if dict.keys.contains("ServiceParameterName") {
                    self.serviceParameterName = dict["ServiceParameterName"] as! String
                }
            }
        }
        public var systemParameter: [DescribeDeployedApiResponseBody.SystemParameters.SystemParameter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemParameter != nil {
                var tmp : [Any] = []
                for k in self.systemParameter! {
                    tmp.append(k.toMap())
                }
                map["SystemParameter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemParameter") {
                self.systemParameter = dict["SystemParameter"] as! [DescribeDeployedApiResponseBody.SystemParameters.SystemParameter]
            }
        }
    }
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var authType: String?

    public var constantParameters: DescribeDeployedApiResponseBody.ConstantParameters?

    public var customSystemParameters: DescribeDeployedApiResponseBody.CustomSystemParameters?

    public var deployedTime: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: DescribeDeployedApiResponseBody.ErrorCodeSamples?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var groupName: String?

    public var openIdConnectConfig: DescribeDeployedApiResponseBody.OpenIdConnectConfig?

    public var regionId: String?

    public var requestConfig: DescribeDeployedApiResponseBody.RequestConfig?

    public var requestId: String?

    public var requestParameters: DescribeDeployedApiResponseBody.RequestParameters?

    public var resultBodyModel: String?

    public var resultDescriptions: DescribeDeployedApiResponseBody.ResultDescriptions?

    public var resultSample: String?

    public var resultType: String?

    public var serviceConfig: DescribeDeployedApiResponseBody.ServiceConfig?

    public var serviceParameters: DescribeDeployedApiResponseBody.ServiceParameters?

    public var serviceParametersMap: DescribeDeployedApiResponseBody.ServiceParametersMap?

    public var stageName: String?

    public var systemParameters: DescribeDeployedApiResponseBody.SystemParameters?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.constantParameters?.validate()
        try self.customSystemParameters?.validate()
        try self.errorCodeSamples?.validate()
        try self.openIdConnectConfig?.validate()
        try self.requestConfig?.validate()
        try self.requestParameters?.validate()
        try self.resultDescriptions?.validate()
        try self.serviceConfig?.validate()
        try self.serviceParameters?.validate()
        try self.serviceParametersMap?.validate()
        try self.systemParameters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters?.toMap()
        }
        if self.customSystemParameters != nil {
            map["CustomSystemParameters"] = self.customSystemParameters?.toMap()
        }
        if self.deployedTime != nil {
            map["DeployedTime"] = self.deployedTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples?.toMap()
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters?.toMap()
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions?.toMap()
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig?.toMap()
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters?.toMap()
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap?.toMap()
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters?.toMap()
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AuthType") {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("ConstantParameters") {
            var model = DescribeDeployedApiResponseBody.ConstantParameters()
            model.fromMap(dict["ConstantParameters"] as! [String: Any])
            self.constantParameters = model
        }
        if dict.keys.contains("CustomSystemParameters") {
            var model = DescribeDeployedApiResponseBody.CustomSystemParameters()
            model.fromMap(dict["CustomSystemParameters"] as! [String: Any])
            self.customSystemParameters = model
        }
        if dict.keys.contains("DeployedTime") {
            self.deployedTime = dict["DeployedTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") {
            var model = DescribeDeployedApiResponseBody.ErrorCodeSamples()
            model.fromMap(dict["ErrorCodeSamples"] as! [String: Any])
            self.errorCodeSamples = model
        }
        if dict.keys.contains("FailResultSample") {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") {
            var model = DescribeDeployedApiResponseBody.OpenIdConnectConfig()
            model.fromMap(dict["OpenIdConnectConfig"] as! [String: Any])
            self.openIdConnectConfig = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestConfig") {
            var model = DescribeDeployedApiResponseBody.RequestConfig()
            model.fromMap(dict["RequestConfig"] as! [String: Any])
            self.requestConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestParameters") {
            var model = DescribeDeployedApiResponseBody.RequestParameters()
            model.fromMap(dict["RequestParameters"] as! [String: Any])
            self.requestParameters = model
        }
        if dict.keys.contains("ResultBodyModel") {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultDescriptions") {
            var model = DescribeDeployedApiResponseBody.ResultDescriptions()
            model.fromMap(dict["ResultDescriptions"] as! [String: Any])
            self.resultDescriptions = model
        }
        if dict.keys.contains("ResultSample") {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("ServiceConfig") {
            var model = DescribeDeployedApiResponseBody.ServiceConfig()
            model.fromMap(dict["ServiceConfig"] as! [String: Any])
            self.serviceConfig = model
        }
        if dict.keys.contains("ServiceParameters") {
            var model = DescribeDeployedApiResponseBody.ServiceParameters()
            model.fromMap(dict["ServiceParameters"] as! [String: Any])
            self.serviceParameters = model
        }
        if dict.keys.contains("ServiceParametersMap") {
            var model = DescribeDeployedApiResponseBody.ServiceParametersMap()
            model.fromMap(dict["ServiceParametersMap"] as! [String: Any])
            self.serviceParametersMap = model
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("SystemParameters") {
            var model = DescribeDeployedApiResponseBody.SystemParameters()
            model.fromMap(dict["SystemParameters"] as! [String: Any])
            self.systemParameters = model
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class DescribeDeployedApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeployedApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDeployedApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeployedApisRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var apiId: String?

    public var apiMethod: String?

    public var apiName: String?

    public var apiPath: String?

    public var enableTagAuth: Bool?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public var tag: [DescribeDeployedApisRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiMethod != nil {
            map["ApiMethod"] = self.apiMethod!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.apiPath != nil {
            map["ApiPath"] = self.apiPath!
        }
        if self.enableTagAuth != nil {
            map["EnableTagAuth"] = self.enableTagAuth!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiMethod") {
            self.apiMethod = dict["ApiMethod"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("ApiPath") {
            self.apiPath = dict["ApiPath"] as! String
        }
        if dict.keys.contains("EnableTagAuth") {
            self.enableTagAuth = dict["EnableTagAuth"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeDeployedApisRequest.Tag]
        }
    }
}

public class DescribeDeployedApisResponseBody : Tea.TeaModel {
    public class DeployedApis : Tea.TeaModel {
        public class DeployedApiItem : Tea.TeaModel {
            public var apiId: String?

            public var apiMethod: String?

            public var apiName: String?

            public var apiPath: String?

            public var deployedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiMethod != nil {
                    map["ApiMethod"] = self.apiMethod!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiPath != nil {
                    map["ApiPath"] = self.apiPath!
                }
                if self.deployedTime != nil {
                    map["DeployedTime"] = self.deployedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiMethod") {
                    self.apiMethod = dict["ApiMethod"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiPath") {
                    self.apiPath = dict["ApiPath"] as! String
                }
                if dict.keys.contains("DeployedTime") {
                    self.deployedTime = dict["DeployedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var deployedApiItem: [DescribeDeployedApisResponseBody.DeployedApis.DeployedApiItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deployedApiItem != nil {
                var tmp : [Any] = []
                for k in self.deployedApiItem! {
                    tmp.append(k.toMap())
                }
                map["DeployedApiItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeployedApiItem") {
                self.deployedApiItem = dict["DeployedApiItem"] as! [DescribeDeployedApisResponseBody.DeployedApis.DeployedApiItem]
            }
        }
    }
    public var deployedApis: DescribeDeployedApisResponseBody.DeployedApis?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deployedApis?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deployedApis != nil {
            map["DeployedApis"] = self.deployedApis?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeployedApis") {
            var model = DescribeDeployedApisResponseBody.DeployedApis()
            model.fromMap(dict["DeployedApis"] as! [String: Any])
            self.deployedApis = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDeployedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeployedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDeployedApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeDomainResponseBody : Tea.TeaModel {
    public var certificateBody: String?

    public var certificateId: String?

    public var certificateName: String?

    public var certificatePrivateKey: String?

    public var domainBindingStatus: String?

    public var domainCNAMEStatus: String?

    public var domainLegalStatus: String?

    public var domainName: String?

    public var domainRemark: String?

    public var domainWebSocketStatus: String?

    public var groupId: String?

    public var requestId: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateBody != nil {
            map["CertificateBody"] = self.certificateBody!
        }
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.certificateName != nil {
            map["CertificateName"] = self.certificateName!
        }
        if self.certificatePrivateKey != nil {
            map["CertificatePrivateKey"] = self.certificatePrivateKey!
        }
        if self.domainBindingStatus != nil {
            map["DomainBindingStatus"] = self.domainBindingStatus!
        }
        if self.domainCNAMEStatus != nil {
            map["DomainCNAMEStatus"] = self.domainCNAMEStatus!
        }
        if self.domainLegalStatus != nil {
            map["DomainLegalStatus"] = self.domainLegalStatus!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainRemark != nil {
            map["DomainRemark"] = self.domainRemark!
        }
        if self.domainWebSocketStatus != nil {
            map["DomainWebSocketStatus"] = self.domainWebSocketStatus!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateBody") {
            self.certificateBody = dict["CertificateBody"] as! String
        }
        if dict.keys.contains("CertificateId") {
            self.certificateId = dict["CertificateId"] as! String
        }
        if dict.keys.contains("CertificateName") {
            self.certificateName = dict["CertificateName"] as! String
        }
        if dict.keys.contains("CertificatePrivateKey") {
            self.certificatePrivateKey = dict["CertificatePrivateKey"] as! String
        }
        if dict.keys.contains("DomainBindingStatus") {
            self.domainBindingStatus = dict["DomainBindingStatus"] as! String
        }
        if dict.keys.contains("DomainCNAMEStatus") {
            self.domainCNAMEStatus = dict["DomainCNAMEStatus"] as! String
        }
        if dict.keys.contains("DomainLegalStatus") {
            self.domainLegalStatus = dict["DomainLegalStatus"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainRemark") {
            self.domainRemark = dict["DomainRemark"] as! String
        }
        if dict.keys.contains("DomainWebSocketStatus") {
            self.domainWebSocketStatus = dict["DomainWebSocketStatus"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class DescribeDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHistoryApisRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiName: String?

    public var groupId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeHistoryApisResponseBody : Tea.TeaModel {
    public class ApiHisItems : Tea.TeaModel {
        public class ApiHisItem : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var deployedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var historyVersion: String?

            public var regionId: String?

            public var stageName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.deployedTime != nil {
                    map["DeployedTime"] = self.deployedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.historyVersion != nil {
                    map["HistoryVersion"] = self.historyVersion!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("DeployedTime") {
                    self.deployedTime = dict["DeployedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HistoryVersion") {
                    self.historyVersion = dict["HistoryVersion"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var apiHisItem: [DescribeHistoryApisResponseBody.ApiHisItems.ApiHisItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiHisItem != nil {
                var tmp : [Any] = []
                for k in self.apiHisItem! {
                    tmp.append(k.toMap())
                }
                map["ApiHisItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiHisItem") {
                self.apiHisItem = dict["ApiHisItem"] as! [DescribeHistoryApisResponseBody.ApiHisItems.ApiHisItem]
            }
        }
    }
    public var apiHisItems: DescribeHistoryApisResponseBody.ApiHisItems?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiHisItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiHisItems != nil {
            map["ApiHisItems"] = self.apiHisItems?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiHisItems") {
            var model = DescribeHistoryApisResponseBody.ApiHisItems()
            model.fromMap(dict["ApiHisItems"] as! [String: Any])
            self.apiHisItems = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeHistoryApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHistoryApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHistoryApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImportOASTaskRequest : Tea.TeaModel {
    public var operationId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeImportOASTaskResponseBody : Tea.TeaModel {
    public class ApiResults : Tea.TeaModel {
        public class ApiResult : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var description_: String?

            public var errorMessage: String?

            public var groupId: String?

            public var method: String?

            public var path: String?

            public var updateStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.updateStatus != nil {
                    map["UpdateStatus"] = self.updateStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("UpdateStatus") {
                    self.updateStatus = dict["UpdateStatus"] as! String
                }
            }
        }
        public var apiResult: [DescribeImportOASTaskResponseBody.ApiResults.ApiResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiResult != nil {
                var tmp : [Any] = []
                for k in self.apiResult! {
                    tmp.append(k.toMap())
                }
                map["ApiResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiResult") {
                self.apiResult = dict["ApiResult"] as! [DescribeImportOASTaskResponseBody.ApiResults.ApiResult]
            }
        }
    }
    public class ModelResults : Tea.TeaModel {
        public class ModelResult : Tea.TeaModel {
            public var errorMessage: String?

            public var groupId: String?

            public var modelId: String?

            public var modelName: String?

            public var updateStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelId != nil {
                    map["ModelId"] = self.modelId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.updateStatus != nil {
                    map["UpdateStatus"] = self.updateStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelId") {
                    self.modelId = dict["ModelId"] as! String
                }
                if dict.keys.contains("ModelName") {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("UpdateStatus") {
                    self.updateStatus = dict["UpdateStatus"] as! String
                }
            }
        }
        public var modelResult: [DescribeImportOASTaskResponseBody.ModelResults.ModelResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modelResult != nil {
                var tmp : [Any] = []
                for k in self.modelResult! {
                    tmp.append(k.toMap())
                }
                map["ModelResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModelResult") {
                self.modelResult = dict["ModelResult"] as! [DescribeImportOASTaskResponseBody.ModelResults.ModelResult]
            }
        }
    }
    public var apiResults: DescribeImportOASTaskResponseBody.ApiResults?

    public var modelResults: DescribeImportOASTaskResponseBody.ModelResults?

    public var requestId: String?

    public var taskStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiResults?.validate()
        try self.modelResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiResults != nil {
            map["ApiResults"] = self.apiResults?.toMap()
        }
        if self.modelResults != nil {
            map["ModelResults"] = self.modelResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiResults") {
            var model = DescribeImportOASTaskResponseBody.ApiResults()
            model.fromMap(dict["ApiResults"] as! [String: Any])
            self.apiResults = model
        }
        if dict.keys.contains("ModelResults") {
            var model = DescribeImportOASTaskResponseBody.ModelResults()
            model.fromMap(dict["ModelResults"] as! [String: Any])
            self.modelResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskStatus") {
            self.taskStatus = dict["TaskStatus"] as! String
        }
    }
}

public class DescribeImportOASTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImportOASTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImportOASTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var enableTagAuthorization: Bool?

    public var instanceId: String?

    public var language: String?

    public var securityToken: String?

    public var tag: [DescribeInstancesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableTagAuthorization != nil {
            map["EnableTagAuthorization"] = self.enableTagAuthorization!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableTagAuthorization") {
            self.enableTagAuthorization = dict["EnableTagAuthorization"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeInstancesRequest.Tag]
        }
    }
}

public class DescribeInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class InstanceAttribute : Tea.TeaModel {
            public class InstanceSpecAttributes : Tea.TeaModel {
                public class SpecAttribute : Tea.TeaModel {
                    public var localName: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.localName != nil {
                            map["LocalName"] = self.localName!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LocalName") {
                            self.localName = dict["LocalName"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var specAttribute: [DescribeInstancesResponseBody.Instances.InstanceAttribute.InstanceSpecAttributes.SpecAttribute]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.specAttribute != nil {
                        var tmp : [Any] = []
                        for k in self.specAttribute! {
                            tmp.append(k.toMap())
                        }
                        map["SpecAttribute"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SpecAttribute") {
                        self.specAttribute = dict["SpecAttribute"] as! [DescribeInstancesResponseBody.Instances.InstanceAttribute.InstanceSpecAttributes.SpecAttribute]
                    }
                }
            }
            public var aclId: String?

            public var aclName: String?

            public var aclStatus: String?

            public var aclType: String?

            public var classicEgressAddress: String?

            public var createdTime: String?

            public var egressIpv6Enable: Bool?

            public var expiredTime: String?

            public var httpsPolicies: String?

            public var IPV6AclId: String?

            public var IPV6AclName: String?

            public var IPV6AclStatus: String?

            public var IPV6AclType: String?

            public var instanceChargeType: String?

            public var instanceId: String?

            public var instanceName: String?

            public var instanceRpsLimit: Int32?

            public var instanceSpec: String?

            public var instanceSpecAttributes: DescribeInstancesResponseBody.Instances.InstanceAttribute.InstanceSpecAttributes?

            public var instanceType: String?

            public var internetEgressAddress: String?

            public var intranetSegments: String?

            public var regionId: String?

            public var status: String?

            public var supportIpv6: Bool?

            public var userVpcId: String?

            public var userVswitchId: String?

            public var vipTypeList: String?

            public var vpcEgressAddress: String?

            public var vpcIntranetEnable: Bool?

            public var vpcOwnerId: Int64?

            public var vpcSlbIntranetEnable: Bool?

            public var zoneId: String?

            public var zoneLocalName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceSpecAttributes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aclId != nil {
                    map["AclId"] = self.aclId!
                }
                if self.aclName != nil {
                    map["AclName"] = self.aclName!
                }
                if self.aclStatus != nil {
                    map["AclStatus"] = self.aclStatus!
                }
                if self.aclType != nil {
                    map["AclType"] = self.aclType!
                }
                if self.classicEgressAddress != nil {
                    map["ClassicEgressAddress"] = self.classicEgressAddress!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.egressIpv6Enable != nil {
                    map["EgressIpv6Enable"] = self.egressIpv6Enable!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.httpsPolicies != nil {
                    map["HttpsPolicies"] = self.httpsPolicies!
                }
                if self.IPV6AclId != nil {
                    map["IPV6AclId"] = self.IPV6AclId!
                }
                if self.IPV6AclName != nil {
                    map["IPV6AclName"] = self.IPV6AclName!
                }
                if self.IPV6AclStatus != nil {
                    map["IPV6AclStatus"] = self.IPV6AclStatus!
                }
                if self.IPV6AclType != nil {
                    map["IPV6AclType"] = self.IPV6AclType!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instanceRpsLimit != nil {
                    map["InstanceRpsLimit"] = self.instanceRpsLimit!
                }
                if self.instanceSpec != nil {
                    map["InstanceSpec"] = self.instanceSpec!
                }
                if self.instanceSpecAttributes != nil {
                    map["InstanceSpecAttributes"] = self.instanceSpecAttributes?.toMap()
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetEgressAddress != nil {
                    map["InternetEgressAddress"] = self.internetEgressAddress!
                }
                if self.intranetSegments != nil {
                    map["IntranetSegments"] = self.intranetSegments!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supportIpv6 != nil {
                    map["SupportIpv6"] = self.supportIpv6!
                }
                if self.userVpcId != nil {
                    map["UserVpcId"] = self.userVpcId!
                }
                if self.userVswitchId != nil {
                    map["UserVswitchId"] = self.userVswitchId!
                }
                if self.vipTypeList != nil {
                    map["VipTypeList"] = self.vipTypeList!
                }
                if self.vpcEgressAddress != nil {
                    map["VpcEgressAddress"] = self.vpcEgressAddress!
                }
                if self.vpcIntranetEnable != nil {
                    map["VpcIntranetEnable"] = self.vpcIntranetEnable!
                }
                if self.vpcOwnerId != nil {
                    map["VpcOwnerId"] = self.vpcOwnerId!
                }
                if self.vpcSlbIntranetEnable != nil {
                    map["VpcSlbIntranetEnable"] = self.vpcSlbIntranetEnable!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneLocalName != nil {
                    map["ZoneLocalName"] = self.zoneLocalName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AclId") {
                    self.aclId = dict["AclId"] as! String
                }
                if dict.keys.contains("AclName") {
                    self.aclName = dict["AclName"] as! String
                }
                if dict.keys.contains("AclStatus") {
                    self.aclStatus = dict["AclStatus"] as! String
                }
                if dict.keys.contains("AclType") {
                    self.aclType = dict["AclType"] as! String
                }
                if dict.keys.contains("ClassicEgressAddress") {
                    self.classicEgressAddress = dict["ClassicEgressAddress"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("EgressIpv6Enable") {
                    self.egressIpv6Enable = dict["EgressIpv6Enable"] as! Bool
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("HttpsPolicies") {
                    self.httpsPolicies = dict["HttpsPolicies"] as! String
                }
                if dict.keys.contains("IPV6AclId") {
                    self.IPV6AclId = dict["IPV6AclId"] as! String
                }
                if dict.keys.contains("IPV6AclName") {
                    self.IPV6AclName = dict["IPV6AclName"] as! String
                }
                if dict.keys.contains("IPV6AclStatus") {
                    self.IPV6AclStatus = dict["IPV6AclStatus"] as! String
                }
                if dict.keys.contains("IPV6AclType") {
                    self.IPV6AclType = dict["IPV6AclType"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("InstanceRpsLimit") {
                    self.instanceRpsLimit = dict["InstanceRpsLimit"] as! Int32
                }
                if dict.keys.contains("InstanceSpec") {
                    self.instanceSpec = dict["InstanceSpec"] as! String
                }
                if dict.keys.contains("InstanceSpecAttributes") {
                    var model = DescribeInstancesResponseBody.Instances.InstanceAttribute.InstanceSpecAttributes()
                    model.fromMap(dict["InstanceSpecAttributes"] as! [String: Any])
                    self.instanceSpecAttributes = model
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InternetEgressAddress") {
                    self.internetEgressAddress = dict["InternetEgressAddress"] as! String
                }
                if dict.keys.contains("IntranetSegments") {
                    self.intranetSegments = dict["IntranetSegments"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SupportIpv6") {
                    self.supportIpv6 = dict["SupportIpv6"] as! Bool
                }
                if dict.keys.contains("UserVpcId") {
                    self.userVpcId = dict["UserVpcId"] as! String
                }
                if dict.keys.contains("UserVswitchId") {
                    self.userVswitchId = dict["UserVswitchId"] as! String
                }
                if dict.keys.contains("VipTypeList") {
                    self.vipTypeList = dict["VipTypeList"] as! String
                }
                if dict.keys.contains("VpcEgressAddress") {
                    self.vpcEgressAddress = dict["VpcEgressAddress"] as! String
                }
                if dict.keys.contains("VpcIntranetEnable") {
                    self.vpcIntranetEnable = dict["VpcIntranetEnable"] as! Bool
                }
                if dict.keys.contains("VpcOwnerId") {
                    self.vpcOwnerId = dict["VpcOwnerId"] as! Int64
                }
                if dict.keys.contains("VpcSlbIntranetEnable") {
                    self.vpcSlbIntranetEnable = dict["VpcSlbIntranetEnable"] as! Bool
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
                if dict.keys.contains("ZoneLocalName") {
                    self.zoneLocalName = dict["ZoneLocalName"] as! String
                }
            }
        }
        public var instanceAttribute: [DescribeInstancesResponseBody.Instances.InstanceAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceAttribute != nil {
                var tmp : [Any] = []
                for k in self.instanceAttribute! {
                    tmp.append(k.toMap())
                }
                map["InstanceAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceAttribute") {
                self.instanceAttribute = dict["InstanceAttribute"] as! [DescribeInstancesResponseBody.Instances.InstanceAttribute]
            }
        }
    }
    public var instances: DescribeInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var model = DescribeInstancesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpControlPolicyItemsRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var policyItemId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policyItemId != nil {
            map["PolicyItemId"] = self.policyItemId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PolicyItemId") {
            self.policyItemId = dict["PolicyItemId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeIpControlPolicyItemsResponseBody : Tea.TeaModel {
    public class IpControlPolicyItems : Tea.TeaModel {
        public class IpControlPolicyItem : Tea.TeaModel {
            public var appId: String?

            public var cidrIp: String?

            public var createTime: String?

            public var modifiedTime: String?

            public var policyItemId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.cidrIp != nil {
                    map["CidrIp"] = self.cidrIp!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.policyItemId != nil {
                    map["PolicyItemId"] = self.policyItemId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CidrIp") {
                    self.cidrIp = dict["CidrIp"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("PolicyItemId") {
                    self.policyItemId = dict["PolicyItemId"] as! String
                }
            }
        }
        public var ipControlPolicyItem: [DescribeIpControlPolicyItemsResponseBody.IpControlPolicyItems.IpControlPolicyItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipControlPolicyItem != nil {
                var tmp : [Any] = []
                for k in self.ipControlPolicyItem! {
                    tmp.append(k.toMap())
                }
                map["IpControlPolicyItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpControlPolicyItem") {
                self.ipControlPolicyItem = dict["IpControlPolicyItem"] as! [DescribeIpControlPolicyItemsResponseBody.IpControlPolicyItems.IpControlPolicyItem]
            }
        }
    }
    public var ipControlPolicyItems: DescribeIpControlPolicyItemsResponseBody.IpControlPolicyItems?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipControlPolicyItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlPolicyItems != nil {
            map["IpControlPolicyItems"] = self.ipControlPolicyItems?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlPolicyItems") {
            var model = DescribeIpControlPolicyItemsResponseBody.IpControlPolicyItems()
            model.fromMap(dict["IpControlPolicyItems"] as! [String: Any])
            self.ipControlPolicyItems = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIpControlPolicyItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpControlPolicyItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIpControlPolicyItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpControlsRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var ipControlName: String?

    public var ipControlType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.ipControlName != nil {
            map["IpControlName"] = self.ipControlName!
        }
        if self.ipControlType != nil {
            map["IpControlType"] = self.ipControlType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("IpControlName") {
            self.ipControlName = dict["IpControlName"] as! String
        }
        if dict.keys.contains("IpControlType") {
            self.ipControlType = dict["IpControlType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeIpControlsResponseBody : Tea.TeaModel {
    public class IpControlInfos : Tea.TeaModel {
        public class IpControlInfo : Tea.TeaModel {
            public var createTime: String?

            public var description_: String?

            public var ipControlId: String?

            public var ipControlName: String?

            public var ipControlType: String?

            public var modifiedTime: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ipControlId != nil {
                    map["IpControlId"] = self.ipControlId!
                }
                if self.ipControlName != nil {
                    map["IpControlName"] = self.ipControlName!
                }
                if self.ipControlType != nil {
                    map["IpControlType"] = self.ipControlType!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("IpControlId") {
                    self.ipControlId = dict["IpControlId"] as! String
                }
                if dict.keys.contains("IpControlName") {
                    self.ipControlName = dict["IpControlName"] as! String
                }
                if dict.keys.contains("IpControlType") {
                    self.ipControlType = dict["IpControlType"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var ipControlInfo: [DescribeIpControlsResponseBody.IpControlInfos.IpControlInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipControlInfo != nil {
                var tmp : [Any] = []
                for k in self.ipControlInfo! {
                    tmp.append(k.toMap())
                }
                map["IpControlInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpControlInfo") {
                self.ipControlInfo = dict["IpControlInfo"] as! [DescribeIpControlsResponseBody.IpControlInfos.IpControlInfo]
            }
        }
    }
    public var ipControlInfos: DescribeIpControlsResponseBody.IpControlInfos?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipControlInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlInfos != nil {
            map["IpControlInfos"] = self.ipControlInfos?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlInfos") {
            var model = DescribeIpControlsResponseBody.IpControlInfos()
            model.fromMap(dict["IpControlInfos"] as! [String: Any])
            self.ipControlInfos = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeIpControlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpControlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIpControlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLogConfigRequest : Tea.TeaModel {
    public var logType: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logType != nil {
            map["LogType"] = self.logType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogType") {
            self.logType = dict["LogType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLogConfigResponseBody : Tea.TeaModel {
    public class LogInfos : Tea.TeaModel {
        public class LogInfo : Tea.TeaModel {
            public var logType: String?

            public var regionId: String?

            public var slsLogStore: String?

            public var slsProject: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logType != nil {
                    map["LogType"] = self.logType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.slsLogStore != nil {
                    map["SlsLogStore"] = self.slsLogStore!
                }
                if self.slsProject != nil {
                    map["SlsProject"] = self.slsProject!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LogType") {
                    self.logType = dict["LogType"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SlsLogStore") {
                    self.slsLogStore = dict["SlsLogStore"] as! String
                }
                if dict.keys.contains("SlsProject") {
                    self.slsProject = dict["SlsProject"] as! String
                }
            }
        }
        public var logInfo: [DescribeLogConfigResponseBody.LogInfos.LogInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logInfo != nil {
                var tmp : [Any] = []
                for k in self.logInfo! {
                    tmp.append(k.toMap())
                }
                map["LogInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogInfo") {
                self.logInfo = dict["LogInfo"] as! [DescribeLogConfigResponseBody.LogInfos.LogInfo]
            }
        }
    }
    public var logInfos: DescribeLogConfigResponseBody.LogInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logInfos != nil {
            map["LogInfos"] = self.logInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogInfos") {
            var model = DescribeLogConfigResponseBody.LogInfos()
            model.fromMap(dict["LogInfos"] as! [String: Any])
            self.logInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMarketRemainsQuotaRequest : Tea.TeaModel {
    public var domainName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeMarketRemainsQuotaResponseBody : Tea.TeaModel {
    public var remainsQuota: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remainsQuota != nil {
            map["RemainsQuota"] = self.remainsQuota!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RemainsQuota") {
            self.remainsQuota = dict["RemainsQuota"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeMarketRemainsQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMarketRemainsQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMarketRemainsQuotaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeModelsRequest : Tea.TeaModel {
    public var groupId: String?

    public var modelId: String?

    public var modelName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelId != nil {
            map["ModelId"] = self.modelId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelId") {
            self.modelId = dict["ModelId"] as! String
        }
        if dict.keys.contains("ModelName") {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeModelsResponseBody : Tea.TeaModel {
    public class ModelDetails : Tea.TeaModel {
        public class ModelDetail : Tea.TeaModel {
            public var createdTime: String?

            public var description_: String?

            public var groupId: String?

            public var modelId: String?

            public var modelName: String?

            public var modelRef: String?

            public var modifiedTime: String?

            public var schema: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelId != nil {
                    map["ModelId"] = self.modelId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.modelRef != nil {
                    map["ModelRef"] = self.modelRef!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.schema != nil {
                    map["Schema"] = self.schema!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelId") {
                    self.modelId = dict["ModelId"] as! String
                }
                if dict.keys.contains("ModelName") {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("ModelRef") {
                    self.modelRef = dict["ModelRef"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("Schema") {
                    self.schema = dict["Schema"] as! String
                }
            }
        }
        public var modelDetail: [DescribeModelsResponseBody.ModelDetails.ModelDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.modelDetail != nil {
                var tmp : [Any] = []
                for k in self.modelDetail! {
                    tmp.append(k.toMap())
                }
                map["ModelDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ModelDetail") {
                self.modelDetail = dict["ModelDetail"] as! [DescribeModelsResponseBody.ModelDetails.ModelDetail]
            }
        }
    }
    public var modelDetails: DescribeModelsResponseBody.ModelDetails?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.modelDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modelDetails != nil {
            map["ModelDetails"] = self.modelDetails?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModelDetails") {
            var model = DescribeModelsResponseBody.ModelDetails()
            model.fromMap(dict["ModelDetails"] as! [String: Any])
            self.modelDetails = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeModelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeModelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeModelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginApisRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiName: String?

    public var description_: String?

    public var groupId: String?

    public var method: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var path: String?

    public var pluginId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.method != nil {
            map["Method"] = self.method!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Method") {
            self.method = dict["Method"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePluginApisResponseBody : Tea.TeaModel {
    public class ApiSummarys : Tea.TeaModel {
        public class ApiPluginSummary : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var method: String?

            public var path: String?

            public var regionId: String?

            public var stageName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.method != nil {
                    map["Method"] = self.method!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("Method") {
                    self.method = dict["Method"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
            }
        }
        public var apiPluginSummary: [DescribePluginApisResponseBody.ApiSummarys.ApiPluginSummary]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiPluginSummary != nil {
                var tmp : [Any] = []
                for k in self.apiPluginSummary! {
                    tmp.append(k.toMap())
                }
                map["ApiPluginSummary"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiPluginSummary") {
                self.apiPluginSummary = dict["ApiPluginSummary"] as! [DescribePluginApisResponseBody.ApiSummarys.ApiPluginSummary]
            }
        }
    }
    public var apiSummarys: DescribePluginApisResponseBody.ApiSummarys?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiSummarys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiSummarys != nil {
            map["ApiSummarys"] = self.apiSummarys?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiSummarys") {
            var model = DescribePluginApisResponseBody.ApiSummarys()
            model.fromMap(dict["ApiSummarys"] as! [String: Any])
            self.apiSummarys = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePluginApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePluginApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginSchemasRequest : Tea.TeaModel {
    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePluginSchemasResponseBody : Tea.TeaModel {
    public class PluginSchemas : Tea.TeaModel {
        public class PluginSchema : Tea.TeaModel {
            public var description_: String?

            public var documentId: String?

            public var name: String?

            public var supportClassic: Bool?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.documentId != nil {
                    map["DocumentId"] = self.documentId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.supportClassic != nil {
                    map["SupportClassic"] = self.supportClassic!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocumentId") {
                    self.documentId = dict["DocumentId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SupportClassic") {
                    self.supportClassic = dict["SupportClassic"] as! Bool
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var pluginSchema: [DescribePluginSchemasResponseBody.PluginSchemas.PluginSchema]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pluginSchema != nil {
                var tmp : [Any] = []
                for k in self.pluginSchema! {
                    tmp.append(k.toMap())
                }
                map["PluginSchema"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PluginSchema") {
                self.pluginSchema = dict["PluginSchema"] as! [DescribePluginSchemasResponseBody.PluginSchemas.PluginSchema]
            }
        }
    }
    public var pluginSchemas: DescribePluginSchemasResponseBody.PluginSchemas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pluginSchemas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pluginSchemas != nil {
            map["PluginSchemas"] = self.pluginSchemas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PluginSchemas") {
            var model = DescribePluginSchemasResponseBody.PluginSchemas()
            model.fromMap(dict["PluginSchemas"] as! [String: Any])
            self.pluginSchemas = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePluginSchemasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginSchemasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePluginSchemasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginTemplatesRequest : Tea.TeaModel {
    public var language: String?

    public var pluginName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.pluginName != nil {
            map["PluginName"] = self.pluginName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("PluginName") {
            self.pluginName = dict["PluginName"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePluginTemplatesResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var description_: String?

            public var documentAnchor: String?

            public var documentId: String?

            public var sample: String?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.documentAnchor != nil {
                    map["DocumentAnchor"] = self.documentAnchor!
                }
                if self.documentId != nil {
                    map["DocumentId"] = self.documentId!
                }
                if self.sample != nil {
                    map["Sample"] = self.sample!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DocumentAnchor") {
                    self.documentAnchor = dict["DocumentAnchor"] as! String
                }
                if dict.keys.contains("DocumentId") {
                    self.documentId = dict["DocumentId"] as! String
                }
                if dict.keys.contains("Sample") {
                    self.sample = dict["Sample"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var template: [DescribePluginTemplatesResponseBody.Templates.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") {
                self.template = dict["Template"] as! [DescribePluginTemplatesResponseBody.Templates.Template]
            }
        }
    }
    public var requestId: String?

    public var templates: DescribePluginTemplatesResponseBody.Templates?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            map["Templates"] = self.templates?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Templates") {
            var model = DescribePluginTemplatesResponseBody.Templates()
            model.fromMap(dict["Templates"] as! [String: Any])
            self.templates = model
        }
    }
}

public class DescribePluginTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePluginTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var pluginId: String?

    public var pluginName: String?

    public var pluginType: String?

    public var securityToken: String?

    public var tag: [DescribePluginsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.pluginName != nil {
            map["PluginName"] = self.pluginName!
        }
        if self.pluginType != nil {
            map["PluginType"] = self.pluginType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("PluginName") {
            self.pluginName = dict["PluginName"] as! String
        }
        if dict.keys.contains("PluginType") {
            self.pluginType = dict["PluginType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribePluginsRequest.Tag]
        }
    }
}

public class DescribePluginsResponseBody : Tea.TeaModel {
    public class Plugins : Tea.TeaModel {
        public class PluginAttribute : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class TagInfo : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tagInfo: [DescribePluginsResponseBody.Plugins.PluginAttribute.Tags.TagInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagInfo != nil {
                        var tmp : [Any] = []
                        for k in self.tagInfo! {
                            tmp.append(k.toMap())
                        }
                        map["TagInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagInfo") {
                        self.tagInfo = dict["TagInfo"] as! [DescribePluginsResponseBody.Plugins.PluginAttribute.Tags.TagInfo]
                    }
                }
            }
            public var createdTime: String?

            public var description_: String?

            public var modifiedTime: String?

            public var pluginData: String?

            public var pluginId: String?

            public var pluginName: String?

            public var pluginType: String?

            public var regionId: String?

            public var tags: DescribePluginsResponseBody.Plugins.PluginAttribute.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.pluginData != nil {
                    map["PluginData"] = self.pluginData!
                }
                if self.pluginId != nil {
                    map["PluginId"] = self.pluginId!
                }
                if self.pluginName != nil {
                    map["PluginName"] = self.pluginName!
                }
                if self.pluginType != nil {
                    map["PluginType"] = self.pluginType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("PluginData") {
                    self.pluginData = dict["PluginData"] as! String
                }
                if dict.keys.contains("PluginId") {
                    self.pluginId = dict["PluginId"] as! String
                }
                if dict.keys.contains("PluginName") {
                    self.pluginName = dict["PluginName"] as! String
                }
                if dict.keys.contains("PluginType") {
                    self.pluginType = dict["PluginType"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribePluginsResponseBody.Plugins.PluginAttribute.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var pluginAttribute: [DescribePluginsResponseBody.Plugins.PluginAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pluginAttribute != nil {
                var tmp : [Any] = []
                for k in self.pluginAttribute! {
                    tmp.append(k.toMap())
                }
                map["PluginAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PluginAttribute") {
                self.pluginAttribute = dict["PluginAttribute"] as! [DescribePluginsResponseBody.Plugins.PluginAttribute]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var plugins: DescribePluginsResponseBody.Plugins?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.plugins?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.plugins != nil {
            map["Plugins"] = self.plugins?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Plugins") {
            var model = DescribePluginsResponseBody.Plugins()
            model.fromMap(dict["Plugins"] as! [String: Any])
            self.plugins = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePluginsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePluginsByApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribePluginsByApiResponseBody : Tea.TeaModel {
    public class Plugins : Tea.TeaModel {
        public class PluginAttribute : Tea.TeaModel {
            public var createdTime: String?

            public var description_: String?

            public var modifiedTime: String?

            public var pluginData: String?

            public var pluginId: String?

            public var pluginName: String?

            public var pluginType: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.pluginData != nil {
                    map["PluginData"] = self.pluginData!
                }
                if self.pluginId != nil {
                    map["PluginId"] = self.pluginId!
                }
                if self.pluginName != nil {
                    map["PluginName"] = self.pluginName!
                }
                if self.pluginType != nil {
                    map["PluginType"] = self.pluginType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("PluginData") {
                    self.pluginData = dict["PluginData"] as! String
                }
                if dict.keys.contains("PluginId") {
                    self.pluginId = dict["PluginId"] as! String
                }
                if dict.keys.contains("PluginName") {
                    self.pluginName = dict["PluginName"] as! String
                }
                if dict.keys.contains("PluginType") {
                    self.pluginType = dict["PluginType"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var pluginAttribute: [DescribePluginsByApiResponseBody.Plugins.PluginAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pluginAttribute != nil {
                var tmp : [Any] = []
                for k in self.pluginAttribute! {
                    tmp.append(k.toMap())
                }
                map["PluginAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PluginAttribute") {
                self.pluginAttribute = dict["PluginAttribute"] as! [DescribePluginsByApiResponseBody.Plugins.PluginAttribute]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var plugins: DescribePluginsByApiResponseBody.Plugins?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.plugins?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.plugins != nil {
            map["Plugins"] = self.plugins?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Plugins") {
            var model = DescribePluginsByApiResponseBody.Plugins()
            model.fromMap(dict["Plugins"] as! [String: Any])
            self.plugins = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePluginsByApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePluginsByApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePluginsByApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePurchasedApiGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePurchasedApiGroupResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class DomainItem : Tea.TeaModel {
            public var domainName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
            }
        }
        public var domainItem: [DescribePurchasedApiGroupResponseBody.Domains.DomainItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainItem != nil {
                var tmp : [Any] = []
                for k in self.domainItem! {
                    tmp.append(k.toMap())
                }
                map["DomainItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainItem") {
                self.domainItem = dict["DomainItem"] as! [DescribePurchasedApiGroupResponseBody.Domains.DomainItem]
            }
        }
    }
    public var description_: String?

    public var domains: DescribePurchasedApiGroupResponseBody.Domains?

    public var groupId: String?

    public var groupName: String?

    public var purchasedTime: String?

    public var regionId: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domains != nil {
            map["Domains"] = self.domains?.toMap()
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.purchasedTime != nil {
            map["PurchasedTime"] = self.purchasedTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Domains") {
            var model = DescribePurchasedApiGroupResponseBody.Domains()
            model.fromMap(dict["Domains"] as! [String: Any])
            self.domains = model
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("PurchasedTime") {
            self.purchasedTime = dict["PurchasedTime"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribePurchasedApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePurchasedApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePurchasedApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePurchasedApiGroupsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribePurchasedApiGroupsResponseBody : Tea.TeaModel {
    public class PurchasedApiGroupAttributes : Tea.TeaModel {
        public class PurchasedApiGroupAttribute : Tea.TeaModel {
            public var billingType: String?

            public var description_: String?

            public var expireTime: String?

            public var groupId: String?

            public var groupName: String?

            public var invokeTimesMax: Int64?

            public var invokeTimesNow: Int64?

            public var purchasedTime: String?

            public var regionId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.billingType != nil {
                    map["BillingType"] = self.billingType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.invokeTimesMax != nil {
                    map["InvokeTimesMax"] = self.invokeTimesMax!
                }
                if self.invokeTimesNow != nil {
                    map["InvokeTimesNow"] = self.invokeTimesNow!
                }
                if self.purchasedTime != nil {
                    map["PurchasedTime"] = self.purchasedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BillingType") {
                    self.billingType = dict["BillingType"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("InvokeTimesMax") {
                    self.invokeTimesMax = dict["InvokeTimesMax"] as! Int64
                }
                if dict.keys.contains("InvokeTimesNow") {
                    self.invokeTimesNow = dict["InvokeTimesNow"] as! Int64
                }
                if dict.keys.contains("PurchasedTime") {
                    self.purchasedTime = dict["PurchasedTime"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var purchasedApiGroupAttribute: [DescribePurchasedApiGroupsResponseBody.PurchasedApiGroupAttributes.PurchasedApiGroupAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.purchasedApiGroupAttribute != nil {
                var tmp : [Any] = []
                for k in self.purchasedApiGroupAttribute! {
                    tmp.append(k.toMap())
                }
                map["PurchasedApiGroupAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PurchasedApiGroupAttribute") {
                self.purchasedApiGroupAttribute = dict["PurchasedApiGroupAttribute"] as! [DescribePurchasedApiGroupsResponseBody.PurchasedApiGroupAttributes.PurchasedApiGroupAttribute]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var purchasedApiGroupAttributes: DescribePurchasedApiGroupsResponseBody.PurchasedApiGroupAttributes?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.purchasedApiGroupAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.purchasedApiGroupAttributes != nil {
            map["PurchasedApiGroupAttributes"] = self.purchasedApiGroupAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PurchasedApiGroupAttributes") {
            var model = DescribePurchasedApiGroupsResponseBody.PurchasedApiGroupAttributes()
            model.fromMap(dict["PurchasedApiGroupAttributes"] as! [String: Any])
            self.purchasedApiGroupAttributes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePurchasedApiGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePurchasedApiGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePurchasedApiGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePurchasedApisRequest : Tea.TeaModel {
    public var apiId: String?

    public var apiName: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public var visibility: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
    }
}

public class DescribePurchasedApisResponseBody : Tea.TeaModel {
    public class PurchasedApis : Tea.TeaModel {
        public class PurchasedApi : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var deployedTime: String?

            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public var modifiedTime: String?

            public var purchasedTime: String?

            public var regionId: String?

            public var stageName: String?

            public var visibility: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.deployedTime != nil {
                    map["DeployedTime"] = self.deployedTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.purchasedTime != nil {
                    map["PurchasedTime"] = self.purchasedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.visibility != nil {
                    map["Visibility"] = self.visibility!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("DeployedTime") {
                    self.deployedTime = dict["DeployedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("PurchasedTime") {
                    self.purchasedTime = dict["PurchasedTime"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Visibility") {
                    self.visibility = dict["Visibility"] as! String
                }
            }
        }
        public var purchasedApi: [DescribePurchasedApisResponseBody.PurchasedApis.PurchasedApi]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.purchasedApi != nil {
                var tmp : [Any] = []
                for k in self.purchasedApi! {
                    tmp.append(k.toMap())
                }
                map["PurchasedApi"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PurchasedApi") {
                self.purchasedApi = dict["PurchasedApi"] as! [DescribePurchasedApisResponseBody.PurchasedApis.PurchasedApi]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var purchasedApis: DescribePurchasedApisResponseBody.PurchasedApis?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.purchasedApis?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.purchasedApis != nil {
            map["PurchasedApis"] = self.purchasedApis?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PurchasedApis") {
            var model = DescribePurchasedApisResponseBody.PurchasedApis()
            model.fromMap(dict["PurchasedApis"] as! [String: Any])
            self.purchasedApis = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePurchasedApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePurchasedApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePurchasedApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class Region : Tea.TeaModel {
            public var localName: String?

            public var regionEndpoint: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("RegionEndpoint") {
                    self.regionEndpoint = dict["RegionEndpoint"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var region: [DescribeRegionsResponseBody.Regions.Region]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                var tmp : [Any] = []
                for k in self.region! {
                    tmp.append(k.toMap())
                }
                map["Region"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! [DescribeRegionsResponseBody.Regions.Region]
            }
        }
    }
    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(dict["Regions"] as! [String: Any])
            self.regions = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSignaturesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var signatureId: String?

    public var signatureName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("SignatureName") {
            self.signatureName = dict["SignatureName"] as! String
        }
    }
}

public class DescribeSignaturesResponseBody : Tea.TeaModel {
    public class SignatureInfos : Tea.TeaModel {
        public class SignatureInfo : Tea.TeaModel {
            public var createdTime: String?

            public var modifiedTime: String?

            public var regionId: String?

            public var signatureId: String?

            public var signatureKey: String?

            public var signatureName: String?

            public var signatureSecret: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.signatureId != nil {
                    map["SignatureId"] = self.signatureId!
                }
                if self.signatureKey != nil {
                    map["SignatureKey"] = self.signatureKey!
                }
                if self.signatureName != nil {
                    map["SignatureName"] = self.signatureName!
                }
                if self.signatureSecret != nil {
                    map["SignatureSecret"] = self.signatureSecret!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SignatureId") {
                    self.signatureId = dict["SignatureId"] as! String
                }
                if dict.keys.contains("SignatureKey") {
                    self.signatureKey = dict["SignatureKey"] as! String
                }
                if dict.keys.contains("SignatureName") {
                    self.signatureName = dict["SignatureName"] as! String
                }
                if dict.keys.contains("SignatureSecret") {
                    self.signatureSecret = dict["SignatureSecret"] as! String
                }
            }
        }
        public var signatureInfo: [DescribeSignaturesResponseBody.SignatureInfos.SignatureInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.signatureInfo != nil {
                var tmp : [Any] = []
                for k in self.signatureInfo! {
                    tmp.append(k.toMap())
                }
                map["SignatureInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SignatureInfo") {
                self.signatureInfo = dict["SignatureInfo"] as! [DescribeSignaturesResponseBody.SignatureInfos.SignatureInfo]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var signatureInfos: DescribeSignaturesResponseBody.SignatureInfos?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.signatureInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signatureInfos != nil {
            map["SignatureInfos"] = self.signatureInfos?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SignatureInfos") {
            var model = DescribeSignaturesResponseBody.SignatureInfos()
            model.fromMap(dict["SignatureInfos"] as! [String: Any])
            self.signatureInfos = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSignaturesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSignaturesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSignaturesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSignaturesByApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeSignaturesByApiResponseBody : Tea.TeaModel {
    public class Signatures : Tea.TeaModel {
        public class SignatureItem : Tea.TeaModel {
            public var boundTime: String?

            public var signatureId: String?

            public var signatureName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.signatureId != nil {
                    map["SignatureId"] = self.signatureId!
                }
                if self.signatureName != nil {
                    map["SignatureName"] = self.signatureName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BoundTime") {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("SignatureId") {
                    self.signatureId = dict["SignatureId"] as! String
                }
                if dict.keys.contains("SignatureName") {
                    self.signatureName = dict["SignatureName"] as! String
                }
            }
        }
        public var signatureItem: [DescribeSignaturesByApiResponseBody.Signatures.SignatureItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.signatureItem != nil {
                var tmp : [Any] = []
                for k in self.signatureItem! {
                    tmp.append(k.toMap())
                }
                map["SignatureItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SignatureItem") {
                self.signatureItem = dict["SignatureItem"] as! [DescribeSignaturesByApiResponseBody.Signatures.SignatureItem]
            }
        }
    }
    public var requestId: String?

    public var signatures: DescribeSignaturesByApiResponseBody.Signatures?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.signatures?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signatures != nil {
            map["Signatures"] = self.signatures?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Signatures") {
            var model = DescribeSignaturesByApiResponseBody.Signatures()
            model.fromMap(dict["Signatures"] as! [String: Any])
            self.signatures = model
        }
    }
}

public class DescribeSignaturesByApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSignaturesByApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSignaturesByApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSystemParametersRequest : Tea.TeaModel {
    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeSystemParametersResponseBody : Tea.TeaModel {
    public class SystemParams : Tea.TeaModel {
        public class SystemParamItem : Tea.TeaModel {
            public var demoValue: String?

            public var description_: String?

            public var paramName: String?

            public var paramType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.demoValue != nil {
                    map["DemoValue"] = self.demoValue!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.paramName != nil {
                    map["ParamName"] = self.paramName!
                }
                if self.paramType != nil {
                    map["ParamType"] = self.paramType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DemoValue") {
                    self.demoValue = dict["DemoValue"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ParamName") {
                    self.paramName = dict["ParamName"] as! String
                }
                if dict.keys.contains("ParamType") {
                    self.paramType = dict["ParamType"] as! String
                }
            }
        }
        public var systemParamItem: [DescribeSystemParametersResponseBody.SystemParams.SystemParamItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemParamItem != nil {
                var tmp : [Any] = []
                for k in self.systemParamItem! {
                    tmp.append(k.toMap())
                }
                map["SystemParamItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemParamItem") {
                self.systemParamItem = dict["SystemParamItem"] as! [DescribeSystemParametersResponseBody.SystemParams.SystemParamItem]
            }
        }
    }
    public var requestId: String?

    public var systemParams: DescribeSystemParametersResponseBody.SystemParams?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.systemParams != nil {
            map["SystemParams"] = self.systemParams?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SystemParams") {
            var model = DescribeSystemParametersResponseBody.SystemParams()
            model.fromMap(dict["SystemParams"] as! [String: Any])
            self.systemParams = model
        }
    }
}

public class DescribeSystemParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSystemParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSystemParametersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTrafficControlsRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var stageName: String?

    public var trafficControlId: String?

    public var trafficControlName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        if self.trafficControlName != nil {
            map["TrafficControlName"] = self.trafficControlName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
        if dict.keys.contains("TrafficControlName") {
            self.trafficControlName = dict["TrafficControlName"] as! String
        }
    }
}

public class DescribeTrafficControlsResponseBody : Tea.TeaModel {
    public class TrafficControls : Tea.TeaModel {
        public class TrafficControl : Tea.TeaModel {
            public class SpecialPolicies : Tea.TeaModel {
                public class SpecialPolicy : Tea.TeaModel {
                    public class Specials : Tea.TeaModel {
                        public class Special : Tea.TeaModel {
                            public var specialKey: String?

                            public var trafficValue: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.specialKey != nil {
                                    map["SpecialKey"] = self.specialKey!
                                }
                                if self.trafficValue != nil {
                                    map["TrafficValue"] = self.trafficValue!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("SpecialKey") {
                                    self.specialKey = dict["SpecialKey"] as! String
                                }
                                if dict.keys.contains("TrafficValue") {
                                    self.trafficValue = dict["TrafficValue"] as! Int32
                                }
                            }
                        }
                        public var special: [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy.Specials.Special]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.special != nil {
                                var tmp : [Any] = []
                                for k in self.special! {
                                    tmp.append(k.toMap())
                                }
                                map["Special"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Special") {
                                self.special = dict["Special"] as! [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy.Specials.Special]
                            }
                        }
                    }
                    public var specialType: String?

                    public var specials: DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy.Specials?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.specials?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.specialType != nil {
                            map["SpecialType"] = self.specialType!
                        }
                        if self.specials != nil {
                            map["Specials"] = self.specials?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SpecialType") {
                            self.specialType = dict["SpecialType"] as! String
                        }
                        if dict.keys.contains("Specials") {
                            var model = DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy.Specials()
                            model.fromMap(dict["Specials"] as! [String: Any])
                            self.specials = model
                        }
                    }
                }
                public var specialPolicy: [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.specialPolicy != nil {
                        var tmp : [Any] = []
                        for k in self.specialPolicy! {
                            tmp.append(k.toMap())
                        }
                        map["SpecialPolicy"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SpecialPolicy") {
                        self.specialPolicy = dict["SpecialPolicy"] as! [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies.SpecialPolicy]
                    }
                }
            }
            public var apiDefault: Int32?

            public var appDefault: Int32?

            public var createdTime: String?

            public var description_: String?

            public var modifiedTime: String?

            public var specialPolicies: DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies?

            public var trafficControlId: String?

            public var trafficControlName: String?

            public var trafficControlUnit: String?

            public var userDefault: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.specialPolicies?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiDefault != nil {
                    map["ApiDefault"] = self.apiDefault!
                }
                if self.appDefault != nil {
                    map["AppDefault"] = self.appDefault!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.specialPolicies != nil {
                    map["SpecialPolicies"] = self.specialPolicies?.toMap()
                }
                if self.trafficControlId != nil {
                    map["TrafficControlId"] = self.trafficControlId!
                }
                if self.trafficControlName != nil {
                    map["TrafficControlName"] = self.trafficControlName!
                }
                if self.trafficControlUnit != nil {
                    map["TrafficControlUnit"] = self.trafficControlUnit!
                }
                if self.userDefault != nil {
                    map["UserDefault"] = self.userDefault!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiDefault") {
                    self.apiDefault = dict["ApiDefault"] as! Int32
                }
                if dict.keys.contains("AppDefault") {
                    self.appDefault = dict["AppDefault"] as! Int32
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("SpecialPolicies") {
                    var model = DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl.SpecialPolicies()
                    model.fromMap(dict["SpecialPolicies"] as! [String: Any])
                    self.specialPolicies = model
                }
                if dict.keys.contains("TrafficControlId") {
                    self.trafficControlId = dict["TrafficControlId"] as! String
                }
                if dict.keys.contains("TrafficControlName") {
                    self.trafficControlName = dict["TrafficControlName"] as! String
                }
                if dict.keys.contains("TrafficControlUnit") {
                    self.trafficControlUnit = dict["TrafficControlUnit"] as! String
                }
                if dict.keys.contains("UserDefault") {
                    self.userDefault = dict["UserDefault"] as! Int32
                }
            }
        }
        public var trafficControl: [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trafficControl != nil {
                var tmp : [Any] = []
                for k in self.trafficControl! {
                    tmp.append(k.toMap())
                }
                map["TrafficControl"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TrafficControl") {
                self.trafficControl = dict["TrafficControl"] as! [DescribeTrafficControlsResponseBody.TrafficControls.TrafficControl]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var trafficControls: DescribeTrafficControlsResponseBody.TrafficControls?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficControls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.trafficControls != nil {
            map["TrafficControls"] = self.trafficControls?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("TrafficControls") {
            var model = DescribeTrafficControlsResponseBody.TrafficControls()
            model.fromMap(dict["TrafficControls"] as! [String: Any])
            self.trafficControls = model
        }
    }
}

public class DescribeTrafficControlsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTrafficControlsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTrafficControlsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTrafficControlsByApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DescribeTrafficControlsByApiResponseBody : Tea.TeaModel {
    public class TrafficControlItems : Tea.TeaModel {
        public class TrafficControlItem : Tea.TeaModel {
            public var boundTime: String?

            public var trafficControlItemId: String?

            public var trafficControlItemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.boundTime != nil {
                    map["BoundTime"] = self.boundTime!
                }
                if self.trafficControlItemId != nil {
                    map["TrafficControlItemId"] = self.trafficControlItemId!
                }
                if self.trafficControlItemName != nil {
                    map["TrafficControlItemName"] = self.trafficControlItemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BoundTime") {
                    self.boundTime = dict["BoundTime"] as! String
                }
                if dict.keys.contains("TrafficControlItemId") {
                    self.trafficControlItemId = dict["TrafficControlItemId"] as! String
                }
                if dict.keys.contains("TrafficControlItemName") {
                    self.trafficControlItemName = dict["TrafficControlItemName"] as! String
                }
            }
        }
        public var trafficControlItem: [DescribeTrafficControlsByApiResponseBody.TrafficControlItems.TrafficControlItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trafficControlItem != nil {
                var tmp : [Any] = []
                for k in self.trafficControlItem! {
                    tmp.append(k.toMap())
                }
                map["TrafficControlItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TrafficControlItem") {
                self.trafficControlItem = dict["TrafficControlItem"] as! [DescribeTrafficControlsByApiResponseBody.TrafficControlItems.TrafficControlItem]
            }
        }
    }
    public var requestId: String?

    public var trafficControlItems: DescribeTrafficControlsByApiResponseBody.TrafficControlItems?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficControlItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.trafficControlItems != nil {
            map["TrafficControlItems"] = self.trafficControlItems?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TrafficControlItems") {
            var model = DescribeTrafficControlsByApiResponseBody.TrafficControlItems()
            model.fromMap(dict["TrafficControlItems"] as! [String: Any])
            self.trafficControlItems = model
        }
    }
}

public class DescribeTrafficControlsByApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTrafficControlsByApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTrafficControlsByApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUpdateBackendTaskRequest : Tea.TeaModel {
    public var operationUid: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationUid != nil {
            map["OperationUid"] = self.operationUid!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationUid") {
            self.operationUid = dict["OperationUid"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeUpdateBackendTaskResponseBody : Tea.TeaModel {
    public class ApiUpdateBackendResults : Tea.TeaModel {
        public class ApiUpdateBackendResult : Tea.TeaModel {
            public var apiName: String?

            public var apiUid: String?

            public var backendId: String?

            public var errorMsg: String?

            public var groupId: String?

            public var groupName: String?

            public var stageId: String?

            public var stageName: String?

            public var updateStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.backendId != nil {
                    map["BackendId"] = self.backendId!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.updateStatus != nil {
                    map["UpdateStatus"] = self.updateStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiUid") {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("BackendId") {
                    self.backendId = dict["BackendId"] as! String
                }
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("StageId") {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("UpdateStatus") {
                    self.updateStatus = dict["UpdateStatus"] as! String
                }
            }
        }
        public var apiUpdateBackendResult: [DescribeUpdateBackendTaskResponseBody.ApiUpdateBackendResults.ApiUpdateBackendResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiUpdateBackendResult != nil {
                var tmp : [Any] = []
                for k in self.apiUpdateBackendResult! {
                    tmp.append(k.toMap())
                }
                map["ApiUpdateBackendResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiUpdateBackendResult") {
                self.apiUpdateBackendResult = dict["ApiUpdateBackendResult"] as! [DescribeUpdateBackendTaskResponseBody.ApiUpdateBackendResults.ApiUpdateBackendResult]
            }
        }
    }
    public var apiUpdateBackendResults: DescribeUpdateBackendTaskResponseBody.ApiUpdateBackendResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiUpdateBackendResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiUpdateBackendResults != nil {
            map["ApiUpdateBackendResults"] = self.apiUpdateBackendResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiUpdateBackendResults") {
            var model = DescribeUpdateBackendTaskResponseBody.ApiUpdateBackendResults()
            model.fromMap(dict["ApiUpdateBackendResults"] as! [String: Any])
            self.apiUpdateBackendResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUpdateBackendTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpdateBackendTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUpdateBackendTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUpdateVpcInfoTaskRequest : Tea.TeaModel {
    public var operationUid: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationUid != nil {
            map["OperationUid"] = self.operationUid!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationUid") {
            self.operationUid = dict["OperationUid"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeUpdateVpcInfoTaskResponseBody : Tea.TeaModel {
    public class ApiUpdateVpcInfoResults : Tea.TeaModel {
        public class ApiUpdateVpcInfoResult : Tea.TeaModel {
            public var apiName: String?

            public var apiUid: String?

            public var errorMsg: String?

            public var groupId: String?

            public var groupName: String?

            public var stageId: String?

            public var stageName: String?

            public var updateStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.updateStatus != nil {
                    map["UpdateStatus"] = self.updateStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ApiUid") {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("StageId") {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("UpdateStatus") {
                    self.updateStatus = dict["UpdateStatus"] as! String
                }
            }
        }
        public var apiUpdateVpcInfoResult: [DescribeUpdateVpcInfoTaskResponseBody.ApiUpdateVpcInfoResults.ApiUpdateVpcInfoResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiUpdateVpcInfoResult != nil {
                var tmp : [Any] = []
                for k in self.apiUpdateVpcInfoResult! {
                    tmp.append(k.toMap())
                }
                map["ApiUpdateVpcInfoResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiUpdateVpcInfoResult") {
                self.apiUpdateVpcInfoResult = dict["ApiUpdateVpcInfoResult"] as! [DescribeUpdateVpcInfoTaskResponseBody.ApiUpdateVpcInfoResults.ApiUpdateVpcInfoResult]
            }
        }
    }
    public var apiUpdateVpcInfoResults: DescribeUpdateVpcInfoTaskResponseBody.ApiUpdateVpcInfoResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apiUpdateVpcInfoResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiUpdateVpcInfoResults != nil {
            map["ApiUpdateVpcInfoResults"] = self.apiUpdateVpcInfoResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiUpdateVpcInfoResults") {
            var model = DescribeUpdateVpcInfoTaskResponseBody.ApiUpdateVpcInfoResults()
            model.fromMap(dict["ApiUpdateVpcInfoResults"] as! [String: Any])
            self.apiUpdateVpcInfoResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUpdateVpcInfoTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpdateVpcInfoTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUpdateVpcInfoTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpcAccessesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var port: String?

    public var securityToken: String?

    public var vpcAccessId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcAccessId != nil {
            map["VpcAccessId"] = self.vpcAccessId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcAccessId") {
            self.vpcAccessId = dict["VpcAccessId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeVpcAccessesResponseBody : Tea.TeaModel {
    public class VpcAccessAttributes : Tea.TeaModel {
        public class VpcAccessAttribute : Tea.TeaModel {
            public var createdTime: String?

            public var description_: String?

            public var instanceId: String?

            public var name: String?

            public var port: Int32?

            public var regionId: String?

            public var vpcAccessId: String?

            public var vpcId: String?

            public var vpcTargetHostName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.vpcAccessId != nil {
                    map["VpcAccessId"] = self.vpcAccessId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcTargetHostName != nil {
                    map["VpcTargetHostName"] = self.vpcTargetHostName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("VpcAccessId") {
                    self.vpcAccessId = dict["VpcAccessId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcTargetHostName") {
                    self.vpcTargetHostName = dict["VpcTargetHostName"] as! String
                }
            }
        }
        public var vpcAccessAttribute: [DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpcAccessAttribute != nil {
                var tmp : [Any] = []
                for k in self.vpcAccessAttribute! {
                    tmp.append(k.toMap())
                }
                map["VpcAccessAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpcAccessAttribute") {
                self.vpcAccessAttribute = dict["VpcAccessAttribute"] as! [DescribeVpcAccessesResponseBody.VpcAccessAttributes.VpcAccessAttribute]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpcAccessAttributes: DescribeVpcAccessesResponseBody.VpcAccessAttributes?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcAccessAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpcAccessAttributes != nil {
            map["VpcAccessAttributes"] = self.vpcAccessAttributes?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VpcAccessAttributes") {
            var model = DescribeVpcAccessesResponseBody.VpcAccessAttributes()
            model.fromMap(dict["VpcAccessAttributes"] as! [String: Any])
            self.vpcAccessAttributes = model
        }
    }
}

public class DescribeVpcAccessesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcAccessesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpcAccessesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeZonesRequest : Tea.TeaModel {
    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public class Zone : Tea.TeaModel {
            public var localName: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var zone: [DescribeZonesResponseBody.Zones.Zone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zone != nil {
                var tmp : [Any] = []
                for k in self.zone! {
                    tmp.append(k.toMap())
                }
                map["Zone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Zone") {
                self.zone = dict["Zone"] as! [DescribeZonesResponseBody.Zones.Zone]
            }
        }
    }
    public var requestId: String?

    public var zones: DescribeZonesResponseBody.Zones?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.zones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            map["Zones"] = self.zones?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Zones") {
            var model = DescribeZonesResponseBody.Zones()
            model.fromMap(dict["Zones"] as! [String: Any])
            self.zones = model
        }
    }
}

public class DescribeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachPluginRequest : Tea.TeaModel {
    public var apiId: String?

    public var groupId: String?

    public var pluginId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class DetachPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableInstanceAccessControlRequest : Tea.TeaModel {
    public var aclId: String?

    public var addressIPVersion: String?

    public var instanceId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AddressIPVersion") {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DisableInstanceAccessControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableInstanceAccessControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableInstanceAccessControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableInstanceAccessControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DryRunSwaggerRequest : Tea.TeaModel {
    public var data: String?

    public var dataFormat: String?

    public var globalCondition: [String: Any]?

    public var groupId: String?

    public var overwrite: Bool?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dataFormat != nil {
            map["DataFormat"] = self.dataFormat!
        }
        if self.globalCondition != nil {
            map["GlobalCondition"] = self.globalCondition!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DataFormat") {
            self.dataFormat = dict["DataFormat"] as! String
        }
        if dict.keys.contains("GlobalCondition") {
            self.globalCondition = dict["GlobalCondition"] as! [String: Any]
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DryRunSwaggerShrinkRequest : Tea.TeaModel {
    public var data: String?

    public var dataFormat: String?

    public var globalConditionShrink: String?

    public var groupId: String?

    public var overwrite: Bool?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dataFormat != nil {
            map["DataFormat"] = self.dataFormat!
        }
        if self.globalConditionShrink != nil {
            map["GlobalCondition"] = self.globalConditionShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DataFormat") {
            self.dataFormat = dict["DataFormat"] as! String
        }
        if dict.keys.contains("GlobalCondition") {
            self.globalConditionShrink = dict["GlobalCondition"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DryRunSwaggerResponseBody : Tea.TeaModel {
    public class Failed : Tea.TeaModel {
        public class ApiImportSwaggerFailed : Tea.TeaModel {
            public var errorMsg: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("HttpMethod") {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiImportSwaggerFailed: [DryRunSwaggerResponseBody.Failed.ApiImportSwaggerFailed]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportSwaggerFailed != nil {
                var tmp : [Any] = []
                for k in self.apiImportSwaggerFailed! {
                    tmp.append(k.toMap())
                }
                map["ApiImportSwaggerFailed"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportSwaggerFailed") {
                self.apiImportSwaggerFailed = dict["ApiImportSwaggerFailed"] as! [DryRunSwaggerResponseBody.Failed.ApiImportSwaggerFailed]
            }
        }
    }
    public class ModelFailed : Tea.TeaModel {
        public class ApiImportModelFailed : Tea.TeaModel {
            public var errorMsg: String?

            public var groupId: String?

            public var modelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") {
                    self.modelName = dict["ModelName"] as! String
                }
            }
        }
        public var apiImportModelFailed: [DryRunSwaggerResponseBody.ModelFailed.ApiImportModelFailed]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportModelFailed != nil {
                var tmp : [Any] = []
                for k in self.apiImportModelFailed! {
                    tmp.append(k.toMap())
                }
                map["ApiImportModelFailed"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportModelFailed") {
                self.apiImportModelFailed = dict["ApiImportModelFailed"] as! [DryRunSwaggerResponseBody.ModelFailed.ApiImportModelFailed]
            }
        }
    }
    public class ModelSuccess : Tea.TeaModel {
        public class ApiImportModelSuccess : Tea.TeaModel {
            public var groupId: String?

            public var modelName: String?

            public var modelOperation: String?

            public var modelUid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.modelOperation != nil {
                    map["ModelOperation"] = self.modelOperation!
                }
                if self.modelUid != nil {
                    map["ModelUid"] = self.modelUid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("ModelOperation") {
                    self.modelOperation = dict["ModelOperation"] as! String
                }
                if dict.keys.contains("ModelUid") {
                    self.modelUid = dict["ModelUid"] as! String
                }
            }
        }
        public var apiImportModelSuccess: [DryRunSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportModelSuccess != nil {
                var tmp : [Any] = []
                for k in self.apiImportModelSuccess! {
                    tmp.append(k.toMap())
                }
                map["ApiImportModelSuccess"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportModelSuccess") {
                self.apiImportModelSuccess = dict["ApiImportModelSuccess"] as! [DryRunSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess]
            }
        }
    }
    public class Success : Tea.TeaModel {
        public class ApiDryRunSwaggerSuccess : Tea.TeaModel {
            public var apiOperation: String?

            public var apiSwagger: String?

            public var apiUid: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiOperation != nil {
                    map["ApiOperation"] = self.apiOperation!
                }
                if self.apiSwagger != nil {
                    map["ApiSwagger"] = self.apiSwagger!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiOperation") {
                    self.apiOperation = dict["ApiOperation"] as! String
                }
                if dict.keys.contains("ApiSwagger") {
                    self.apiSwagger = dict["ApiSwagger"] as! String
                }
                if dict.keys.contains("ApiUid") {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("HttpMethod") {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiDryRunSwaggerSuccess: [DryRunSwaggerResponseBody.Success.ApiDryRunSwaggerSuccess]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiDryRunSwaggerSuccess != nil {
                var tmp : [Any] = []
                for k in self.apiDryRunSwaggerSuccess! {
                    tmp.append(k.toMap())
                }
                map["ApiDryRunSwaggerSuccess"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiDryRunSwaggerSuccess") {
                self.apiDryRunSwaggerSuccess = dict["ApiDryRunSwaggerSuccess"] as! [DryRunSwaggerResponseBody.Success.ApiDryRunSwaggerSuccess]
            }
        }
    }
    public var failed: DryRunSwaggerResponseBody.Failed?

    public var globalCondition: String?

    public var modelFailed: DryRunSwaggerResponseBody.ModelFailed?

    public var modelSuccess: DryRunSwaggerResponseBody.ModelSuccess?

    public var requestId: String?

    public var success: DryRunSwaggerResponseBody.Success?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failed?.validate()
        try self.modelFailed?.validate()
        try self.modelSuccess?.validate()
        try self.success?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failed != nil {
            map["Failed"] = self.failed?.toMap()
        }
        if self.globalCondition != nil {
            map["GlobalCondition"] = self.globalCondition!
        }
        if self.modelFailed != nil {
            map["ModelFailed"] = self.modelFailed?.toMap()
        }
        if self.modelSuccess != nil {
            map["ModelSuccess"] = self.modelSuccess?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Failed") {
            var model = DryRunSwaggerResponseBody.Failed()
            model.fromMap(dict["Failed"] as! [String: Any])
            self.failed = model
        }
        if dict.keys.contains("GlobalCondition") {
            self.globalCondition = dict["GlobalCondition"] as! String
        }
        if dict.keys.contains("ModelFailed") {
            var model = DryRunSwaggerResponseBody.ModelFailed()
            model.fromMap(dict["ModelFailed"] as! [String: Any])
            self.modelFailed = model
        }
        if dict.keys.contains("ModelSuccess") {
            var model = DryRunSwaggerResponseBody.ModelSuccess()
            model.fromMap(dict["ModelSuccess"] as! [String: Any])
            self.modelSuccess = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            var model = DryRunSwaggerResponseBody.Success()
            model.fromMap(dict["Success"] as! [String: Any])
            self.success = model
        }
    }
}

public class DryRunSwaggerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DryRunSwaggerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DryRunSwaggerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableInstanceAccessControlRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclType: String?

    public var addressIPVersion: String?

    public var instanceId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclType") {
            self.aclType = dict["AclType"] as! String
        }
        if dict.keys.contains("AddressIPVersion") {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class EnableInstanceAccessControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableInstanceAccessControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableInstanceAccessControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableInstanceAccessControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportOASRequest : Tea.TeaModel {
    public var authType: String?

    public var backendName: String?

    public var data: String?

    public var groupId: String?

    public var ignoreWarning: Bool?

    public var OASVersion: String?

    public var overwrite: Bool?

    public var requestMode: String?

    public var securityToken: String?

    public var skipDryRun: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.ignoreWarning != nil {
            map["IgnoreWarning"] = self.ignoreWarning!
        }
        if self.OASVersion != nil {
            map["OASVersion"] = self.OASVersion!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.requestMode != nil {
            map["RequestMode"] = self.requestMode!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.skipDryRun != nil {
            map["SkipDryRun"] = self.skipDryRun!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthType") {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendName") {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IgnoreWarning") {
            self.ignoreWarning = dict["IgnoreWarning"] as! Bool
        }
        if dict.keys.contains("OASVersion") {
            self.OASVersion = dict["OASVersion"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("RequestMode") {
            self.requestMode = dict["RequestMode"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SkipDryRun") {
            self.skipDryRun = dict["SkipDryRun"] as! Bool
        }
    }
}

public class ImportOASResponseBody : Tea.TeaModel {
    public class ErrorMessages : Tea.TeaModel {
        public var errorMessage: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! [String]
            }
        }
    }
    public class FailedApis : Tea.TeaModel {
        public class FailedApi : Tea.TeaModel {
            public var errorMsg: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("HttpMethod") {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var failedApi: [ImportOASResponseBody.FailedApis.FailedApi]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedApi != nil {
                var tmp : [Any] = []
                for k in self.failedApi! {
                    tmp.append(k.toMap())
                }
                map["FailedApi"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedApi") {
                self.failedApi = dict["FailedApi"] as! [ImportOASResponseBody.FailedApis.FailedApi]
            }
        }
    }
    public class FailedModels : Tea.TeaModel {
        public class FailedModel : Tea.TeaModel {
            public var errorMsg: String?

            public var groupId: String?

            public var modelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") {
                    self.modelName = dict["ModelName"] as! String
                }
            }
        }
        public var failedModel: [ImportOASResponseBody.FailedModels.FailedModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedModel != nil {
                var tmp : [Any] = []
                for k in self.failedModel! {
                    tmp.append(k.toMap())
                }
                map["FailedModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedModel") {
                self.failedModel = dict["FailedModel"] as! [ImportOASResponseBody.FailedModels.FailedModel]
            }
        }
    }
    public class SuccessApis : Tea.TeaModel {
        public class SuccessApi : Tea.TeaModel {
            public var apiId: String?

            public var apiOperation: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiOperation != nil {
                    map["ApiOperation"] = self.apiOperation!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiOperation") {
                    self.apiOperation = dict["ApiOperation"] as! String
                }
                if dict.keys.contains("HttpMethod") {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var successApi: [ImportOASResponseBody.SuccessApis.SuccessApi]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.successApi != nil {
                var tmp : [Any] = []
                for k in self.successApi! {
                    tmp.append(k.toMap())
                }
                map["SuccessApi"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SuccessApi") {
                self.successApi = dict["SuccessApi"] as! [ImportOASResponseBody.SuccessApis.SuccessApi]
            }
        }
    }
    public class SuccessModels : Tea.TeaModel {
        public class SuccessModel : Tea.TeaModel {
            public var groupId: String?

            public var modelName: String?

            public var modelOperation: String?

            public var modelUid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.modelOperation != nil {
                    map["ModelOperation"] = self.modelOperation!
                }
                if self.modelUid != nil {
                    map["ModelUid"] = self.modelUid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("ModelOperation") {
                    self.modelOperation = dict["ModelOperation"] as! String
                }
                if dict.keys.contains("ModelUid") {
                    self.modelUid = dict["ModelUid"] as! String
                }
            }
        }
        public var successModel: [ImportOASResponseBody.SuccessModels.SuccessModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.successModel != nil {
                var tmp : [Any] = []
                for k in self.successModel! {
                    tmp.append(k.toMap())
                }
                map["SuccessModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SuccessModel") {
                self.successModel = dict["SuccessModel"] as! [ImportOASResponseBody.SuccessModels.SuccessModel]
            }
        }
    }
    public class WarningMessages : Tea.TeaModel {
        public var warningMessage: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.warningMessage != nil {
                map["WarningMessage"] = self.warningMessage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WarningMessage") {
                self.warningMessage = dict["WarningMessage"] as! [String]
            }
        }
    }
    public var errorMessages: ImportOASResponseBody.ErrorMessages?

    public var failedApis: ImportOASResponseBody.FailedApis?

    public var failedModels: ImportOASResponseBody.FailedModels?

    public var operationId: String?

    public var requestId: String?

    public var successApis: ImportOASResponseBody.SuccessApis?

    public var successModels: ImportOASResponseBody.SuccessModels?

    public var warningMessages: ImportOASResponseBody.WarningMessages?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.errorMessages?.validate()
        try self.failedApis?.validate()
        try self.failedModels?.validate()
        try self.successApis?.validate()
        try self.successModels?.validate()
        try self.warningMessages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorMessages != nil {
            map["ErrorMessages"] = self.errorMessages?.toMap()
        }
        if self.failedApis != nil {
            map["FailedApis"] = self.failedApis?.toMap()
        }
        if self.failedModels != nil {
            map["FailedModels"] = self.failedModels?.toMap()
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successApis != nil {
            map["SuccessApis"] = self.successApis?.toMap()
        }
        if self.successModels != nil {
            map["SuccessModels"] = self.successModels?.toMap()
        }
        if self.warningMessages != nil {
            map["WarningMessages"] = self.warningMessages?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorMessages") {
            var model = ImportOASResponseBody.ErrorMessages()
            model.fromMap(dict["ErrorMessages"] as! [String: Any])
            self.errorMessages = model
        }
        if dict.keys.contains("FailedApis") {
            var model = ImportOASResponseBody.FailedApis()
            model.fromMap(dict["FailedApis"] as! [String: Any])
            self.failedApis = model
        }
        if dict.keys.contains("FailedModels") {
            var model = ImportOASResponseBody.FailedModels()
            model.fromMap(dict["FailedModels"] as! [String: Any])
            self.failedModels = model
        }
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessApis") {
            var model = ImportOASResponseBody.SuccessApis()
            model.fromMap(dict["SuccessApis"] as! [String: Any])
            self.successApis = model
        }
        if dict.keys.contains("SuccessModels") {
            var model = ImportOASResponseBody.SuccessModels()
            model.fromMap(dict["SuccessModels"] as! [String: Any])
            self.successModels = model
        }
        if dict.keys.contains("WarningMessages") {
            var model = ImportOASResponseBody.WarningMessages()
            model.fromMap(dict["WarningMessages"] as! [String: Any])
            self.warningMessages = model
        }
    }
}

public class ImportOASResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportOASResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportOASResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportSwaggerRequest : Tea.TeaModel {
    public var data: String?

    public var dataFormat: String?

    public var dryRun: Bool?

    public var globalCondition: [String: Any]?

    public var groupId: String?

    public var overwrite: Bool?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dataFormat != nil {
            map["DataFormat"] = self.dataFormat!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.globalCondition != nil {
            map["GlobalCondition"] = self.globalCondition!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DataFormat") {
            self.dataFormat = dict["DataFormat"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("GlobalCondition") {
            self.globalCondition = dict["GlobalCondition"] as! [String: Any]
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ImportSwaggerShrinkRequest : Tea.TeaModel {
    public var data: String?

    public var dataFormat: String?

    public var dryRun: Bool?

    public var globalConditionShrink: String?

    public var groupId: String?

    public var overwrite: Bool?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.dataFormat != nil {
            map["DataFormat"] = self.dataFormat!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.globalConditionShrink != nil {
            map["GlobalCondition"] = self.globalConditionShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("DataFormat") {
            self.dataFormat = dict["DataFormat"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("GlobalCondition") {
            self.globalConditionShrink = dict["GlobalCondition"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ImportSwaggerResponseBody : Tea.TeaModel {
    public class Failed : Tea.TeaModel {
        public class ApiImportSwaggerFailed : Tea.TeaModel {
            public var errorMsg: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("HttpMethod") {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiImportSwaggerFailed: [ImportSwaggerResponseBody.Failed.ApiImportSwaggerFailed]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportSwaggerFailed != nil {
                var tmp : [Any] = []
                for k in self.apiImportSwaggerFailed! {
                    tmp.append(k.toMap())
                }
                map["ApiImportSwaggerFailed"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportSwaggerFailed") {
                self.apiImportSwaggerFailed = dict["ApiImportSwaggerFailed"] as! [ImportSwaggerResponseBody.Failed.ApiImportSwaggerFailed]
            }
        }
    }
    public class ModelFailed : Tea.TeaModel {
        public class ApiImportModelFailed : Tea.TeaModel {
            public var errorMsg: String?

            public var groupId: String?

            public var modelName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") {
                    self.modelName = dict["ModelName"] as! String
                }
            }
        }
        public var apiImportModelFailed: [ImportSwaggerResponseBody.ModelFailed.ApiImportModelFailed]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportModelFailed != nil {
                var tmp : [Any] = []
                for k in self.apiImportModelFailed! {
                    tmp.append(k.toMap())
                }
                map["ApiImportModelFailed"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportModelFailed") {
                self.apiImportModelFailed = dict["ApiImportModelFailed"] as! [ImportSwaggerResponseBody.ModelFailed.ApiImportModelFailed]
            }
        }
    }
    public class ModelSuccess : Tea.TeaModel {
        public class ApiImportModelSuccess : Tea.TeaModel {
            public var groupId: String?

            public var modelName: String?

            public var modelOperation: String?

            public var modelUid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.modelName != nil {
                    map["ModelName"] = self.modelName!
                }
                if self.modelOperation != nil {
                    map["ModelOperation"] = self.modelOperation!
                }
                if self.modelUid != nil {
                    map["ModelUid"] = self.modelUid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ModelName") {
                    self.modelName = dict["ModelName"] as! String
                }
                if dict.keys.contains("ModelOperation") {
                    self.modelOperation = dict["ModelOperation"] as! String
                }
                if dict.keys.contains("ModelUid") {
                    self.modelUid = dict["ModelUid"] as! String
                }
            }
        }
        public var apiImportModelSuccess: [ImportSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportModelSuccess != nil {
                var tmp : [Any] = []
                for k in self.apiImportModelSuccess! {
                    tmp.append(k.toMap())
                }
                map["ApiImportModelSuccess"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportModelSuccess") {
                self.apiImportModelSuccess = dict["ApiImportModelSuccess"] as! [ImportSwaggerResponseBody.ModelSuccess.ApiImportModelSuccess]
            }
        }
    }
    public class Success : Tea.TeaModel {
        public class ApiImportSwaggerSuccess : Tea.TeaModel {
            public var apiOperation: String?

            public var apiUid: String?

            public var httpMethod: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiOperation != nil {
                    map["ApiOperation"] = self.apiOperation!
                }
                if self.apiUid != nil {
                    map["ApiUid"] = self.apiUid!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiOperation") {
                    self.apiOperation = dict["ApiOperation"] as! String
                }
                if dict.keys.contains("ApiUid") {
                    self.apiUid = dict["ApiUid"] as! String
                }
                if dict.keys.contains("HttpMethod") {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var apiImportSwaggerSuccess: [ImportSwaggerResponseBody.Success.ApiImportSwaggerSuccess]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiImportSwaggerSuccess != nil {
                var tmp : [Any] = []
                for k in self.apiImportSwaggerSuccess! {
                    tmp.append(k.toMap())
                }
                map["ApiImportSwaggerSuccess"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApiImportSwaggerSuccess") {
                self.apiImportSwaggerSuccess = dict["ApiImportSwaggerSuccess"] as! [ImportSwaggerResponseBody.Success.ApiImportSwaggerSuccess]
            }
        }
    }
    public var failed: ImportSwaggerResponseBody.Failed?

    public var modelFailed: ImportSwaggerResponseBody.ModelFailed?

    public var modelSuccess: ImportSwaggerResponseBody.ModelSuccess?

    public var requestId: String?

    public var success: ImportSwaggerResponseBody.Success?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failed?.validate()
        try self.modelFailed?.validate()
        try self.modelSuccess?.validate()
        try self.success?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failed != nil {
            map["Failed"] = self.failed?.toMap()
        }
        if self.modelFailed != nil {
            map["ModelFailed"] = self.modelFailed?.toMap()
        }
        if self.modelSuccess != nil {
            map["ModelSuccess"] = self.modelSuccess?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Failed") {
            var model = ImportSwaggerResponseBody.Failed()
            model.fromMap(dict["Failed"] as! [String: Any])
            self.failed = model
        }
        if dict.keys.contains("ModelFailed") {
            var model = ImportSwaggerResponseBody.ModelFailed()
            model.fromMap(dict["ModelFailed"] as! [String: Any])
            self.modelFailed = model
        }
        if dict.keys.contains("ModelSuccess") {
            var model = ImportSwaggerResponseBody.ModelSuccess()
            model.fromMap(dict["ModelSuccess"] as! [String: Any])
            self.modelSuccess = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            var model = ImportSwaggerResponseBody.Success()
            model.fromMap(dict["Success"] as! [String: Any])
            self.success = model
        }
    }
}

public class ImportSwaggerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportSwaggerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportSwaggerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var nextToken: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ListTagResourcesRequest.Tag]
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") {
                self.tagResource = dict["TagResource"] as! [ListTagResourcesResponseBody.TagResources.TagResource]
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiRequest : Tea.TeaModel {
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendEnable: Bool?

    public var backendId: String?

    public var constantParameters: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: String?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var groupId: String?

    public var openIdConnectConfig: String?

    public var requestConfig: String?

    public var requestParameters: String?

    public var resultBodyModel: String?

    public var resultDescriptions: String?

    public var resultSample: String?

    public var resultType: String?

    public var securityToken: String?

    public var serviceConfig: String?

    public var serviceParameters: String?

    public var serviceParametersMap: String?

    public var systemParameters: String?

    public var visibility: String?

    public var webSocketApiType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendEnable != nil {
            map["BackendEnable"] = self.backendEnable!
        }
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.constantParameters != nil {
            map["ConstantParameters"] = self.constantParameters!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples!
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.openIdConnectConfig != nil {
            map["OpenIdConnectConfig"] = self.openIdConnectConfig!
        }
        if self.requestConfig != nil {
            map["RequestConfig"] = self.requestConfig!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters!
        }
        if self.resultBodyModel != nil {
            map["ResultBodyModel"] = self.resultBodyModel!
        }
        if self.resultDescriptions != nil {
            map["ResultDescriptions"] = self.resultDescriptions!
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.serviceConfig != nil {
            map["ServiceConfig"] = self.serviceConfig!
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters!
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap!
        }
        if self.systemParameters != nil {
            map["SystemParameters"] = self.systemParameters!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.webSocketApiType != nil {
            map["WebSocketApiType"] = self.webSocketApiType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendEnable") {
            self.backendEnable = dict["BackendEnable"] as! Bool
        }
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("ConstantParameters") {
            self.constantParameters = dict["ConstantParameters"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") {
            self.errorCodeSamples = dict["ErrorCodeSamples"] as! String
        }
        if dict.keys.contains("FailResultSample") {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OpenIdConnectConfig") {
            self.openIdConnectConfig = dict["OpenIdConnectConfig"] as! String
        }
        if dict.keys.contains("RequestConfig") {
            self.requestConfig = dict["RequestConfig"] as! String
        }
        if dict.keys.contains("RequestParameters") {
            self.requestParameters = dict["RequestParameters"] as! String
        }
        if dict.keys.contains("ResultBodyModel") {
            self.resultBodyModel = dict["ResultBodyModel"] as! String
        }
        if dict.keys.contains("ResultDescriptions") {
            self.resultDescriptions = dict["ResultDescriptions"] as! String
        }
        if dict.keys.contains("ResultSample") {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("ServiceConfig") {
            self.serviceConfig = dict["ServiceConfig"] as! String
        }
        if dict.keys.contains("ServiceParameters") {
            self.serviceParameters = dict["ServiceParameters"] as! String
        }
        if dict.keys.contains("ServiceParametersMap") {
            self.serviceParametersMap = dict["ServiceParametersMap"] as! String
        }
        if dict.keys.contains("SystemParameters") {
            self.systemParameters = dict["SystemParameters"] as! String
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("WebSocketApiType") {
            self.webSocketApiType = dict["WebSocketApiType"] as! String
        }
    }
}

public class ModifyApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiConfigurationRequest : Tea.TeaModel {
    public var allowSignatureMethod: String?

    public var apiId: String?

    public var apiName: String?

    public var appCodeAuthType: String?

    public var authType: String?

    public var backendName: String?

    public var bodyFormat: String?

    public var bodyModel: String?

    public var contentTypeCategory: String?

    public var contentTypeValue: String?

    public var description_: String?

    public var disableInternet: Bool?

    public var errorCodeSamples: String?

    public var failResultSample: String?

    public var forceNonceCheck: Bool?

    public var functionComputeConfig: String?

    public var httpConfig: String?

    public var mockConfig: String?

    public var modelName: String?

    public var ossConfig: String?

    public var postBodyDescription: String?

    public var requestHttpMethod: String?

    public var requestMode: String?

    public var requestParameters: String?

    public var requestPath: String?

    public var requestProtocol: String?

    public var resultSample: String?

    public var resultType: String?

    public var securityToken: String?

    public var serviceParameters: String?

    public var serviceParametersMap: String?

    public var serviceProtocol: String?

    public var serviceTimeout: Int32?

    public var useBackendService: Bool?

    public var visibility: String?

    public var vpcConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allowSignatureMethod != nil {
            map["AllowSignatureMethod"] = self.allowSignatureMethod!
        }
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.apiName != nil {
            map["ApiName"] = self.apiName!
        }
        if self.appCodeAuthType != nil {
            map["AppCodeAuthType"] = self.appCodeAuthType!
        }
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.bodyFormat != nil {
            map["BodyFormat"] = self.bodyFormat!
        }
        if self.bodyModel != nil {
            map["BodyModel"] = self.bodyModel!
        }
        if self.contentTypeCategory != nil {
            map["ContentTypeCategory"] = self.contentTypeCategory!
        }
        if self.contentTypeValue != nil {
            map["ContentTypeValue"] = self.contentTypeValue!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInternet != nil {
            map["DisableInternet"] = self.disableInternet!
        }
        if self.errorCodeSamples != nil {
            map["ErrorCodeSamples"] = self.errorCodeSamples!
        }
        if self.failResultSample != nil {
            map["FailResultSample"] = self.failResultSample!
        }
        if self.forceNonceCheck != nil {
            map["ForceNonceCheck"] = self.forceNonceCheck!
        }
        if self.functionComputeConfig != nil {
            map["FunctionComputeConfig"] = self.functionComputeConfig!
        }
        if self.httpConfig != nil {
            map["HttpConfig"] = self.httpConfig!
        }
        if self.mockConfig != nil {
            map["MockConfig"] = self.mockConfig!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.ossConfig != nil {
            map["OssConfig"] = self.ossConfig!
        }
        if self.postBodyDescription != nil {
            map["PostBodyDescription"] = self.postBodyDescription!
        }
        if self.requestHttpMethod != nil {
            map["RequestHttpMethod"] = self.requestHttpMethod!
        }
        if self.requestMode != nil {
            map["RequestMode"] = self.requestMode!
        }
        if self.requestParameters != nil {
            map["RequestParameters"] = self.requestParameters!
        }
        if self.requestPath != nil {
            map["RequestPath"] = self.requestPath!
        }
        if self.requestProtocol != nil {
            map["RequestProtocol"] = self.requestProtocol!
        }
        if self.resultSample != nil {
            map["ResultSample"] = self.resultSample!
        }
        if self.resultType != nil {
            map["ResultType"] = self.resultType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.serviceParameters != nil {
            map["ServiceParameters"] = self.serviceParameters!
        }
        if self.serviceParametersMap != nil {
            map["ServiceParametersMap"] = self.serviceParametersMap!
        }
        if self.serviceProtocol != nil {
            map["ServiceProtocol"] = self.serviceProtocol!
        }
        if self.serviceTimeout != nil {
            map["ServiceTimeout"] = self.serviceTimeout!
        }
        if self.useBackendService != nil {
            map["UseBackendService"] = self.useBackendService!
        }
        if self.visibility != nil {
            map["Visibility"] = self.visibility!
        }
        if self.vpcConfig != nil {
            map["VpcConfig"] = self.vpcConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllowSignatureMethod") {
            self.allowSignatureMethod = dict["AllowSignatureMethod"] as! String
        }
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("ApiName") {
            self.apiName = dict["ApiName"] as! String
        }
        if dict.keys.contains("AppCodeAuthType") {
            self.appCodeAuthType = dict["AppCodeAuthType"] as! String
        }
        if dict.keys.contains("AuthType") {
            self.authType = dict["AuthType"] as! String
        }
        if dict.keys.contains("BackendName") {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("BodyFormat") {
            self.bodyFormat = dict["BodyFormat"] as! String
        }
        if dict.keys.contains("BodyModel") {
            self.bodyModel = dict["BodyModel"] as! String
        }
        if dict.keys.contains("ContentTypeCategory") {
            self.contentTypeCategory = dict["ContentTypeCategory"] as! String
        }
        if dict.keys.contains("ContentTypeValue") {
            self.contentTypeValue = dict["ContentTypeValue"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInternet") {
            self.disableInternet = dict["DisableInternet"] as! Bool
        }
        if dict.keys.contains("ErrorCodeSamples") {
            self.errorCodeSamples = dict["ErrorCodeSamples"] as! String
        }
        if dict.keys.contains("FailResultSample") {
            self.failResultSample = dict["FailResultSample"] as! String
        }
        if dict.keys.contains("ForceNonceCheck") {
            self.forceNonceCheck = dict["ForceNonceCheck"] as! Bool
        }
        if dict.keys.contains("FunctionComputeConfig") {
            self.functionComputeConfig = dict["FunctionComputeConfig"] as! String
        }
        if dict.keys.contains("HttpConfig") {
            self.httpConfig = dict["HttpConfig"] as! String
        }
        if dict.keys.contains("MockConfig") {
            self.mockConfig = dict["MockConfig"] as! String
        }
        if dict.keys.contains("ModelName") {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("OssConfig") {
            self.ossConfig = dict["OssConfig"] as! String
        }
        if dict.keys.contains("PostBodyDescription") {
            self.postBodyDescription = dict["PostBodyDescription"] as! String
        }
        if dict.keys.contains("RequestHttpMethod") {
            self.requestHttpMethod = dict["RequestHttpMethod"] as! String
        }
        if dict.keys.contains("RequestMode") {
            self.requestMode = dict["RequestMode"] as! String
        }
        if dict.keys.contains("RequestParameters") {
            self.requestParameters = dict["RequestParameters"] as! String
        }
        if dict.keys.contains("RequestPath") {
            self.requestPath = dict["RequestPath"] as! String
        }
        if dict.keys.contains("RequestProtocol") {
            self.requestProtocol = dict["RequestProtocol"] as! String
        }
        if dict.keys.contains("ResultSample") {
            self.resultSample = dict["ResultSample"] as! String
        }
        if dict.keys.contains("ResultType") {
            self.resultType = dict["ResultType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("ServiceParameters") {
            self.serviceParameters = dict["ServiceParameters"] as! String
        }
        if dict.keys.contains("ServiceParametersMap") {
            self.serviceParametersMap = dict["ServiceParametersMap"] as! String
        }
        if dict.keys.contains("ServiceProtocol") {
            self.serviceProtocol = dict["ServiceProtocol"] as! String
        }
        if dict.keys.contains("ServiceTimeout") {
            self.serviceTimeout = dict["ServiceTimeout"] as! Int32
        }
        if dict.keys.contains("UseBackendService") {
            self.useBackendService = dict["UseBackendService"] as! Bool
        }
        if dict.keys.contains("Visibility") {
            self.visibility = dict["Visibility"] as! String
        }
        if dict.keys.contains("VpcConfig") {
            self.vpcConfig = dict["VpcConfig"] as! String
        }
    }
}

public class ModifyApiConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyApiConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyApiConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var basePath: String?

    public var compatibleFlags: String?

    public var customTraceConfig: String?

    public var customerConfigs: String?

    public var defaultDomain: String?

    public var description_: String?

    public var groupId: String?

    public var groupName: String?

    public var passthroughHeaders: String?

    public var rpcPattern: String?

    public var securityToken: String?

    public var tag: [ModifyApiGroupRequest.Tag]?

    public var userLogConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.compatibleFlags != nil {
            map["CompatibleFlags"] = self.compatibleFlags!
        }
        if self.customTraceConfig != nil {
            map["CustomTraceConfig"] = self.customTraceConfig!
        }
        if self.customerConfigs != nil {
            map["CustomerConfigs"] = self.customerConfigs!
        }
        if self.defaultDomain != nil {
            map["DefaultDomain"] = self.defaultDomain!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.passthroughHeaders != nil {
            map["PassthroughHeaders"] = self.passthroughHeaders!
        }
        if self.rpcPattern != nil {
            map["RpcPattern"] = self.rpcPattern!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userLogConfig != nil {
            map["UserLogConfig"] = self.userLogConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("CompatibleFlags") {
            self.compatibleFlags = dict["CompatibleFlags"] as! String
        }
        if dict.keys.contains("CustomTraceConfig") {
            self.customTraceConfig = dict["CustomTraceConfig"] as! String
        }
        if dict.keys.contains("CustomerConfigs") {
            self.customerConfigs = dict["CustomerConfigs"] as! String
        }
        if dict.keys.contains("DefaultDomain") {
            self.defaultDomain = dict["DefaultDomain"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("PassthroughHeaders") {
            self.passthroughHeaders = dict["PassthroughHeaders"] as! String
        }
        if dict.keys.contains("RpcPattern") {
            self.rpcPattern = dict["RpcPattern"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ModifyApiGroupRequest.Tag]
        }
        if dict.keys.contains("UserLogConfig") {
            self.userLogConfig = dict["UserLogConfig"] as! String
        }
    }
}

public class ModifyApiGroupResponseBody : Tea.TeaModel {
    public var basePath: String?

    public var description_: String?

    public var groupId: String?

    public var groupName: String?

    public var requestId: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.basePath != nil {
            map["BasePath"] = self.basePath!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BasePath") {
            self.basePath = dict["BasePath"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("GroupName") {
            self.groupName = dict["GroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class ModifyApiGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyApiGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyApiGroupVpcWhitelistRequest : Tea.TeaModel {
    public var groupId: String?

    public var securityToken: String?

    public var vpcIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcIds != nil {
            map["VpcIds"] = self.vpcIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcIds") {
            self.vpcIds = dict["VpcIds"] as! String
        }
    }
}

public class ModifyApiGroupVpcWhitelistResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyApiGroupVpcWhitelistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApiGroupVpcWhitelistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyApiGroupVpcWhitelistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAppRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var appId: Int64?

    public var appName: String?

    public var description_: String?

    public var securityToken: String?

    public var tag: [ModifyAppRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ModifyAppRequest.Tag]
        }
    }
}

public class ModifyAppResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBackendRequest : Tea.TeaModel {
    public var backendId: String?

    public var backendName: String?

    public var backendType: String?

    public var description_: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.backendName != nil {
            map["BackendName"] = self.backendName!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("BackendName") {
            self.backendName = dict["BackendName"] as! String
        }
        if dict.keys.contains("BackendType") {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyBackendResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBackendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBackendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyBackendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBackendModelRequest : Tea.TeaModel {
    public var backendId: String?

    public var backendModelData: String?

    public var backendModelId: String?

    public var backendType: String?

    public var description_: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendId != nil {
            map["BackendId"] = self.backendId!
        }
        if self.backendModelData != nil {
            map["BackendModelData"] = self.backendModelData!
        }
        if self.backendModelId != nil {
            map["BackendModelId"] = self.backendModelId!
        }
        if self.backendType != nil {
            map["BackendType"] = self.backendType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendId") {
            self.backendId = dict["BackendId"] as! String
        }
        if dict.keys.contains("BackendModelData") {
            self.backendModelData = dict["BackendModelData"] as! String
        }
        if dict.keys.contains("BackendModelId") {
            self.backendModelId = dict["BackendModelId"] as! String
        }
        if dict.keys.contains("BackendType") {
            self.backendType = dict["BackendType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class ModifyBackendModelResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBackendModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBackendModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyBackendModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDatasetRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetName != nil {
            map["DatasetName"] = self.datasetName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetName") {
            self.datasetName = dict["DatasetName"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyDatasetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDatasetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDatasetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDatasetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDatasetItemRequest : Tea.TeaModel {
    public var datasetId: String?

    public var datasetItemId: String?

    public var description_: String?

    public var expiredTime: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.datasetId != nil {
            map["DatasetId"] = self.datasetId!
        }
        if self.datasetItemId != nil {
            map["DatasetItemId"] = self.datasetItemId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DatasetId") {
            self.datasetId = dict["DatasetId"] as! String
        }
        if dict.keys.contains("DatasetItemId") {
            self.datasetItemId = dict["DatasetItemId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyDatasetItemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDatasetItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDatasetItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDatasetItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceSpecRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var instanceId: String?

    public var instanceSpec: String?

    public var modifyAction: String?

    public var skipWaitSwitch: Bool?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceSpec != nil {
            map["InstanceSpec"] = self.instanceSpec!
        }
        if self.modifyAction != nil {
            map["ModifyAction"] = self.modifyAction!
        }
        if self.skipWaitSwitch != nil {
            map["SkipWaitSwitch"] = self.skipWaitSwitch!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceSpec") {
            self.instanceSpec = dict["InstanceSpec"] as! String
        }
        if dict.keys.contains("ModifyAction") {
            self.modifyAction = dict["ModifyAction"] as! String
        }
        if dict.keys.contains("SkipWaitSwitch") {
            self.skipWaitSwitch = dict["SkipWaitSwitch"] as! Bool
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class ModifyInstanceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIpControlRequest : Tea.TeaModel {
    public var description_: String?

    public var ipControlId: String?

    public var ipControlName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.ipControlName != nil {
            map["IpControlName"] = self.ipControlName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("IpControlName") {
            self.ipControlName = dict["IpControlName"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyIpControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIpControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIpControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyIpControlPolicyItemRequest : Tea.TeaModel {
    public var appId: String?

    public var cidrIp: String?

    public var ipControlId: String?

    public var policyItemId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cidrIp != nil {
            map["CidrIp"] = self.cidrIp!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.policyItemId != nil {
            map["PolicyItemId"] = self.policyItemId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CidrIp") {
            self.cidrIp = dict["CidrIp"] as! String
        }
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("PolicyItemId") {
            self.policyItemId = dict["PolicyItemId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ModifyIpControlPolicyItemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyIpControlPolicyItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyIpControlPolicyItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyIpControlPolicyItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLogConfigRequest : Tea.TeaModel {
    public var logType: String?

    public var securityToken: String?

    public var slsLogStore: String?

    public var slsProject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logType != nil {
            map["LogType"] = self.logType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.slsLogStore != nil {
            map["SlsLogStore"] = self.slsLogStore!
        }
        if self.slsProject != nil {
            map["SlsProject"] = self.slsProject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogType") {
            self.logType = dict["LogType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SlsLogStore") {
            self.slsLogStore = dict["SlsLogStore"] as! String
        }
        if dict.keys.contains("SlsProject") {
            self.slsProject = dict["SlsProject"] as! String
        }
    }
}

public class ModifyLogConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyModelRequest : Tea.TeaModel {
    public var description_: String?

    public var groupId: String?

    public var modelName: String?

    public var newModelName: String?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.modelName != nil {
            map["ModelName"] = self.modelName!
        }
        if self.newModelName != nil {
            map["NewModelName"] = self.newModelName!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("ModelName") {
            self.modelName = dict["ModelName"] as! String
        }
        if dict.keys.contains("NewModelName") {
            self.newModelName = dict["NewModelName"] as! String
        }
        if dict.keys.contains("Schema") {
            self.schema = dict["Schema"] as! String
        }
    }
}

public class ModifyModelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyModelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyModelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyModelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPluginRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var description_: String?

    public var pluginData: String?

    public var pluginId: String?

    public var pluginName: String?

    public var securityToken: String?

    public var tag: [ModifyPluginRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.pluginData != nil {
            map["PluginData"] = self.pluginData!
        }
        if self.pluginId != nil {
            map["PluginId"] = self.pluginId!
        }
        if self.pluginName != nil {
            map["PluginName"] = self.pluginName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("PluginData") {
            self.pluginData = dict["PluginData"] as! String
        }
        if dict.keys.contains("PluginId") {
            self.pluginId = dict["PluginId"] as! String
        }
        if dict.keys.contains("PluginName") {
            self.pluginName = dict["PluginName"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ModifyPluginRequest.Tag]
        }
    }
}

public class ModifyPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySignatureRequest : Tea.TeaModel {
    public var securityToken: String?

    public var signatureId: String?

    public var signatureKey: String?

    public var signatureName: String?

    public var signatureSecret: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.signatureKey != nil {
            map["SignatureKey"] = self.signatureKey!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        if self.signatureSecret != nil {
            map["SignatureSecret"] = self.signatureSecret!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("SignatureKey") {
            self.signatureKey = dict["SignatureKey"] as! String
        }
        if dict.keys.contains("SignatureName") {
            self.signatureName = dict["SignatureName"] as! String
        }
        if dict.keys.contains("SignatureSecret") {
            self.signatureSecret = dict["SignatureSecret"] as! String
        }
    }
}

public class ModifySignatureResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var signatureId: String?

    public var signatureName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.signatureName != nil {
            map["SignatureName"] = self.signatureName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SignatureId") {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("SignatureName") {
            self.signatureName = dict["SignatureName"] as! String
        }
    }
}

public class ModifySignatureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySignatureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySignatureResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTrafficControlRequest : Tea.TeaModel {
    public var apiDefault: Int32?

    public var appDefault: Int32?

    public var description_: String?

    public var securityToken: String?

    public var trafficControlId: String?

    public var trafficControlName: String?

    public var trafficControlUnit: String?

    public var userDefault: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiDefault != nil {
            map["ApiDefault"] = self.apiDefault!
        }
        if self.appDefault != nil {
            map["AppDefault"] = self.appDefault!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        if self.trafficControlName != nil {
            map["TrafficControlName"] = self.trafficControlName!
        }
        if self.trafficControlUnit != nil {
            map["TrafficControlUnit"] = self.trafficControlUnit!
        }
        if self.userDefault != nil {
            map["UserDefault"] = self.userDefault!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiDefault") {
            self.apiDefault = dict["ApiDefault"] as! Int32
        }
        if dict.keys.contains("AppDefault") {
            self.appDefault = dict["AppDefault"] as! Int32
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
        if dict.keys.contains("TrafficControlName") {
            self.trafficControlName = dict["TrafficControlName"] as! String
        }
        if dict.keys.contains("TrafficControlUnit") {
            self.trafficControlUnit = dict["TrafficControlUnit"] as! String
        }
        if dict.keys.contains("UserDefault") {
            self.userDefault = dict["UserDefault"] as! Int32
        }
    }
}

public class ModifyTrafficControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyTrafficControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTrafficControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTrafficControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpcAccessAndUpdateApisRequest : Tea.TeaModel {
    public var instanceId: String?

    public var name: String?

    public var needBatchWork: Bool?

    public var port: Int32?

    public var refresh: Bool?

    public var securityToken: String?

    public var token: String?

    public var vpcId: String?

    public var vpcTargetHostName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.needBatchWork != nil {
            map["NeedBatchWork"] = self.needBatchWork!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.refresh != nil {
            map["Refresh"] = self.refresh!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcTargetHostName != nil {
            map["VpcTargetHostName"] = self.vpcTargetHostName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NeedBatchWork") {
            self.needBatchWork = dict["NeedBatchWork"] as! Bool
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("Refresh") {
            self.refresh = dict["Refresh"] as! Bool
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcTargetHostName") {
            self.vpcTargetHostName = dict["VpcTargetHostName"] as! String
        }
    }
}

public class ModifyVpcAccessAndUpdateApisResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpcAccessAndUpdateApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpcAccessAndUpdateApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpcAccessAndUpdateApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenApiGatewayServiceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenApiGatewayServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenApiGatewayServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenApiGatewayServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryRequestLogsRequest : Tea.TeaModel {
    public var requestLogId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestLogId != nil {
            map["RequestLogId"] = self.requestLogId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestLogId") {
            self.requestLogId = dict["RequestLogId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class QueryRequestLogsResponseBody : Tea.TeaModel {
    public class RequestLogs : Tea.TeaModel {
        public class RequestLog : Tea.TeaModel {
            public var apiId: String?

            public var apiName: String?

            public var clientIp: String?

            public var clientNonce: String?

            public var consumerAppId: String?

            public var consumerAppKey: String?

            public var customTraceId: String?

            public var domain: String?

            public var errorCode: String?

            public var errorMessage: String?

            public var exception: String?

            public var groupId: String?

            public var groupName: String?

            public var httpMethod: String?

            public var httpPath: String?

            public var initialRequestId: String?

            public var instanceId: String?

            public var jwtClaims: String?

            public var region: String?

            public var requestBody: String?

            public var requestHeaders: String?

            public var requestId: String?

            public var requestProtocol: String?

            public var requestQueryString: String?

            public var requestSize: String?

            public var requestTime: String?

            public var responseBody: String?

            public var responseHeaders: String?

            public var responseSize: String?

            public var serviceLatency: String?

            public var stageId: String?

            public var stageName: String?

            public var statusCode: String?

            public var totalLatency: String?

            public var plugin: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.apiName != nil {
                    map["ApiName"] = self.apiName!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.clientNonce != nil {
                    map["ClientNonce"] = self.clientNonce!
                }
                if self.consumerAppId != nil {
                    map["ConsumerAppId"] = self.consumerAppId!
                }
                if self.consumerAppKey != nil {
                    map["ConsumerAppKey"] = self.consumerAppKey!
                }
                if self.customTraceId != nil {
                    map["CustomTraceId"] = self.customTraceId!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.exception != nil {
                    map["Exception"] = self.exception!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.httpMethod != nil {
                    map["HttpMethod"] = self.httpMethod!
                }
                if self.httpPath != nil {
                    map["HttpPath"] = self.httpPath!
                }
                if self.initialRequestId != nil {
                    map["InitialRequestId"] = self.initialRequestId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jwtClaims != nil {
                    map["JwtClaims"] = self.jwtClaims!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.requestBody != nil {
                    map["RequestBody"] = self.requestBody!
                }
                if self.requestHeaders != nil {
                    map["RequestHeaders"] = self.requestHeaders!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                if self.requestProtocol != nil {
                    map["RequestProtocol"] = self.requestProtocol!
                }
                if self.requestQueryString != nil {
                    map["RequestQueryString"] = self.requestQueryString!
                }
                if self.requestSize != nil {
                    map["RequestSize"] = self.requestSize!
                }
                if self.requestTime != nil {
                    map["RequestTime"] = self.requestTime!
                }
                if self.responseBody != nil {
                    map["ResponseBody"] = self.responseBody!
                }
                if self.responseHeaders != nil {
                    map["ResponseHeaders"] = self.responseHeaders!
                }
                if self.responseSize != nil {
                    map["ResponseSize"] = self.responseSize!
                }
                if self.serviceLatency != nil {
                    map["ServiceLatency"] = self.serviceLatency!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.statusCode != nil {
                    map["StatusCode"] = self.statusCode!
                }
                if self.totalLatency != nil {
                    map["TotalLatency"] = self.totalLatency!
                }
                if self.plugin != nil {
                    map["plugin"] = self.plugin!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("ApiName") {
                    self.apiName = dict["ApiName"] as! String
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("ClientNonce") {
                    self.clientNonce = dict["ClientNonce"] as! String
                }
                if dict.keys.contains("ConsumerAppId") {
                    self.consumerAppId = dict["ConsumerAppId"] as! String
                }
                if dict.keys.contains("ConsumerAppKey") {
                    self.consumerAppKey = dict["ConsumerAppKey"] as! String
                }
                if dict.keys.contains("CustomTraceId") {
                    self.customTraceId = dict["CustomTraceId"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("Exception") {
                    self.exception = dict["Exception"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("GroupName") {
                    self.groupName = dict["GroupName"] as! String
                }
                if dict.keys.contains("HttpMethod") {
                    self.httpMethod = dict["HttpMethod"] as! String
                }
                if dict.keys.contains("HttpPath") {
                    self.httpPath = dict["HttpPath"] as! String
                }
                if dict.keys.contains("InitialRequestId") {
                    self.initialRequestId = dict["InitialRequestId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JwtClaims") {
                    self.jwtClaims = dict["JwtClaims"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("RequestBody") {
                    self.requestBody = dict["RequestBody"] as! String
                }
                if dict.keys.contains("RequestHeaders") {
                    self.requestHeaders = dict["RequestHeaders"] as! String
                }
                if dict.keys.contains("RequestId") {
                    self.requestId = dict["RequestId"] as! String
                }
                if dict.keys.contains("RequestProtocol") {
                    self.requestProtocol = dict["RequestProtocol"] as! String
                }
                if dict.keys.contains("RequestQueryString") {
                    self.requestQueryString = dict["RequestQueryString"] as! String
                }
                if dict.keys.contains("RequestSize") {
                    self.requestSize = dict["RequestSize"] as! String
                }
                if dict.keys.contains("RequestTime") {
                    self.requestTime = dict["RequestTime"] as! String
                }
                if dict.keys.contains("ResponseBody") {
                    self.responseBody = dict["ResponseBody"] as! String
                }
                if dict.keys.contains("ResponseHeaders") {
                    self.responseHeaders = dict["ResponseHeaders"] as! String
                }
                if dict.keys.contains("ResponseSize") {
                    self.responseSize = dict["ResponseSize"] as! String
                }
                if dict.keys.contains("ServiceLatency") {
                    self.serviceLatency = dict["ServiceLatency"] as! String
                }
                if dict.keys.contains("StageId") {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("StatusCode") {
                    self.statusCode = dict["StatusCode"] as! String
                }
                if dict.keys.contains("TotalLatency") {
                    self.totalLatency = dict["TotalLatency"] as! String
                }
                if dict.keys.contains("plugin") {
                    self.plugin = dict["plugin"] as! String
                }
            }
        }
        public var requestLog: [QueryRequestLogsResponseBody.RequestLogs.RequestLog]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.requestLog != nil {
                var tmp : [Any] = []
                for k in self.requestLog! {
                    tmp.append(k.toMap())
                }
                map["RequestLog"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RequestLog") {
                self.requestLog = dict["RequestLog"] as! [QueryRequestLogsResponseBody.RequestLogs.RequestLog]
            }
        }
    }
    public var requestId: String?

    public var requestLogs: QueryRequestLogsResponseBody.RequestLogs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.requestLogs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestLogs != nil {
            map["RequestLogs"] = self.requestLogs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestLogs") {
            var model = QueryRequestLogsResponseBody.RequestLogs()
            model.fromMap(dict["RequestLogs"] as! [String: Any])
            self.requestLogs = model
        }
    }
}

public class QueryRequestLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRequestLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryRequestLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReactivateDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ReactivateDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReactivateDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReactivateDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReactivateDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAccessControlListEntryRequest : Tea.TeaModel {
    public var aclEntrys: String?

    public var aclId: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntrys != nil {
            map["AclEntrys"] = self.aclEntrys!
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntrys") {
            self.aclEntrys = dict["AclEntrys"] as! String
        }
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class RemoveAccessControlListEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveAccessControlListEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAccessControlListEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveAccessControlListEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveApisAuthoritiesRequest : Tea.TeaModel {
    public var apiIds: String?

    public var appId: Int64?

    public var description_: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class RemoveApisAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveApisAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveApisAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveApisAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveAppsAuthoritiesRequest : Tea.TeaModel {
    public var apiId: String?

    public var appIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class RemoveAppsAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveAppsAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveAppsAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveAppsAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveIpControlApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var ipControlId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class RemoveIpControlApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveIpControlApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveIpControlApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveIpControlApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveIpControlPolicyItemRequest : Tea.TeaModel {
    public var ipControlId: String?

    public var policyItemIds: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.policyItemIds != nil {
            map["PolicyItemIds"] = self.policyItemIds!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("PolicyItemIds") {
            self.policyItemIds = dict["PolicyItemIds"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class RemoveIpControlPolicyItemResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveIpControlPolicyItemResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveIpControlPolicyItemResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveIpControlPolicyItemResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveSignatureApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var signatureId: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class RemoveSignatureApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveSignatureApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSignatureApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveSignatureApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveTrafficControlApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class RemoveTrafficControlApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveTrafficControlApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTrafficControlApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveTrafficControlApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveVpcAccessRequest : Tea.TeaModel {
    public var instanceId: String?

    public var needBatchWork: Bool?

    public var port: Int32?

    public var securityToken: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.needBatchWork != nil {
            map["NeedBatchWork"] = self.needBatchWork!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NeedBatchWork") {
            self.needBatchWork = dict["NeedBatchWork"] as! Bool
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class RemoveVpcAccessResponseBody : Tea.TeaModel {
    public class Apis : Tea.TeaModel {
        public class Api : Tea.TeaModel {
            public var apiId: String?

            public var groupId: String?

            public var stageId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.apiId != nil {
                    map["ApiId"] = self.apiId!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApiId") {
                    self.apiId = dict["ApiId"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("StageId") {
                    self.stageId = dict["StageId"] as! String
                }
            }
        }
        public var api: [RemoveVpcAccessResponseBody.Apis.Api]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.api != nil {
                var tmp : [Any] = []
                for k in self.api! {
                    tmp.append(k.toMap())
                }
                map["Api"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Api") {
                self.api = dict["Api"] as! [RemoveVpcAccessResponseBody.Apis.Api]
            }
        }
    }
    public var apis: RemoveVpcAccessResponseBody.Apis?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apis?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apis != nil {
            map["Apis"] = self.apis?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Apis") {
            var model = RemoveVpcAccessResponseBody.Apis()
            model.fromMap(dict["Apis"] as! [String: Any])
            self.apis = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveVpcAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveVpcAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveVpcAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveVpcAccessAndAbolishApisRequest : Tea.TeaModel {
    public var instanceId: String?

    public var needBatchWork: Bool?

    public var port: Int32?

    public var securityToken: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.needBatchWork != nil {
            map["NeedBatchWork"] = self.needBatchWork!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NeedBatchWork") {
            self.needBatchWork = dict["NeedBatchWork"] as! Bool
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class RemoveVpcAccessAndAbolishApisResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveVpcAccessAndAbolishApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveVpcAccessAndAbolishApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveVpcAccessAndAbolishApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAppCodeRequest : Tea.TeaModel {
    public var appCode: String?

    public var newAppCode: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCode != nil {
            map["AppCode"] = self.appCode!
        }
        if self.newAppCode != nil {
            map["NewAppCode"] = self.newAppCode!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppCode") {
            self.appCode = dict["AppCode"] as! String
        }
        if dict.keys.contains("NewAppCode") {
            self.newAppCode = dict["NewAppCode"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ResetAppCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetAppCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAppCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetAppCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAppSecretRequest : Tea.TeaModel {
    public var appKey: String?

    public var newAppSecret: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.newAppSecret != nil {
            map["NewAppSecret"] = self.newAppSecret!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppKey") {
            self.appKey = dict["AppKey"] as! String
        }
        if dict.keys.contains("NewAppSecret") {
            self.newAppSecret = dict["NewAppSecret"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class ResetAppSecretResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetAppSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAppSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetAppSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SdkGenerateByAppRequest : Tea.TeaModel {
    public var appId: Int64?

    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SdkGenerateByAppResponseBody : Tea.TeaModel {
    public var downloadLink: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadLink != nil {
            map["DownloadLink"] = self.downloadLink!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadLink") {
            self.downloadLink = dict["DownloadLink"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SdkGenerateByAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SdkGenerateByAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SdkGenerateByAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SdkGenerateByAppForRegionRequest : Tea.TeaModel {
    public var appId: Int64?

    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SdkGenerateByAppForRegionResponseBody : Tea.TeaModel {
    public var downloadLink: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadLink != nil {
            map["DownloadLink"] = self.downloadLink!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadLink") {
            self.downloadLink = dict["DownloadLink"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SdkGenerateByAppForRegionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SdkGenerateByAppForRegionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SdkGenerateByAppForRegionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SdkGenerateByGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var language: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("Language") {
            self.language = dict["Language"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SdkGenerateByGroupResponseBody : Tea.TeaModel {
    public var downloadLink: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadLink != nil {
            map["DownloadLink"] = self.downloadLink!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DownloadLink") {
            self.downloadLink = dict["DownloadLink"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SdkGenerateByGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SdkGenerateByGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SdkGenerateByGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetAccessControlListAttributeRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclName: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclName") {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SetAccessControlListAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetAccessControlListAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetAccessControlListAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetAccessControlListAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetApisAuthoritiesRequest : Tea.TeaModel {
    public var apiIds: String?

    public var appId: Int64?

    public var authValidTime: String?

    public var description_: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.authValidTime != nil {
            map["AuthValidTime"] = self.authValidTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! Int64
        }
        if dict.keys.contains("AuthValidTime") {
            self.authValidTime = dict["AuthValidTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SetApisAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetApisAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetApisAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetApisAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetAppsAuthoritiesRequest : Tea.TeaModel {
    public var apiId: String?

    public var appIds: String?

    public var authValidTime: String?

    public var description_: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.authValidTime != nil {
            map["AuthValidTime"] = self.authValidTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("AuthValidTime") {
            self.authValidTime = dict["AuthValidTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SetAppsAuthoritiesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetAppsAuthoritiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetAppsAuthoritiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetAppsAuthoritiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainRequest : Tea.TeaModel {
    public var bindStageName: String?

    public var customDomainType: String?

    public var domainName: String?

    public var groupId: String?

    public var isForce: Bool?

    public var isHttpRedirectToHttps: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bindStageName != nil {
            map["BindStageName"] = self.bindStageName!
        }
        if self.customDomainType != nil {
            map["CustomDomainType"] = self.customDomainType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isForce != nil {
            map["IsForce"] = self.isForce!
        }
        if self.isHttpRedirectToHttps != nil {
            map["IsHttpRedirectToHttps"] = self.isHttpRedirectToHttps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BindStageName") {
            self.bindStageName = dict["BindStageName"] as! String
        }
        if dict.keys.contains("CustomDomainType") {
            self.customDomainType = dict["CustomDomainType"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IsForce") {
            self.isForce = dict["IsForce"] as! Bool
        }
        if dict.keys.contains("IsHttpRedirectToHttps") {
            self.isHttpRedirectToHttps = dict["IsHttpRedirectToHttps"] as! Bool
        }
    }
}

public class SetDomainResponseBody : Tea.TeaModel {
    public var domainBindingStatus: String?

    public var domainLegalStatus: String?

    public var domainName: String?

    public var domainRemark: String?

    public var domainWebSocketStatus: String?

    public var groupId: String?

    public var requestId: String?

    public var subDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainBindingStatus != nil {
            map["DomainBindingStatus"] = self.domainBindingStatus!
        }
        if self.domainLegalStatus != nil {
            map["DomainLegalStatus"] = self.domainLegalStatus!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainRemark != nil {
            map["DomainRemark"] = self.domainRemark!
        }
        if self.domainWebSocketStatus != nil {
            map["DomainWebSocketStatus"] = self.domainWebSocketStatus!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subDomain != nil {
            map["SubDomain"] = self.subDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainBindingStatus") {
            self.domainBindingStatus = dict["DomainBindingStatus"] as! String
        }
        if dict.keys.contains("DomainLegalStatus") {
            self.domainLegalStatus = dict["DomainLegalStatus"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainRemark") {
            self.domainRemark = dict["DomainRemark"] as! String
        }
        if dict.keys.contains("DomainWebSocketStatus") {
            self.domainWebSocketStatus = dict["DomainWebSocketStatus"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SubDomain") {
            self.subDomain = dict["SubDomain"] as! String
        }
    }
}

public class SetDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainCertificateRequest : Tea.TeaModel {
    public var caCertificateBody: String?

    public var certificateBody: String?

    public var certificateName: String?

    public var certificatePrivateKey: String?

    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public var sslVerifyDepth: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.caCertificateBody != nil {
            map["CaCertificateBody"] = self.caCertificateBody!
        }
        if self.certificateBody != nil {
            map["CertificateBody"] = self.certificateBody!
        }
        if self.certificateName != nil {
            map["CertificateName"] = self.certificateName!
        }
        if self.certificatePrivateKey != nil {
            map["CertificatePrivateKey"] = self.certificatePrivateKey!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sslVerifyDepth != nil {
            map["SslVerifyDepth"] = self.sslVerifyDepth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CaCertificateBody") {
            self.caCertificateBody = dict["CaCertificateBody"] as! String
        }
        if dict.keys.contains("CertificateBody") {
            self.certificateBody = dict["CertificateBody"] as! String
        }
        if dict.keys.contains("CertificateName") {
            self.certificateName = dict["CertificateName"] as! String
        }
        if dict.keys.contains("CertificatePrivateKey") {
            self.certificatePrivateKey = dict["CertificatePrivateKey"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SslVerifyDepth") {
            self.sslVerifyDepth = dict["SslVerifyDepth"] as! String
        }
    }
}

public class SetDomainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDomainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDomainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetDomainWebSocketStatusRequest : Tea.TeaModel {
    public var actionValue: String?

    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public var WSSEnable: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionValue != nil {
            map["ActionValue"] = self.actionValue!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.WSSEnable != nil {
            map["WSSEnable"] = self.WSSEnable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionValue") {
            self.actionValue = dict["ActionValue"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("WSSEnable") {
            self.WSSEnable = dict["WSSEnable"] as! String
        }
    }
}

public class SetDomainWebSocketStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetDomainWebSocketStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDomainWebSocketStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetDomainWebSocketStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetIpControlApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var ipControlId: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.ipControlId != nil {
            map["IpControlId"] = self.ipControlId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IpControlId") {
            self.ipControlId = dict["IpControlId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SetIpControlApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetIpControlApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetIpControlApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetIpControlApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetSignatureApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var signatureId: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.signatureId != nil {
            map["SignatureId"] = self.signatureId!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SignatureId") {
            self.signatureId = dict["SignatureId"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SetSignatureApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetSignatureApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetSignatureApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetSignatureApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetTrafficControlApisRequest : Tea.TeaModel {
    public var apiIds: String?

    public var groupId: String?

    public var securityToken: String?

    public var stageName: String?

    public var trafficControlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiIds != nil {
            map["ApiIds"] = self.apiIds!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        if self.trafficControlId != nil {
            map["TrafficControlId"] = self.trafficControlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiIds") {
            self.apiIds = dict["ApiIds"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
        if dict.keys.contains("TrafficControlId") {
            self.trafficControlId = dict["TrafficControlId"] as! String
        }
    }
}

public class SetTrafficControlApisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetTrafficControlApisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetTrafficControlApisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetTrafficControlApisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetVpcAccessRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var name: String?

    public var port: Int32?

    public var securityToken: String?

    public var vpcId: String?

    public var vpcTargetHostName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcTargetHostName != nil {
            map["VpcTargetHostName"] = self.vpcTargetHostName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcTargetHostName") {
            self.vpcTargetHostName = dict["VpcTargetHostName"] as! String
        }
    }
}

public class SetVpcAccessResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetVpcAccessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetVpcAccessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetVpcAccessResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetWildcardDomainPatternsRequest : Tea.TeaModel {
    public var domainName: String?

    public var groupId: String?

    public var securityToken: String?

    public var wildcardDomainPatterns: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.wildcardDomainPatterns != nil {
            map["WildcardDomainPatterns"] = self.wildcardDomainPatterns!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("WildcardDomainPatterns") {
            self.wildcardDomainPatterns = dict["WildcardDomainPatterns"] as! String
        }
    }
}

public class SetWildcardDomainPatternsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetWildcardDomainPatternsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetWildcardDomainPatternsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetWildcardDomainPatternsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchApiRequest : Tea.TeaModel {
    public var apiId: String?

    public var description_: String?

    public var groupId: String?

    public var historyVersion: String?

    public var securityToken: String?

    public var stageName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apiId != nil {
            map["ApiId"] = self.apiId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.historyVersion != nil {
            map["HistoryVersion"] = self.historyVersion!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.stageName != nil {
            map["StageName"] = self.stageName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApiId") {
            self.apiId = dict["ApiId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HistoryVersion") {
            self.historyVersion = dict["HistoryVersion"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StageName") {
            self.stageName = dict["StageName"] as! String
        }
    }
}

public class SwitchApiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SwitchApiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchApiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchApiResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var resourceId: [String]?

    public var resourceType: String?

    public var securityToken: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [TagResourcesRequest.Tag]
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var resourceId: [String]?

    public var resourceType: String?

    public var securityToken: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
