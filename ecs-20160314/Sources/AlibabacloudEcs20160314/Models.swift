import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddMigratableInstancesRequest : Tea.TeaModel {
    public var businessMigrationType: Int32?

    public var instanceId: [String]?

    public var networkMigrationType: Int32?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessMigrationType != nil {
            map["BusinessMigrationType"] = self.businessMigrationType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkMigrationType != nil {
            map["NetworkMigrationType"] = self.networkMigrationType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessMigrationType") {
            self.businessMigrationType = dict["BusinessMigrationType"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("NetworkMigrationType") {
            self.networkMigrationType = dict["NetworkMigrationType"] as! Int32
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class AddMigratableInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMigratableInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMigratableInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMigratableInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocateDedicatedHostsRequest : Tea.TeaModel {
    public class NetworkAttributes : Tea.TeaModel {
        public var slbUdpTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbUdpTimeout != nil {
                map["SlbUdpTimeout"] = self.slbUdpTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbUdpTimeout") {
                self.slbUdpTimeout = dict["SlbUdpTimeout"] as! Int32
            }
            if dict.keys.contains("UdpTimeout") {
                self.udpTimeout = dict["UdpTimeout"] as! Int32
            }
        }
    }
    public class SchedulerOptions : Tea.TeaModel {
        public var managedPrivateSpaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.managedPrivateSpaceId != nil {
                map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ManagedPrivateSpaceId") {
                self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var networkAttributes: AllocateDedicatedHostsRequest.NetworkAttributes?

    public var schedulerOptions: AllocateDedicatedHostsRequest.SchedulerOptions?

    public var actionOnMaintenance: String?

    public var autoPlacement: String?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var businessInfo: String?

    public var chargeType: String?

    public var clientToken: String?

    public var cpuOverCommitRatio: Double?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostName: String?

    public var dedicatedHostType: String?

    public var description_: String?

    public var fromApp: String?

    public var minQuantity: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var quantity: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [AllocateDedicatedHostsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAttributes?.validate()
        try self.schedulerOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAttributes != nil {
            map["NetworkAttributes"] = self.networkAttributes?.toMap()
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.actionOnMaintenance != nil {
            map["ActionOnMaintenance"] = self.actionOnMaintenance!
        }
        if self.autoPlacement != nil {
            map["AutoPlacement"] = self.autoPlacement!
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.cpuOverCommitRatio != nil {
            map["CpuOverCommitRatio"] = self.cpuOverCommitRatio!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostName != nil {
            map["DedicatedHostName"] = self.dedicatedHostName!
        }
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.minQuantity != nil {
            map["MinQuantity"] = self.minQuantity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAttributes") {
            var model = AllocateDedicatedHostsRequest.NetworkAttributes()
            model.fromMap(dict["NetworkAttributes"] as! [String: Any])
            self.networkAttributes = model
        }
        if dict.keys.contains("SchedulerOptions") {
            var model = AllocateDedicatedHostsRequest.SchedulerOptions()
            model.fromMap(dict["SchedulerOptions"] as! [String: Any])
            self.schedulerOptions = model
        }
        if dict.keys.contains("ActionOnMaintenance") {
            self.actionOnMaintenance = dict["ActionOnMaintenance"] as! String
        }
        if dict.keys.contains("AutoPlacement") {
            self.autoPlacement = dict["AutoPlacement"] as! String
        }
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("BusinessInfo") {
            self.businessInfo = dict["BusinessInfo"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CpuOverCommitRatio") {
            self.cpuOverCommitRatio = dict["CpuOverCommitRatio"] as! Double
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostName") {
            self.dedicatedHostName = dict["DedicatedHostName"] as! String
        }
        if dict.keys.contains("DedicatedHostType") {
            self.dedicatedHostType = dict["DedicatedHostType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FromApp") {
            self.fromApp = dict["FromApp"] as! String
        }
        if dict.keys.contains("MinQuantity") {
            self.minQuantity = dict["MinQuantity"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Quantity") {
            self.quantity = dict["Quantity"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [AllocateDedicatedHostsRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class AllocateDedicatedHostsResponseBody : Tea.TeaModel {
    public class DedicatedHostIdSets : Tea.TeaModel {
        public var dedicatedHostId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostId") {
                self.dedicatedHostId = dict["DedicatedHostId"] as! [String]
            }
        }
    }
    public var dedicatedHostIdSets: AllocateDedicatedHostsResponseBody.DedicatedHostIdSets?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostIdSets != nil {
            map["DedicatedHostIdSets"] = self.dedicatedHostIdSets?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostIdSets") {
            var model = AllocateDedicatedHostsResponseBody.DedicatedHostIdSets()
            model.fromMap(dict["DedicatedHostIdSets"] as! [String: Any])
            self.dedicatedHostIdSets = model
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AllocateDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocateDedicatedHostsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelMigrationInstancesRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var networkMigrationType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkMigrationType != nil {
            map["NetworkMigrationType"] = self.networkMigrationType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("NetworkMigrationType") {
            self.networkMigrationType = dict["NetworkMigrationType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelMigrationInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelMigrationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelMigrationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelMigrationInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelMigrationPlanRequest : Tea.TeaModel {
    public var migrationPlanId: String?

    public var onlyCancelPlan: Bool?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationPlanId != nil {
            map["MigrationPlanId"] = self.migrationPlanId!
        }
        if self.onlyCancelPlan != nil {
            map["OnlyCancelPlan"] = self.onlyCancelPlan!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationPlanId") {
            self.migrationPlanId = dict["MigrationPlanId"] as! String
        }
        if dict.keys.contains("OnlyCancelPlan") {
            self.onlyCancelPlan = dict["OnlyCancelPlan"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelMigrationPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelMigrationPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelMigrationPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelMigrationPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigureSecurityGroupPermissionsRequest : Tea.TeaModel {
    public class AuthorizePermission : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var destGroupId: String?

        public var destPrefixListId: String?

        public var direction: String?

        public var gressFlow: String?

        public var groupOwnerAccount: String?

        public var groupOwnerId: Int64?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourceGroupId: String?

        public var sourcePortRange: String?

        public var sourcePrefixListId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.destGroupId != nil {
                map["DestGroupId"] = self.destGroupId!
            }
            if self.destPrefixListId != nil {
                map["DestPrefixListId"] = self.destPrefixListId!
            }
            if self.direction != nil {
                map["Direction"] = self.direction!
            }
            if self.gressFlow != nil {
                map["GressFlow"] = self.gressFlow!
            }
            if self.groupOwnerAccount != nil {
                map["GroupOwnerAccount"] = self.groupOwnerAccount!
            }
            if self.groupOwnerId != nil {
                map["GroupOwnerId"] = self.groupOwnerId!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourceGroupId != nil {
                map["SourceGroupId"] = self.sourceGroupId!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            if self.sourcePrefixListId != nil {
                map["SourcePrefixListId"] = self.sourcePrefixListId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestCidrIp") {
                self.destCidrIp = dict["DestCidrIp"] as! String
            }
            if dict.keys.contains("DestGroupId") {
                self.destGroupId = dict["DestGroupId"] as! String
            }
            if dict.keys.contains("DestPrefixListId") {
                self.destPrefixListId = dict["DestPrefixListId"] as! String
            }
            if dict.keys.contains("Direction") {
                self.direction = dict["Direction"] as! String
            }
            if dict.keys.contains("GressFlow") {
                self.gressFlow = dict["GressFlow"] as! String
            }
            if dict.keys.contains("GroupOwnerAccount") {
                self.groupOwnerAccount = dict["GroupOwnerAccount"] as! String
            }
            if dict.keys.contains("GroupOwnerId") {
                self.groupOwnerId = dict["GroupOwnerId"] as! Int64
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Ipv6DestCidrIp") {
                self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
            }
            if dict.keys.contains("Ipv6SourceCidrIp") {
                self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
            }
            if dict.keys.contains("NicType") {
                self.nicType = dict["NicType"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("SourceCidrIp") {
                self.sourceCidrIp = dict["SourceCidrIp"] as! String
            }
            if dict.keys.contains("SourceGroupId") {
                self.sourceGroupId = dict["SourceGroupId"] as! String
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
            if dict.keys.contains("SourcePrefixListId") {
                self.sourcePrefixListId = dict["SourcePrefixListId"] as! String
            }
        }
    }
    public class RevokePermission : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var destGroupId: String?

        public var destPrefixListId: String?

        public var direction: String?

        public var gressFlow: String?

        public var groupOwnerAccount: String?

        public var groupOwnerId: Int64?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourceGroupId: String?

        public var sourcePortRange: String?

        public var sourcePrefixListId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.destGroupId != nil {
                map["DestGroupId"] = self.destGroupId!
            }
            if self.destPrefixListId != nil {
                map["DestPrefixListId"] = self.destPrefixListId!
            }
            if self.direction != nil {
                map["Direction"] = self.direction!
            }
            if self.gressFlow != nil {
                map["GressFlow"] = self.gressFlow!
            }
            if self.groupOwnerAccount != nil {
                map["GroupOwnerAccount"] = self.groupOwnerAccount!
            }
            if self.groupOwnerId != nil {
                map["GroupOwnerId"] = self.groupOwnerId!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourceGroupId != nil {
                map["SourceGroupId"] = self.sourceGroupId!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            if self.sourcePrefixListId != nil {
                map["SourcePrefixListId"] = self.sourcePrefixListId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestCidrIp") {
                self.destCidrIp = dict["DestCidrIp"] as! String
            }
            if dict.keys.contains("DestGroupId") {
                self.destGroupId = dict["DestGroupId"] as! String
            }
            if dict.keys.contains("DestPrefixListId") {
                self.destPrefixListId = dict["DestPrefixListId"] as! String
            }
            if dict.keys.contains("Direction") {
                self.direction = dict["Direction"] as! String
            }
            if dict.keys.contains("GressFlow") {
                self.gressFlow = dict["GressFlow"] as! String
            }
            if dict.keys.contains("GroupOwnerAccount") {
                self.groupOwnerAccount = dict["GroupOwnerAccount"] as! String
            }
            if dict.keys.contains("GroupOwnerId") {
                self.groupOwnerId = dict["GroupOwnerId"] as! Int64
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Ipv6DestCidrIp") {
                self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
            }
            if dict.keys.contains("Ipv6SourceCidrIp") {
                self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
            }
            if dict.keys.contains("NicType") {
                self.nicType = dict["NicType"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("SourceCidrIp") {
                self.sourceCidrIp = dict["SourceCidrIp"] as! String
            }
            if dict.keys.contains("SourceGroupId") {
                self.sourceGroupId = dict["SourceGroupId"] as! String
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
            if dict.keys.contains("SourcePrefixListId") {
                self.sourcePrefixListId = dict["SourcePrefixListId"] as! String
            }
        }
    }
    public var authorizePermission: [ConfigureSecurityGroupPermissionsRequest.AuthorizePermission]?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var revokePermission: [ConfigureSecurityGroupPermissionsRequest.RevokePermission]?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizePermission != nil {
            var tmp : [Any] = []
            for k in self.authorizePermission! {
                tmp.append(k.toMap())
            }
            map["AuthorizePermission"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.revokePermission != nil {
            var tmp : [Any] = []
            for k in self.revokePermission! {
                tmp.append(k.toMap())
            }
            map["RevokePermission"] = tmp
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizePermission") {
            self.authorizePermission = dict["AuthorizePermission"] as! [ConfigureSecurityGroupPermissionsRequest.AuthorizePermission]
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RevokePermission") {
            self.revokePermission = dict["RevokePermission"] as! [ConfigureSecurityGroupPermissionsRequest.RevokePermission]
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class ConfigureSecurityGroupPermissionsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfigureSecurityGroupPermissionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigureSecurityGroupPermissionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfigureSecurityGroupPermissionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmReservationDemandRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var demandId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [ConfirmReservationDemandRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demandId != nil {
            map["DemandId"] = self.demandId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemandId") {
            self.demandId = dict["DemandId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ConfirmReservationDemandRequest.Tag]
        }
    }
}

public class ConfirmReservationDemandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfirmReservationDemandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmReservationDemandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfirmReservationDemandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCapacityReservationRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var capacityReservationName: String?

    public var description_: String?

    public var endDateType: String?

    public var instanceCount: String?

    public var instanceMatchCriteria: String?

    public var instancePlatform: String?

    public var instanceType: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateCapacityReservationRequest.Tag]?

    public var timeSlot: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationName != nil {
            map["CapacityReservationName"] = self.capacityReservationName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endDateType != nil {
            map["EndDateType"] = self.endDateType!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.instanceMatchCriteria != nil {
            map["InstanceMatchCriteria"] = self.instanceMatchCriteria!
        }
        if self.instancePlatform != nil {
            map["InstancePlatform"] = self.instancePlatform!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timeSlot != nil {
            map["TimeSlot"] = self.timeSlot!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CapacityReservationName") {
            self.capacityReservationName = dict["CapacityReservationName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndDateType") {
            self.endDateType = dict["EndDateType"] as! String
        }
        if dict.keys.contains("InstanceCount") {
            self.instanceCount = dict["InstanceCount"] as! String
        }
        if dict.keys.contains("InstanceMatchCriteria") {
            self.instanceMatchCriteria = dict["InstanceMatchCriteria"] as! String
        }
        if dict.keys.contains("InstancePlatform") {
            self.instancePlatform = dict["InstancePlatform"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateCapacityReservationRequest.Tag]
        }
        if dict.keys.contains("TimeSlot") {
            self.timeSlot = dict["TimeSlot"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateCapacityReservationResponseBody : Tea.TeaModel {
    public var capacityReservationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationId != nil {
            map["CapacityReservationId"] = self.capacityReservationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CapacityReservationId") {
            self.capacityReservationId = dict["CapacityReservationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCapacityReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCapacityReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCapacityReservationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDedicatedBlockStorageClusterRequest : Tea.TeaModel {
    public var capacity: Int32?

    public var category: String?

    public var clientToken: String?

    public var dedicatedBlockStorageClusterName: String?

    public var description_: String?

    public var fromApp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var type: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacity != nil {
            map["Capacity"] = self.capacity!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dedicatedBlockStorageClusterName != nil {
            map["DedicatedBlockStorageClusterName"] = self.dedicatedBlockStorageClusterName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Capacity") {
            self.capacity = dict["Capacity"] as! Int32
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DedicatedBlockStorageClusterName") {
            self.dedicatedBlockStorageClusterName = dict["DedicatedBlockStorageClusterName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FromApp") {
            self.fromApp = dict["FromApp"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateDedicatedBlockStorageClusterResponseBody : Tea.TeaModel {
    public var dedicatedBlockStorageClusterId: String?

    public var dedicatedBlockStorageClusterOrderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedBlockStorageClusterId != nil {
            map["DedicatedBlockStorageClusterId"] = self.dedicatedBlockStorageClusterId!
        }
        if self.dedicatedBlockStorageClusterOrderId != nil {
            map["DedicatedBlockStorageClusterOrderId"] = self.dedicatedBlockStorageClusterOrderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedBlockStorageClusterId") {
            self.dedicatedBlockStorageClusterId = dict["DedicatedBlockStorageClusterId"] as! String
        }
        if dict.keys.contains("DedicatedBlockStorageClusterOrderId") {
            self.dedicatedBlockStorageClusterOrderId = dict["DedicatedBlockStorageClusterOrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDedicatedBlockStorageClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDedicatedBlockStorageClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDedicatedBlockStorageClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDedicatedHostClusterRequest : Tea.TeaModel {
    public class SchedulerOptions : Tea.TeaModel {
        public var managedPrivateSpaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.managedPrivateSpaceId != nil {
                map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ManagedPrivateSpaceId") {
                self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var schedulerOptions: CreateDedicatedHostClusterRequest.SchedulerOptions?

    public var dedicatedHostClusterName: String?

    public var description_: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateDedicatedHostClusterRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.schedulerOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.dedicatedHostClusterName != nil {
            map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SchedulerOptions") {
            var model = CreateDedicatedHostClusterRequest.SchedulerOptions()
            model.fromMap(dict["SchedulerOptions"] as! [String: Any])
            self.schedulerOptions = model
        }
        if dict.keys.contains("DedicatedHostClusterName") {
            self.dedicatedHostClusterName = dict["DedicatedHostClusterName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateDedicatedHostClusterRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateDedicatedHostClusterResponseBody : Tea.TeaModel {
    public var dedicatedHostClusterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDedicatedHostClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDedicatedHostClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDedicatedHostClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDefaultAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateDefaultAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var autoSnapshotPolicyId: String?

    public var autoSnapshotPolicyName: String?

    public var repeatWeekdays: String?

    public var requestId: String?

    public var retentionDays: Int32?

    public var timePoints: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSnapshotPolicyId != nil {
            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.autoSnapshotPolicyName != nil {
            map["AutoSnapshotPolicyName"] = self.autoSnapshotPolicyName!
        }
        if self.repeatWeekdays != nil {
            map["RepeatWeekdays"] = self.repeatWeekdays!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        if self.timePoints != nil {
            map["TimePoints"] = self.timePoints!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoSnapshotPolicyId") {
            self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
        }
        if dict.keys.contains("AutoSnapshotPolicyName") {
            self.autoSnapshotPolicyName = dict["AutoSnapshotPolicyName"] as! String
        }
        if dict.keys.contains("RepeatWeekdays") {
            self.repeatWeekdays = dict["RepeatWeekdays"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RetentionDays") {
            self.retentionDays = dict["RetentionDays"] as! Int32
        }
        if dict.keys.contains("TimePoints") {
            self.timePoints = dict["TimePoints"] as! String
        }
    }
}

public class CreateDefaultAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDefaultAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDefaultAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiagnoseRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var amount: Int32?

    public var diagnoseAction: String?

    public var diagnoseErrorCode: String?

    public var diagnoseProduct: String?

    public var diagnoseRequestId: String?

    public var diagnoseRequestParams: String?

    public var diagnoseResponse: String?

    public var diskCategory: String?

    public var expireTime: String?

    public var instanceChargeType: String?

    public var instanceTypeName: String?

    public var izNo: String?

    public var mark: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateDiagnoseRequest.Tag]?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.diagnoseAction != nil {
            map["DiagnoseAction"] = self.diagnoseAction!
        }
        if self.diagnoseErrorCode != nil {
            map["DiagnoseErrorCode"] = self.diagnoseErrorCode!
        }
        if self.diagnoseProduct != nil {
            map["DiagnoseProduct"] = self.diagnoseProduct!
        }
        if self.diagnoseRequestId != nil {
            map["DiagnoseRequestId"] = self.diagnoseRequestId!
        }
        if self.diagnoseRequestParams != nil {
            map["DiagnoseRequestParams"] = self.diagnoseRequestParams!
        }
        if self.diagnoseResponse != nil {
            map["DiagnoseResponse"] = self.diagnoseResponse!
        }
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceTypeName != nil {
            map["InstanceTypeName"] = self.instanceTypeName!
        }
        if self.izNo != nil {
            map["IzNo"] = self.izNo!
        }
        if self.mark != nil {
            map["Mark"] = self.mark!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("DiagnoseAction") {
            self.diagnoseAction = dict["DiagnoseAction"] as! String
        }
        if dict.keys.contains("DiagnoseErrorCode") {
            self.diagnoseErrorCode = dict["DiagnoseErrorCode"] as! String
        }
        if dict.keys.contains("DiagnoseProduct") {
            self.diagnoseProduct = dict["DiagnoseProduct"] as! String
        }
        if dict.keys.contains("DiagnoseRequestId") {
            self.diagnoseRequestId = dict["DiagnoseRequestId"] as! String
        }
        if dict.keys.contains("DiagnoseRequestParams") {
            self.diagnoseRequestParams = dict["DiagnoseRequestParams"] as! String
        }
        if dict.keys.contains("DiagnoseResponse") {
            self.diagnoseResponse = dict["DiagnoseResponse"] as! String
        }
        if dict.keys.contains("DiskCategory") {
            self.diskCategory = dict["DiskCategory"] as! String
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceTypeName") {
            self.instanceTypeName = dict["InstanceTypeName"] as! String
        }
        if dict.keys.contains("IzNo") {
            self.izNo = dict["IzNo"] as! String
        }
        if dict.keys.contains("Mark") {
            self.mark = dict["Mark"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateDiagnoseRequest.Tag]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class CreateDiagnoseResponseBody : Tea.TeaModel {
    public var diagnoseId: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiagnoseId") {
            self.diagnoseId = dict["DiagnoseId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class CreateDiagnoseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnoseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiagnoseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiagnosisOperateRecordsRequest : Tea.TeaModel {
    public var errorCode: String?

    public var instanceType: String?

    public var newInstanceType: String?

    public var newZoneId: String?

    public var operateRecordType: String?

    public var ownerId: Int64?

    public var payType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.newInstanceType != nil {
            map["NewInstanceType"] = self.newInstanceType!
        }
        if self.newZoneId != nil {
            map["NewZoneId"] = self.newZoneId!
        }
        if self.operateRecordType != nil {
            map["OperateRecordType"] = self.operateRecordType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("NewInstanceType") {
            self.newInstanceType = dict["NewInstanceType"] as! String
        }
        if dict.keys.contains("NewZoneId") {
            self.newZoneId = dict["NewZoneId"] as! String
        }
        if dict.keys.contains("OperateRecordType") {
            self.operateRecordType = dict["OperateRecordType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateDiagnosisOperateRecordsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDiagnosisOperateRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnosisOperateRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiagnosisOperateRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiagnosticReportRequest : Tea.TeaModel {
    public var clientToken: String?

    public var commandName: [String]?

    public var commandType: String?

    public var diagnosticCategory: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pluginVersion: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var sourceSystem: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commandName != nil {
            map["CommandName"] = self.commandName!
        }
        if self.commandType != nil {
            map["CommandType"] = self.commandType!
        }
        if self.diagnosticCategory != nil {
            map["DiagnosticCategory"] = self.diagnosticCategory!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pluginVersion != nil {
            map["PluginVersion"] = self.pluginVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.sourceSystem != nil {
            map["SourceSystem"] = self.sourceSystem!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CommandName") {
            self.commandName = dict["CommandName"] as! [String]
        }
        if dict.keys.contains("CommandType") {
            self.commandType = dict["CommandType"] as! String
        }
        if dict.keys.contains("DiagnosticCategory") {
            self.diagnosticCategory = dict["DiagnosticCategory"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PluginVersion") {
            self.pluginVersion = dict["PluginVersion"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("SourceSystem") {
            self.sourceSystem = dict["SourceSystem"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class CreateDiagnosticReportResponseBody : Tea.TeaModel {
    public class CommandInvokeResults : Tea.TeaModel {
        public class InvokeResult : Tea.TeaModel {
            public var commandName: String?

            public var dataFileDir: String?

            public var invokeResult: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commandName != nil {
                    map["CommandName"] = self.commandName!
                }
                if self.dataFileDir != nil {
                    map["DataFileDir"] = self.dataFileDir!
                }
                if self.invokeResult != nil {
                    map["InvokeResult"] = self.invokeResult!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CommandName") {
                    self.commandName = dict["CommandName"] as! String
                }
                if dict.keys.contains("DataFileDir") {
                    self.dataFileDir = dict["DataFileDir"] as! String
                }
                if dict.keys.contains("InvokeResult") {
                    self.invokeResult = dict["InvokeResult"] as! String
                }
            }
        }
        public var invokeResult: [CreateDiagnosticReportResponseBody.CommandInvokeResults.InvokeResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.invokeResult != nil {
                var tmp : [Any] = []
                for k in self.invokeResult! {
                    tmp.append(k.toMap())
                }
                map["InvokeResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InvokeResult") {
                self.invokeResult = dict["InvokeResult"] as! [CreateDiagnosticReportResponseBody.CommandInvokeResults.InvokeResult]
            }
        }
    }
    public var commandInvokeResults: CreateDiagnosticReportResponseBody.CommandInvokeResults?

    public var createTime: String?

    public var reportId: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commandInvokeResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandInvokeResults != nil {
            map["CommandInvokeResults"] = self.commandInvokeResults?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandInvokeResults") {
            var model = CreateDiagnosticReportResponseBody.CommandInvokeResults()
            model.fromMap(dict["CommandInvokeResults"] as! [String: Any])
            self.commandInvokeResults = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class CreateDiagnosticReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnosticReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiagnosticReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDisksRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var amount: Int32?

    public var autoSnapshotPolicyId: String?

    public var burstingEnabled: Bool?

    public var category: String?

    public var clientToken: String?

    public var description_: String?

    public var diskName: String?

    public var encryptAlgorithm: String?

    public var encrypted: Bool?

    public var KMSKeyId: String?

    public var multiAttach: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var performanceLevel: String?

    public var provisionedIops: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var size: Int32?

    public var snapshotId: String?

    public var storageClusterId: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [CreateDisksRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.autoSnapshotPolicyId != nil {
            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.encryptAlgorithm != nil {
            map["EncryptAlgorithm"] = self.encryptAlgorithm!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.multiAttach != nil {
            map["MultiAttach"] = self.multiAttach!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.provisionedIops != nil {
            map["ProvisionedIops"] = self.provisionedIops!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.storageClusterId != nil {
            map["StorageClusterId"] = self.storageClusterId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("AutoSnapshotPolicyId") {
            self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
        }
        if dict.keys.contains("BurstingEnabled") {
            self.burstingEnabled = dict["BurstingEnabled"] as! Bool
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DiskName") {
            self.diskName = dict["DiskName"] as! String
        }
        if dict.keys.contains("EncryptAlgorithm") {
            self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
        }
        if dict.keys.contains("Encrypted") {
            self.encrypted = dict["Encrypted"] as! Bool
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("MultiAttach") {
            self.multiAttach = dict["MultiAttach"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("ProvisionedIops") {
            self.provisionedIops = dict["ProvisionedIops"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("StorageClusterId") {
            self.storageClusterId = dict["StorageClusterId"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateDisksRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateDisksResponseBody : Tea.TeaModel {
    public class DiskId : Tea.TeaModel {
        public var diskIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskIds != nil {
                map["DiskIds"] = self.diskIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskIds") {
                self.diskIds = dict["DiskIds"] as! [String]
            }
        }
    }
    public var diskId: CreateDisksResponseBody.DiskId?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.diskId?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            var model = CreateDisksResponseBody.DiskId()
            model.fromMap(dict["DiskId"] as! [String: Any])
            self.diskId = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDisksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDisksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDisksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateElasticityAssuranceRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var matchCriteria: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var privatePoolOptions: CreateElasticityAssuranceRequest.PrivatePoolOptions?

    public var assuranceTimes: String?

    public var clientToken: String?

    public var description_: String?

    public var instanceAmount: Int32?

    public var instanceCpuCoreCount: Int32?

    public var instanceType: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var tag: [CreateElasticityAssuranceRequest.Tag]?

    public var zoneId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.assuranceTimes != nil {
            map["AssuranceTimes"] = self.assuranceTimes!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceCpuCoreCount != nil {
            map["InstanceCpuCoreCount"] = self.instanceCpuCoreCount!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = CreateElasticityAssuranceRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("AssuranceTimes") {
            self.assuranceTimes = dict["AssuranceTimes"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("InstanceCpuCoreCount") {
            self.instanceCpuCoreCount = dict["InstanceCpuCoreCount"] as! Int32
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateElasticityAssuranceRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! [String]
        }
    }
}

public class CreateElasticityAssuranceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var privatePoolOptionsId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.privatePoolOptionsId != nil {
            map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("PrivatePoolOptionsId") {
            self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateElasticityAssuranceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateElasticityAssuranceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateElasticityAssuranceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEniQosGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var qosGroupName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var rx: Int32?

    public var rxPps: Int32?

    public var tx: Int32?

    public var txPps: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosGroupName != nil {
            map["QosGroupName"] = self.qosGroupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.rx != nil {
            map["Rx"] = self.rx!
        }
        if self.rxPps != nil {
            map["RxPps"] = self.rxPps!
        }
        if self.tx != nil {
            map["Tx"] = self.tx!
        }
        if self.txPps != nil {
            map["TxPps"] = self.txPps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosGroupName") {
            self.qosGroupName = dict["QosGroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Rx") {
            self.rx = dict["Rx"] as! Int32
        }
        if dict.keys.contains("RxPps") {
            self.rxPps = dict["RxPps"] as! Int32
        }
        if dict.keys.contains("Tx") {
            self.tx = dict["Tx"] as! Int32
        }
        if dict.keys.contains("TxPps") {
            self.txPps = dict["TxPps"] as! Int32
        }
    }
}

public class CreateEniQosGroupResponseBody : Tea.TeaModel {
    public var qosGroupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qosGroupName != nil {
            map["QosGroupName"] = self.qosGroupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QosGroupName") {
            self.qosGroupName = dict["QosGroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEniQosGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEniQosGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEniQosGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFunctionFeedbackRequest : Tea.TeaModel {
    public var category: String?

    public var feedback: String?

    public var functionName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var suggestion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.feedback != nil {
            map["Feedback"] = self.feedback!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.suggestion != nil {
            map["Suggestion"] = self.suggestion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Feedback") {
            self.feedback = dict["Feedback"] as! String
        }
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Suggestion") {
            self.suggestion = dict["Suggestion"] as! String
        }
    }
}

public class CreateFunctionFeedbackResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFunctionFeedbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFunctionFeedbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFunctionFeedbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateImageCacheRequest : Tea.TeaModel {
    public var clientToken: String?

    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateImageCacheResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateImageCacheResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImageCacheResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateImageCacheResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIssueCategoryReportRelationRequest : Tea.TeaModel {
    public class RelationModelList : Tea.TeaModel {
        public var customerInputContent: String?

        public var issueCategoryId: Int64?

        public var issueCategoryName: String?

        public var mappingTools: String?

        public var reportId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customerInputContent != nil {
                map["CustomerInputContent"] = self.customerInputContent!
            }
            if self.issueCategoryId != nil {
                map["IssueCategoryId"] = self.issueCategoryId!
            }
            if self.issueCategoryName != nil {
                map["IssueCategoryName"] = self.issueCategoryName!
            }
            if self.mappingTools != nil {
                map["MappingTools"] = self.mappingTools!
            }
            if self.reportId != nil {
                map["ReportId"] = self.reportId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomerInputContent") {
                self.customerInputContent = dict["CustomerInputContent"] as! String
            }
            if dict.keys.contains("IssueCategoryId") {
                self.issueCategoryId = dict["IssueCategoryId"] as! Int64
            }
            if dict.keys.contains("IssueCategoryName") {
                self.issueCategoryName = dict["IssueCategoryName"] as! String
            }
            if dict.keys.contains("MappingTools") {
                self.mappingTools = dict["MappingTools"] as! String
            }
            if dict.keys.contains("ReportId") {
                self.reportId = dict["ReportId"] as! String
            }
        }
    }
    public var regionId: String?

    public var relationModelList: [CreateIssueCategoryReportRelationRequest.RelationModelList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.relationModelList != nil {
            var tmp : [Any] = []
            for k in self.relationModelList! {
                tmp.append(k.toMap())
            }
            map["RelationModelList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RelationModelList") {
            self.relationModelList = dict["RelationModelList"] as! [CreateIssueCategoryReportRelationRequest.RelationModelList]
        }
    }
}

public class CreateIssueCategoryReportRelationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class CreateIssueCategoryReportRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIssueCategoryReportRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIssueCategoryReportRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMigrationPlanRequest : Tea.TeaModel {
    public class CustomMigrationTimes : Tea.TeaModel {
        public var instanceId: String?

        public var migrationTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.migrationTime != nil {
                map["MigrationTime"] = self.migrationTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MigrationTime") {
                self.migrationTime = dict["MigrationTime"] as! String
            }
        }
    }
    public var customMigrationTimes: [CreateMigrationPlanRequest.CustomMigrationTimes]?

    public var dryRun: Bool?

    public var enableAutoCreateVSwitch: Bool?

    public var ensureNetworkConnectivity: Bool?

    public var globalMigrationTime: String?

    public var instanceIds: [String]?

    public var name: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var remainPrivateIp: Bool?

    public var remainPublicMacAsPriority: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var targetSecurityGroupIds: [String]?

    public var targetVSwitchId: String?

    public var targetVpcId: String?

    public var targetZoneId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customMigrationTimes != nil {
            var tmp : [Any] = []
            for k in self.customMigrationTimes! {
                tmp.append(k.toMap())
            }
            map["CustomMigrationTimes"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableAutoCreateVSwitch != nil {
            map["EnableAutoCreateVSwitch"] = self.enableAutoCreateVSwitch!
        }
        if self.ensureNetworkConnectivity != nil {
            map["EnsureNetworkConnectivity"] = self.ensureNetworkConnectivity!
        }
        if self.globalMigrationTime != nil {
            map["GlobalMigrationTime"] = self.globalMigrationTime!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.remainPrivateIp != nil {
            map["RemainPrivateIp"] = self.remainPrivateIp!
        }
        if self.remainPublicMacAsPriority != nil {
            map["RemainPublicMacAsPriority"] = self.remainPublicMacAsPriority!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetSecurityGroupIds != nil {
            map["TargetSecurityGroupIds"] = self.targetSecurityGroupIds!
        }
        if self.targetVSwitchId != nil {
            map["TargetVSwitchId"] = self.targetVSwitchId!
        }
        if self.targetVpcId != nil {
            map["TargetVpcId"] = self.targetVpcId!
        }
        if self.targetZoneId != nil {
            map["TargetZoneId"] = self.targetZoneId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomMigrationTimes") {
            self.customMigrationTimes = dict["CustomMigrationTimes"] as! [CreateMigrationPlanRequest.CustomMigrationTimes]
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnableAutoCreateVSwitch") {
            self.enableAutoCreateVSwitch = dict["EnableAutoCreateVSwitch"] as! Bool
        }
        if dict.keys.contains("EnsureNetworkConnectivity") {
            self.ensureNetworkConnectivity = dict["EnsureNetworkConnectivity"] as! Bool
        }
        if dict.keys.contains("GlobalMigrationTime") {
            self.globalMigrationTime = dict["GlobalMigrationTime"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemainPrivateIp") {
            self.remainPrivateIp = dict["RemainPrivateIp"] as! Bool
        }
        if dict.keys.contains("RemainPublicMacAsPriority") {
            self.remainPublicMacAsPriority = dict["RemainPublicMacAsPriority"] as! Bool
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TargetSecurityGroupIds") {
            self.targetSecurityGroupIds = dict["TargetSecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("TargetVSwitchId") {
            self.targetVSwitchId = dict["TargetVSwitchId"] as! String
        }
        if dict.keys.contains("TargetVpcId") {
            self.targetVpcId = dict["TargetVpcId"] as! String
        }
        if dict.keys.contains("TargetZoneId") {
            self.targetZoneId = dict["TargetZoneId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateMigrationPlanResponseBody : Tea.TeaModel {
    public class InstancesFailModels : Tea.TeaModel {
        public class InstancesFailModel : Tea.TeaModel {
            public class FailModels : Tea.TeaModel {
                public class FailModel : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                    }
                }
                public var failModel: [CreateMigrationPlanResponseBody.InstancesFailModels.InstancesFailModel.FailModels.FailModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failModel != nil {
                        var tmp : [Any] = []
                        for k in self.failModel! {
                            tmp.append(k.toMap())
                        }
                        map["FailModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FailModel") {
                        self.failModel = dict["FailModel"] as! [CreateMigrationPlanResponseBody.InstancesFailModels.InstancesFailModel.FailModels.FailModel]
                    }
                }
            }
            public var failModels: CreateMigrationPlanResponseBody.InstancesFailModels.InstancesFailModel.FailModels?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.failModels?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failModels != nil {
                    map["FailModels"] = self.failModels?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailModels") {
                    var model = CreateMigrationPlanResponseBody.InstancesFailModels.InstancesFailModel.FailModels()
                    model.fromMap(dict["FailModels"] as! [String: Any])
                    self.failModels = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var instancesFailModel: [CreateMigrationPlanResponseBody.InstancesFailModels.InstancesFailModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instancesFailModel != nil {
                var tmp : [Any] = []
                for k in self.instancesFailModel! {
                    tmp.append(k.toMap())
                }
                map["InstancesFailModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstancesFailModel") {
                self.instancesFailModel = dict["InstancesFailModel"] as! [CreateMigrationPlanResponseBody.InstancesFailModels.InstancesFailModel]
            }
        }
    }
    public class PlanFailModels : Tea.TeaModel {
        public class PlanFailModel : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
            }
        }
        public var planFailModel: [CreateMigrationPlanResponseBody.PlanFailModels.PlanFailModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.planFailModel != nil {
                var tmp : [Any] = []
                for k in self.planFailModel! {
                    tmp.append(k.toMap())
                }
                map["PlanFailModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PlanFailModel") {
                self.planFailModel = dict["PlanFailModel"] as! [CreateMigrationPlanResponseBody.PlanFailModels.PlanFailModel]
            }
        }
    }
    public class SgFailModels : Tea.TeaModel {
        public class SgFailModel : Tea.TeaModel {
            public class FailModels : Tea.TeaModel {
                public class FailModel : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                    }
                }
                public var failModel: [CreateMigrationPlanResponseBody.SgFailModels.SgFailModel.FailModels.FailModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failModel != nil {
                        var tmp : [Any] = []
                        for k in self.failModel! {
                            tmp.append(k.toMap())
                        }
                        map["FailModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FailModel") {
                        self.failModel = dict["FailModel"] as! [CreateMigrationPlanResponseBody.SgFailModels.SgFailModel.FailModels.FailModel]
                    }
                }
            }
            public var failModels: CreateMigrationPlanResponseBody.SgFailModels.SgFailModel.FailModels?

            public var groupNo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.failModels?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failModels != nil {
                    map["FailModels"] = self.failModels?.toMap()
                }
                if self.groupNo != nil {
                    map["GroupNo"] = self.groupNo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailModels") {
                    var model = CreateMigrationPlanResponseBody.SgFailModels.SgFailModel.FailModels()
                    model.fromMap(dict["FailModels"] as! [String: Any])
                    self.failModels = model
                }
                if dict.keys.contains("GroupNo") {
                    self.groupNo = dict["GroupNo"] as! String
                }
            }
        }
        public var sgFailModel: [CreateMigrationPlanResponseBody.SgFailModels.SgFailModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sgFailModel != nil {
                var tmp : [Any] = []
                for k in self.sgFailModel! {
                    tmp.append(k.toMap())
                }
                map["SgFailModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SgFailModel") {
                self.sgFailModel = dict["SgFailModel"] as! [CreateMigrationPlanResponseBody.SgFailModels.SgFailModel]
            }
        }
    }
    public var instancesFailModels: CreateMigrationPlanResponseBody.InstancesFailModels?

    public var migrationPlanId: String?

    public var planFailModels: CreateMigrationPlanResponseBody.PlanFailModels?

    public var requestId: String?

    public var sgFailModels: CreateMigrationPlanResponseBody.SgFailModels?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instancesFailModels?.validate()
        try self.planFailModels?.validate()
        try self.sgFailModels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instancesFailModels != nil {
            map["InstancesFailModels"] = self.instancesFailModels?.toMap()
        }
        if self.migrationPlanId != nil {
            map["MigrationPlanId"] = self.migrationPlanId!
        }
        if self.planFailModels != nil {
            map["PlanFailModels"] = self.planFailModels?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sgFailModels != nil {
            map["SgFailModels"] = self.sgFailModels?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstancesFailModels") {
            var model = CreateMigrationPlanResponseBody.InstancesFailModels()
            model.fromMap(dict["InstancesFailModels"] as! [String: Any])
            self.instancesFailModels = model
        }
        if dict.keys.contains("MigrationPlanId") {
            self.migrationPlanId = dict["MigrationPlanId"] as! String
        }
        if dict.keys.contains("PlanFailModels") {
            var model = CreateMigrationPlanResponseBody.PlanFailModels()
            model.fromMap(dict["PlanFailModels"] as! [String: Any])
            self.planFailModels = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SgFailModels") {
            var model = CreateMigrationPlanResponseBody.SgFailModels()
            model.fromMap(dict["SgFailModels"] as! [String: Any])
            self.sgFailModels = model
        }
    }
}

public class CreateMigrationPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMigrationPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMigrationPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkInsightsPathRequest : Tea.TeaModel {
    public var clientToken: String?

    public var destination: String?

    public var destinationPort: String?

    public var destinationType: String?

    public var dryRun: Bool?

    public var needDiagnoseGuest: Bool?

    public var networkInsightsPathName: String?

    public var protocol_: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var source: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destination != nil {
            map["Destination"] = self.destination!
        }
        if self.destinationPort != nil {
            map["DestinationPort"] = self.destinationPort!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.needDiagnoseGuest != nil {
            map["NeedDiagnoseGuest"] = self.needDiagnoseGuest!
        }
        if self.networkInsightsPathName != nil {
            map["NetworkInsightsPathName"] = self.networkInsightsPathName!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Destination") {
            self.destination = dict["Destination"] as! String
        }
        if dict.keys.contains("DestinationPort") {
            self.destinationPort = dict["DestinationPort"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NeedDiagnoseGuest") {
            self.needDiagnoseGuest = dict["NeedDiagnoseGuest"] as! Bool
        }
        if dict.keys.contains("NetworkInsightsPathName") {
            self.networkInsightsPathName = dict["NetworkInsightsPathName"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class CreateNetworkInsightsPathResponseBody : Tea.TeaModel {
    public var networkInsightsPathId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInsightsPathId != nil {
            map["NetworkInsightsPathId"] = self.networkInsightsPathId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInsightsPathId") {
            self.networkInsightsPathId = dict["NetworkInsightsPathId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkInsightsPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkInsightsPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkInsightsPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrderRequest : Tea.TeaModel {
    public var affinity: String?

    public var asyncPattern: Bool?

    public var businessInfo: String?

    public var chargeType: String?

    public var clientToken: String?

    public var commodity: String?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var fromApp: String?

    public var orderType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tenancy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.asyncPattern != nil {
            map["AsyncPattern"] = self.asyncPattern!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commodity != nil {
            map["Commodity"] = self.commodity!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("AsyncPattern") {
            self.asyncPattern = dict["AsyncPattern"] as! Bool
        }
        if dict.keys.contains("BusinessInfo") {
            self.businessInfo = dict["BusinessInfo"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Commodity") {
            self.commodity = dict["Commodity"] as! String
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("FromApp") {
            self.fromApp = dict["FromApp"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
    }
}

public class CreateOrderResponseBody : Tea.TeaModel {
    public class OrderParams : Tea.TeaModel {
        public var orderParam: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.orderParam != nil {
                map["OrderParam"] = self.orderParam!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OrderParam") {
                self.orderParam = dict["OrderParam"] as! [String]
            }
        }
    }
    public class RelatedOrderItemSets : Tea.TeaModel {
        public class RelatedOrderItemSet : Tea.TeaModel {
            public class InstanceIdSet : Tea.TeaModel {
                public var instanceIds: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceIds != nil {
                        map["InstanceIds"] = self.instanceIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceIds") {
                        self.instanceIds = dict["InstanceIds"] as! [String]
                    }
                }
            }
            public class RelatedOrderIds : Tea.TeaModel {
                public var relatedOrderId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.relatedOrderId != nil {
                        map["RelatedOrderId"] = self.relatedOrderId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RelatedOrderId") {
                        self.relatedOrderId = dict["RelatedOrderId"] as! [String]
                    }
                }
            }
            public var instanceIdSet: CreateOrderResponseBody.RelatedOrderItemSets.RelatedOrderItemSet.InstanceIdSet?

            public var relatedOrderIds: CreateOrderResponseBody.RelatedOrderItemSets.RelatedOrderItemSet.RelatedOrderIds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceIdSet?.validate()
                try self.relatedOrderIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceIdSet != nil {
                    map["InstanceIdSet"] = self.instanceIdSet?.toMap()
                }
                if self.relatedOrderIds != nil {
                    map["RelatedOrderIds"] = self.relatedOrderIds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceIdSet") {
                    var model = CreateOrderResponseBody.RelatedOrderItemSets.RelatedOrderItemSet.InstanceIdSet()
                    model.fromMap(dict["InstanceIdSet"] as! [String: Any])
                    self.instanceIdSet = model
                }
                if dict.keys.contains("RelatedOrderIds") {
                    var model = CreateOrderResponseBody.RelatedOrderItemSets.RelatedOrderItemSet.RelatedOrderIds()
                    model.fromMap(dict["RelatedOrderIds"] as! [String: Any])
                    self.relatedOrderIds = model
                }
            }
        }
        public var relatedOrderItemSet: [CreateOrderResponseBody.RelatedOrderItemSets.RelatedOrderItemSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.relatedOrderItemSet != nil {
                var tmp : [Any] = []
                for k in self.relatedOrderItemSet! {
                    tmp.append(k.toMap())
                }
                map["RelatedOrderItemSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RelatedOrderItemSet") {
                self.relatedOrderItemSet = dict["RelatedOrderItemSet"] as! [CreateOrderResponseBody.RelatedOrderItemSets.RelatedOrderItemSet]
            }
        }
    }
    public var orderId: String?

    public var orderParams: CreateOrderResponseBody.OrderParams?

    public var relatedOrderItemSets: CreateOrderResponseBody.RelatedOrderItemSets?

    public var requestId: String?

    public var taskId: String?

    public var tradePrice: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.orderParams?.validate()
        try self.relatedOrderItemSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.orderParams != nil {
            map["OrderParams"] = self.orderParams?.toMap()
        }
        if self.relatedOrderItemSets != nil {
            map["RelatedOrderItemSets"] = self.relatedOrderItemSets?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.tradePrice != nil {
            map["TradePrice"] = self.tradePrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("OrderParams") {
            var model = CreateOrderResponseBody.OrderParams()
            model.fromMap(dict["OrderParams"] as! [String: Any])
            self.orderParams = model
        }
        if dict.keys.contains("RelatedOrderItemSets") {
            var model = CreateOrderResponseBody.RelatedOrderItemSets()
            model.fromMap(dict["RelatedOrderItemSets"] as! [String: Any])
            self.relatedOrderItemSets = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TradePrice") {
            self.tradePrice = dict["TradePrice"] as! Double
        }
    }
}

public class CreateOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateReservationDemandRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var instanceAmount: Int32?

        public var instanceType: String?

        public var matchCriteria: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceAmount != nil {
                map["InstanceAmount"] = self.instanceAmount!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceAmount") {
                self.instanceAmount = dict["InstanceAmount"] as! Int32
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var confirmType: String?

    public var couponAuto: Bool?

    public var couponType: String?

    public var description_: String?

    public var endTime: String?

    public var instanceAmount: Int32?

    public var instanceChargeType: String?

    public var instanceCpuCoreCount: Int32?

    public var instanceTypeFamily: String?

    public var instanceTypes: String?

    public var matchCriteria: String?

    public var name: String?

    public var period: Int32?

    public var periodUnit: String?

    public var phoneNumber: String?

    public var platform: String?

    public var privatePoolOptions: [CreateReservationDemandRequest.PrivatePoolOptions]?

    public var productType: String?

    public var regionId: String?

    public var reservedInstanceDescription: String?

    public var reservedInstanceName: String?

    public var reservedInstanceOfferingType: String?

    public var reservedInstanceScope: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var resourceSupplyType: String?

    public var savingPlanDescription: String?

    public var savingPlanHourFee: Double?

    public var savingPlanId: String?

    public var savingPlanInstanceTypeFamilyGroup: String?

    public var savingPlanName: String?

    public var savingPlanPayMode: String?

    public var savingPlanSavingType: String?

    public var startTime: String?

    public var tag: [CreateReservationDemandRequest.Tag]?

    public var zoneIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.confirmType != nil {
            map["ConfirmType"] = self.confirmType!
        }
        if self.couponAuto != nil {
            map["CouponAuto"] = self.couponAuto!
        }
        if self.couponType != nil {
            map["CouponType"] = self.couponType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceCpuCoreCount != nil {
            map["InstanceCpuCoreCount"] = self.instanceCpuCoreCount!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.matchCriteria != nil {
            map["MatchCriteria"] = self.matchCriteria!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.privatePoolOptions != nil {
            var tmp : [Any] = []
            for k in self.privatePoolOptions! {
                tmp.append(k.toMap())
            }
            map["PrivatePoolOptions"] = tmp
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceDescription != nil {
            map["ReservedInstanceDescription"] = self.reservedInstanceDescription!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.reservedInstanceOfferingType != nil {
            map["ReservedInstanceOfferingType"] = self.reservedInstanceOfferingType!
        }
        if self.reservedInstanceScope != nil {
            map["ReservedInstanceScope"] = self.reservedInstanceScope!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceSupplyType != nil {
            map["ResourceSupplyType"] = self.resourceSupplyType!
        }
        if self.savingPlanDescription != nil {
            map["SavingPlanDescription"] = self.savingPlanDescription!
        }
        if self.savingPlanHourFee != nil {
            map["SavingPlanHourFee"] = self.savingPlanHourFee!
        }
        if self.savingPlanId != nil {
            map["SavingPlanId"] = self.savingPlanId!
        }
        if self.savingPlanInstanceTypeFamilyGroup != nil {
            map["SavingPlanInstanceTypeFamilyGroup"] = self.savingPlanInstanceTypeFamilyGroup!
        }
        if self.savingPlanName != nil {
            map["SavingPlanName"] = self.savingPlanName!
        }
        if self.savingPlanPayMode != nil {
            map["SavingPlanPayMode"] = self.savingPlanPayMode!
        }
        if self.savingPlanSavingType != nil {
            map["SavingPlanSavingType"] = self.savingPlanSavingType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneIds != nil {
            map["ZoneIds"] = self.zoneIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfirmType") {
            self.confirmType = dict["ConfirmType"] as! String
        }
        if dict.keys.contains("CouponAuto") {
            self.couponAuto = dict["CouponAuto"] as! Bool
        }
        if dict.keys.contains("CouponType") {
            self.couponType = dict["CouponType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceCpuCoreCount") {
            self.instanceCpuCoreCount = dict["InstanceCpuCoreCount"] as! Int32
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! String
        }
        if dict.keys.contains("MatchCriteria") {
            self.matchCriteria = dict["MatchCriteria"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PhoneNumber") {
            self.phoneNumber = dict["PhoneNumber"] as! String
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("PrivatePoolOptions") {
            self.privatePoolOptions = dict["PrivatePoolOptions"] as! [CreateReservationDemandRequest.PrivatePoolOptions]
        }
        if dict.keys.contains("ProductType") {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceDescription") {
            self.reservedInstanceDescription = dict["ReservedInstanceDescription"] as! String
        }
        if dict.keys.contains("ReservedInstanceName") {
            self.reservedInstanceName = dict["ReservedInstanceName"] as! String
        }
        if dict.keys.contains("ReservedInstanceOfferingType") {
            self.reservedInstanceOfferingType = dict["ReservedInstanceOfferingType"] as! String
        }
        if dict.keys.contains("ReservedInstanceScope") {
            self.reservedInstanceScope = dict["ReservedInstanceScope"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceSupplyType") {
            self.resourceSupplyType = dict["ResourceSupplyType"] as! String
        }
        if dict.keys.contains("SavingPlanDescription") {
            self.savingPlanDescription = dict["SavingPlanDescription"] as! String
        }
        if dict.keys.contains("SavingPlanHourFee") {
            self.savingPlanHourFee = dict["SavingPlanHourFee"] as! Double
        }
        if dict.keys.contains("SavingPlanId") {
            self.savingPlanId = dict["SavingPlanId"] as! String
        }
        if dict.keys.contains("SavingPlanInstanceTypeFamilyGroup") {
            self.savingPlanInstanceTypeFamilyGroup = dict["SavingPlanInstanceTypeFamilyGroup"] as! String
        }
        if dict.keys.contains("SavingPlanName") {
            self.savingPlanName = dict["SavingPlanName"] as! String
        }
        if dict.keys.contains("SavingPlanPayMode") {
            self.savingPlanPayMode = dict["SavingPlanPayMode"] as! String
        }
        if dict.keys.contains("SavingPlanSavingType") {
            self.savingPlanSavingType = dict["SavingPlanSavingType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateReservationDemandRequest.Tag]
        }
        if dict.keys.contains("ZoneIds") {
            self.zoneIds = dict["ZoneIds"] as! String
        }
    }
}

public class CreateReservationDemandResponseBody : Tea.TeaModel {
    public var demandId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demandId != nil {
            map["DemandId"] = self.demandId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemandId") {
            self.demandId = dict["DemandId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateReservationDemandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateReservationDemandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateReservationDemandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateStorageSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var maxPartitionNumber: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetName: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.maxPartitionNumber != nil {
            map["MaxPartitionNumber"] = self.maxPartitionNumber!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetName != nil {
            map["StorageSetName"] = self.storageSetName!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MaxPartitionNumber") {
            self.maxPartitionNumber = dict["MaxPartitionNumber"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetName") {
            self.storageSetName = dict["StorageSetName"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateStorageSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var storageSetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
    }
}

public class CreateStorageSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStorageSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateStorageSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUserQuotaApplicationRequest : Tea.TeaModel {
    public var chargeType: String?

    public var clientToken: String?

    public var description_: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var quotaType: String?

    public var quotaValue: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.quotaType != nil {
            map["QuotaType"] = self.quotaType!
        }
        if self.quotaValue != nil {
            map["QuotaValue"] = self.quotaValue!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QuotaType") {
            self.quotaType = dict["QuotaType"] as! String
        }
        if dict.keys.contains("QuotaValue") {
            self.quotaValue = dict["QuotaValue"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateUserQuotaApplicationResponseBody : Tea.TeaModel {
    public var applicationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationId") {
            self.applicationId = dict["ApplicationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateUserQuotaApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUserQuotaApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUserQuotaApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVolumesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var amount: Int32?

    public var clientToken: String?

    public var description_: String?

    public var KMSKeyId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var size: Int32?

    public var snapshotId: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [CreateVolumesRequest.Tag]?

    public var volumeCategory: String?

    public var volumeEncrypted: Bool?

    public var volumeName: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.volumeCategory != nil {
            map["VolumeCategory"] = self.volumeCategory!
        }
        if self.volumeEncrypted != nil {
            map["VolumeEncrypted"] = self.volumeEncrypted!
        }
        if self.volumeName != nil {
            map["VolumeName"] = self.volumeName!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateVolumesRequest.Tag]
        }
        if dict.keys.contains("VolumeCategory") {
            self.volumeCategory = dict["VolumeCategory"] as! String
        }
        if dict.keys.contains("VolumeEncrypted") {
            self.volumeEncrypted = dict["VolumeEncrypted"] as! Bool
        }
        if dict.keys.contains("VolumeName") {
            self.volumeName = dict["VolumeName"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateVolumesResponseBody : Tea.TeaModel {
    public class VolumeIds : Tea.TeaModel {
        public var volumeId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.volumeId != nil {
                map["VolumeId"] = self.volumeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VolumeId") {
                self.volumeId = dict["VolumeId"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var volumeIds: CreateVolumesResponseBody.VolumeIds?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.volumeIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.volumeIds != nil {
            map["VolumeIds"] = self.volumeIds?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VolumeIds") {
            var model = CreateVolumesResponseBody.VolumeIds()
            model.fromMap(dict["VolumeIds"] as! [String: Any])
            self.volumeIds = model
        }
    }
}

public class CreateVolumesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVolumesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVolumesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateWaitingOrderRequest : Tea.TeaModel {
    public class CpuOptions : Tea.TeaModel {
        public var core: Int32?

        public var numa: String?

        public var threadsPerCore: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.core != nil {
                map["Core"] = self.core!
            }
            if self.numa != nil {
                map["Numa"] = self.numa!
            }
            if self.threadsPerCore != nil {
                map["ThreadsPerCore"] = self.threadsPerCore!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Core") {
                self.core = dict["Core"] as! Int32
            }
            if dict.keys.contains("Numa") {
                self.numa = dict["Numa"] as! String
            }
            if dict.keys.contains("ThreadsPerCore") {
                self.threadsPerCore = dict["ThreadsPerCore"] as! Int32
            }
        }
    }
    public class HibernationOptions : Tea.TeaModel {
        public var configured: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configured != nil {
                map["Configured"] = self.configured!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Configured") {
                self.configured = dict["Configured"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SchedulerOptions : Tea.TeaModel {
        public var dedicatedHostClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostClusterId != nil {
                map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostClusterId") {
                self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public var trustedSystemMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            if self.trustedSystemMode != nil {
                map["TrustedSystemMode"] = self.trustedSystemMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfidentialComputingMode") {
                self.confidentialComputingMode = dict["ConfidentialComputingMode"] as! String
            }
            if dict.keys.contains("TrustedSystemMode") {
                self.trustedSystemMode = dict["TrustedSystemMode"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var performanceLevel: String?

        public var size: String?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("StorageClusterId") {
                self.storageClusterId = dict["StorageClusterId"] as! String
            }
        }
    }
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssumeRoleFor") {
                self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
            if dict.keys.contains("Rolearn") {
                self.rolearn = dict["Rolearn"] as! String
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var size: Int32?

        public var snapshotId: String?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
            if dict.keys.contains("StorageClusterId") {
                self.storageClusterId = dict["StorageClusterId"] as! String
            }
        }
    }
    public class NetworkInterface : Tea.TeaModel {
        public var description_: String?

        public var networkInterfaceName: String?

        public var primaryIpAddress: String?

        public var queueNumber: Int32?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.networkInterfaceName != nil {
                map["NetworkInterfaceName"] = self.networkInterfaceName!
            }
            if self.primaryIpAddress != nil {
                map["PrimaryIpAddress"] = self.primaryIpAddress!
            }
            if self.queueNumber != nil {
                map["QueueNumber"] = self.queueNumber!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("NetworkInterfaceName") {
                self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
            }
            if dict.keys.contains("PrimaryIpAddress") {
                self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
            }
            if dict.keys.contains("QueueNumber") {
                self.queueNumber = dict["QueueNumber"] as! Int32
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var cpuOptions: CreateWaitingOrderRequest.CpuOptions?

    public var hibernationOptions: CreateWaitingOrderRequest.HibernationOptions?

    public var privatePoolOptions: CreateWaitingOrderRequest.PrivatePoolOptions?

    public var schedulerOptions: CreateWaitingOrderRequest.SchedulerOptions?

    public var securityOptions: CreateWaitingOrderRequest.SecurityOptions?

    public var systemDisk: CreateWaitingOrderRequest.SystemDisk?

    public var affinity: String?

    public var arn: [CreateWaitingOrderRequest.Arn]?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var creditSpecification: String?

    public var dataDisk: [CreateWaitingOrderRequest.DataDisk]?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetGroupNo: Int32?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var expiredTime: String?

    public var hostName: String?

    public var hostNames: [String]?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6Address: [String]?

    public var ipv6AddressCount: Int32?

    public var isp: String?

    public var keyPairName: String?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var launchTemplateVersion: Int64?

    public var maxAmount: Int32?

    public var minAmount: Int32?

    public var networkInterface: [CreateWaitingOrderRequest.NetworkInterface]?

    public var networkInterfaceQueueNumber: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [CreateWaitingOrderRequest.Tag]?

    public var tenancy: String?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cpuOptions?.validate()
        try self.hibernationOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.schedulerOptions?.validate()
        try self.securityOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuOptions != nil {
            map["CpuOptions"] = self.cpuOptions?.toMap()
        }
        if self.hibernationOptions != nil {
            map["HibernationOptions"] = self.hibernationOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetGroupNo != nil {
            map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hostNames != nil {
            map["HostNames"] = self.hostNames!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxAmount != nil {
            map["MaxAmount"] = self.maxAmount!
        }
        if self.minAmount != nil {
            map["MinAmount"] = self.minAmount!
        }
        if self.networkInterface != nil {
            var tmp : [Any] = []
            for k in self.networkInterface! {
                tmp.append(k.toMap())
            }
            map["NetworkInterface"] = tmp
        }
        if self.networkInterfaceQueueNumber != nil {
            map["NetworkInterfaceQueueNumber"] = self.networkInterfaceQueueNumber!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuOptions") {
            var model = CreateWaitingOrderRequest.CpuOptions()
            model.fromMap(dict["CpuOptions"] as! [String: Any])
            self.cpuOptions = model
        }
        if dict.keys.contains("HibernationOptions") {
            var model = CreateWaitingOrderRequest.HibernationOptions()
            model.fromMap(dict["HibernationOptions"] as! [String: Any])
            self.hibernationOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") {
            var model = CreateWaitingOrderRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SchedulerOptions") {
            var model = CreateWaitingOrderRequest.SchedulerOptions()
            model.fromMap(dict["SchedulerOptions"] as! [String: Any])
            self.schedulerOptions = model
        }
        if dict.keys.contains("SecurityOptions") {
            var model = CreateWaitingOrderRequest.SecurityOptions()
            model.fromMap(dict["SecurityOptions"] as! [String: Any])
            self.securityOptions = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = CreateWaitingOrderRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("Arn") {
            self.arn = dict["Arn"] as! [CreateWaitingOrderRequest.Arn]
        }
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("DataDisk") {
            self.dataDisk = dict["DataDisk"] as! [CreateWaitingOrderRequest.DataDisk]
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetGroupNo") {
            self.deploymentSetGroupNo = dict["DeploymentSetGroupNo"] as! Int32
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HostNames") {
            self.hostNames = dict["HostNames"] as! [String]
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpPutResponseHopLimit") {
            self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateName") {
            self.launchTemplateName = dict["LaunchTemplateName"] as! String
        }
        if dict.keys.contains("LaunchTemplateVersion") {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! Int64
        }
        if dict.keys.contains("MaxAmount") {
            self.maxAmount = dict["MaxAmount"] as! Int32
        }
        if dict.keys.contains("MinAmount") {
            self.minAmount = dict["MinAmount"] as! Int32
        }
        if dict.keys.contains("NetworkInterface") {
            self.networkInterface = dict["NetworkInterface"] as! [CreateWaitingOrderRequest.NetworkInterface]
        }
        if dict.keys.contains("NetworkInterfaceQueueNumber") {
            self.networkInterfaceQueueNumber = dict["NetworkInterfaceQueueNumber"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimit") {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [CreateWaitingOrderRequest.Tag]
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UniqueSuffix") {
            self.uniqueSuffix = dict["UniqueSuffix"] as! Bool
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateWaitingOrderResponseBody : Tea.TeaModel {
    public var dryRunResult: String?

    public var requestId: String?

    public var waitTimeCycle: String?

    public var waitTimeValue: Int32?

    public var waitingOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRunResult != nil {
            map["DryRunResult"] = self.dryRunResult!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.waitTimeCycle != nil {
            map["WaitTimeCycle"] = self.waitTimeCycle!
        }
        if self.waitTimeValue != nil {
            map["WaitTimeValue"] = self.waitTimeValue!
        }
        if self.waitingOrderId != nil {
            map["WaitingOrderId"] = self.waitingOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRunResult") {
            self.dryRunResult = dict["DryRunResult"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WaitTimeCycle") {
            self.waitTimeCycle = dict["WaitTimeCycle"] as! String
        }
        if dict.keys.contains("WaitTimeValue") {
            self.waitTimeValue = dict["WaitTimeValue"] as! Int32
        }
        if dict.keys.contains("WaitingOrderId") {
            self.waitingOrderId = dict["WaitingOrderId"] as! String
        }
    }
}

public class CreateWaitingOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateWaitingOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateWaitingOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDedicatedHostClusterRequest : Tea.TeaModel {
    public var dedicatedHostClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDedicatedHostClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDedicatedHostClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDedicatedHostClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDedicatedHostClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEniQosGroupRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var qosGroupName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosGroupName != nil {
            map["QosGroupName"] = self.qosGroupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosGroupName") {
            self.qosGroupName = dict["QosGroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteEniQosGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEniQosGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEniQosGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteEniQosGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImageCacheRequest : Tea.TeaModel {
    public var clientToken: String?

    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DeleteImageCacheResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteImageCacheResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageCacheResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteImageCacheResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMigratableInstancesRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteMigratableInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMigratableInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMigratableInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMigratableInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkInsightsAnalysisRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var networkInsightsAnalysisId: [String]?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkInsightsAnalysisId != nil {
            map["NetworkInsightsAnalysisId"] = self.networkInsightsAnalysisId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkInsightsAnalysisId") {
            self.networkInsightsAnalysisId = dict["NetworkInsightsAnalysisId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteNetworkInsightsAnalysisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkInsightsAnalysisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkInsightsAnalysisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkInsightsAnalysisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkInsightsPathRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var networkInsightsPathId: [String]?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkInsightsPathId != nil {
            map["NetworkInsightsPathId"] = self.networkInsightsPathId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkInsightsPathId") {
            self.networkInsightsPathId = dict["NetworkInsightsPathId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteNetworkInsightsPathResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkInsightsPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkInsightsPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkInsightsPathResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteReservationDemandRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var demandId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var tag: [DeleteReservationDemandRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demandId != nil {
            map["DemandId"] = self.demandId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemandId") {
            self.demandId = dict["DemandId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DeleteReservationDemandRequest.Tag]
        }
    }
}

public class DeleteReservationDemandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteReservationDemandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteReservationDemandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteReservationDemandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStorageSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
    }
}

public class DeleteStorageSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteStorageSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStorageSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteStorageSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteUserQuotaApplicationRequest : Tea.TeaModel {
    public var applicationId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationId") {
            self.applicationId = dict["ApplicationId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteUserQuotaApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteUserQuotaApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserQuotaApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteUserQuotaApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWaitingOrdersRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceGroupId: Int64?

    public var waitingOrderId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.waitingOrderId != nil {
            map["WaitingOrderId"] = self.waitingOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! Int64
        }
        if dict.keys.contains("WaitingOrderId") {
            self.waitingOrderId = dict["WaitingOrderId"] as! [String]
        }
    }
}

public class DeleteWaitingOrdersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteWaitingOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWaitingOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWaitingOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccountAttributesRequest : Tea.TeaModel {
    public var attributeName: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeName != nil {
            map["AttributeName"] = self.attributeName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttributeName") {
            self.attributeName = dict["AttributeName"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeAccountAttributesResponseBody : Tea.TeaModel {
    public class AccountAttributeItems : Tea.TeaModel {
        public class AccountAttributeItem : Tea.TeaModel {
            public class AttributeValues : Tea.TeaModel {
                public class ValueItem : Tea.TeaModel {
                    public var count: Int32?

                    public var diskCategory: String?

                    public var expiredTime: String?

                    public var instanceChargeType: String?

                    public var instanceType: String?

                    public var value: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.diskCategory != nil {
                            map["DiskCategory"] = self.diskCategory!
                        }
                        if self.expiredTime != nil {
                            map["ExpiredTime"] = self.expiredTime!
                        }
                        if self.instanceChargeType != nil {
                            map["InstanceChargeType"] = self.instanceChargeType!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("DiskCategory") {
                            self.diskCategory = dict["DiskCategory"] as! String
                        }
                        if dict.keys.contains("ExpiredTime") {
                            self.expiredTime = dict["ExpiredTime"] as! String
                        }
                        if dict.keys.contains("InstanceChargeType") {
                            self.instanceChargeType = dict["InstanceChargeType"] as! String
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                        if dict.keys.contains("ZoneId") {
                            self.zoneId = dict["ZoneId"] as! String
                        }
                    }
                }
                public var valueItem: [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues.ValueItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.valueItem != nil {
                        var tmp : [Any] = []
                        for k in self.valueItem! {
                            tmp.append(k.toMap())
                        }
                        map["ValueItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ValueItem") {
                        self.valueItem = dict["ValueItem"] as! [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues.ValueItem]
                    }
                }
            }
            public var attributeName: String?

            public var attributeValues: DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.attributeValues?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attributeName != nil {
                    map["AttributeName"] = self.attributeName!
                }
                if self.attributeValues != nil {
                    map["AttributeValues"] = self.attributeValues?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AttributeName") {
                    self.attributeName = dict["AttributeName"] as! String
                }
                if dict.keys.contains("AttributeValues") {
                    var model = DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues()
                    model.fromMap(dict["AttributeValues"] as! [String: Any])
                    self.attributeValues = model
                }
            }
        }
        public var accountAttributeItem: [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountAttributeItem != nil {
                var tmp : [Any] = []
                for k in self.accountAttributeItem! {
                    tmp.append(k.toMap())
                }
                map["AccountAttributeItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountAttributeItem") {
                self.accountAttributeItem = dict["AccountAttributeItem"] as! [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem]
            }
        }
    }
    public var accountAttributeItems: DescribeAccountAttributesResponseBody.AccountAttributeItems?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountAttributeItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountAttributeItems != nil {
            map["AccountAttributeItems"] = self.accountAttributeItems?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountAttributeItems") {
            var model = DescribeAccountAttributesResponseBody.AccountAttributeItems()
            model.fromMap(dict["AccountAttributeItems"] as! [String: Any])
            self.accountAttributeItems = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAccountAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAccountAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccountLimitsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var filter: [DescribeAccountLimitsRequest.Filter]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            self.filter = dict["Filter"] as! [DescribeAccountLimitsRequest.Filter]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeAccountLimitsResponseBody : Tea.TeaModel {
    public class AccountLimitTypeSet : Tea.TeaModel {
        public class AccountLimit : Tea.TeaModel {
            public class LimitValueSet : Tea.TeaModel {
                public var limitValue: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.limitValue != nil {
                        map["LimitValue"] = self.limitValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LimitValue") {
                        self.limitValue = dict["LimitValue"] as! [String]
                    }
                }
            }
            public var limitName: String?

            public var limitValueSet: DescribeAccountLimitsResponseBody.AccountLimitTypeSet.AccountLimit.LimitValueSet?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.limitValueSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.limitName != nil {
                    map["LimitName"] = self.limitName!
                }
                if self.limitValueSet != nil {
                    map["LimitValueSet"] = self.limitValueSet?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LimitName") {
                    self.limitName = dict["LimitName"] as! String
                }
                if dict.keys.contains("LimitValueSet") {
                    var model = DescribeAccountLimitsResponseBody.AccountLimitTypeSet.AccountLimit.LimitValueSet()
                    model.fromMap(dict["LimitValueSet"] as! [String: Any])
                    self.limitValueSet = model
                }
            }
        }
        public var accountLimit: [DescribeAccountLimitsResponseBody.AccountLimitTypeSet.AccountLimit]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountLimit != nil {
                var tmp : [Any] = []
                for k in self.accountLimit! {
                    tmp.append(k.toMap())
                }
                map["AccountLimit"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountLimit") {
                self.accountLimit = dict["AccountLimit"] as! [DescribeAccountLimitsResponseBody.AccountLimitTypeSet.AccountLimit]
            }
        }
    }
    public var accountLimitTypeSet: DescribeAccountLimitsResponseBody.AccountLimitTypeSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountLimitTypeSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountLimitTypeSet != nil {
            map["AccountLimitTypeSet"] = self.accountLimitTypeSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountLimitTypeSet") {
            var model = DescribeAccountLimitsResponseBody.AccountLimitTypeSet()
            model.fromMap(dict["AccountLimitTypeSet"] as! [String: Any])
            self.accountLimitTypeSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAccountLimitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountLimitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAccountLimitsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccountQuotaAttributesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeAccountQuotaAttributesResponseBody : Tea.TeaModel {
    public class QuotaAttributes : Tea.TeaModel {
        public var ecsElasticQuotaEnable: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecsElasticQuotaEnable != nil {
                map["EcsElasticQuotaEnable"] = self.ecsElasticQuotaEnable!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EcsElasticQuotaEnable") {
                self.ecsElasticQuotaEnable = dict["EcsElasticQuotaEnable"] as! Bool
            }
        }
    }
    public var quotaAttributes: DescribeAccountQuotaAttributesResponseBody.QuotaAttributes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.quotaAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.quotaAttributes != nil {
            map["QuotaAttributes"] = self.quotaAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QuotaAttributes") {
            var model = DescribeAccountQuotaAttributesResponseBody.QuotaAttributes()
            model.fromMap(dict["QuotaAttributes"] as! [String: Any])
            self.quotaAttributes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAccountQuotaAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountQuotaAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAccountQuotaAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoProvisioningGroupCapacitiesRequest : Tea.TeaModel {
    public var autoProvisioningGroupId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoProvisioningGroupId") {
            self.autoProvisioningGroupId = dict["AutoProvisioningGroupId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeAutoProvisioningGroupCapacitiesResponseBody : Tea.TeaModel {
    public class Capacities : Tea.TeaModel {
        public class Capacity : Tea.TeaModel {
            public var autoProvisioningGroupId: String?

            public var payAsYouGoCapacity: String?

            public var spotCapacity: String?

            public var totalCapacity: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoProvisioningGroupId != nil {
                    map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
                }
                if self.payAsYouGoCapacity != nil {
                    map["PayAsYouGoCapacity"] = self.payAsYouGoCapacity!
                }
                if self.spotCapacity != nil {
                    map["SpotCapacity"] = self.spotCapacity!
                }
                if self.totalCapacity != nil {
                    map["TotalCapacity"] = self.totalCapacity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoProvisioningGroupId") {
                    self.autoProvisioningGroupId = dict["AutoProvisioningGroupId"] as! String
                }
                if dict.keys.contains("PayAsYouGoCapacity") {
                    self.payAsYouGoCapacity = dict["PayAsYouGoCapacity"] as! String
                }
                if dict.keys.contains("SpotCapacity") {
                    self.spotCapacity = dict["SpotCapacity"] as! String
                }
                if dict.keys.contains("TotalCapacity") {
                    self.totalCapacity = dict["TotalCapacity"] as! String
                }
            }
        }
        public var capacity: [DescribeAutoProvisioningGroupCapacitiesResponseBody.Capacities.Capacity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacity != nil {
                var tmp : [Any] = []
                for k in self.capacity! {
                    tmp.append(k.toMap())
                }
                map["Capacity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Capacity") {
                self.capacity = dict["Capacity"] as! [DescribeAutoProvisioningGroupCapacitiesResponseBody.Capacities.Capacity]
            }
        }
    }
    public var capacities: DescribeAutoProvisioningGroupCapacitiesResponseBody.Capacities?

    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacities?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacities != nil {
            map["Capacities"] = self.capacities?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Capacities") {
            var model = DescribeAutoProvisioningGroupCapacitiesResponseBody.Capacities()
            model.fromMap(dict["Capacities"] as! [String: Any])
            self.capacities = model
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAutoProvisioningGroupCapacitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoProvisioningGroupCapacitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAutoProvisioningGroupCapacitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBandwidthPriceRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priceUnit: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var verbose: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priceUnit != nil {
            map["PriceUnit"] = self.priceUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.verbose != nil {
            map["Verbose"] = self.verbose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PriceUnit") {
            self.priceUnit = dict["PriceUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Verbose") {
            self.verbose = dict["Verbose"] as! Bool
        }
    }
}

public class DescribeBandwidthPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Order : Tea.TeaModel {
            public class RuleIdSet : Tea.TeaModel {
                public var ruleId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! [String]
                    }
                }
            }
            public var currency: String?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var ruleIdSet: DescribeBandwidthPriceResponseBody.PriceInfo.Order.RuleIdSet?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ruleIdSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.ruleIdSet != nil {
                    map["RuleIdSet"] = self.ruleIdSet?.toMap()
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("RuleIdSet") {
                    var model = DescribeBandwidthPriceResponseBody.PriceInfo.Order.RuleIdSet()
                    model.fromMap(dict["RuleIdSet"] as! [String: Any])
                    self.ruleIdSet = model
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var name: String?

                public var ruleId: Int64?

                public var title: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! Int64
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                }
            }
            public var rule: [DescribeBandwidthPriceResponseBody.PriceInfo.Rules.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Rule") {
                    self.rule = dict["Rule"] as! [DescribeBandwidthPriceResponseBody.PriceInfo.Rules.Rule]
                }
            }
        }
        public var order: DescribeBandwidthPriceResponseBody.PriceInfo.Order?

        public var rules: DescribeBandwidthPriceResponseBody.PriceInfo.Rules?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.order?.validate()
            try self.rules?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.order != nil {
                map["Order"] = self.order?.toMap()
            }
            if self.rules != nil {
                map["Rules"] = self.rules?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Order") {
                var model = DescribeBandwidthPriceResponseBody.PriceInfo.Order()
                model.fromMap(dict["Order"] as! [String: Any])
                self.order = model
            }
            if dict.keys.contains("Rules") {
                var model = DescribeBandwidthPriceResponseBody.PriceInfo.Rules()
                model.fromMap(dict["Rules"] as! [String: Any])
                self.rules = model
            }
        }
    }
    public var priceInfo: DescribeBandwidthPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribeBandwidthPriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBandwidthPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandwidthPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBandwidthPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCapacityReservationsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var capacityReservationIds: String?

    public var capacityReservationName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeCapacityReservationsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationIds != nil {
            map["CapacityReservationIds"] = self.capacityReservationIds!
        }
        if self.capacityReservationName != nil {
            map["CapacityReservationName"] = self.capacityReservationName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CapacityReservationIds") {
            self.capacityReservationIds = dict["CapacityReservationIds"] as! String
        }
        if dict.keys.contains("CapacityReservationName") {
            self.capacityReservationName = dict["CapacityReservationName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeCapacityReservationsRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeCapacityReservationsResponseBody : Tea.TeaModel {
    public class CapacityReservations : Tea.TeaModel {
        public class CapacityReservation : Tea.TeaModel {
            public var availableInstanceCount: Int32?

            public var capacityReservationId: String?

            public var capacityReservationName: String?

            public var description_: String?

            public var endDateType: String?

            public var instanceMatchCriteria: String?

            public var instancePlatform: String?

            public var instanceType: String?

            public var networkType: String?

            public var regionId: String?

            public var status: String?

            public var timeSlot: String?

            public var totalInstanceCount: Int32?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableInstanceCount != nil {
                    map["AvailableInstanceCount"] = self.availableInstanceCount!
                }
                if self.capacityReservationId != nil {
                    map["CapacityReservationId"] = self.capacityReservationId!
                }
                if self.capacityReservationName != nil {
                    map["CapacityReservationName"] = self.capacityReservationName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endDateType != nil {
                    map["EndDateType"] = self.endDateType!
                }
                if self.instanceMatchCriteria != nil {
                    map["InstanceMatchCriteria"] = self.instanceMatchCriteria!
                }
                if self.instancePlatform != nil {
                    map["InstancePlatform"] = self.instancePlatform!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeSlot != nil {
                    map["TimeSlot"] = self.timeSlot!
                }
                if self.totalInstanceCount != nil {
                    map["TotalInstanceCount"] = self.totalInstanceCount!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableInstanceCount") {
                    self.availableInstanceCount = dict["AvailableInstanceCount"] as! Int32
                }
                if dict.keys.contains("CapacityReservationId") {
                    self.capacityReservationId = dict["CapacityReservationId"] as! String
                }
                if dict.keys.contains("CapacityReservationName") {
                    self.capacityReservationName = dict["CapacityReservationName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndDateType") {
                    self.endDateType = dict["EndDateType"] as! String
                }
                if dict.keys.contains("InstanceMatchCriteria") {
                    self.instanceMatchCriteria = dict["InstanceMatchCriteria"] as! String
                }
                if dict.keys.contains("InstancePlatform") {
                    self.instancePlatform = dict["InstancePlatform"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeSlot") {
                    self.timeSlot = dict["TimeSlot"] as! String
                }
                if dict.keys.contains("TotalInstanceCount") {
                    self.totalInstanceCount = dict["TotalInstanceCount"] as! Int32
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var capacityReservation: [DescribeCapacityReservationsResponseBody.CapacityReservations.CapacityReservation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacityReservation != nil {
                var tmp : [Any] = []
                for k in self.capacityReservation! {
                    tmp.append(k.toMap())
                }
                map["CapacityReservation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CapacityReservation") {
                self.capacityReservation = dict["CapacityReservation"] as! [DescribeCapacityReservationsResponseBody.CapacityReservations.CapacityReservation]
            }
        }
    }
    public var capacityReservations: DescribeCapacityReservationsResponseBody.CapacityReservations?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacityReservations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservations != nil {
            map["CapacityReservations"] = self.capacityReservations?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CapacityReservations") {
            var model = DescribeCapacityReservationsResponseBody.CapacityReservations()
            model.fromMap(dict["CapacityReservations"] as! [String: Any])
            self.capacityReservations = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeCapacityReservationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCapacityReservationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCapacityReservationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomerIssueCategoryRequest : Tea.TeaModel {
    public var layer: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.layer != nil {
            map["Layer"] = self.layer!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Layer") {
            self.layer = dict["Layer"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCustomerIssueCategoryResponseBody : Tea.TeaModel {
    public class IssueCategoryModelList : Tea.TeaModel {
        public var issueCategoryId: Int64?

        public var issueCategoryName: String?

        public var issueCategoryParentId: Int64?

        public var layer: Int64?

        public var mappingTools: String?

        public var metricSetId: String?

        public var resourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.issueCategoryId != nil {
                map["IssueCategoryId"] = self.issueCategoryId!
            }
            if self.issueCategoryName != nil {
                map["IssueCategoryName"] = self.issueCategoryName!
            }
            if self.issueCategoryParentId != nil {
                map["IssueCategoryParentId"] = self.issueCategoryParentId!
            }
            if self.layer != nil {
                map["Layer"] = self.layer!
            }
            if self.mappingTools != nil {
                map["MappingTools"] = self.mappingTools!
            }
            if self.metricSetId != nil {
                map["MetricSetId"] = self.metricSetId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IssueCategoryId") {
                self.issueCategoryId = dict["IssueCategoryId"] as! Int64
            }
            if dict.keys.contains("IssueCategoryName") {
                self.issueCategoryName = dict["IssueCategoryName"] as! String
            }
            if dict.keys.contains("IssueCategoryParentId") {
                self.issueCategoryParentId = dict["IssueCategoryParentId"] as! Int64
            }
            if dict.keys.contains("Layer") {
                self.layer = dict["Layer"] as! Int64
            }
            if dict.keys.contains("MappingTools") {
                self.mappingTools = dict["MappingTools"] as! String
            }
            if dict.keys.contains("MetricSetId") {
                self.metricSetId = dict["MetricSetId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
        }
    }
    public var issueCategoryModelList: [DescribeCustomerIssueCategoryResponseBody.IssueCategoryModelList]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.issueCategoryModelList != nil {
            var tmp : [Any] = []
            for k in self.issueCategoryModelList! {
                tmp.append(k.toMap())
            }
            map["IssueCategoryModelList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IssueCategoryModelList") {
            self.issueCategoryModelList = dict["IssueCategoryModelList"] as! [DescribeCustomerIssueCategoryResponseBody.IssueCategoryModelList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCustomerIssueCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomerIssueCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCustomerIssueCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedHostAutoRenewRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeDedicatedHostAutoRenewResponseBody : Tea.TeaModel {
    public class InstanceRenewAttributes : Tea.TeaModel {
        public class InstanceRenewAttribute : Tea.TeaModel {
            public var autoRenewEnabled: Bool?

            public var duration: Int32?

            public var instanceId: String?

            public var periodUnit: String?

            public var renewalStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewEnabled != nil {
                    map["AutoRenewEnabled"] = self.autoRenewEnabled!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.renewalStatus != nil {
                    map["RenewalStatus"] = self.renewalStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoRenewEnabled") {
                    self.autoRenewEnabled = dict["AutoRenewEnabled"] as! Bool
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PeriodUnit") {
                    self.periodUnit = dict["PeriodUnit"] as! String
                }
                if dict.keys.contains("RenewalStatus") {
                    self.renewalStatus = dict["RenewalStatus"] as! String
                }
            }
        }
        public var instanceRenewAttribute: [DescribeDedicatedHostAutoRenewResponseBody.InstanceRenewAttributes.InstanceRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.instanceRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["InstanceRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceRenewAttribute") {
                self.instanceRenewAttribute = dict["InstanceRenewAttribute"] as! [DescribeDedicatedHostAutoRenewResponseBody.InstanceRenewAttributes.InstanceRenewAttribute]
            }
        }
    }
    public var instanceRenewAttributes: DescribeDedicatedHostAutoRenewResponseBody.InstanceRenewAttributes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRenewAttributes != nil {
            map["InstanceRenewAttributes"] = self.instanceRenewAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRenewAttributes") {
            var model = DescribeDedicatedHostAutoRenewResponseBody.InstanceRenewAttributes()
            model.fromMap(dict["InstanceRenewAttributes"] as! [String: Any])
            self.instanceRenewAttributes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDedicatedHostAutoRenewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostAutoRenewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedHostAutoRenewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedHostClustersRequest : Tea.TeaModel {
    public class SchedulerOptions : Tea.TeaModel {
        public var managedPrivateSpaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.managedPrivateSpaceId != nil {
                map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ManagedPrivateSpaceId") {
                self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var schedulerOptions: DescribeDedicatedHostClustersRequest.SchedulerOptions?

    public var dedicatedHostClusterIds: String?

    public var dedicatedHostClusterName: String?

    public var lockReason: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeDedicatedHostClustersRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.schedulerOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.dedicatedHostClusterIds != nil {
            map["DedicatedHostClusterIds"] = self.dedicatedHostClusterIds!
        }
        if self.dedicatedHostClusterName != nil {
            map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SchedulerOptions") {
            var model = DescribeDedicatedHostClustersRequest.SchedulerOptions()
            model.fromMap(dict["SchedulerOptions"] as! [String: Any])
            self.schedulerOptions = model
        }
        if dict.keys.contains("DedicatedHostClusterIds") {
            self.dedicatedHostClusterIds = dict["DedicatedHostClusterIds"] as! String
        }
        if dict.keys.contains("DedicatedHostClusterName") {
            self.dedicatedHostClusterName = dict["DedicatedHostClusterName"] as! String
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeDedicatedHostClustersRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeDedicatedHostClustersResponseBody : Tea.TeaModel {
    public class DedicatedHostClusters : Tea.TeaModel {
        public class DedicatedHostCluster : Tea.TeaModel {
            public class SchedulerOptions : Tea.TeaModel {
                public var managedPrivateSpaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.managedPrivateSpaceId != nil {
                        map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ManagedPrivateSpaceId") {
                        self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
                    }
                }
            }
            public class DedicatedHostClusterCapacity : Tea.TeaModel {
                public class AvailableInstanceTypes : Tea.TeaModel {
                    public class AvailableInstanceType : Tea.TeaModel {
                        public var availableInstanceCapacity: Int32?

                        public var instanceType: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableInstanceCapacity != nil {
                                map["AvailableInstanceCapacity"] = self.availableInstanceCapacity!
                            }
                            if self.instanceType != nil {
                                map["InstanceType"] = self.instanceType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AvailableInstanceCapacity") {
                                self.availableInstanceCapacity = dict["AvailableInstanceCapacity"] as! Int32
                            }
                            if dict.keys.contains("InstanceType") {
                                self.instanceType = dict["InstanceType"] as! String
                            }
                        }
                    }
                    public var availableInstanceType: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes.AvailableInstanceType]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableInstanceType != nil {
                            var tmp : [Any] = []
                            for k in self.availableInstanceType! {
                                tmp.append(k.toMap())
                            }
                            map["AvailableInstanceType"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AvailableInstanceType") {
                            self.availableInstanceType = dict["AvailableInstanceType"] as! [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes.AvailableInstanceType]
                        }
                    }
                }
                public class LocalStorageCapacities : Tea.TeaModel {
                    public class LocalStorageCapacity : Tea.TeaModel {
                        public var availableDisk: Int32?

                        public var dataDiskCategory: String?

                        public var totalDisk: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableDisk != nil {
                                map["AvailableDisk"] = self.availableDisk!
                            }
                            if self.dataDiskCategory != nil {
                                map["DataDiskCategory"] = self.dataDiskCategory!
                            }
                            if self.totalDisk != nil {
                                map["TotalDisk"] = self.totalDisk!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AvailableDisk") {
                                self.availableDisk = dict["AvailableDisk"] as! Int32
                            }
                            if dict.keys.contains("DataDiskCategory") {
                                self.dataDiskCategory = dict["DataDiskCategory"] as! String
                            }
                            if dict.keys.contains("TotalDisk") {
                                self.totalDisk = dict["TotalDisk"] as! Int32
                            }
                        }
                    }
                    public var localStorageCapacity: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities.LocalStorageCapacity]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.localStorageCapacity != nil {
                            var tmp : [Any] = []
                            for k in self.localStorageCapacity! {
                                tmp.append(k.toMap())
                            }
                            map["LocalStorageCapacity"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LocalStorageCapacity") {
                            self.localStorageCapacity = dict["LocalStorageCapacity"] as! [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities.LocalStorageCapacity]
                        }
                    }
                }
                public var availableInstanceTypes: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes?

                public var availableMemory: Int32?

                public var availableVcpus: Int32?

                public var localStorageCapacities: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities?

                public var totalMemory: Int32?

                public var totalVcpus: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.availableInstanceTypes?.validate()
                    try self.localStorageCapacities?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableInstanceTypes != nil {
                        map["AvailableInstanceTypes"] = self.availableInstanceTypes?.toMap()
                    }
                    if self.availableMemory != nil {
                        map["AvailableMemory"] = self.availableMemory!
                    }
                    if self.availableVcpus != nil {
                        map["AvailableVcpus"] = self.availableVcpus!
                    }
                    if self.localStorageCapacities != nil {
                        map["LocalStorageCapacities"] = self.localStorageCapacities?.toMap()
                    }
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.totalVcpus != nil {
                        map["TotalVcpus"] = self.totalVcpus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableInstanceTypes") {
                        var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes()
                        model.fromMap(dict["AvailableInstanceTypes"] as! [String: Any])
                        self.availableInstanceTypes = model
                    }
                    if dict.keys.contains("AvailableMemory") {
                        self.availableMemory = dict["AvailableMemory"] as! Int32
                    }
                    if dict.keys.contains("AvailableVcpus") {
                        self.availableVcpus = dict["AvailableVcpus"] as! Int32
                    }
                    if dict.keys.contains("LocalStorageCapacities") {
                        var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities()
                        model.fromMap(dict["LocalStorageCapacities"] as! [String: Any])
                        self.localStorageCapacities = model
                    }
                    if dict.keys.contains("TotalMemory") {
                        self.totalMemory = dict["TotalMemory"] as! Int32
                    }
                    if dict.keys.contains("TotalVcpus") {
                        self.totalVcpus = dict["TotalVcpus"] as! Int32
                    }
                }
            }
            public class DedicatedHostIds : Tea.TeaModel {
                public var dedicatedHostId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dedicatedHostId != nil {
                        map["DedicatedHostId"] = self.dedicatedHostId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DedicatedHostId") {
                        self.dedicatedHostId = dict["DedicatedHostId"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags.Tag]
                    }
                }
            }
            public var schedulerOptions: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.SchedulerOptions?

            public var dedicatedHostClusterCapacity: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity?

            public var dedicatedHostClusterId: String?

            public var dedicatedHostClusterName: String?

            public var dedicatedHostIds: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostIds?

            public var description_: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var tags: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.validateRequired(self.schedulerOptions, "schedulerOptions")
                try self.schedulerOptions?.validate()
                try self.dedicatedHostClusterCapacity?.validate()
                try self.dedicatedHostIds?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulerOptions != nil {
                    map["SchedulerOptions"] = self.schedulerOptions?.toMap()
                }
                if self.dedicatedHostClusterCapacity != nil {
                    map["DedicatedHostClusterCapacity"] = self.dedicatedHostClusterCapacity?.toMap()
                }
                if self.dedicatedHostClusterId != nil {
                    map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
                }
                if self.dedicatedHostClusterName != nil {
                    map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
                }
                if self.dedicatedHostIds != nil {
                    map["DedicatedHostIds"] = self.dedicatedHostIds?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SchedulerOptions") {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.SchedulerOptions()
                    model.fromMap(dict["SchedulerOptions"] as! [String: Any])
                    self.schedulerOptions = model
                }
                if dict.keys.contains("DedicatedHostClusterCapacity") {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity()
                    model.fromMap(dict["DedicatedHostClusterCapacity"] as! [String: Any])
                    self.dedicatedHostClusterCapacity = model
                }
                if dict.keys.contains("DedicatedHostClusterId") {
                    self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
                }
                if dict.keys.contains("DedicatedHostClusterName") {
                    self.dedicatedHostClusterName = dict["DedicatedHostClusterName"] as! String
                }
                if dict.keys.contains("DedicatedHostIds") {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostIds()
                    model.fromMap(dict["DedicatedHostIds"] as! [String: Any])
                    self.dedicatedHostIds = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var dedicatedHostCluster: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostCluster != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHostCluster! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHostCluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostCluster") {
                self.dedicatedHostCluster = dict["DedicatedHostCluster"] as! [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster]
            }
        }
    }
    public var dedicatedHostClusters: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostClusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusters != nil {
            map["DedicatedHostClusters"] = self.dedicatedHostClusters?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusters") {
            var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters()
            model.fromMap(dict["DedicatedHostClusters"] as! [String: Any])
            self.dedicatedHostClusters = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDedicatedHostClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedHostClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedHostTypesRequest : Tea.TeaModel {
    public var dedicatedHostType: String?

    public var generation: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var supportInstanceTypeFamily: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.generation != nil {
            map["Generation"] = self.generation!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.supportInstanceTypeFamily != nil {
            map["SupportInstanceTypeFamily"] = self.supportInstanceTypeFamily!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostType") {
            self.dedicatedHostType = dict["DedicatedHostType"] as! String
        }
        if dict.keys.contains("Generation") {
            self.generation = dict["Generation"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SupportInstanceTypeFamily") {
            self.supportInstanceTypeFamily = dict["SupportInstanceTypeFamily"] as! String
        }
    }
}

public class DescribeDedicatedHostTypesResponseBody : Tea.TeaModel {
    public class DedicatedHostTypes : Tea.TeaModel {
        public class DedicatedHostType : Tea.TeaModel {
            public class SupportInstanceTypeFamilies : Tea.TeaModel {
                public var supportInstanceTypeFamily: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportInstanceTypeFamily != nil {
                        map["SupportInstanceTypeFamily"] = self.supportInstanceTypeFamily!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportInstanceTypeFamily") {
                        self.supportInstanceTypeFamily = dict["SupportInstanceTypeFamily"] as! [String]
                    }
                }
            }
            public class SupportInstanceTypesList : Tea.TeaModel {
                public var supportInstanceTypesList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportInstanceTypesList != nil {
                        map["SupportInstanceTypesList"] = self.supportInstanceTypesList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportInstanceTypesList") {
                        self.supportInstanceTypesList = dict["SupportInstanceTypesList"] as! [String]
                    }
                }
            }
            public var cpuOverCommitRatioRange: String?

            public var dedicatedHostType: String?

            public var GPUSpec: String?

            public var generation: String?

            public var localStorageAmount: Int32?

            public var localStorageCapacity: Int64?

            public var localStorageCategory: String?

            public var memorySize: Double?

            public var physicalGpus: Int32?

            public var supportCpuOverCommitRatio: Bool?

            public var supportInstanceTypeFamilies: DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportInstanceTypeFamilies?

            public var supportInstanceTypesList: DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportInstanceTypesList?

            public var totalPhysicalCores: Int32?

            public var totalSockets: Int32?

            public var totalVcpus: Int32?

            public var totalVgpus: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.supportInstanceTypeFamilies?.validate()
                try self.supportInstanceTypesList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuOverCommitRatioRange != nil {
                    map["CpuOverCommitRatioRange"] = self.cpuOverCommitRatioRange!
                }
                if self.dedicatedHostType != nil {
                    map["DedicatedHostType"] = self.dedicatedHostType!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.generation != nil {
                    map["Generation"] = self.generation!
                }
                if self.localStorageAmount != nil {
                    map["LocalStorageAmount"] = self.localStorageAmount!
                }
                if self.localStorageCapacity != nil {
                    map["LocalStorageCapacity"] = self.localStorageCapacity!
                }
                if self.localStorageCategory != nil {
                    map["LocalStorageCategory"] = self.localStorageCategory!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                if self.physicalGpus != nil {
                    map["PhysicalGpus"] = self.physicalGpus!
                }
                if self.supportCpuOverCommitRatio != nil {
                    map["SupportCpuOverCommitRatio"] = self.supportCpuOverCommitRatio!
                }
                if self.supportInstanceTypeFamilies != nil {
                    map["SupportInstanceTypeFamilies"] = self.supportInstanceTypeFamilies?.toMap()
                }
                if self.supportInstanceTypesList != nil {
                    map["SupportInstanceTypesList"] = self.supportInstanceTypesList?.toMap()
                }
                if self.totalPhysicalCores != nil {
                    map["TotalPhysicalCores"] = self.totalPhysicalCores!
                }
                if self.totalSockets != nil {
                    map["TotalSockets"] = self.totalSockets!
                }
                if self.totalVcpus != nil {
                    map["TotalVcpus"] = self.totalVcpus!
                }
                if self.totalVgpus != nil {
                    map["TotalVgpus"] = self.totalVgpus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CpuOverCommitRatioRange") {
                    self.cpuOverCommitRatioRange = dict["CpuOverCommitRatioRange"] as! String
                }
                if dict.keys.contains("DedicatedHostType") {
                    self.dedicatedHostType = dict["DedicatedHostType"] as! String
                }
                if dict.keys.contains("GPUSpec") {
                    self.GPUSpec = dict["GPUSpec"] as! String
                }
                if dict.keys.contains("Generation") {
                    self.generation = dict["Generation"] as! String
                }
                if dict.keys.contains("LocalStorageAmount") {
                    self.localStorageAmount = dict["LocalStorageAmount"] as! Int32
                }
                if dict.keys.contains("LocalStorageCapacity") {
                    self.localStorageCapacity = dict["LocalStorageCapacity"] as! Int64
                }
                if dict.keys.contains("LocalStorageCategory") {
                    self.localStorageCategory = dict["LocalStorageCategory"] as! String
                }
                if dict.keys.contains("MemorySize") {
                    self.memorySize = dict["MemorySize"] as! Double
                }
                if dict.keys.contains("PhysicalGpus") {
                    self.physicalGpus = dict["PhysicalGpus"] as! Int32
                }
                if dict.keys.contains("SupportCpuOverCommitRatio") {
                    self.supportCpuOverCommitRatio = dict["SupportCpuOverCommitRatio"] as! Bool
                }
                if dict.keys.contains("SupportInstanceTypeFamilies") {
                    var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportInstanceTypeFamilies()
                    model.fromMap(dict["SupportInstanceTypeFamilies"] as! [String: Any])
                    self.supportInstanceTypeFamilies = model
                }
                if dict.keys.contains("SupportInstanceTypesList") {
                    var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportInstanceTypesList()
                    model.fromMap(dict["SupportInstanceTypesList"] as! [String: Any])
                    self.supportInstanceTypesList = model
                }
                if dict.keys.contains("TotalPhysicalCores") {
                    self.totalPhysicalCores = dict["TotalPhysicalCores"] as! Int32
                }
                if dict.keys.contains("TotalSockets") {
                    self.totalSockets = dict["TotalSockets"] as! Int32
                }
                if dict.keys.contains("TotalVcpus") {
                    self.totalVcpus = dict["TotalVcpus"] as! Int32
                }
                if dict.keys.contains("TotalVgpus") {
                    self.totalVgpus = dict["TotalVgpus"] as! Int32
                }
            }
        }
        public var dedicatedHostType: [DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostType != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHostType! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHostType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostType") {
                self.dedicatedHostType = dict["DedicatedHostType"] as! [DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType]
            }
        }
    }
    public var dedicatedHostTypes: DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostTypes != nil {
            map["DedicatedHostTypes"] = self.dedicatedHostTypes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostTypes") {
            var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes()
            model.fromMap(dict["DedicatedHostTypes"] as! [String: Any])
            self.dedicatedHostTypes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDedicatedHostTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedHostTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedHostsRequest : Tea.TeaModel {
    public class SchedulerOptions : Tea.TeaModel {
        public var managedPrivateSpaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.managedPrivateSpaceId != nil {
                map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ManagedPrivateSpaceId") {
                self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var schedulerOptions: DescribeDedicatedHostsRequest.SchedulerOptions?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostIds: String?

    public var dedicatedHostName: String?

    public var dedicatedHostType: String?

    public var lockReason: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeDedicatedHostsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.schedulerOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.dedicatedHostName != nil {
            map["DedicatedHostName"] = self.dedicatedHostName!
        }
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SchedulerOptions") {
            var model = DescribeDedicatedHostsRequest.SchedulerOptions()
            model.fromMap(dict["SchedulerOptions"] as! [String: Any])
            self.schedulerOptions = model
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostIds") {
            self.dedicatedHostIds = dict["DedicatedHostIds"] as! String
        }
        if dict.keys.contains("DedicatedHostName") {
            self.dedicatedHostName = dict["DedicatedHostName"] as! String
        }
        if dict.keys.contains("DedicatedHostType") {
            self.dedicatedHostType = dict["DedicatedHostType"] as! String
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeDedicatedHostsRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeDedicatedHostsResponseBody : Tea.TeaModel {
    public class DedicatedHosts : Tea.TeaModel {
        public class DedicatedHost : Tea.TeaModel {
            public class SchedulerOptions : Tea.TeaModel {
                public var managedPrivateSpaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.managedPrivateSpaceId != nil {
                        map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ManagedPrivateSpaceId") {
                        self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
                    }
                }
            }
            public class Capacity : Tea.TeaModel {
                public var availableLocalStorage: Int32?

                public var availableMemory: Double?

                public var availableVcpus: Int32?

                public var availableVgpus: Int32?

                public var localStorageCategory: String?

                public var totalLocalStorage: Int32?

                public var totalMemory: Double?

                public var totalVcpus: Int32?

                public var totalVgpus: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableLocalStorage != nil {
                        map["AvailableLocalStorage"] = self.availableLocalStorage!
                    }
                    if self.availableMemory != nil {
                        map["AvailableMemory"] = self.availableMemory!
                    }
                    if self.availableVcpus != nil {
                        map["AvailableVcpus"] = self.availableVcpus!
                    }
                    if self.availableVgpus != nil {
                        map["AvailableVgpus"] = self.availableVgpus!
                    }
                    if self.localStorageCategory != nil {
                        map["LocalStorageCategory"] = self.localStorageCategory!
                    }
                    if self.totalLocalStorage != nil {
                        map["TotalLocalStorage"] = self.totalLocalStorage!
                    }
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.totalVcpus != nil {
                        map["TotalVcpus"] = self.totalVcpus!
                    }
                    if self.totalVgpus != nil {
                        map["TotalVgpus"] = self.totalVgpus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableLocalStorage") {
                        self.availableLocalStorage = dict["AvailableLocalStorage"] as! Int32
                    }
                    if dict.keys.contains("AvailableMemory") {
                        self.availableMemory = dict["AvailableMemory"] as! Double
                    }
                    if dict.keys.contains("AvailableVcpus") {
                        self.availableVcpus = dict["AvailableVcpus"] as! Int32
                    }
                    if dict.keys.contains("AvailableVgpus") {
                        self.availableVgpus = dict["AvailableVgpus"] as! Int32
                    }
                    if dict.keys.contains("LocalStorageCategory") {
                        self.localStorageCategory = dict["LocalStorageCategory"] as! String
                    }
                    if dict.keys.contains("TotalLocalStorage") {
                        self.totalLocalStorage = dict["TotalLocalStorage"] as! Int32
                    }
                    if dict.keys.contains("TotalMemory") {
                        self.totalMemory = dict["TotalMemory"] as! Double
                    }
                    if dict.keys.contains("TotalVcpus") {
                        self.totalVcpus = dict["TotalVcpus"] as! Int32
                    }
                    if dict.keys.contains("TotalVgpus") {
                        self.totalVgpus = dict["TotalVgpus"] as! Int32
                    }
                }
            }
            public class HostDetailInfo : Tea.TeaModel {
                public var serialNumber: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serialNumber != nil {
                        map["SerialNumber"] = self.serialNumber!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SerialNumber") {
                        self.serialNumber = dict["SerialNumber"] as! String
                    }
                }
            }
            public class Instances : Tea.TeaModel {
                public class Instance : Tea.TeaModel {
                    public var instanceId: String?

                    public var instanceType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                    }
                }
                public var instance: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances.Instance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instance != nil {
                        var tmp : [Any] = []
                        for k in self.instance! {
                            tmp.append(k.toMap())
                        }
                        map["Instance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Instance") {
                        self.instance = dict["Instance"] as! [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances.Instance]
                    }
                }
            }
            public class NetworkAttributes : Tea.TeaModel {
                public var slbUdpTimeout: Int32?

                public var udpTimeout: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.slbUdpTimeout != nil {
                        map["SlbUdpTimeout"] = self.slbUdpTimeout!
                    }
                    if self.udpTimeout != nil {
                        map["UdpTimeout"] = self.udpTimeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SlbUdpTimeout") {
                        self.slbUdpTimeout = dict["SlbUdpTimeout"] as! Int32
                    }
                    if dict.keys.contains("UdpTimeout") {
                        self.udpTimeout = dict["UdpTimeout"] as! Int32
                    }
                }
            }
            public class OperationLocks : Tea.TeaModel {
                public class OperationLock : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LockReason") {
                            self.lockReason = dict["LockReason"] as! String
                        }
                    }
                }
                public var operationLock: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks.OperationLock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operationLock != nil {
                        var tmp : [Any] = []
                        for k in self.operationLock! {
                            tmp.append(k.toMap())
                        }
                        map["OperationLock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OperationLock") {
                        self.operationLock = dict["OperationLock"] as! [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks.OperationLock]
                    }
                }
            }
            public class SupportInstanceTypeFamilies : Tea.TeaModel {
                public var supportInstanceTypeFamily: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportInstanceTypeFamily != nil {
                        map["SupportInstanceTypeFamily"] = self.supportInstanceTypeFamily!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportInstanceTypeFamily") {
                        self.supportInstanceTypeFamily = dict["SupportInstanceTypeFamily"] as! [String]
                    }
                }
            }
            public class SupportInstanceTypesList : Tea.TeaModel {
                public var supportInstanceTypesList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportInstanceTypesList != nil {
                        map["SupportInstanceTypesList"] = self.supportInstanceTypesList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportInstanceTypesList") {
                        self.supportInstanceTypesList = dict["SupportInstanceTypesList"] as! [String]
                    }
                }
            }
            public class SupportedCustomInstanceTypeFamilies : Tea.TeaModel {
                public var supportedCustomInstanceTypeFamily: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedCustomInstanceTypeFamily != nil {
                        map["SupportedCustomInstanceTypeFamily"] = self.supportedCustomInstanceTypeFamily!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportedCustomInstanceTypeFamily") {
                        self.supportedCustomInstanceTypeFamily = dict["SupportedCustomInstanceTypeFamily"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags.Tag]
                    }
                }
            }
            public var schedulerOptions: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SchedulerOptions?

            public var actionOnMaintenance: String?

            public var autoPlacement: String?

            public var autoReleaseTime: String?

            public var capacity: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity?

            public var chargeType: String?

            public var cpuOverCommitRatio: Double?

            public var creationTime: String?

            public var dedicatedHostClusterId: String?

            public var dedicatedHostId: String?

            public var dedicatedHostName: String?

            public var dedicatedHostType: String?

            public var description_: String?

            public var expiredTime: String?

            public var GPUSpec: String?

            public var hostDetailInfo: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.HostDetailInfo?

            public var instances: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances?

            public var machineId: String?

            public var networkAttributes: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.NetworkAttributes?

            public var operationLocks: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks?

            public var physicalGpus: Int32?

            public var regionId: String?

            public var resourceGroupId: String?

            public var saleCycle: String?

            public var status: String?

            public var supportInstanceTypeFamilies: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportInstanceTypeFamilies?

            public var supportInstanceTypesList: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportInstanceTypesList?

            public var supportedCustomInstanceTypeFamilies: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedCustomInstanceTypeFamilies?

            public var tags: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags?

            public var totalPhysicalCores: Int32?

            public var totalSockets: Int32?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.validateRequired(self.schedulerOptions, "schedulerOptions")
                try self.schedulerOptions?.validate()
                try self.capacity?.validate()
                try self.hostDetailInfo?.validate()
                try self.instances?.validate()
                try self.networkAttributes?.validate()
                try self.operationLocks?.validate()
                try self.supportInstanceTypeFamilies?.validate()
                try self.supportInstanceTypesList?.validate()
                try self.supportedCustomInstanceTypeFamilies?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulerOptions != nil {
                    map["SchedulerOptions"] = self.schedulerOptions?.toMap()
                }
                if self.actionOnMaintenance != nil {
                    map["ActionOnMaintenance"] = self.actionOnMaintenance!
                }
                if self.autoPlacement != nil {
                    map["AutoPlacement"] = self.autoPlacement!
                }
                if self.autoReleaseTime != nil {
                    map["AutoReleaseTime"] = self.autoReleaseTime!
                }
                if self.capacity != nil {
                    map["Capacity"] = self.capacity?.toMap()
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.cpuOverCommitRatio != nil {
                    map["CpuOverCommitRatio"] = self.cpuOverCommitRatio!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.dedicatedHostClusterId != nil {
                    map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
                }
                if self.dedicatedHostId != nil {
                    map["DedicatedHostId"] = self.dedicatedHostId!
                }
                if self.dedicatedHostName != nil {
                    map["DedicatedHostName"] = self.dedicatedHostName!
                }
                if self.dedicatedHostType != nil {
                    map["DedicatedHostType"] = self.dedicatedHostType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.hostDetailInfo != nil {
                    map["HostDetailInfo"] = self.hostDetailInfo?.toMap()
                }
                if self.instances != nil {
                    map["Instances"] = self.instances?.toMap()
                }
                if self.machineId != nil {
                    map["MachineId"] = self.machineId!
                }
                if self.networkAttributes != nil {
                    map["NetworkAttributes"] = self.networkAttributes?.toMap()
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.physicalGpus != nil {
                    map["PhysicalGpus"] = self.physicalGpus!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.saleCycle != nil {
                    map["SaleCycle"] = self.saleCycle!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supportInstanceTypeFamilies != nil {
                    map["SupportInstanceTypeFamilies"] = self.supportInstanceTypeFamilies?.toMap()
                }
                if self.supportInstanceTypesList != nil {
                    map["SupportInstanceTypesList"] = self.supportInstanceTypesList?.toMap()
                }
                if self.supportedCustomInstanceTypeFamilies != nil {
                    map["SupportedCustomInstanceTypeFamilies"] = self.supportedCustomInstanceTypeFamilies?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.totalPhysicalCores != nil {
                    map["TotalPhysicalCores"] = self.totalPhysicalCores!
                }
                if self.totalSockets != nil {
                    map["TotalSockets"] = self.totalSockets!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SchedulerOptions") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SchedulerOptions()
                    model.fromMap(dict["SchedulerOptions"] as! [String: Any])
                    self.schedulerOptions = model
                }
                if dict.keys.contains("ActionOnMaintenance") {
                    self.actionOnMaintenance = dict["ActionOnMaintenance"] as! String
                }
                if dict.keys.contains("AutoPlacement") {
                    self.autoPlacement = dict["AutoPlacement"] as! String
                }
                if dict.keys.contains("AutoReleaseTime") {
                    self.autoReleaseTime = dict["AutoReleaseTime"] as! String
                }
                if dict.keys.contains("Capacity") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity()
                    model.fromMap(dict["Capacity"] as! [String: Any])
                    self.capacity = model
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CpuOverCommitRatio") {
                    self.cpuOverCommitRatio = dict["CpuOverCommitRatio"] as! Double
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DedicatedHostClusterId") {
                    self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
                }
                if dict.keys.contains("DedicatedHostId") {
                    self.dedicatedHostId = dict["DedicatedHostId"] as! String
                }
                if dict.keys.contains("DedicatedHostName") {
                    self.dedicatedHostName = dict["DedicatedHostName"] as! String
                }
                if dict.keys.contains("DedicatedHostType") {
                    self.dedicatedHostType = dict["DedicatedHostType"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("GPUSpec") {
                    self.GPUSpec = dict["GPUSpec"] as! String
                }
                if dict.keys.contains("HostDetailInfo") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.HostDetailInfo()
                    model.fromMap(dict["HostDetailInfo"] as! [String: Any])
                    self.hostDetailInfo = model
                }
                if dict.keys.contains("Instances") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances()
                    model.fromMap(dict["Instances"] as! [String: Any])
                    self.instances = model
                }
                if dict.keys.contains("MachineId") {
                    self.machineId = dict["MachineId"] as! String
                }
                if dict.keys.contains("NetworkAttributes") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.NetworkAttributes()
                    model.fromMap(dict["NetworkAttributes"] as! [String: Any])
                    self.networkAttributes = model
                }
                if dict.keys.contains("OperationLocks") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks()
                    model.fromMap(dict["OperationLocks"] as! [String: Any])
                    self.operationLocks = model
                }
                if dict.keys.contains("PhysicalGpus") {
                    self.physicalGpus = dict["PhysicalGpus"] as! Int32
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SaleCycle") {
                    self.saleCycle = dict["SaleCycle"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SupportInstanceTypeFamilies") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportInstanceTypeFamilies()
                    model.fromMap(dict["SupportInstanceTypeFamilies"] as! [String: Any])
                    self.supportInstanceTypeFamilies = model
                }
                if dict.keys.contains("SupportInstanceTypesList") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportInstanceTypesList()
                    model.fromMap(dict["SupportInstanceTypesList"] as! [String: Any])
                    self.supportInstanceTypesList = model
                }
                if dict.keys.contains("SupportedCustomInstanceTypeFamilies") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedCustomInstanceTypeFamilies()
                    model.fromMap(dict["SupportedCustomInstanceTypeFamilies"] as! [String: Any])
                    self.supportedCustomInstanceTypeFamilies = model
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TotalPhysicalCores") {
                    self.totalPhysicalCores = dict["TotalPhysicalCores"] as! Int32
                }
                if dict.keys.contains("TotalSockets") {
                    self.totalSockets = dict["TotalSockets"] as! Int32
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var dedicatedHost: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHost != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHost! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHost"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHost") {
                self.dedicatedHost = dict["DedicatedHost"] as! [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost]
            }
        }
    }
    public var dedicatedHosts: DescribeDedicatedHostsResponseBody.DedicatedHosts?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHosts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHosts != nil {
            map["DedicatedHosts"] = self.dedicatedHosts?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHosts") {
            var model = DescribeDedicatedHostsResponseBody.DedicatedHosts()
            model.fromMap(dict["DedicatedHosts"] as! [String: Any])
            self.dedicatedHosts = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedHostsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnoseRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var diagnoseAction: String?

    public var diagnoseId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: Int32?

    public var tag: [DescribeDiagnoseRequest.Tag]?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnoseAction != nil {
            map["DiagnoseAction"] = self.diagnoseAction!
        }
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiagnoseAction") {
            self.diagnoseAction = dict["DiagnoseAction"] as! String
        }
        if dict.keys.contains("DiagnoseId") {
            self.diagnoseId = dict["DiagnoseId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeDiagnoseRequest.Tag]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class DescribeDiagnoseResponseBody : Tea.TeaModel {
    public class DiagnoseInstances : Tea.TeaModel {
        public class DiagnoseInstance : Tea.TeaModel {
            public var amount: Int32?

            public var creationTime: String?

            public var diagnoseAction: String?

            public var diagnoseId: String?

            public var diagnoseRequestId: String?

            public var diskCategory: String?

            public var errorCode: String?

            public var expireTime: String?

            public var instanceChargeType: String?

            public var instanceTypeName: String?

            public var izNo: String?

            public var mark: String?

            public var modificationTime: String?

            public var networkType: String?

            public var period: Int32?

            public var periodUnit: String?

            public var product: String?

            public var regionId: String?

            public var solutions: String?

            public var star: Int32?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diagnoseAction != nil {
                    map["DiagnoseAction"] = self.diagnoseAction!
                }
                if self.diagnoseId != nil {
                    map["DiagnoseId"] = self.diagnoseId!
                }
                if self.diagnoseRequestId != nil {
                    map["DiagnoseRequestId"] = self.diagnoseRequestId!
                }
                if self.diskCategory != nil {
                    map["DiskCategory"] = self.diskCategory!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceTypeName != nil {
                    map["InstanceTypeName"] = self.instanceTypeName!
                }
                if self.izNo != nil {
                    map["IzNo"] = self.izNo!
                }
                if self.mark != nil {
                    map["Mark"] = self.mark!
                }
                if self.modificationTime != nil {
                    map["ModificationTime"] = self.modificationTime!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.solutions != nil {
                    map["Solutions"] = self.solutions!
                }
                if self.star != nil {
                    map["Star"] = self.star!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Amount") {
                    self.amount = dict["Amount"] as! Int32
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DiagnoseAction") {
                    self.diagnoseAction = dict["DiagnoseAction"] as! String
                }
                if dict.keys.contains("DiagnoseId") {
                    self.diagnoseId = dict["DiagnoseId"] as! String
                }
                if dict.keys.contains("DiagnoseRequestId") {
                    self.diagnoseRequestId = dict["DiagnoseRequestId"] as! String
                }
                if dict.keys.contains("DiskCategory") {
                    self.diskCategory = dict["DiskCategory"] as! String
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InstanceTypeName") {
                    self.instanceTypeName = dict["InstanceTypeName"] as! String
                }
                if dict.keys.contains("IzNo") {
                    self.izNo = dict["IzNo"] as! String
                }
                if dict.keys.contains("Mark") {
                    self.mark = dict["Mark"] as! String
                }
                if dict.keys.contains("ModificationTime") {
                    self.modificationTime = dict["ModificationTime"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! Int32
                }
                if dict.keys.contains("PeriodUnit") {
                    self.periodUnit = dict["PeriodUnit"] as! String
                }
                if dict.keys.contains("Product") {
                    self.product = dict["Product"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Solutions") {
                    self.solutions = dict["Solutions"] as! String
                }
                if dict.keys.contains("Star") {
                    self.star = dict["Star"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var diagnoseInstance: [DescribeDiagnoseResponseBody.DiagnoseInstances.DiagnoseInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diagnoseInstance != nil {
                var tmp : [Any] = []
                for k in self.diagnoseInstance! {
                    tmp.append(k.toMap())
                }
                map["DiagnoseInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiagnoseInstance") {
                self.diagnoseInstance = dict["DiagnoseInstance"] as! [DescribeDiagnoseResponseBody.DiagnoseInstances.DiagnoseInstance]
            }
        }
    }
    public var diagnoseInstances: DescribeDiagnoseResponseBody.DiagnoseInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.diagnoseInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnoseInstances != nil {
            map["DiagnoseInstances"] = self.diagnoseInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiagnoseInstances") {
            var model = DescribeDiagnoseResponseBody.DiagnoseInstances()
            model.fromMap(dict["DiagnoseInstances"] as! [String: Any])
            self.diagnoseInstances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDiagnoseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnoseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnoseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnosisOperateRecordsRequest : Tea.TeaModel {
    public var errorCode: String?

    public var instanceType: String?

    public var operateRecordType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var payType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.operateRecordType != nil {
            map["OperateRecordType"] = self.operateRecordType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OperateRecordType") {
            self.operateRecordType = dict["OperateRecordType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeDiagnosisOperateRecordsResponseBody : Tea.TeaModel {
    public class DiagnosisOperateRecordModels : Tea.TeaModel {
        public var instanceType: String?

        public var newInstanceType: String?

        public var newZoneId: String?

        public var operateDate: String?

        public var operateRecordType: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.newInstanceType != nil {
                map["NewInstanceType"] = self.newInstanceType!
            }
            if self.newZoneId != nil {
                map["NewZoneId"] = self.newZoneId!
            }
            if self.operateDate != nil {
                map["OperateDate"] = self.operateDate!
            }
            if self.operateRecordType != nil {
                map["OperateRecordType"] = self.operateRecordType!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("NewInstanceType") {
                self.newInstanceType = dict["NewInstanceType"] as! String
            }
            if dict.keys.contains("NewZoneId") {
                self.newZoneId = dict["NewZoneId"] as! String
            }
            if dict.keys.contains("OperateDate") {
                self.operateDate = dict["OperateDate"] as! String
            }
            if dict.keys.contains("OperateRecordType") {
                self.operateRecordType = dict["OperateRecordType"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var diagnosisOperateRecordModels: [DescribeDiagnosisOperateRecordsResponseBody.DiagnosisOperateRecordModels]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnosisOperateRecordModels != nil {
            var tmp : [Any] = []
            for k in self.diagnosisOperateRecordModels! {
                tmp.append(k.toMap())
            }
            map["DiagnosisOperateRecordModels"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiagnosisOperateRecordModels") {
            self.diagnosisOperateRecordModels = dict["DiagnosisOperateRecordModels"] as! [DescribeDiagnosisOperateRecordsResponseBody.DiagnosisOperateRecordModels]
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDiagnosisOperateRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosisOperateRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnosisOperateRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnosticReportsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reportId: [String]?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var severity: String?

    public var sourceSystem: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.sourceSystem != nil {
            map["SourceSystem"] = self.sourceSystem!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! [String]
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("SourceSystem") {
            self.sourceSystem = dict["SourceSystem"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeDiagnosticReportsResponseBody : Tea.TeaModel {
    public class Reports : Tea.TeaModel {
        public class Report : Tea.TeaModel {
            public class Issues : Tea.TeaModel {
                public class Issue : Tea.TeaModel {
                    public class RecommendedActions : Tea.TeaModel {
                        public class RecommendedAction : Tea.TeaModel {
                            public class Parameters : Tea.TeaModel {
                                public class Parameter : Tea.TeaModel {
                                    public var key: String?

                                    public var value: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.key != nil {
                                            map["Key"] = self.key!
                                        }
                                        if self.value != nil {
                                            map["Value"] = self.value!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Key") {
                                            self.key = dict["Key"] as! String
                                        }
                                        if dict.keys.contains("Value") {
                                            self.value = dict["Value"] as! String
                                        }
                                    }
                                }
                                public var parameter: [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue.RecommendedActions.RecommendedAction.Parameters.Parameter]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.parameter != nil {
                                        var tmp : [Any] = []
                                        for k in self.parameter! {
                                            tmp.append(k.toMap())
                                        }
                                        map["Parameter"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Parameter") {
                                        self.parameter = dict["Parameter"] as! [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue.RecommendedActions.RecommendedAction.Parameters.Parameter]
                                    }
                                }
                            }
                            public var actionCode: String?

                            public var parameters: DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue.RecommendedActions.RecommendedAction.Parameters?

                            public var url: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.parameters?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.actionCode != nil {
                                    map["ActionCode"] = self.actionCode!
                                }
                                if self.parameters != nil {
                                    map["Parameters"] = self.parameters?.toMap()
                                }
                                if self.url != nil {
                                    map["Url"] = self.url!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ActionCode") {
                                    self.actionCode = dict["ActionCode"] as! String
                                }
                                if dict.keys.contains("Parameters") {
                                    var model = DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue.RecommendedActions.RecommendedAction.Parameters()
                                    model.fromMap(dict["Parameters"] as! [String: Any])
                                    self.parameters = model
                                }
                                if dict.keys.contains("Url") {
                                    self.url = dict["Url"] as! String
                                }
                            }
                        }
                        public var recommendedAction: [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue.RecommendedActions.RecommendedAction]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.recommendedAction != nil {
                                var tmp : [Any] = []
                                for k in self.recommendedAction! {
                                    tmp.append(k.toMap())
                                }
                                map["RecommendedAction"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("RecommendedAction") {
                                self.recommendedAction = dict["RecommendedAction"] as! [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue.RecommendedActions.RecommendedAction]
                            }
                        }
                    }
                    public var issueCategory: String?

                    public var issueCode: String?

                    public var message: String?

                    public var occurrenceTime: String?

                    public var recommendedActions: DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue.RecommendedActions?

                    public var severity: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.recommendedActions?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.issueCategory != nil {
                            map["IssueCategory"] = self.issueCategory!
                        }
                        if self.issueCode != nil {
                            map["IssueCode"] = self.issueCode!
                        }
                        if self.message != nil {
                            map["Message"] = self.message!
                        }
                        if self.occurrenceTime != nil {
                            map["OccurrenceTime"] = self.occurrenceTime!
                        }
                        if self.recommendedActions != nil {
                            map["RecommendedActions"] = self.recommendedActions?.toMap()
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IssueCategory") {
                            self.issueCategory = dict["IssueCategory"] as! String
                        }
                        if dict.keys.contains("IssueCode") {
                            self.issueCode = dict["IssueCode"] as! String
                        }
                        if dict.keys.contains("Message") {
                            self.message = dict["Message"] as! String
                        }
                        if dict.keys.contains("OccurrenceTime") {
                            self.occurrenceTime = dict["OccurrenceTime"] as! String
                        }
                        if dict.keys.contains("RecommendedActions") {
                            var model = DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue.RecommendedActions()
                            model.fromMap(dict["RecommendedActions"] as! [String: Any])
                            self.recommendedActions = model
                        }
                        if dict.keys.contains("Severity") {
                            self.severity = dict["Severity"] as! String
                        }
                    }
                }
                public var issue: [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.issue != nil {
                        var tmp : [Any] = []
                        for k in self.issue! {
                            tmp.append(k.toMap())
                        }
                        map["Issue"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Issue") {
                        self.issue = dict["Issue"] as! [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue]
                    }
                }
            }
            public class Items : Tea.TeaModel {
                public class Item : Tea.TeaModel {
                    public class ItemDatas : Tea.TeaModel {
                        public class ItemData : Tea.TeaModel {
                            public var name: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.name != nil {
                                    map["Name"] = self.name!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Name") {
                                    self.name = dict["Name"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var itemData: [DescribeDiagnosticReportsResponseBody.Reports.Report.Items.Item.ItemDatas.ItemData]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.itemData != nil {
                                var tmp : [Any] = []
                                for k in self.itemData! {
                                    tmp.append(k.toMap())
                                }
                                map["ItemData"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ItemData") {
                                self.itemData = dict["ItemData"] as! [DescribeDiagnosticReportsResponseBody.Reports.Report.Items.Item.ItemDatas.ItemData]
                            }
                        }
                    }
                    public var itemCategory: String?

                    public var itemCode: String?

                    public var itemDatas: DescribeDiagnosticReportsResponseBody.Reports.Report.Items.Item.ItemDatas?

                    public var occurrenceTime: String?

                    public var severity: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.itemDatas?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.itemCategory != nil {
                            map["ItemCategory"] = self.itemCategory!
                        }
                        if self.itemCode != nil {
                            map["ItemCode"] = self.itemCode!
                        }
                        if self.itemDatas != nil {
                            map["ItemDatas"] = self.itemDatas?.toMap()
                        }
                        if self.occurrenceTime != nil {
                            map["OccurrenceTime"] = self.occurrenceTime!
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ItemCategory") {
                            self.itemCategory = dict["ItemCategory"] as! String
                        }
                        if dict.keys.contains("ItemCode") {
                            self.itemCode = dict["ItemCode"] as! String
                        }
                        if dict.keys.contains("ItemDatas") {
                            var model = DescribeDiagnosticReportsResponseBody.Reports.Report.Items.Item.ItemDatas()
                            model.fromMap(dict["ItemDatas"] as! [String: Any])
                            self.itemDatas = model
                        }
                        if dict.keys.contains("OccurrenceTime") {
                            self.occurrenceTime = dict["OccurrenceTime"] as! String
                        }
                        if dict.keys.contains("Severity") {
                            self.severity = dict["Severity"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var item: [DescribeDiagnosticReportsResponseBody.Reports.Report.Items.Item]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.item != nil {
                        var tmp : [Any] = []
                        for k in self.item! {
                            tmp.append(k.toMap())
                        }
                        map["Item"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Item") {
                        self.item = dict["Item"] as! [DescribeDiagnosticReportsResponseBody.Reports.Report.Items.Item]
                    }
                }
            }
            public class RecentEvents : Tea.TeaModel {
                public class RecentEvent : Tea.TeaModel {
                    public var eventID: String?

                    public var eventName: String?

                    public var publishTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.eventID != nil {
                            map["EventID"] = self.eventID!
                        }
                        if self.eventName != nil {
                            map["EventName"] = self.eventName!
                        }
                        if self.publishTime != nil {
                            map["PublishTime"] = self.publishTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EventID") {
                            self.eventID = dict["EventID"] as! String
                        }
                        if dict.keys.contains("EventName") {
                            self.eventName = dict["EventName"] as! String
                        }
                        if dict.keys.contains("PublishTime") {
                            self.publishTime = dict["PublishTime"] as! String
                        }
                    }
                }
                public var recentEvent: [DescribeDiagnosticReportsResponseBody.Reports.Report.RecentEvents.RecentEvent]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recentEvent != nil {
                        var tmp : [Any] = []
                        for k in self.recentEvent! {
                            tmp.append(k.toMap())
                        }
                        map["RecentEvent"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RecentEvent") {
                        self.recentEvent = dict["RecentEvent"] as! [DescribeDiagnosticReportsResponseBody.Reports.Report.RecentEvents.RecentEvent]
                    }
                }
            }
            public var creationTime: String?

            public var diagnosticCategory: String?

            public var endTime: String?

            public var finishedTime: String?

            public var invokeSystem: String?

            public var issueCategoryId: String?

            public var issues: DescribeDiagnosticReportsResponseBody.Reports.Report.Issues?

            public var items: DescribeDiagnosticReportsResponseBody.Reports.Report.Items?

            public var offlineDiagReportStatus: String?

            public var pePassword: String?

            public var recentEvents: DescribeDiagnosticReportsResponseBody.Reports.Report.RecentEvents?

            public var reportId: String?

            public var resourceId: String?

            public var resourceType: String?

            public var severity: String?

            public var startTime: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.issues?.validate()
                try self.items?.validate()
                try self.recentEvents?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diagnosticCategory != nil {
                    map["DiagnosticCategory"] = self.diagnosticCategory!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.invokeSystem != nil {
                    map["InvokeSystem"] = self.invokeSystem!
                }
                if self.issueCategoryId != nil {
                    map["IssueCategoryId"] = self.issueCategoryId!
                }
                if self.issues != nil {
                    map["Issues"] = self.issues?.toMap()
                }
                if self.items != nil {
                    map["Items"] = self.items?.toMap()
                }
                if self.offlineDiagReportStatus != nil {
                    map["OfflineDiagReportStatus"] = self.offlineDiagReportStatus!
                }
                if self.pePassword != nil {
                    map["PePassword"] = self.pePassword!
                }
                if self.recentEvents != nil {
                    map["RecentEvents"] = self.recentEvents?.toMap()
                }
                if self.reportId != nil {
                    map["ReportId"] = self.reportId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DiagnosticCategory") {
                    self.diagnosticCategory = dict["DiagnosticCategory"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("FinishedTime") {
                    self.finishedTime = dict["FinishedTime"] as! String
                }
                if dict.keys.contains("InvokeSystem") {
                    self.invokeSystem = dict["InvokeSystem"] as! String
                }
                if dict.keys.contains("IssueCategoryId") {
                    self.issueCategoryId = dict["IssueCategoryId"] as! String
                }
                if dict.keys.contains("Issues") {
                    var model = DescribeDiagnosticReportsResponseBody.Reports.Report.Issues()
                    model.fromMap(dict["Issues"] as! [String: Any])
                    self.issues = model
                }
                if dict.keys.contains("Items") {
                    var model = DescribeDiagnosticReportsResponseBody.Reports.Report.Items()
                    model.fromMap(dict["Items"] as! [String: Any])
                    self.items = model
                }
                if dict.keys.contains("OfflineDiagReportStatus") {
                    self.offlineDiagReportStatus = dict["OfflineDiagReportStatus"] as! String
                }
                if dict.keys.contains("PePassword") {
                    self.pePassword = dict["PePassword"] as! String
                }
                if dict.keys.contains("RecentEvents") {
                    var model = DescribeDiagnosticReportsResponseBody.Reports.Report.RecentEvents()
                    model.fromMap(dict["RecentEvents"] as! [String: Any])
                    self.recentEvents = model
                }
                if dict.keys.contains("ReportId") {
                    self.reportId = dict["ReportId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var report: [DescribeDiagnosticReportsResponseBody.Reports.Report]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.report != nil {
                var tmp : [Any] = []
                for k in self.report! {
                    tmp.append(k.toMap())
                }
                map["Report"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Report") {
                self.report = dict["Report"] as! [DescribeDiagnosticReportsResponseBody.Reports.Report]
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var reports: DescribeDiagnosticReportsResponseBody.Reports?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reports?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.reports != nil {
            map["Reports"] = self.reports?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Reports") {
            var model = DescribeDiagnosticReportsResponseBody.Reports()
            model.fromMap(dict["Reports"] as! [String: Any])
            self.reports = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDiagnosticReportsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticReportsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnosticReportsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiskReplicaPairsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeDiskReplicaPairsResponseBody : Tea.TeaModel {
    public class DiskReplicaPairs : Tea.TeaModel {
        public class DiskReplicaPair : Tea.TeaModel {
            public var asyncCycle: Int32?

            public var bandwidth: Int32?

            public var description_: String?

            public var destinationDiskId: String?

            public var destinationRegion: String?

            public var healthStatus: String?

            public var pairName: String?

            public var replicaPairId: String?

            public var rpoTime: String?

            public var sourceDiskId: String?

            public var sourceRegion: String?

            public var status: String?

            public var totalCopiedSize: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.asyncCycle != nil {
                    map["AsyncCycle"] = self.asyncCycle!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.destinationDiskId != nil {
                    map["DestinationDiskId"] = self.destinationDiskId!
                }
                if self.destinationRegion != nil {
                    map["DestinationRegion"] = self.destinationRegion!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.pairName != nil {
                    map["PairName"] = self.pairName!
                }
                if self.replicaPairId != nil {
                    map["ReplicaPairId"] = self.replicaPairId!
                }
                if self.rpoTime != nil {
                    map["RpoTime"] = self.rpoTime!
                }
                if self.sourceDiskId != nil {
                    map["SourceDiskId"] = self.sourceDiskId!
                }
                if self.sourceRegion != nil {
                    map["SourceRegion"] = self.sourceRegion!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.totalCopiedSize != nil {
                    map["TotalCopiedSize"] = self.totalCopiedSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AsyncCycle") {
                    self.asyncCycle = dict["AsyncCycle"] as! Int32
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DestinationDiskId") {
                    self.destinationDiskId = dict["DestinationDiskId"] as! String
                }
                if dict.keys.contains("DestinationRegion") {
                    self.destinationRegion = dict["DestinationRegion"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("PairName") {
                    self.pairName = dict["PairName"] as! String
                }
                if dict.keys.contains("ReplicaPairId") {
                    self.replicaPairId = dict["ReplicaPairId"] as! String
                }
                if dict.keys.contains("RpoTime") {
                    self.rpoTime = dict["RpoTime"] as! String
                }
                if dict.keys.contains("SourceDiskId") {
                    self.sourceDiskId = dict["SourceDiskId"] as! String
                }
                if dict.keys.contains("SourceRegion") {
                    self.sourceRegion = dict["SourceRegion"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TotalCopiedSize") {
                    self.totalCopiedSize = dict["TotalCopiedSize"] as! Int64
                }
            }
        }
        public var diskReplicaPair: [DescribeDiskReplicaPairsResponseBody.DiskReplicaPairs.DiskReplicaPair]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskReplicaPair != nil {
                var tmp : [Any] = []
                for k in self.diskReplicaPair! {
                    tmp.append(k.toMap())
                }
                map["DiskReplicaPair"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskReplicaPair") {
                self.diskReplicaPair = dict["DiskReplicaPair"] as! [DescribeDiskReplicaPairsResponseBody.DiskReplicaPairs.DiskReplicaPair]
            }
        }
    }
    public var diskReplicaPairs: DescribeDiskReplicaPairsResponseBody.DiskReplicaPairs?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.diskReplicaPairs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskReplicaPairs != nil {
            map["DiskReplicaPairs"] = self.diskReplicaPairs?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskReplicaPairs") {
            var model = DescribeDiskReplicaPairsResponseBody.DiskReplicaPairs()
            model.fromMap(dict["DiskReplicaPairs"] as! [String: Any])
            self.diskReplicaPairs = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDiskReplicaPairsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiskReplicaPairsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiskReplicaPairsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEcsScenarioFacadeRequest : Tea.TeaModel {
    public class ScenarioList : Tea.TeaModel {
        public class ScenarioResources : Tea.TeaModel {
            public var type: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Values") {
                    self.values = dict["Values"] as! [String]
                }
            }
        }
        public var scenario: String?

        public var scenarioResources: [DescribeEcsScenarioFacadeRequest.ScenarioList.ScenarioResources]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scenario != nil {
                map["Scenario"] = self.scenario!
            }
            if self.scenarioResources != nil {
                var tmp : [Any] = []
                for k in self.scenarioResources! {
                    tmp.append(k.toMap())
                }
                map["ScenarioResources"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Scenario") {
                self.scenario = dict["Scenario"] as! String
            }
            if dict.keys.contains("ScenarioResources") {
                self.scenarioResources = dict["ScenarioResources"] as! [DescribeEcsScenarioFacadeRequest.ScenarioList.ScenarioResources]
            }
        }
    }
    public var extMap: [String: String]?

    public var extParam: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var scenarioList: [DescribeEcsScenarioFacadeRequest.ScenarioList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extMap != nil {
            map["ExtMap"] = self.extMap!
        }
        if self.extParam != nil {
            map["ExtParam"] = self.extParam!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scenarioList != nil {
            var tmp : [Any] = []
            for k in self.scenarioList! {
                tmp.append(k.toMap())
            }
            map["ScenarioList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtMap") {
            self.extMap = dict["ExtMap"] as! [String: String]
        }
        if dict.keys.contains("ExtParam") {
            self.extParam = dict["ExtParam"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScenarioList") {
            self.scenarioList = dict["ScenarioList"] as! [DescribeEcsScenarioFacadeRequest.ScenarioList]
        }
    }
}

public class DescribeEcsScenarioFacadeResponseBody : Tea.TeaModel {
    public class Scenarios : Tea.TeaModel {
        public class Contents : Tea.TeaModel {
            public class EcsScenarioContentData : Tea.TeaModel {
                public var type: String?

                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Values") {
                        self.values = dict["Values"] as! [String]
                    }
                }
            }
            public var action: [String: String]?

            public var attributes: [String: String]?

            public var colorLevel: String?

            public var description_: String?

            public var ecsScenarioContentData: [DescribeEcsScenarioFacadeResponseBody.Scenarios.Contents.EcsScenarioContentData]?

            public var icon: String?

            public var supportCancel: String?

            public var tips: String?

            public var title: String?

            public var track: [String: String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.attributes != nil {
                    map["Attributes"] = self.attributes!
                }
                if self.colorLevel != nil {
                    map["ColorLevel"] = self.colorLevel!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ecsScenarioContentData != nil {
                    var tmp : [Any] = []
                    for k in self.ecsScenarioContentData! {
                        tmp.append(k.toMap())
                    }
                    map["EcsScenarioContentData"] = tmp
                }
                if self.icon != nil {
                    map["Icon"] = self.icon!
                }
                if self.supportCancel != nil {
                    map["SupportCancel"] = self.supportCancel!
                }
                if self.tips != nil {
                    map["Tips"] = self.tips!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.track != nil {
                    map["Track"] = self.track!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! [String: String]
                }
                if dict.keys.contains("Attributes") {
                    self.attributes = dict["Attributes"] as! [String: String]
                }
                if dict.keys.contains("ColorLevel") {
                    self.colorLevel = dict["ColorLevel"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EcsScenarioContentData") {
                    self.ecsScenarioContentData = dict["EcsScenarioContentData"] as! [DescribeEcsScenarioFacadeResponseBody.Scenarios.Contents.EcsScenarioContentData]
                }
                if dict.keys.contains("Icon") {
                    self.icon = dict["Icon"] as! String
                }
                if dict.keys.contains("SupportCancel") {
                    self.supportCancel = dict["SupportCancel"] as! String
                }
                if dict.keys.contains("Tips") {
                    self.tips = dict["Tips"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("Track") {
                    self.track = dict["Track"] as! [String: String]
                }
            }
        }
        public var contents: [DescribeEcsScenarioFacadeResponseBody.Scenarios.Contents]?

        public var scenario: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contents != nil {
                var tmp : [Any] = []
                for k in self.contents! {
                    tmp.append(k.toMap())
                }
                map["Contents"] = tmp
            }
            if self.scenario != nil {
                map["Scenario"] = self.scenario!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Contents") {
                self.contents = dict["Contents"] as! [DescribeEcsScenarioFacadeResponseBody.Scenarios.Contents]
            }
            if dict.keys.contains("Scenario") {
                self.scenario = dict["Scenario"] as! String
            }
        }
    }
    public var requestId: String?

    public var scenarios: [DescribeEcsScenarioFacadeResponseBody.Scenarios]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scenarios != nil {
            var tmp : [Any] = []
            for k in self.scenarios! {
                tmp.append(k.toMap())
            }
            map["Scenarios"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Scenarios") {
            self.scenarios = dict["Scenarios"] as! [DescribeEcsScenarioFacadeResponseBody.Scenarios]
        }
    }
}

public class DescribeEcsScenarioFacadeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEcsScenarioFacadeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEcsScenarioFacadeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEniQosGroupInfoRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var qosGroupName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosGroupName != nil {
            map["QosGroupName"] = self.qosGroupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosGroupName") {
            self.qosGroupName = dict["QosGroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeEniQosGroupInfoResponseBody : Tea.TeaModel {
    public class QosGroupInfo : Tea.TeaModel {
        public class NetworkInterfaceIds : Tea.TeaModel {
            public var networkInterfaceId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NetworkInterfaceId") {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! [String]
                }
            }
        }
        public class QosGroup : Tea.TeaModel {
            public var gmtCreate: String?

            public var gmtModify: String?

            public var qosGroupName: String?

            public var rx: String?

            public var rxPps: String?

            public var tx: String?

            public var txPps: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModify != nil {
                    map["GmtModify"] = self.gmtModify!
                }
                if self.qosGroupName != nil {
                    map["QosGroupName"] = self.qosGroupName!
                }
                if self.rx != nil {
                    map["Rx"] = self.rx!
                }
                if self.rxPps != nil {
                    map["RxPps"] = self.rxPps!
                }
                if self.tx != nil {
                    map["Tx"] = self.tx!
                }
                if self.txPps != nil {
                    map["TxPps"] = self.txPps!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! String
                }
                if dict.keys.contains("GmtModify") {
                    self.gmtModify = dict["GmtModify"] as! String
                }
                if dict.keys.contains("QosGroupName") {
                    self.qosGroupName = dict["QosGroupName"] as! String
                }
                if dict.keys.contains("Rx") {
                    self.rx = dict["Rx"] as! String
                }
                if dict.keys.contains("RxPps") {
                    self.rxPps = dict["RxPps"] as! String
                }
                if dict.keys.contains("Tx") {
                    self.tx = dict["Tx"] as! String
                }
                if dict.keys.contains("TxPps") {
                    self.txPps = dict["TxPps"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var instanceId: String?

        public var networkInterfaceIds: DescribeEniQosGroupInfoResponseBody.QosGroupInfo.NetworkInterfaceIds?

        public var qosGroup: DescribeEniQosGroupInfoResponseBody.QosGroupInfo.QosGroup?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.networkInterfaceIds?.validate()
            try self.qosGroup?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.networkInterfaceIds != nil {
                map["NetworkInterfaceIds"] = self.networkInterfaceIds?.toMap()
            }
            if self.qosGroup != nil {
                map["QosGroup"] = self.qosGroup?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("NetworkInterfaceIds") {
                var model = DescribeEniQosGroupInfoResponseBody.QosGroupInfo.NetworkInterfaceIds()
                model.fromMap(dict["NetworkInterfaceIds"] as! [String: Any])
                self.networkInterfaceIds = model
            }
            if dict.keys.contains("QosGroup") {
                var model = DescribeEniQosGroupInfoResponseBody.QosGroupInfo.QosGroup()
                model.fromMap(dict["QosGroup"] as! [String: Any])
                self.qosGroup = model
            }
        }
    }
    public var qosGroupInfo: DescribeEniQosGroupInfoResponseBody.QosGroupInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.qosGroupInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qosGroupInfo != nil {
            map["QosGroupInfo"] = self.qosGroupInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QosGroupInfo") {
            var model = DescribeEniQosGroupInfoResponseBody.QosGroupInfo()
            model.fromMap(dict["QosGroupInfo"] as! [String: Any])
            self.qosGroupInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEniQosGroupInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEniQosGroupInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEniQosGroupInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFunctionFeedbackRequest : Tea.TeaModel {
    public var category: String?

    public var feedback: String?

    public var functionName: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.feedback != nil {
            map["Feedback"] = self.feedback!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("Feedback") {
            self.feedback = dict["Feedback"] as! String
        }
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeFunctionFeedbackResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Feedback : Tea.TeaModel {
            public var category: String?

            public var creationTime: String?

            public var feedback: String?

            public var finishedTime: String?

            public var functionName: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.feedback != nil {
                    map["Feedback"] = self.feedback!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Feedback") {
                    self.feedback = dict["Feedback"] as! String
                }
                if dict.keys.contains("FinishedTime") {
                    self.finishedTime = dict["FinishedTime"] as! String
                }
                if dict.keys.contains("FunctionName") {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public var feedback: [DescribeFunctionFeedbackResponseBody.Data.Feedback]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feedback != nil {
                var tmp : [Any] = []
                for k in self.feedback! {
                    tmp.append(k.toMap())
                }
                map["feedback"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("feedback") {
                self.feedback = dict["feedback"] as! [DescribeFunctionFeedbackResponseBody.Data.Feedback]
            }
        }
    }
    public var data: DescribeFunctionFeedbackResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeFunctionFeedbackResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFunctionFeedbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFunctionFeedbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFunctionFeedbackResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHavsInstanceTypesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeHavsInstanceTypesResponseBody : Tea.TeaModel {
    public class DescribeHavsInstanceTypesResponse : Tea.TeaModel {
        public class HavsInstanceTypes : Tea.TeaModel {
            public var havsInstanceTypes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.havsInstanceTypes != nil {
                    map["HavsInstanceTypes"] = self.havsInstanceTypes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HavsInstanceTypes") {
                    self.havsInstanceTypes = dict["HavsInstanceTypes"] as! [String]
                }
            }
        }
        public var havsInstanceTypes: DescribeHavsInstanceTypesResponseBody.DescribeHavsInstanceTypesResponse.HavsInstanceTypes?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.havsInstanceTypes?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.havsInstanceTypes != nil {
                map["HavsInstanceTypes"] = self.havsInstanceTypes?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HavsInstanceTypes") {
                var model = DescribeHavsInstanceTypesResponseBody.DescribeHavsInstanceTypesResponse.HavsInstanceTypes()
                model.fromMap(dict["HavsInstanceTypes"] as! [String: Any])
                self.havsInstanceTypes = model
            }
        }
    }
    public var describeHavsInstanceTypesResponse: DescribeHavsInstanceTypesResponseBody.DescribeHavsInstanceTypesResponse?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.describeHavsInstanceTypesResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describeHavsInstanceTypesResponse != nil {
            map["DescribeHavsInstanceTypesResponse"] = self.describeHavsInstanceTypesResponse?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DescribeHavsInstanceTypesResponse") {
            var model = DescribeHavsInstanceTypesResponseBody.DescribeHavsInstanceTypesResponse()
            model.fromMap(dict["DescribeHavsInstanceTypesResponse"] as! [String: Any])
            self.describeHavsInstanceTypesResponse = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeHavsInstanceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHavsInstanceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHavsInstanceTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageAgreementRequest : Tea.TeaModel {
    public var agreementType: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agreementType != nil {
            map["AgreementType"] = self.agreementType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgreementType") {
            self.agreementType = dict["AgreementType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeImageAgreementResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeImageAgreementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageAgreementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageAgreementResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageCachesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var imageId: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeImageCachesResponseBody : Tea.TeaModel {
    public class ImageCaches : Tea.TeaModel {
        public class ImageCache : Tea.TeaModel {
            public var creationTime: String?

            public var imageId: String?

            public var progress: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var imageCache: [DescribeImageCachesResponseBody.ImageCaches.ImageCache]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageCache != nil {
                var tmp : [Any] = []
                for k in self.imageCache! {
                    tmp.append(k.toMap())
                }
                map["ImageCache"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageCache") {
                self.imageCache = dict["ImageCache"] as! [DescribeImageCachesResponseBody.ImageCaches.ImageCache]
            }
        }
    }
    public var imageCaches: DescribeImageCachesResponseBody.ImageCaches?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageCaches?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageCaches != nil {
            map["ImageCaches"] = self.imageCaches?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageCaches") {
            var model = DescribeImageCachesResponseBody.ImageCaches()
            model.fromMap(dict["ImageCaches"] as! [String: Any])
            self.imageCaches = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImageCachesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageCachesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageCachesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageFamiliesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeImageFamiliesResponseBody : Tea.TeaModel {
    public class ImageFamilies : Tea.TeaModel {
        public var imageFamily: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageFamily") {
                self.imageFamily = dict["ImageFamily"] as! [String]
            }
        }
    }
    public var imageFamilies: DescribeImageFamiliesResponseBody.ImageFamilies?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageFamilies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageFamilies != nil {
            map["ImageFamilies"] = self.imageFamilies?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageFamilies") {
            var model = DescribeImageFamiliesResponseBody.ImageFamilies()
            model.fromMap(dict["ImageFamilies"] as! [String: Any])
            self.imageFamilies = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImageFamiliesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageFamiliesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageFamiliesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceAutoRebootTimeRequest : Tea.TeaModel {
    public var autoRebootTimeFrom: String?

    public var autoRebootTimeTo: String?

    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRebootTimeFrom != nil {
            map["AutoRebootTimeFrom"] = self.autoRebootTimeFrom!
        }
        if self.autoRebootTimeTo != nil {
            map["AutoRebootTimeTo"] = self.autoRebootTimeTo!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRebootTimeFrom") {
            self.autoRebootTimeFrom = dict["AutoRebootTimeFrom"] as! String
        }
        if dict.keys.contains("AutoRebootTimeTo") {
            self.autoRebootTimeTo = dict["AutoRebootTimeTo"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceAutoRebootTimeResponseBody : Tea.TeaModel {
    public class AutoRebootInfos : Tea.TeaModel {
        public class AutoRebootInfo : Tea.TeaModel {
            public var instanceId: String?

            public var limitRebootTime: String?

            public var orderType: String?

            public var rebootTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.limitRebootTime != nil {
                    map["LimitRebootTime"] = self.limitRebootTime!
                }
                if self.orderType != nil {
                    map["OrderType"] = self.orderType!
                }
                if self.rebootTime != nil {
                    map["RebootTime"] = self.rebootTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LimitRebootTime") {
                    self.limitRebootTime = dict["LimitRebootTime"] as! String
                }
                if dict.keys.contains("OrderType") {
                    self.orderType = dict["OrderType"] as! String
                }
                if dict.keys.contains("RebootTime") {
                    self.rebootTime = dict["RebootTime"] as! String
                }
            }
        }
        public var autoRebootInfo: [DescribeInstanceAutoRebootTimeResponseBody.AutoRebootInfos.AutoRebootInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRebootInfo != nil {
                var tmp : [Any] = []
                for k in self.autoRebootInfo! {
                    tmp.append(k.toMap())
                }
                map["AutoRebootInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoRebootInfo") {
                self.autoRebootInfo = dict["AutoRebootInfo"] as! [DescribeInstanceAutoRebootTimeResponseBody.AutoRebootInfos.AutoRebootInfo]
            }
        }
    }
    public var autoRebootInfos: DescribeInstanceAutoRebootTimeResponseBody.AutoRebootInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.autoRebootInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRebootInfos != nil {
            map["AutoRebootInfos"] = self.autoRebootInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRebootInfos") {
            var model = DescribeInstanceAutoRebootTimeResponseBody.AutoRebootInfos()
            model.fromMap(dict["AutoRebootInfos"] as! [String: Any])
            self.autoRebootInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceAutoRebootTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAutoRebootTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceAutoRebootTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceHealthStatusRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeInstanceHealthStatusResponseBody : Tea.TeaModel {
    public class HealthStatusModel : Tea.TeaModel {
        public class HealthStatus : Tea.TeaModel {
            public var code: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var healthStatus: DescribeInstanceHealthStatusResponseBody.HealthStatusModel.HealthStatus?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.healthStatus?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus?.toMap()
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HealthStatus") {
                var model = DescribeInstanceHealthStatusResponseBody.HealthStatusModel.HealthStatus()
                model.fromMap(dict["HealthStatus"] as! [String: Any])
                self.healthStatus = model
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public var healthStatusModel: [DescribeInstanceHealthStatusResponseBody.HealthStatusModel]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.healthStatusModel != nil {
            var tmp : [Any] = []
            for k in self.healthStatusModel! {
                tmp.append(k.toMap())
            }
            map["HealthStatusModel"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HealthStatusModel") {
            self.healthStatusModel = dict["HealthStatusModel"] as! [DescribeInstanceHealthStatusResponseBody.HealthStatusModel]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceHealthStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceHealthStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceHealthStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceMaintenanceAttributesRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceMaintenanceAttributesResponseBody : Tea.TeaModel {
    public class MaintenanceAttributes : Tea.TeaModel {
        public class MaintenanceAttribute : Tea.TeaModel {
            public class ActionOnMaintenance : Tea.TeaModel {
                public class SupportedValues : Tea.TeaModel {
                    public var supportedValue: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.supportedValue != nil {
                            map["SupportedValue"] = self.supportedValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SupportedValue") {
                            self.supportedValue = dict["SupportedValue"] as! [String]
                        }
                    }
                }
                public var defaultValue: String?

                public var supportedValues: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance.SupportedValues?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.supportedValues?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.supportedValues != nil {
                        map["SupportedValues"] = self.supportedValues?.toMap()
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DefaultValue") {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("SupportedValues") {
                        var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance.SupportedValues()
                        model.fromMap(dict["SupportedValues"] as! [String: Any])
                        self.supportedValues = model
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class MaintenanceWindows : Tea.TeaModel {
                public class MaintenanceWindow : Tea.TeaModel {
                    public var endTime: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public var maintenanceWindow: [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows.MaintenanceWindow]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maintenanceWindow != nil {
                        var tmp : [Any] = []
                        for k in self.maintenanceWindow! {
                            tmp.append(k.toMap())
                        }
                        map["MaintenanceWindow"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaintenanceWindow") {
                        self.maintenanceWindow = dict["MaintenanceWindow"] as! [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows.MaintenanceWindow]
                    }
                }
            }
            public var actionOnMaintenance: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance?

            public var instanceId: String?

            public var liveMigration: Bool?

            public var maintenanceWindows: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.actionOnMaintenance?.validate()
                try self.maintenanceWindows?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionOnMaintenance != nil {
                    map["ActionOnMaintenance"] = self.actionOnMaintenance?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.liveMigration != nil {
                    map["LiveMigration"] = self.liveMigration!
                }
                if self.maintenanceWindows != nil {
                    map["MaintenanceWindows"] = self.maintenanceWindows?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActionOnMaintenance") {
                    var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance()
                    model.fromMap(dict["ActionOnMaintenance"] as! [String: Any])
                    self.actionOnMaintenance = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LiveMigration") {
                    self.liveMigration = dict["LiveMigration"] as! Bool
                }
                if dict.keys.contains("MaintenanceWindows") {
                    var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows()
                    model.fromMap(dict["MaintenanceWindows"] as! [String: Any])
                    self.maintenanceWindows = model
                }
            }
        }
        public var maintenanceAttribute: [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maintenanceAttribute != nil {
                var tmp : [Any] = []
                for k in self.maintenanceAttribute! {
                    tmp.append(k.toMap())
                }
                map["MaintenanceAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaintenanceAttribute") {
                self.maintenanceAttribute = dict["MaintenanceAttribute"] as! [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute]
            }
        }
    }
    public var maintenanceAttributes: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.maintenanceAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maintenanceAttributes != nil {
            map["MaintenanceAttributes"] = self.maintenanceAttributes?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaintenanceAttributes") {
            var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes()
            model.fromMap(dict["MaintenanceAttributes"] as! [String: Any])
            self.maintenanceAttributes = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceMaintenanceAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceMaintenanceAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceMaintenanceAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceModificationPriceRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public var systemDisk: DescribeInstanceModificationPriceRequest.SystemDisk?

    public var dataDisk: [DescribeInstanceModificationPriceRequest.DataDisk]?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SystemDisk") {
            var model = DescribeInstanceModificationPriceRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("DataDisk") {
            self.dataDisk = dict["DataDisk"] as! [DescribeInstanceModificationPriceRequest.DataDisk]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceModificationPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public var currency: String?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var description_: String?

                public var ruleId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! Int64
                    }
                }
            }
            public var rule: [DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Rule") {
                    self.rule = dict["Rule"] as! [DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules.Rule]
                }
            }
        }
        public var price: DescribeInstanceModificationPriceResponseBody.PriceInfo.Price?

        public var rules: DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
            try self.rules?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                map["Rules"] = self.rules?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
            if dict.keys.contains("Rules") {
                var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules()
                model.fromMap(dict["Rules"] as! [String: Any])
                self.rules = model
            }
        }
    }
    public var priceInfo: DescribeInstanceModificationPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribeInstanceModificationPriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceModificationPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceModificationPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceModificationPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceNeedRebootRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceNeedRebootResponseBody : Tea.TeaModel {
    public class InstanceInfo : Tea.TeaModel {
        public var instanceInfo: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceInfo != nil {
                map["InstanceInfo"] = self.instanceInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceInfo") {
                self.instanceInfo = dict["InstanceInfo"] as! [String]
            }
        }
    }
    public var instanceInfo: DescribeInstanceNeedRebootResponseBody.InstanceInfo?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceInfo != nil {
            map["InstanceInfo"] = self.instanceInfo?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceInfo") {
            var model = DescribeInstanceNeedRebootResponseBody.InstanceInfo()
            model.fromMap(dict["InstanceInfo"] as! [String: Any])
            self.instanceInfo = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceNeedRebootResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceNeedRebootResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceNeedRebootResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstancePerformanceRestrictHistoryRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstancePerformanceRestrictHistoryResponseBody : Tea.TeaModel {
    public class PerformanceRestrictHistories : Tea.TeaModel {
        public class PerformanceRestrictHistory : Tea.TeaModel {
            public class Intervals : Tea.TeaModel {
                public var interval: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! [String]
                    }
                }
            }
            public var instanceId: String?

            public var intervals: DescribeInstancePerformanceRestrictHistoryResponseBody.PerformanceRestrictHistories.PerformanceRestrictHistory.Intervals?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.intervals?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.intervals != nil {
                    map["Intervals"] = self.intervals?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Intervals") {
                    var model = DescribeInstancePerformanceRestrictHistoryResponseBody.PerformanceRestrictHistories.PerformanceRestrictHistory.Intervals()
                    model.fromMap(dict["Intervals"] as! [String: Any])
                    self.intervals = model
                }
            }
        }
        public var performanceRestrictHistory: [DescribeInstancePerformanceRestrictHistoryResponseBody.PerformanceRestrictHistories.PerformanceRestrictHistory]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.performanceRestrictHistory != nil {
                var tmp : [Any] = []
                for k in self.performanceRestrictHistory! {
                    tmp.append(k.toMap())
                }
                map["PerformanceRestrictHistory"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PerformanceRestrictHistory") {
                self.performanceRestrictHistory = dict["PerformanceRestrictHistory"] as! [DescribeInstancePerformanceRestrictHistoryResponseBody.PerformanceRestrictHistories.PerformanceRestrictHistory]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var performanceRestrictHistories: DescribeInstancePerformanceRestrictHistoryResponseBody.PerformanceRestrictHistories?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.performanceRestrictHistories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.performanceRestrictHistories != nil {
            map["PerformanceRestrictHistories"] = self.performanceRestrictHistories?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PerformanceRestrictHistories") {
            var model = DescribeInstancePerformanceRestrictHistoryResponseBody.PerformanceRestrictHistories()
            model.fromMap(dict["PerformanceRestrictHistories"] as! [String: Any])
            self.performanceRestrictHistories = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstancePerformanceRestrictHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancePerformanceRestrictHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstancePerformanceRestrictHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTypeResourceRequest : Tea.TeaModel {
    public var cores: Int32?

    public var instanceTypeFamilies: [String]?

    public var instanceTypeMatchMode: String?

    public var instanceTypes: [String]?

    public var memories: [Double]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var searchTypes: [String]?

    public var zoneIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
        }
        if self.instanceTypeMatchMode != nil {
            map["InstanceTypeMatchMode"] = self.instanceTypeMatchMode!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.memories != nil {
            map["Memories"] = self.memories!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.searchTypes != nil {
            map["SearchTypes"] = self.searchTypes!
        }
        if self.zoneIds != nil {
            map["ZoneIds"] = self.zoneIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("InstanceTypeFamilies") {
            self.instanceTypeFamilies = dict["InstanceTypeFamilies"] as! [String]
        }
        if dict.keys.contains("InstanceTypeMatchMode") {
            self.instanceTypeMatchMode = dict["InstanceTypeMatchMode"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("Memories") {
            self.memories = dict["Memories"] as! [Double]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SearchTypes") {
            self.searchTypes = dict["SearchTypes"] as! [String]
        }
        if dict.keys.contains("ZoneIds") {
            self.zoneIds = dict["ZoneIds"] as! [String]
        }
    }
}

public class DescribeInstanceTypeResourceResponseBody : Tea.TeaModel {
    public class InstanceTypeResources : Tea.TeaModel {
        public class InstanceTypeResource : Tea.TeaModel {
            public class StockHealth : Tea.TeaModel {
                public var adequacyScore: Int32?

                public var healthScore: Int32?

                public var hotScore: Int32?

                public var supplyScore: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adequacyScore != nil {
                        map["AdequacyScore"] = self.adequacyScore!
                    }
                    if self.healthScore != nil {
                        map["HealthScore"] = self.healthScore!
                    }
                    if self.hotScore != nil {
                        map["HotScore"] = self.hotScore!
                    }
                    if self.supplyScore != nil {
                        map["SupplyScore"] = self.supplyScore!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdequacyScore") {
                        self.adequacyScore = dict["AdequacyScore"] as! Int32
                    }
                    if dict.keys.contains("HealthScore") {
                        self.healthScore = dict["HealthScore"] as! Int32
                    }
                    if dict.keys.contains("HotScore") {
                        self.hotScore = dict["HotScore"] as! Int32
                    }
                    if dict.keys.contains("SupplyScore") {
                        self.supplyScore = dict["SupplyScore"] as! Int32
                    }
                }
            }
            public var instanceType: String?

            public var instanceTypeFamily: String?

            public var regionId: String?

            public var searchType: String?

            public var stockHealth: DescribeInstanceTypeResourceResponseBody.InstanceTypeResources.InstanceTypeResource.StockHealth?

            public var totalQuota: Int64?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.stockHealth?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.searchType != nil {
                    map["SearchType"] = self.searchType!
                }
                if self.stockHealth != nil {
                    map["StockHealth"] = self.stockHealth?.toMap()
                }
                if self.totalQuota != nil {
                    map["TotalQuota"] = self.totalQuota!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InstanceTypeFamily") {
                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SearchType") {
                    self.searchType = dict["SearchType"] as! String
                }
                if dict.keys.contains("StockHealth") {
                    var model = DescribeInstanceTypeResourceResponseBody.InstanceTypeResources.InstanceTypeResource.StockHealth()
                    model.fromMap(dict["StockHealth"] as! [String: Any])
                    self.stockHealth = model
                }
                if dict.keys.contains("TotalQuota") {
                    self.totalQuota = dict["TotalQuota"] as! Int64
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var instanceTypeResource: [DescribeInstanceTypeResourceResponseBody.InstanceTypeResources.InstanceTypeResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceTypeResource != nil {
                var tmp : [Any] = []
                for k in self.instanceTypeResource! {
                    tmp.append(k.toMap())
                }
                map["InstanceTypeResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceTypeResource") {
                self.instanceTypeResource = dict["InstanceTypeResource"] as! [DescribeInstanceTypeResourceResponseBody.InstanceTypeResources.InstanceTypeResource]
            }
        }
    }
    public var instanceTypeResources: DescribeInstanceTypeResourceResponseBody.InstanceTypeResources?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypeResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypeResources != nil {
            map["InstanceTypeResources"] = self.instanceTypeResources?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceTypeResources") {
            var model = DescribeInstanceTypeResourceResponseBody.InstanceTypeResources()
            model.fromMap(dict["InstanceTypeResources"] as! [String: Any])
            self.instanceTypeResources = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceTypeResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTypeResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceTypeResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeKMSKeyAttributeRequest : Tea.TeaModel {
    public var KMSKeyId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var appKey: String?

    public var channel: String?

    public var operator_: String?

    public var proxyId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.appKey != nil {
            map["appKey"] = self.appKey!
        }
        if self.channel != nil {
            map["channel"] = self.channel!
        }
        if self.operator_ != nil {
            map["operator"] = self.operator_!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        if self.token != nil {
            map["token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("appKey") {
            self.appKey = dict["appKey"] as! String
        }
        if dict.keys.contains("channel") {
            self.channel = dict["channel"] as! String
        }
        if dict.keys.contains("operator") {
            self.operator_ = dict["operator"] as! String
        }
        if dict.keys.contains("proxyId") {
            self.proxyId = dict["proxyId"] as! String
        }
        if dict.keys.contains("token") {
            self.token = dict["token"] as! String
        }
    }
}

public class DescribeKMSKeyAttributeResponseBody : Tea.TeaModel {
    public var alias: String?

    public var creator: String?

    public var ecsTagged: Bool?

    public var KMSKeyId: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alias != nil {
            map["Alias"] = self.alias!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.ecsTagged != nil {
            map["EcsTagged"] = self.ecsTagged!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Alias") {
            self.alias = dict["Alias"] as! String
        }
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
        if dict.keys.contains("EcsTagged") {
            self.ecsTagged = dict["EcsTagged"] as! Bool
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeKMSKeyAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKMSKeyAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeKMSKeyAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeKMSKeysRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var appKey: String?

    public var channel: String?

    public var operator_: String?

    public var proxyId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.appKey != nil {
            map["appKey"] = self.appKey!
        }
        if self.channel != nil {
            map["channel"] = self.channel!
        }
        if self.operator_ != nil {
            map["operator"] = self.operator_!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        if self.token != nil {
            map["token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("appKey") {
            self.appKey = dict["appKey"] as! String
        }
        if dict.keys.contains("channel") {
            self.channel = dict["channel"] as! String
        }
        if dict.keys.contains("operator") {
            self.operator_ = dict["operator"] as! String
        }
        if dict.keys.contains("proxyId") {
            self.proxyId = dict["proxyId"] as! String
        }
        if dict.keys.contains("token") {
            self.token = dict["token"] as! String
        }
    }
}

public class DescribeKMSKeysResponseBody : Tea.TeaModel {
    public class KMSKeyIds : Tea.TeaModel {
        public var kmsKeyId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.kmsKeyId != nil {
                map["kmsKeyId"] = self.kmsKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("kmsKeyId") {
                self.kmsKeyId = dict["kmsKeyId"] as! [String]
            }
        }
    }
    public var KMSKeyIds: DescribeKMSKeysResponseBody.KMSKeyIds?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.KMSKeyIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.KMSKeyIds != nil {
            map["KMSKeyIds"] = self.KMSKeyIds?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KMSKeyIds") {
            var model = DescribeKMSKeysResponseBody.KMSKeyIds()
            model.fromMap(dict["KMSKeyIds"] as! [String: Any])
            self.KMSKeyIds = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeKMSKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKMSKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeKMSKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLinkedKMSKeysRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var appKey: String?

    public var channel: String?

    public var operator_: String?

    public var proxyId: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.appKey != nil {
            map["appKey"] = self.appKey!
        }
        if self.channel != nil {
            map["channel"] = self.channel!
        }
        if self.operator_ != nil {
            map["operator"] = self.operator_!
        }
        if self.proxyId != nil {
            map["proxyId"] = self.proxyId!
        }
        if self.token != nil {
            map["token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("appKey") {
            self.appKey = dict["appKey"] as! String
        }
        if dict.keys.contains("channel") {
            self.channel = dict["channel"] as! String
        }
        if dict.keys.contains("operator") {
            self.operator_ = dict["operator"] as! String
        }
        if dict.keys.contains("proxyId") {
            self.proxyId = dict["proxyId"] as! String
        }
        if dict.keys.contains("token") {
            self.token = dict["token"] as! String
        }
    }
}

public class DescribeLinkedKMSKeysResponseBody : Tea.TeaModel {
    public class KMSKeys : Tea.TeaModel {
        public class KMSKey : Tea.TeaModel {
            public var alias: String?

            public var KMSKeyId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("KMSKeyId") {
                    self.KMSKeyId = dict["KMSKeyId"] as! String
                }
            }
        }
        public var KMSKey: [DescribeLinkedKMSKeysResponseBody.KMSKeys.KMSKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.KMSKey != nil {
                var tmp : [Any] = []
                for k in self.KMSKey! {
                    tmp.append(k.toMap())
                }
                map["KMSKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("KMSKey") {
                self.KMSKey = dict["KMSKey"] as! [DescribeLinkedKMSKeysResponseBody.KMSKeys.KMSKey]
            }
        }
    }
    public var KMSKeys: DescribeLinkedKMSKeysResponseBody.KMSKeys?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.KMSKeys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.KMSKeys != nil {
            map["KMSKeys"] = self.KMSKeys?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KMSKeys") {
            var model = DescribeLinkedKMSKeysResponseBody.KMSKeys()
            model.fromMap(dict["KMSKeys"] as! [String: Any])
            self.KMSKeys = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLinkedKMSKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLinkedKMSKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLinkedKMSKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLocalDiskRepairActivitiesRequest : Tea.TeaModel {
    public var diskId: [String]?

    public var includeHistory: Bool?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.includeHistory != nil {
            map["IncludeHistory"] = self.includeHistory!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! [String]
        }
        if dict.keys.contains("IncludeHistory") {
            self.includeHistory = dict["IncludeHistory"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeLocalDiskRepairActivitiesResponseBody : Tea.TeaModel {
    public class LocalDiskRepairActivities : Tea.TeaModel {
        public class LocalDiskRepairActivity : Tea.TeaModel {
            public class DiskEvent : Tea.TeaModel {
                public class EventType : Tea.TeaModel {
                    public var code: Int32?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! Int32
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var eventEndTime: String?

                public var eventId: String?

                public var eventTime: String?

                public var eventType: DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.DiskEvent.EventType?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.eventType?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.eventEndTime != nil {
                        map["EventEndTime"] = self.eventEndTime!
                    }
                    if self.eventId != nil {
                        map["EventId"] = self.eventId!
                    }
                    if self.eventTime != nil {
                        map["EventTime"] = self.eventTime!
                    }
                    if self.eventType != nil {
                        map["EventType"] = self.eventType?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EventEndTime") {
                        self.eventEndTime = dict["EventEndTime"] as! String
                    }
                    if dict.keys.contains("EventId") {
                        self.eventId = dict["EventId"] as! String
                    }
                    if dict.keys.contains("EventTime") {
                        self.eventTime = dict["EventTime"] as! String
                    }
                    if dict.keys.contains("EventType") {
                        var model = DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.DiskEvent.EventType()
                        model.fromMap(dict["EventType"] as! [String: Any])
                        self.eventType = model
                    }
                }
            }
            public class InstanceEvents : Tea.TeaModel {
                public class InstanceEvent : Tea.TeaModel {
                    public class EventCycleStatus : Tea.TeaModel {
                        public var code: Int32?

                        public var name: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.code != nil {
                                map["Code"] = self.code!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Code") {
                                self.code = dict["Code"] as! Int32
                            }
                            if dict.keys.contains("Name") {
                                self.name = dict["Name"] as! String
                            }
                        }
                    }
                    public class EventType : Tea.TeaModel {
                        public var code: Int32?

                        public var name: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.code != nil {
                                map["Code"] = self.code!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Code") {
                                self.code = dict["Code"] as! Int32
                            }
                            if dict.keys.contains("Name") {
                                self.name = dict["Name"] as! String
                            }
                        }
                    }
                    public class ExtendedAttribute : Tea.TeaModel {
                        public var device: String?

                        public var diskId: String?

                        public var onlineRepairPolicy: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.device != nil {
                                map["Device"] = self.device!
                            }
                            if self.diskId != nil {
                                map["DiskId"] = self.diskId!
                            }
                            if self.onlineRepairPolicy != nil {
                                map["OnlineRepairPolicy"] = self.onlineRepairPolicy!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Device") {
                                self.device = dict["Device"] as! String
                            }
                            if dict.keys.contains("DiskId") {
                                self.diskId = dict["DiskId"] as! String
                            }
                            if dict.keys.contains("OnlineRepairPolicy") {
                                self.onlineRepairPolicy = dict["OnlineRepairPolicy"] as! String
                            }
                        }
                    }
                    public var eventCycleStatus: DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents.InstanceEvent.EventCycleStatus?

                    public var eventFinishTime: String?

                    public var eventId: String?

                    public var eventPublishTime: String?

                    public var eventType: DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents.InstanceEvent.EventType?

                    public var extendedAttribute: DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents.InstanceEvent.ExtendedAttribute?

                    public var instanceId: String?

                    public var reason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.eventCycleStatus?.validate()
                        try self.eventType?.validate()
                        try self.extendedAttribute?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.eventCycleStatus != nil {
                            map["EventCycleStatus"] = self.eventCycleStatus?.toMap()
                        }
                        if self.eventFinishTime != nil {
                            map["EventFinishTime"] = self.eventFinishTime!
                        }
                        if self.eventId != nil {
                            map["EventId"] = self.eventId!
                        }
                        if self.eventPublishTime != nil {
                            map["EventPublishTime"] = self.eventPublishTime!
                        }
                        if self.eventType != nil {
                            map["EventType"] = self.eventType?.toMap()
                        }
                        if self.extendedAttribute != nil {
                            map["ExtendedAttribute"] = self.extendedAttribute?.toMap()
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EventCycleStatus") {
                            var model = DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents.InstanceEvent.EventCycleStatus()
                            model.fromMap(dict["EventCycleStatus"] as! [String: Any])
                            self.eventCycleStatus = model
                        }
                        if dict.keys.contains("EventFinishTime") {
                            self.eventFinishTime = dict["EventFinishTime"] as! String
                        }
                        if dict.keys.contains("EventId") {
                            self.eventId = dict["EventId"] as! String
                        }
                        if dict.keys.contains("EventPublishTime") {
                            self.eventPublishTime = dict["EventPublishTime"] as! String
                        }
                        if dict.keys.contains("EventType") {
                            var model = DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents.InstanceEvent.EventType()
                            model.fromMap(dict["EventType"] as! [String: Any])
                            self.eventType = model
                        }
                        if dict.keys.contains("ExtendedAttribute") {
                            var model = DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents.InstanceEvent.ExtendedAttribute()
                            model.fromMap(dict["ExtendedAttribute"] as! [String: Any])
                            self.extendedAttribute = model
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("Reason") {
                            self.reason = dict["Reason"] as! String
                        }
                    }
                }
                public var instanceEvent: [DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents.InstanceEvent]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceEvent != nil {
                        var tmp : [Any] = []
                        for k in self.instanceEvent! {
                            tmp.append(k.toMap())
                        }
                        map["InstanceEvent"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceEvent") {
                        self.instanceEvent = dict["InstanceEvent"] as! [DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents.InstanceEvent]
                    }
                }
            }
            public var diskEvent: DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.DiskEvent?

            public var diskId: String?

            public var instanceEvents: DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents?

            public var instanceId: String?

            public var progress: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.diskEvent?.validate()
                try self.instanceEvents?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskEvent != nil {
                    map["DiskEvent"] = self.diskEvent?.toMap()
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.instanceEvents != nil {
                    map["InstanceEvents"] = self.instanceEvents?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskEvent") {
                    var model = DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.DiskEvent()
                    model.fromMap(dict["DiskEvent"] as! [String: Any])
                    self.diskEvent = model
                }
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("InstanceEvents") {
                    var model = DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity.InstanceEvents()
                    model.fromMap(dict["InstanceEvents"] as! [String: Any])
                    self.instanceEvents = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
            }
        }
        public var localDiskRepairActivity: [DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localDiskRepairActivity != nil {
                var tmp : [Any] = []
                for k in self.localDiskRepairActivity! {
                    tmp.append(k.toMap())
                }
                map["LocalDiskRepairActivity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LocalDiskRepairActivity") {
                self.localDiskRepairActivity = dict["LocalDiskRepairActivity"] as! [DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities.LocalDiskRepairActivity]
            }
        }
    }
    public var localDiskRepairActivities: DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.localDiskRepairActivities?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.localDiskRepairActivities != nil {
            map["LocalDiskRepairActivities"] = self.localDiskRepairActivities?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LocalDiskRepairActivities") {
            var model = DescribeLocalDiskRepairActivitiesResponseBody.LocalDiskRepairActivities()
            model.fromMap(dict["LocalDiskRepairActivities"] as! [String: Any])
            self.localDiskRepairActivities = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLocalDiskRepairActivitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLocalDiskRepairActivitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLocalDiskRepairActivitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMigrationInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var businessMigrationType: String?

    public var hostname: String?

    public var instanceId: [String]?

    public var migrationPlanId: String?

    public var migrationStatus: String?

    public var networkMigrationType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeMigrationInstancesRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessMigrationType != nil {
            map["BusinessMigrationType"] = self.businessMigrationType!
        }
        if self.hostname != nil {
            map["Hostname"] = self.hostname!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.migrationPlanId != nil {
            map["MigrationPlanId"] = self.migrationPlanId!
        }
        if self.migrationStatus != nil {
            map["MigrationStatus"] = self.migrationStatus!
        }
        if self.networkMigrationType != nil {
            map["NetworkMigrationType"] = self.networkMigrationType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessMigrationType") {
            self.businessMigrationType = dict["BusinessMigrationType"] as! String
        }
        if dict.keys.contains("Hostname") {
            self.hostname = dict["Hostname"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("MigrationPlanId") {
            self.migrationPlanId = dict["MigrationPlanId"] as! String
        }
        if dict.keys.contains("MigrationStatus") {
            self.migrationStatus = dict["MigrationStatus"] as! String
        }
        if dict.keys.contains("NetworkMigrationType") {
            self.networkMigrationType = dict["NetworkMigrationType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeMigrationInstancesRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeMigrationInstancesResponseBody : Tea.TeaModel {
    public class MigrationInstanceSet : Tea.TeaModel {
        public class MigrationInstance : Tea.TeaModel {
            public class SecurityGroupIdSets : Tea.TeaModel {
                public var securityGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! [String]
                    }
                }
            }
            public class SecurityGroupIdSetsAfterTransition : Tea.TeaModel {
                public var securityGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance.Tags.Tag]
                    }
                }
            }
            public var businessMigrationType: String?

            public var businessStatus: String?

            public var changePublicIp: Bool?

            public var finishTime: String?

            public var hasLocalDisk: Bool?

            public var instanceChargeType: String?

            public var instanceId: String?

            public var instanceType: String?

            public var internetIp: String?

            public var internetIpAfterTransition: String?

            public var intranetIp: String?

            public var intranetIpAfterTransition: String?

            public var loadProgress: String?

            public var macAddressAfterTransition: String?

            public var mergeProgress: String?

            public var migrationPlanId: String?

            public var migrationStatus: String?

            public var name: String?

            public var networkConnectivityStatus: Bool?

            public var networkMigrationType: Int32?

            public var nonStandardInstanceType: Bool?

            public var privateMacAddress: String?

            public var publicMacAddress: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var securityGroupIdSets: DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance.SecurityGroupIdSets?

            public var securityGroupIdSetsAfterTransition: DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance.SecurityGroupIdSetsAfterTransition?

            public var status: String?

            public var tags: DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance.Tags?

            public var targetVSwitchId: String?

            public var targetVpcId: String?

            public var targetZoneId: String?

            public var transitionTime: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.securityGroupIdSets?.validate()
                try self.securityGroupIdSetsAfterTransition?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.businessMigrationType != nil {
                    map["BusinessMigrationType"] = self.businessMigrationType!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.changePublicIp != nil {
                    map["ChangePublicIp"] = self.changePublicIp!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.hasLocalDisk != nil {
                    map["HasLocalDisk"] = self.hasLocalDisk!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetIp != nil {
                    map["InternetIp"] = self.internetIp!
                }
                if self.internetIpAfterTransition != nil {
                    map["InternetIpAfterTransition"] = self.internetIpAfterTransition!
                }
                if self.intranetIp != nil {
                    map["IntranetIp"] = self.intranetIp!
                }
                if self.intranetIpAfterTransition != nil {
                    map["IntranetIpAfterTransition"] = self.intranetIpAfterTransition!
                }
                if self.loadProgress != nil {
                    map["LoadProgress"] = self.loadProgress!
                }
                if self.macAddressAfterTransition != nil {
                    map["MacAddressAfterTransition"] = self.macAddressAfterTransition!
                }
                if self.mergeProgress != nil {
                    map["MergeProgress"] = self.mergeProgress!
                }
                if self.migrationPlanId != nil {
                    map["MigrationPlanId"] = self.migrationPlanId!
                }
                if self.migrationStatus != nil {
                    map["MigrationStatus"] = self.migrationStatus!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.networkConnectivityStatus != nil {
                    map["NetworkConnectivityStatus"] = self.networkConnectivityStatus!
                }
                if self.networkMigrationType != nil {
                    map["NetworkMigrationType"] = self.networkMigrationType!
                }
                if self.nonStandardInstanceType != nil {
                    map["NonStandardInstanceType"] = self.nonStandardInstanceType!
                }
                if self.privateMacAddress != nil {
                    map["PrivateMacAddress"] = self.privateMacAddress!
                }
                if self.publicMacAddress != nil {
                    map["PublicMacAddress"] = self.publicMacAddress!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityGroupIdSets != nil {
                    map["SecurityGroupIdSets"] = self.securityGroupIdSets?.toMap()
                }
                if self.securityGroupIdSetsAfterTransition != nil {
                    map["SecurityGroupIdSetsAfterTransition"] = self.securityGroupIdSetsAfterTransition?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.targetVSwitchId != nil {
                    map["TargetVSwitchId"] = self.targetVSwitchId!
                }
                if self.targetVpcId != nil {
                    map["TargetVpcId"] = self.targetVpcId!
                }
                if self.targetZoneId != nil {
                    map["TargetZoneId"] = self.targetZoneId!
                }
                if self.transitionTime != nil {
                    map["TransitionTime"] = self.transitionTime!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BusinessMigrationType") {
                    self.businessMigrationType = dict["BusinessMigrationType"] as! String
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("ChangePublicIp") {
                    self.changePublicIp = dict["ChangePublicIp"] as! Bool
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("HasLocalDisk") {
                    self.hasLocalDisk = dict["HasLocalDisk"] as! Bool
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InternetIp") {
                    self.internetIp = dict["InternetIp"] as! String
                }
                if dict.keys.contains("InternetIpAfterTransition") {
                    self.internetIpAfterTransition = dict["InternetIpAfterTransition"] as! String
                }
                if dict.keys.contains("IntranetIp") {
                    self.intranetIp = dict["IntranetIp"] as! String
                }
                if dict.keys.contains("IntranetIpAfterTransition") {
                    self.intranetIpAfterTransition = dict["IntranetIpAfterTransition"] as! String
                }
                if dict.keys.contains("LoadProgress") {
                    self.loadProgress = dict["LoadProgress"] as! String
                }
                if dict.keys.contains("MacAddressAfterTransition") {
                    self.macAddressAfterTransition = dict["MacAddressAfterTransition"] as! String
                }
                if dict.keys.contains("MergeProgress") {
                    self.mergeProgress = dict["MergeProgress"] as! String
                }
                if dict.keys.contains("MigrationPlanId") {
                    self.migrationPlanId = dict["MigrationPlanId"] as! String
                }
                if dict.keys.contains("MigrationStatus") {
                    self.migrationStatus = dict["MigrationStatus"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NetworkConnectivityStatus") {
                    self.networkConnectivityStatus = dict["NetworkConnectivityStatus"] as! Bool
                }
                if dict.keys.contains("NetworkMigrationType") {
                    self.networkMigrationType = dict["NetworkMigrationType"] as! Int32
                }
                if dict.keys.contains("NonStandardInstanceType") {
                    self.nonStandardInstanceType = dict["NonStandardInstanceType"] as! Bool
                }
                if dict.keys.contains("PrivateMacAddress") {
                    self.privateMacAddress = dict["PrivateMacAddress"] as! String
                }
                if dict.keys.contains("PublicMacAddress") {
                    self.publicMacAddress = dict["PublicMacAddress"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SecurityGroupIdSets") {
                    var model = DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance.SecurityGroupIdSets()
                    model.fromMap(dict["SecurityGroupIdSets"] as! [String: Any])
                    self.securityGroupIdSets = model
                }
                if dict.keys.contains("SecurityGroupIdSetsAfterTransition") {
                    var model = DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance.SecurityGroupIdSetsAfterTransition()
                    model.fromMap(dict["SecurityGroupIdSetsAfterTransition"] as! [String: Any])
                    self.securityGroupIdSetsAfterTransition = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TargetVSwitchId") {
                    self.targetVSwitchId = dict["TargetVSwitchId"] as! String
                }
                if dict.keys.contains("TargetVpcId") {
                    self.targetVpcId = dict["TargetVpcId"] as! String
                }
                if dict.keys.contains("TargetZoneId") {
                    self.targetZoneId = dict["TargetZoneId"] as! String
                }
                if dict.keys.contains("TransitionTime") {
                    self.transitionTime = dict["TransitionTime"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var migrationInstance: [DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.migrationInstance != nil {
                var tmp : [Any] = []
                for k in self.migrationInstance! {
                    tmp.append(k.toMap())
                }
                map["MigrationInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MigrationInstance") {
                self.migrationInstance = dict["MigrationInstance"] as! [DescribeMigrationInstancesResponseBody.MigrationInstanceSet.MigrationInstance]
            }
        }
    }
    public var migrationInstanceSet: DescribeMigrationInstancesResponseBody.MigrationInstanceSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.migrationInstanceSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationInstanceSet != nil {
            map["MigrationInstanceSet"] = self.migrationInstanceSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationInstanceSet") {
            var model = DescribeMigrationInstancesResponseBody.MigrationInstanceSet()
            model.fromMap(dict["MigrationInstanceSet"] as! [String: Any])
            self.migrationInstanceSet = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeMigrationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMigrationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMigrationInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMigrationPlansRequest : Tea.TeaModel {
    public var migrationPlanId: String?

    public var name: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationPlanId != nil {
            map["MigrationPlanId"] = self.migrationPlanId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationPlanId") {
            self.migrationPlanId = dict["MigrationPlanId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeMigrationPlansResponseBody : Tea.TeaModel {
    public class MigrationPlanSet : Tea.TeaModel {
        public class MigrationPlan : Tea.TeaModel {
            public class SecurityGroupNos : Tea.TeaModel {
                public var securityGroupNo: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupNo != nil {
                        map["SecurityGroupNo"] = self.securityGroupNo!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityGroupNo") {
                        self.securityGroupNo = dict["SecurityGroupNo"] as! [String]
                    }
                }
            }
            public var createTime: String?

            public var enableAutoCreateVSwitch: Bool?

            public var enableNetworkConnectivity: Bool?

            public var finishInstanceCount: Int32?

            public var migrationPlanId: String?

            public var name: String?

            public var remainPrivateIp: Bool?

            public var remainPublicMacAsPriority: Bool?

            public var securityGroupNos: DescribeMigrationPlansResponseBody.MigrationPlanSet.MigrationPlan.SecurityGroupNos?

            public var status: String?

            public var targetVSwitchId: String?

            public var targetVpcId: String?

            public var targetZoneId: String?

            public var totalInstanceCount: Int32?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.securityGroupNos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.enableAutoCreateVSwitch != nil {
                    map["EnableAutoCreateVSwitch"] = self.enableAutoCreateVSwitch!
                }
                if self.enableNetworkConnectivity != nil {
                    map["EnableNetworkConnectivity"] = self.enableNetworkConnectivity!
                }
                if self.finishInstanceCount != nil {
                    map["FinishInstanceCount"] = self.finishInstanceCount!
                }
                if self.migrationPlanId != nil {
                    map["MigrationPlanId"] = self.migrationPlanId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.remainPrivateIp != nil {
                    map["RemainPrivateIp"] = self.remainPrivateIp!
                }
                if self.remainPublicMacAsPriority != nil {
                    map["RemainPublicMacAsPriority"] = self.remainPublicMacAsPriority!
                }
                if self.securityGroupNos != nil {
                    map["SecurityGroupNos"] = self.securityGroupNos?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.targetVSwitchId != nil {
                    map["TargetVSwitchId"] = self.targetVSwitchId!
                }
                if self.targetVpcId != nil {
                    map["TargetVpcId"] = self.targetVpcId!
                }
                if self.targetZoneId != nil {
                    map["TargetZoneId"] = self.targetZoneId!
                }
                if self.totalInstanceCount != nil {
                    map["TotalInstanceCount"] = self.totalInstanceCount!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("EnableAutoCreateVSwitch") {
                    self.enableAutoCreateVSwitch = dict["EnableAutoCreateVSwitch"] as! Bool
                }
                if dict.keys.contains("EnableNetworkConnectivity") {
                    self.enableNetworkConnectivity = dict["EnableNetworkConnectivity"] as! Bool
                }
                if dict.keys.contains("FinishInstanceCount") {
                    self.finishInstanceCount = dict["FinishInstanceCount"] as! Int32
                }
                if dict.keys.contains("MigrationPlanId") {
                    self.migrationPlanId = dict["MigrationPlanId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RemainPrivateIp") {
                    self.remainPrivateIp = dict["RemainPrivateIp"] as! Bool
                }
                if dict.keys.contains("RemainPublicMacAsPriority") {
                    self.remainPublicMacAsPriority = dict["RemainPublicMacAsPriority"] as! Bool
                }
                if dict.keys.contains("SecurityGroupNos") {
                    var model = DescribeMigrationPlansResponseBody.MigrationPlanSet.MigrationPlan.SecurityGroupNos()
                    model.fromMap(dict["SecurityGroupNos"] as! [String: Any])
                    self.securityGroupNos = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TargetVSwitchId") {
                    self.targetVSwitchId = dict["TargetVSwitchId"] as! String
                }
                if dict.keys.contains("TargetVpcId") {
                    self.targetVpcId = dict["TargetVpcId"] as! String
                }
                if dict.keys.contains("TargetZoneId") {
                    self.targetZoneId = dict["TargetZoneId"] as! String
                }
                if dict.keys.contains("TotalInstanceCount") {
                    self.totalInstanceCount = dict["TotalInstanceCount"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var migrationPlan: [DescribeMigrationPlansResponseBody.MigrationPlanSet.MigrationPlan]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.migrationPlan != nil {
                var tmp : [Any] = []
                for k in self.migrationPlan! {
                    tmp.append(k.toMap())
                }
                map["MigrationPlan"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MigrationPlan") {
                self.migrationPlan = dict["MigrationPlan"] as! [DescribeMigrationPlansResponseBody.MigrationPlanSet.MigrationPlan]
            }
        }
    }
    public var migrationPlanSet: DescribeMigrationPlansResponseBody.MigrationPlanSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.migrationPlanSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationPlanSet != nil {
            map["MigrationPlanSet"] = self.migrationPlanSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationPlanSet") {
            var model = DescribeMigrationPlansResponseBody.MigrationPlanSet()
            model.fromMap(dict["MigrationPlanSet"] as! [String: Any])
            self.migrationPlanSet = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeMigrationPlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMigrationPlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMigrationPlansResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMigrationPreferencesRequest : Tea.TeaModel {
    public var migrationNetworkType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationNetworkType != nil {
            map["MigrationNetworkType"] = self.migrationNetworkType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationNetworkType") {
            self.migrationNetworkType = dict["MigrationNetworkType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeMigrationPreferencesResponseBody : Tea.TeaModel {
    public class TargetZoneIdSet : Tea.TeaModel {
        public var targetZoneId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.targetZoneId != nil {
                map["TargetZoneId"] = self.targetZoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TargetZoneId") {
                self.targetZoneId = dict["TargetZoneId"] as! [String]
            }
        }
    }
    public var migrationNetworkType: String?

    public var regionId: String?

    public var requestId: String?

    public var targetZoneIdSet: DescribeMigrationPreferencesResponseBody.TargetZoneIdSet?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.targetZoneIdSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationNetworkType != nil {
            map["MigrationNetworkType"] = self.migrationNetworkType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.targetZoneIdSet != nil {
            map["TargetZoneIdSet"] = self.targetZoneIdSet?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationNetworkType") {
            self.migrationNetworkType = dict["MigrationNetworkType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TargetZoneIdSet") {
            var model = DescribeMigrationPreferencesResponseBody.TargetZoneIdSet()
            model.fromMap(dict["TargetZoneIdSet"] as! [String: Any])
            self.targetZoneIdSet = model
        }
    }
}

public class DescribeMigrationPreferencesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMigrationPreferencesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMigrationPreferencesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkInsightsAnalysisResultRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var networkInsightsAnalysisId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkInsightsAnalysisId != nil {
            map["NetworkInsightsAnalysisId"] = self.networkInsightsAnalysisId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkInsightsAnalysisId") {
            self.networkInsightsAnalysisId = dict["NetworkInsightsAnalysisId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeNetworkInsightsAnalysisResultResponseBody : Tea.TeaModel {
    public class NetworkInsightsAnalysisComponents : Tea.TeaModel {
        public class NetworkInsightsAnalysisComponent : Tea.TeaModel {
            public class DiagnoseCategories : Tea.TeaModel {
                public class DiagnoseCategory : Tea.TeaModel {
                    public class CategoryItems : Tea.TeaModel {
                        public class CategoryItem : Tea.TeaModel {
                            public class Explanations : Tea.TeaModel {
                                public class NetworkAclEntry : Tea.TeaModel {
                                    public var direction: String?

                                    public var networkAclEntryId: String?

                                    public var networkAclId: String?

                                    public var networkAclName: String?

                                    public var policy: String?

                                    public var port: String?

                                    public var protocol_: String?

                                    public var sourceCidrIp: String?

                                    public var vpcId: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.direction != nil {
                                            map["Direction"] = self.direction!
                                        }
                                        if self.networkAclEntryId != nil {
                                            map["NetworkAclEntryId"] = self.networkAclEntryId!
                                        }
                                        if self.networkAclId != nil {
                                            map["NetworkAclId"] = self.networkAclId!
                                        }
                                        if self.networkAclName != nil {
                                            map["NetworkAclName"] = self.networkAclName!
                                        }
                                        if self.policy != nil {
                                            map["Policy"] = self.policy!
                                        }
                                        if self.port != nil {
                                            map["Port"] = self.port!
                                        }
                                        if self.protocol_ != nil {
                                            map["Protocol"] = self.protocol_!
                                        }
                                        if self.sourceCidrIp != nil {
                                            map["SourceCidrIp"] = self.sourceCidrIp!
                                        }
                                        if self.vpcId != nil {
                                            map["VpcId"] = self.vpcId!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Direction") {
                                            self.direction = dict["Direction"] as! String
                                        }
                                        if dict.keys.contains("NetworkAclEntryId") {
                                            self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                                        }
                                        if dict.keys.contains("NetworkAclId") {
                                            self.networkAclId = dict["NetworkAclId"] as! String
                                        }
                                        if dict.keys.contains("NetworkAclName") {
                                            self.networkAclName = dict["NetworkAclName"] as! String
                                        }
                                        if dict.keys.contains("Policy") {
                                            self.policy = dict["Policy"] as! String
                                        }
                                        if dict.keys.contains("Port") {
                                            self.port = dict["Port"] as! String
                                        }
                                        if dict.keys.contains("Protocol") {
                                            self.protocol_ = dict["Protocol"] as! String
                                        }
                                        if dict.keys.contains("SourceCidrIp") {
                                            self.sourceCidrIp = dict["SourceCidrIp"] as! String
                                        }
                                        if dict.keys.contains("VpcId") {
                                            self.vpcId = dict["VpcId"] as! String
                                        }
                                    }
                                }
                                public class RelativeGroupIds : Tea.TeaModel {
                                    public var relativeGroupId: [String]?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.relativeGroupId != nil {
                                            map["RelativeGroupId"] = self.relativeGroupId!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("RelativeGroupId") {
                                            self.relativeGroupId = dict["RelativeGroupId"] as! [String]
                                        }
                                    }
                                }
                                public class SecurityGroupAcl : Tea.TeaModel {
                                    public var createTime: String?

                                    public var description_: String?

                                    public var destCidrIp: String?

                                    public var destGroupId: String?

                                    public var destPortRange: String?

                                    public var innerAccessPolicy: String?

                                    public var nicType: String?

                                    public var policy: String?

                                    public var sourceCidrIp: String?

                                    public var sourcePortRange: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.createTime != nil {
                                            map["CreateTime"] = self.createTime!
                                        }
                                        if self.description_ != nil {
                                            map["Description"] = self.description_!
                                        }
                                        if self.destCidrIp != nil {
                                            map["DestCidrIp"] = self.destCidrIp!
                                        }
                                        if self.destGroupId != nil {
                                            map["DestGroupId"] = self.destGroupId!
                                        }
                                        if self.destPortRange != nil {
                                            map["DestPortRange"] = self.destPortRange!
                                        }
                                        if self.innerAccessPolicy != nil {
                                            map["InnerAccessPolicy"] = self.innerAccessPolicy!
                                        }
                                        if self.nicType != nil {
                                            map["NicType"] = self.nicType!
                                        }
                                        if self.policy != nil {
                                            map["Policy"] = self.policy!
                                        }
                                        if self.sourceCidrIp != nil {
                                            map["SourceCidrIp"] = self.sourceCidrIp!
                                        }
                                        if self.sourcePortRange != nil {
                                            map["SourcePortRange"] = self.sourcePortRange!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("CreateTime") {
                                            self.createTime = dict["CreateTime"] as! String
                                        }
                                        if dict.keys.contains("Description") {
                                            self.description_ = dict["Description"] as! String
                                        }
                                        if dict.keys.contains("DestCidrIp") {
                                            self.destCidrIp = dict["DestCidrIp"] as! String
                                        }
                                        if dict.keys.contains("DestGroupId") {
                                            self.destGroupId = dict["DestGroupId"] as! String
                                        }
                                        if dict.keys.contains("DestPortRange") {
                                            self.destPortRange = dict["DestPortRange"] as! String
                                        }
                                        if dict.keys.contains("InnerAccessPolicy") {
                                            self.innerAccessPolicy = dict["InnerAccessPolicy"] as! String
                                        }
                                        if dict.keys.contains("NicType") {
                                            self.nicType = dict["NicType"] as! String
                                        }
                                        if dict.keys.contains("Policy") {
                                            self.policy = dict["Policy"] as! String
                                        }
                                        if dict.keys.contains("SourceCidrIp") {
                                            self.sourceCidrIp = dict["SourceCidrIp"] as! String
                                        }
                                        if dict.keys.contains("SourcePortRange") {
                                            self.sourcePortRange = dict["SourcePortRange"] as! String
                                        }
                                    }
                                }
                                public class TopProcesses : Tea.TeaModel {
                                    public var topProcess: [String]?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.topProcess != nil {
                                            map["TopProcess"] = self.topProcess!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("TopProcess") {
                                            self.topProcess = dict["TopProcess"] as! [String]
                                        }
                                    }
                                }
                                public var actualIP: String?

                                public var actualPort: Int64?

                                public var expectIP: String?

                                public var expectPort: Int64?

                                public var expireDate: String?

                                public var groupId: String?

                                public var header: String?

                                public var ip: String?

                                public var missingFiles: String?

                                public var netmask: String?

                                public var networkAclEntry: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations.NetworkAclEntry?

                                public var networkInterfaceName: String?

                                public var port: Int64?

                                public var processName: String?

                                public var relativeGroupIds: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations.RelativeGroupIds?

                                public var rule: String?

                                public var securityGroupAcl: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations.SecurityGroupAcl?

                                public var topProcesses: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations.TopProcesses?

                                public var usePercent: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.networkAclEntry?.validate()
                                    try self.relativeGroupIds?.validate()
                                    try self.securityGroupAcl?.validate()
                                    try self.topProcesses?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.actualIP != nil {
                                        map["ActualIP"] = self.actualIP!
                                    }
                                    if self.actualPort != nil {
                                        map["ActualPort"] = self.actualPort!
                                    }
                                    if self.expectIP != nil {
                                        map["ExpectIP"] = self.expectIP!
                                    }
                                    if self.expectPort != nil {
                                        map["ExpectPort"] = self.expectPort!
                                    }
                                    if self.expireDate != nil {
                                        map["ExpireDate"] = self.expireDate!
                                    }
                                    if self.groupId != nil {
                                        map["GroupId"] = self.groupId!
                                    }
                                    if self.header != nil {
                                        map["Header"] = self.header!
                                    }
                                    if self.ip != nil {
                                        map["Ip"] = self.ip!
                                    }
                                    if self.missingFiles != nil {
                                        map["MissingFiles"] = self.missingFiles!
                                    }
                                    if self.netmask != nil {
                                        map["Netmask"] = self.netmask!
                                    }
                                    if self.networkAclEntry != nil {
                                        map["NetworkAclEntry"] = self.networkAclEntry?.toMap()
                                    }
                                    if self.networkInterfaceName != nil {
                                        map["NetworkInterfaceName"] = self.networkInterfaceName!
                                    }
                                    if self.port != nil {
                                        map["Port"] = self.port!
                                    }
                                    if self.processName != nil {
                                        map["ProcessName"] = self.processName!
                                    }
                                    if self.relativeGroupIds != nil {
                                        map["RelativeGroupIds"] = self.relativeGroupIds?.toMap()
                                    }
                                    if self.rule != nil {
                                        map["Rule"] = self.rule!
                                    }
                                    if self.securityGroupAcl != nil {
                                        map["SecurityGroupAcl"] = self.securityGroupAcl?.toMap()
                                    }
                                    if self.topProcesses != nil {
                                        map["TopProcesses"] = self.topProcesses?.toMap()
                                    }
                                    if self.usePercent != nil {
                                        map["UsePercent"] = self.usePercent!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("ActualIP") {
                                        self.actualIP = dict["ActualIP"] as! String
                                    }
                                    if dict.keys.contains("ActualPort") {
                                        self.actualPort = dict["ActualPort"] as! Int64
                                    }
                                    if dict.keys.contains("ExpectIP") {
                                        self.expectIP = dict["ExpectIP"] as! String
                                    }
                                    if dict.keys.contains("ExpectPort") {
                                        self.expectPort = dict["ExpectPort"] as! Int64
                                    }
                                    if dict.keys.contains("ExpireDate") {
                                        self.expireDate = dict["ExpireDate"] as! String
                                    }
                                    if dict.keys.contains("GroupId") {
                                        self.groupId = dict["GroupId"] as! String
                                    }
                                    if dict.keys.contains("Header") {
                                        self.header = dict["Header"] as! String
                                    }
                                    if dict.keys.contains("Ip") {
                                        self.ip = dict["Ip"] as! String
                                    }
                                    if dict.keys.contains("MissingFiles") {
                                        self.missingFiles = dict["MissingFiles"] as! String
                                    }
                                    if dict.keys.contains("Netmask") {
                                        self.netmask = dict["Netmask"] as! String
                                    }
                                    if dict.keys.contains("NetworkAclEntry") {
                                        var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations.NetworkAclEntry()
                                        model.fromMap(dict["NetworkAclEntry"] as! [String: Any])
                                        self.networkAclEntry = model
                                    }
                                    if dict.keys.contains("NetworkInterfaceName") {
                                        self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
                                    }
                                    if dict.keys.contains("Port") {
                                        self.port = dict["Port"] as! Int64
                                    }
                                    if dict.keys.contains("ProcessName") {
                                        self.processName = dict["ProcessName"] as! String
                                    }
                                    if dict.keys.contains("RelativeGroupIds") {
                                        var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations.RelativeGroupIds()
                                        model.fromMap(dict["RelativeGroupIds"] as! [String: Any])
                                        self.relativeGroupIds = model
                                    }
                                    if dict.keys.contains("Rule") {
                                        self.rule = dict["Rule"] as! String
                                    }
                                    if dict.keys.contains("SecurityGroupAcl") {
                                        var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations.SecurityGroupAcl()
                                        model.fromMap(dict["SecurityGroupAcl"] as! [String: Any])
                                        self.securityGroupAcl = model
                                    }
                                    if dict.keys.contains("TopProcesses") {
                                        var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations.TopProcesses()
                                        model.fromMap(dict["TopProcesses"] as! [String: Any])
                                        self.topProcesses = model
                                    }
                                    if dict.keys.contains("UsePercent") {
                                        self.usePercent = dict["UsePercent"] as! String
                                    }
                                }
                            }
                            public var code: String?

                            public var explanations: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations?

                            public var itemName: String?

                            public var reachable: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.explanations?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.code != nil {
                                    map["Code"] = self.code!
                                }
                                if self.explanations != nil {
                                    map["Explanations"] = self.explanations?.toMap()
                                }
                                if self.itemName != nil {
                                    map["ItemName"] = self.itemName!
                                }
                                if self.reachable != nil {
                                    map["Reachable"] = self.reachable!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Code") {
                                    self.code = dict["Code"] as! String
                                }
                                if dict.keys.contains("Explanations") {
                                    var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem.Explanations()
                                    model.fromMap(dict["Explanations"] as! [String: Any])
                                    self.explanations = model
                                }
                                if dict.keys.contains("ItemName") {
                                    self.itemName = dict["ItemName"] as! String
                                }
                                if dict.keys.contains("Reachable") {
                                    self.reachable = dict["Reachable"] as! String
                                }
                            }
                        }
                        public var categoryItem: [DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.categoryItem != nil {
                                var tmp : [Any] = []
                                for k in self.categoryItem! {
                                    tmp.append(k.toMap())
                                }
                                map["CategoryItem"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CategoryItem") {
                                self.categoryItem = dict["CategoryItem"] as! [DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems.CategoryItem]
                            }
                        }
                    }
                    public var categoryItems: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems?

                    public var categoryName: String?

                    public var reachable: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.categoryItems?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.categoryItems != nil {
                            map["CategoryItems"] = self.categoryItems?.toMap()
                        }
                        if self.categoryName != nil {
                            map["CategoryName"] = self.categoryName!
                        }
                        if self.reachable != nil {
                            map["Reachable"] = self.reachable!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CategoryItems") {
                            var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory.CategoryItems()
                            model.fromMap(dict["CategoryItems"] as! [String: Any])
                            self.categoryItems = model
                        }
                        if dict.keys.contains("CategoryName") {
                            self.categoryName = dict["CategoryName"] as! String
                        }
                        if dict.keys.contains("Reachable") {
                            self.reachable = dict["Reachable"] as! String
                        }
                    }
                }
                public var diagnoseCategory: [DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diagnoseCategory != nil {
                        var tmp : [Any] = []
                        for k in self.diagnoseCategory! {
                            tmp.append(k.toMap())
                        }
                        map["DiagnoseCategory"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiagnoseCategory") {
                        self.diagnoseCategory = dict["DiagnoseCategory"] as! [DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories.DiagnoseCategory]
                    }
                }
            }
            public class NetworkAclEntry : Tea.TeaModel {
                public var creationTime: String?

                public var destinationCidrIp: String?

                public var direction: String?

                public var networkAclEntryId: String?

                public var networkAclEntryName: String?

                public var networkAclId: String?

                public var networkAclName: String?

                public var policy: String?

                public var port: String?

                public var protocol_: String?

                public var sourceCidrIp: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.creationTime != nil {
                        map["CreationTime"] = self.creationTime!
                    }
                    if self.destinationCidrIp != nil {
                        map["DestinationCidrIp"] = self.destinationCidrIp!
                    }
                    if self.direction != nil {
                        map["Direction"] = self.direction!
                    }
                    if self.networkAclEntryId != nil {
                        map["NetworkAclEntryId"] = self.networkAclEntryId!
                    }
                    if self.networkAclEntryName != nil {
                        map["NetworkAclEntryName"] = self.networkAclEntryName!
                    }
                    if self.networkAclId != nil {
                        map["NetworkAclId"] = self.networkAclId!
                    }
                    if self.networkAclName != nil {
                        map["NetworkAclName"] = self.networkAclName!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.protocol_ != nil {
                        map["Protocol"] = self.protocol_!
                    }
                    if self.sourceCidrIp != nil {
                        map["SourceCidrIp"] = self.sourceCidrIp!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreationTime") {
                        self.creationTime = dict["CreationTime"] as! String
                    }
                    if dict.keys.contains("DestinationCidrIp") {
                        self.destinationCidrIp = dict["DestinationCidrIp"] as! String
                    }
                    if dict.keys.contains("Direction") {
                        self.direction = dict["Direction"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryId") {
                        self.networkAclEntryId = dict["NetworkAclEntryId"] as! String
                    }
                    if dict.keys.contains("NetworkAclEntryName") {
                        self.networkAclEntryName = dict["NetworkAclEntryName"] as! String
                    }
                    if dict.keys.contains("NetworkAclId") {
                        self.networkAclId = dict["NetworkAclId"] as! String
                    }
                    if dict.keys.contains("NetworkAclName") {
                        self.networkAclName = dict["NetworkAclName"] as! String
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! String
                    }
                    if dict.keys.contains("Protocol") {
                        self.protocol_ = dict["Protocol"] as! String
                    }
                    if dict.keys.contains("SourceCidrIp") {
                        self.sourceCidrIp = dict["SourceCidrIp"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public class RelativeGroupIds : Tea.TeaModel {
                public var relativeGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.relativeGroupId != nil {
                        map["RelativeGroupId"] = self.relativeGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RelativeGroupId") {
                        self.relativeGroupId = dict["RelativeGroupId"] as! [String]
                    }
                }
            }
            public class SecurityGroupAcl : Tea.TeaModel {
                public var createTime: String?

                public var description_: String?

                public var destCidrIp: String?

                public var destGroupId: String?

                public var destGroupName: String?

                public var destPortRange: String?

                public var direction: String?

                public var innerAccessPolicy: String?

                public var ipProtocol: String?

                public var ipv6DestCidrIp: String?

                public var ipv6SourceCidrIp: String?

                public var nicType: String?

                public var permissionDescription: String?

                public var policy: String?

                public var priority: String?

                public var securityGroupId: String?

                public var sourceCidrIp: String?

                public var sourceGroupId: String?

                public var sourceGroupName: String?

                public var sourcePortRange: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.destCidrIp != nil {
                        map["DestCidrIp"] = self.destCidrIp!
                    }
                    if self.destGroupId != nil {
                        map["DestGroupId"] = self.destGroupId!
                    }
                    if self.destGroupName != nil {
                        map["DestGroupName"] = self.destGroupName!
                    }
                    if self.destPortRange != nil {
                        map["DestPortRange"] = self.destPortRange!
                    }
                    if self.direction != nil {
                        map["Direction"] = self.direction!
                    }
                    if self.innerAccessPolicy != nil {
                        map["InnerAccessPolicy"] = self.innerAccessPolicy!
                    }
                    if self.ipProtocol != nil {
                        map["IpProtocol"] = self.ipProtocol!
                    }
                    if self.ipv6DestCidrIp != nil {
                        map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
                    }
                    if self.ipv6SourceCidrIp != nil {
                        map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
                    }
                    if self.nicType != nil {
                        map["NicType"] = self.nicType!
                    }
                    if self.permissionDescription != nil {
                        map["PermissionDescription"] = self.permissionDescription!
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    if self.sourceCidrIp != nil {
                        map["SourceCidrIp"] = self.sourceCidrIp!
                    }
                    if self.sourceGroupId != nil {
                        map["SourceGroupId"] = self.sourceGroupId!
                    }
                    if self.sourceGroupName != nil {
                        map["SourceGroupName"] = self.sourceGroupName!
                    }
                    if self.sourcePortRange != nil {
                        map["SourcePortRange"] = self.sourcePortRange!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DestCidrIp") {
                        self.destCidrIp = dict["DestCidrIp"] as! String
                    }
                    if dict.keys.contains("DestGroupId") {
                        self.destGroupId = dict["DestGroupId"] as! String
                    }
                    if dict.keys.contains("DestGroupName") {
                        self.destGroupName = dict["DestGroupName"] as! String
                    }
                    if dict.keys.contains("DestPortRange") {
                        self.destPortRange = dict["DestPortRange"] as! String
                    }
                    if dict.keys.contains("Direction") {
                        self.direction = dict["Direction"] as! String
                    }
                    if dict.keys.contains("InnerAccessPolicy") {
                        self.innerAccessPolicy = dict["InnerAccessPolicy"] as! String
                    }
                    if dict.keys.contains("IpProtocol") {
                        self.ipProtocol = dict["IpProtocol"] as! String
                    }
                    if dict.keys.contains("Ipv6DestCidrIp") {
                        self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
                    }
                    if dict.keys.contains("Ipv6SourceCidrIp") {
                        self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
                    }
                    if dict.keys.contains("NicType") {
                        self.nicType = dict["NicType"] as! String
                    }
                    if dict.keys.contains("PermissionDescription") {
                        self.permissionDescription = dict["PermissionDescription"] as! String
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! String
                    }
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! String
                    }
                    if dict.keys.contains("SourceCidrIp") {
                        self.sourceCidrIp = dict["SourceCidrIp"] as! String
                    }
                    if dict.keys.contains("SourceGroupId") {
                        self.sourceGroupId = dict["SourceGroupId"] as! String
                    }
                    if dict.keys.contains("SourceGroupName") {
                        self.sourceGroupName = dict["SourceGroupName"] as! String
                    }
                    if dict.keys.contains("SourcePortRange") {
                        self.sourcePortRange = dict["SourcePortRange"] as! String
                    }
                }
            }
            public var code: String?

            public var diagnoseCategories: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories?

            public var message: String?

            public var networkAclEntry: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.NetworkAclEntry?

            public var reachable: String?

            public var relativeGroupIds: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.RelativeGroupIds?

            public var resourceId: String?

            public var resourceType: String?

            public var securityGroupAcl: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.SecurityGroupAcl?

            public var sequence: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.diagnoseCategories?.validate()
                try self.networkAclEntry?.validate()
                try self.relativeGroupIds?.validate()
                try self.securityGroupAcl?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.diagnoseCategories != nil {
                    map["DiagnoseCategories"] = self.diagnoseCategories?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.networkAclEntry != nil {
                    map["NetworkAclEntry"] = self.networkAclEntry?.toMap()
                }
                if self.reachable != nil {
                    map["Reachable"] = self.reachable!
                }
                if self.relativeGroupIds != nil {
                    map["RelativeGroupIds"] = self.relativeGroupIds?.toMap()
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.securityGroupAcl != nil {
                    map["SecurityGroupAcl"] = self.securityGroupAcl?.toMap()
                }
                if self.sequence != nil {
                    map["Sequence"] = self.sequence!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("DiagnoseCategories") {
                    var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.DiagnoseCategories()
                    model.fromMap(dict["DiagnoseCategories"] as! [String: Any])
                    self.diagnoseCategories = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("NetworkAclEntry") {
                    var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.NetworkAclEntry()
                    model.fromMap(dict["NetworkAclEntry"] as! [String: Any])
                    self.networkAclEntry = model
                }
                if dict.keys.contains("Reachable") {
                    self.reachable = dict["Reachable"] as! String
                }
                if dict.keys.contains("RelativeGroupIds") {
                    var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.RelativeGroupIds()
                    model.fromMap(dict["RelativeGroupIds"] as! [String: Any])
                    self.relativeGroupIds = model
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("SecurityGroupAcl") {
                    var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent.SecurityGroupAcl()
                    model.fromMap(dict["SecurityGroupAcl"] as! [String: Any])
                    self.securityGroupAcl = model
                }
                if dict.keys.contains("Sequence") {
                    self.sequence = dict["Sequence"] as! Int32
                }
            }
        }
        public var networkInsightsAnalysisComponent: [DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInsightsAnalysisComponent != nil {
                var tmp : [Any] = []
                for k in self.networkInsightsAnalysisComponent! {
                    tmp.append(k.toMap())
                }
                map["NetworkInsightsAnalysisComponent"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInsightsAnalysisComponent") {
                self.networkInsightsAnalysisComponent = dict["NetworkInsightsAnalysisComponent"] as! [DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents.NetworkInsightsAnalysisComponent]
            }
        }
    }
    public var creationTime: String?

    public var destination: String?

    public var destinationIp: String?

    public var destinationPort: String?

    public var destinationType: String?

    public var networkInsightsAnalysisComponents: DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents?

    public var networkInsightsAnalysisId: String?

    public var networkInsightsPathId: String?

    public var networkPathFound: String?

    public var protocol_: String?

    public var requestId: String?

    public var source: String?

    public var sourceIp: String?

    public var sourceType: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInsightsAnalysisComponents?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.destination != nil {
            map["Destination"] = self.destination!
        }
        if self.destinationIp != nil {
            map["DestinationIp"] = self.destinationIp!
        }
        if self.destinationPort != nil {
            map["DestinationPort"] = self.destinationPort!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.networkInsightsAnalysisComponents != nil {
            map["NetworkInsightsAnalysisComponents"] = self.networkInsightsAnalysisComponents?.toMap()
        }
        if self.networkInsightsAnalysisId != nil {
            map["NetworkInsightsAnalysisId"] = self.networkInsightsAnalysisId!
        }
        if self.networkInsightsPathId != nil {
            map["NetworkInsightsPathId"] = self.networkInsightsPathId!
        }
        if self.networkPathFound != nil {
            map["NetworkPathFound"] = self.networkPathFound!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.sourceIp != nil {
            map["SourceIp"] = self.sourceIp!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("Destination") {
            self.destination = dict["Destination"] as! String
        }
        if dict.keys.contains("DestinationIp") {
            self.destinationIp = dict["DestinationIp"] as! String
        }
        if dict.keys.contains("DestinationPort") {
            self.destinationPort = dict["DestinationPort"] as! String
        }
        if dict.keys.contains("DestinationType") {
            self.destinationType = dict["DestinationType"] as! String
        }
        if dict.keys.contains("NetworkInsightsAnalysisComponents") {
            var model = DescribeNetworkInsightsAnalysisResultResponseBody.NetworkInsightsAnalysisComponents()
            model.fromMap(dict["NetworkInsightsAnalysisComponents"] as! [String: Any])
            self.networkInsightsAnalysisComponents = model
        }
        if dict.keys.contains("NetworkInsightsAnalysisId") {
            self.networkInsightsAnalysisId = dict["NetworkInsightsAnalysisId"] as! String
        }
        if dict.keys.contains("NetworkInsightsPathId") {
            self.networkInsightsPathId = dict["NetworkInsightsPathId"] as! String
        }
        if dict.keys.contains("NetworkPathFound") {
            self.networkPathFound = dict["NetworkPathFound"] as! String
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SourceIp") {
            self.sourceIp = dict["SourceIp"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeNetworkInsightsAnalysisResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInsightsAnalysisResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkInsightsAnalysisResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkInsightsAnalysisesRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var maxResults: Int32?

    public var networkInsightsAnalysisId: [String]?

    public var networkInsightsPathId: String?

    public var networkPathFound: String?

    public var nextToken: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkInsightsAnalysisId != nil {
            map["NetworkInsightsAnalysisId"] = self.networkInsightsAnalysisId!
        }
        if self.networkInsightsPathId != nil {
            map["NetworkInsightsPathId"] = self.networkInsightsPathId!
        }
        if self.networkPathFound != nil {
            map["NetworkPathFound"] = self.networkPathFound!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NetworkInsightsAnalysisId") {
            self.networkInsightsAnalysisId = dict["NetworkInsightsAnalysisId"] as! [String]
        }
        if dict.keys.contains("NetworkInsightsPathId") {
            self.networkInsightsPathId = dict["NetworkInsightsPathId"] as! String
        }
        if dict.keys.contains("NetworkPathFound") {
            self.networkPathFound = dict["NetworkPathFound"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeNetworkInsightsAnalysisesResponseBody : Tea.TeaModel {
    public class NetworkInsightsAnalysisSets : Tea.TeaModel {
        public class NetworkInsightsAnalysisSet : Tea.TeaModel {
            public var creationTime: String?

            public var networkInsightsAnalysisId: String?

            public var networkInsightsPathId: String?

            public var networkPathFound: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.networkInsightsAnalysisId != nil {
                    map["NetworkInsightsAnalysisId"] = self.networkInsightsAnalysisId!
                }
                if self.networkInsightsPathId != nil {
                    map["NetworkInsightsPathId"] = self.networkInsightsPathId!
                }
                if self.networkPathFound != nil {
                    map["NetworkPathFound"] = self.networkPathFound!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("NetworkInsightsAnalysisId") {
                    self.networkInsightsAnalysisId = dict["NetworkInsightsAnalysisId"] as! String
                }
                if dict.keys.contains("NetworkInsightsPathId") {
                    self.networkInsightsPathId = dict["NetworkInsightsPathId"] as! String
                }
                if dict.keys.contains("NetworkPathFound") {
                    self.networkPathFound = dict["NetworkPathFound"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var networkInsightsAnalysisSet: [DescribeNetworkInsightsAnalysisesResponseBody.NetworkInsightsAnalysisSets.NetworkInsightsAnalysisSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInsightsAnalysisSet != nil {
                var tmp : [Any] = []
                for k in self.networkInsightsAnalysisSet! {
                    tmp.append(k.toMap())
                }
                map["NetworkInsightsAnalysisSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInsightsAnalysisSet") {
                self.networkInsightsAnalysisSet = dict["NetworkInsightsAnalysisSet"] as! [DescribeNetworkInsightsAnalysisesResponseBody.NetworkInsightsAnalysisSets.NetworkInsightsAnalysisSet]
            }
        }
    }
    public var maxResults: Int32?

    public var networkInsightsAnalysisSets: DescribeNetworkInsightsAnalysisesResponseBody.NetworkInsightsAnalysisSets?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInsightsAnalysisSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkInsightsAnalysisSets != nil {
            map["NetworkInsightsAnalysisSets"] = self.networkInsightsAnalysisSets?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NetworkInsightsAnalysisSets") {
            var model = DescribeNetworkInsightsAnalysisesResponseBody.NetworkInsightsAnalysisSets()
            model.fromMap(dict["NetworkInsightsAnalysisSets"] as! [String: Any])
            self.networkInsightsAnalysisSets = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNetworkInsightsAnalysisesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInsightsAnalysisesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkInsightsAnalysisesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkInsightsPathsRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var maxResults: Int32?

    public var networkInsightsPathId: [String]?

    public var networkPathFound: String?

    public var nextToken: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkInsightsPathId != nil {
            map["NetworkInsightsPathId"] = self.networkInsightsPathId!
        }
        if self.networkPathFound != nil {
            map["NetworkPathFound"] = self.networkPathFound!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NetworkInsightsPathId") {
            self.networkInsightsPathId = dict["NetworkInsightsPathId"] as! [String]
        }
        if dict.keys.contains("NetworkPathFound") {
            self.networkPathFound = dict["NetworkPathFound"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeNetworkInsightsPathsResponseBody : Tea.TeaModel {
    public class NetworkInsightsPathSets : Tea.TeaModel {
        public class NetworkInsightsPathSet : Tea.TeaModel {
            public var creationTime: String?

            public var destination: String?

            public var destinationPort: String?

            public var destinationType: String?

            public var networkInsightsPathId: String?

            public var networkInsightsPathName: String?

            public var networkPathFound: String?

            public var protocol_: String?

            public var source: String?

            public var sourceType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.destination != nil {
                    map["Destination"] = self.destination!
                }
                if self.destinationPort != nil {
                    map["DestinationPort"] = self.destinationPort!
                }
                if self.destinationType != nil {
                    map["DestinationType"] = self.destinationType!
                }
                if self.networkInsightsPathId != nil {
                    map["NetworkInsightsPathId"] = self.networkInsightsPathId!
                }
                if self.networkInsightsPathName != nil {
                    map["NetworkInsightsPathName"] = self.networkInsightsPathName!
                }
                if self.networkPathFound != nil {
                    map["NetworkPathFound"] = self.networkPathFound!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Destination") {
                    self.destination = dict["Destination"] as! String
                }
                if dict.keys.contains("DestinationPort") {
                    self.destinationPort = dict["DestinationPort"] as! String
                }
                if dict.keys.contains("DestinationType") {
                    self.destinationType = dict["DestinationType"] as! String
                }
                if dict.keys.contains("NetworkInsightsPathId") {
                    self.networkInsightsPathId = dict["NetworkInsightsPathId"] as! String
                }
                if dict.keys.contains("NetworkInsightsPathName") {
                    self.networkInsightsPathName = dict["NetworkInsightsPathName"] as! String
                }
                if dict.keys.contains("NetworkPathFound") {
                    self.networkPathFound = dict["NetworkPathFound"] as! String
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var networkInsightsPathSet: [DescribeNetworkInsightsPathsResponseBody.NetworkInsightsPathSets.NetworkInsightsPathSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInsightsPathSet != nil {
                var tmp : [Any] = []
                for k in self.networkInsightsPathSet! {
                    tmp.append(k.toMap())
                }
                map["NetworkInsightsPathSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInsightsPathSet") {
                self.networkInsightsPathSet = dict["NetworkInsightsPathSet"] as! [DescribeNetworkInsightsPathsResponseBody.NetworkInsightsPathSets.NetworkInsightsPathSet]
            }
        }
    }
    public var maxResults: Int32?

    public var networkInsightsPathSets: DescribeNetworkInsightsPathsResponseBody.NetworkInsightsPathSets?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInsightsPathSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkInsightsPathSets != nil {
            map["NetworkInsightsPathSets"] = self.networkInsightsPathSets?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NetworkInsightsPathSets") {
            var model = DescribeNetworkInsightsPathsResponseBody.NetworkInsightsPathSets()
            model.fromMap(dict["NetworkInsightsPathSets"] as! [String: Any])
            self.networkInsightsPathSets = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNetworkInsightsPathsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInsightsPathsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkInsightsPathsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrderAutoRebootTimeRequest : Tea.TeaModel {
    public var orderId: Int64?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeOrderAutoRebootTimeResponseBody : Tea.TeaModel {
    public class DescribeOrderAutoRebootTimeInfo : Tea.TeaModel {
        public var autoRebootTime: String?

        public var instanceId: String?

        public var orderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRebootTime != nil {
                map["AutoRebootTime"] = self.autoRebootTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoRebootTime") {
                self.autoRebootTime = dict["AutoRebootTime"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! Int64
            }
        }
    }
    public var describeOrderAutoRebootTimeInfo: DescribeOrderAutoRebootTimeResponseBody.DescribeOrderAutoRebootTimeInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.describeOrderAutoRebootTimeInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describeOrderAutoRebootTimeInfo != nil {
            map["DescribeOrderAutoRebootTimeInfo"] = self.describeOrderAutoRebootTimeInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DescribeOrderAutoRebootTimeInfo") {
            var model = DescribeOrderAutoRebootTimeResponseBody.DescribeOrderAutoRebootTimeInfo()
            model.fromMap(dict["DescribeOrderAutoRebootTimeInfo"] as! [String: Any])
            self.describeOrderAutoRebootTimeInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeOrderAutoRebootTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrderAutoRebootTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrderAutoRebootTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrePaidResourceRefundPriceRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribePrePaidResourceRefundPriceResponseBody : Tea.TeaModel {
    public var currency: String?

    public var refunds: Double?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.refunds != nil {
            map["Refunds"] = self.refunds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Currency") {
            self.currency = dict["Currency"] as! String
        }
        if dict.keys.contains("Refunds") {
            self.refunds = dict["Refunds"] as! Double
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePrePaidResourceRefundPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrePaidResourceRefundPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePrePaidResourceRefundPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePriceRequest : Tea.TeaModel {
    public var businessInfo: String?

    public var commodity: String?

    public var defaultVpc: String?

    public var fromApp: String?

    public var needSpotPrice: Bool?

    public var networkType: String?

    public var orderType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var verbose: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.commodity != nil {
            map["Commodity"] = self.commodity!
        }
        if self.defaultVpc != nil {
            map["DefaultVpc"] = self.defaultVpc!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.needSpotPrice != nil {
            map["NeedSpotPrice"] = self.needSpotPrice!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.verbose != nil {
            map["Verbose"] = self.verbose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessInfo") {
            self.businessInfo = dict["BusinessInfo"] as! String
        }
        if dict.keys.contains("Commodity") {
            self.commodity = dict["Commodity"] as! String
        }
        if dict.keys.contains("DefaultVpc") {
            self.defaultVpc = dict["DefaultVpc"] as! String
        }
        if dict.keys.contains("FromApp") {
            self.fromApp = dict["FromApp"] as! String
        }
        if dict.keys.contains("NeedSpotPrice") {
            self.needSpotPrice = dict["NeedSpotPrice"] as! Bool
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OrderType") {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Verbose") {
            self.verbose = dict["Verbose"] as! Bool
        }
    }
}

public class DescribePriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Order : Tea.TeaModel {
            public class Coupons : Tea.TeaModel {
                public class Coupon : Tea.TeaModel {
                    public var couponNo: String?

                    public var description_: String?

                    public var discountOff: Double?

                    public var isSelected: Bool?

                    public var name: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.couponNo != nil {
                            map["CouponNo"] = self.couponNo!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.discountOff != nil {
                            map["DiscountOff"] = self.discountOff!
                        }
                        if self.isSelected != nil {
                            map["IsSelected"] = self.isSelected!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CouponNo") {
                            self.couponNo = dict["CouponNo"] as! String
                        }
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("DiscountOff") {
                            self.discountOff = dict["DiscountOff"] as! Double
                        }
                        if dict.keys.contains("IsSelected") {
                            self.isSelected = dict["IsSelected"] as! Bool
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                    }
                }
                public var coupon: [DescribePriceResponseBody.PriceInfo.Order.Coupons.Coupon]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.coupon != nil {
                        var tmp : [Any] = []
                        for k in self.coupon! {
                            tmp.append(k.toMap())
                        }
                        map["Coupon"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Coupon") {
                        self.coupon = dict["Coupon"] as! [DescribePriceResponseBody.PriceInfo.Order.Coupons.Coupon]
                    }
                }
            }
            public class DetailInfos : Tea.TeaModel {
                public class ResourcePriceModel : Tea.TeaModel {
                    public class SubRules : Tea.TeaModel {
                        public class Rule : Tea.TeaModel {
                            public var name: String?

                            public var ruleId: Int64?

                            public var title: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.name != nil {
                                    map["Name"] = self.name!
                                }
                                if self.ruleId != nil {
                                    map["RuleId"] = self.ruleId!
                                }
                                if self.title != nil {
                                    map["Title"] = self.title!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Name") {
                                    self.name = dict["Name"] as! String
                                }
                                if dict.keys.contains("RuleId") {
                                    self.ruleId = dict["RuleId"] as! Int64
                                }
                                if dict.keys.contains("Title") {
                                    self.title = dict["Title"] as! String
                                }
                            }
                        }
                        public var rule: [DescribePriceResponseBody.PriceInfo.Order.DetailInfos.ResourcePriceModel.SubRules.Rule]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.rule != nil {
                                var tmp : [Any] = []
                                for k in self.rule! {
                                    tmp.append(k.toMap())
                                }
                                map["Rule"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Rule") {
                                self.rule = dict["Rule"] as! [DescribePriceResponseBody.PriceInfo.Order.DetailInfos.ResourcePriceModel.SubRules.Rule]
                            }
                        }
                    }
                    public var discountPrice: Double?

                    public var originalPrice: Double?

                    public var resource: String?

                    public var subRules: DescribePriceResponseBody.PriceInfo.Order.DetailInfos.ResourcePriceModel.SubRules?

                    public var tradePrice: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.subRules?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.discountPrice != nil {
                            map["DiscountPrice"] = self.discountPrice!
                        }
                        if self.originalPrice != nil {
                            map["OriginalPrice"] = self.originalPrice!
                        }
                        if self.resource != nil {
                            map["Resource"] = self.resource!
                        }
                        if self.subRules != nil {
                            map["SubRules"] = self.subRules?.toMap()
                        }
                        if self.tradePrice != nil {
                            map["TradePrice"] = self.tradePrice!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DiscountPrice") {
                            self.discountPrice = dict["DiscountPrice"] as! Double
                        }
                        if dict.keys.contains("OriginalPrice") {
                            self.originalPrice = dict["OriginalPrice"] as! Double
                        }
                        if dict.keys.contains("Resource") {
                            self.resource = dict["Resource"] as! String
                        }
                        if dict.keys.contains("SubRules") {
                            var model = DescribePriceResponseBody.PriceInfo.Order.DetailInfos.ResourcePriceModel.SubRules()
                            model.fromMap(dict["SubRules"] as! [String: Any])
                            self.subRules = model
                        }
                        if dict.keys.contains("TradePrice") {
                            self.tradePrice = dict["TradePrice"] as! Double
                        }
                    }
                }
                public var resourcePriceModel: [DescribePriceResponseBody.PriceInfo.Order.DetailInfos.ResourcePriceModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourcePriceModel != nil {
                        var tmp : [Any] = []
                        for k in self.resourcePriceModel! {
                            tmp.append(k.toMap())
                        }
                        map["ResourcePriceModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourcePriceModel") {
                        self.resourcePriceModel = dict["ResourcePriceModel"] as! [DescribePriceResponseBody.PriceInfo.Order.DetailInfos.ResourcePriceModel]
                    }
                }
            }
            public class RuleIdSet : Tea.TeaModel {
                public var ruleId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! [String]
                    }
                }
            }
            public class SubOrders : Tea.TeaModel {
                public class SubOrder : Tea.TeaModel {
                    public class RuleIdSet : Tea.TeaModel {
                        public var ruleId: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ruleId != nil {
                                map["RuleId"] = self.ruleId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("RuleId") {
                                self.ruleId = dict["RuleId"] as! [String]
                            }
                        }
                    }
                    public var discountPrice: Double?

                    public var instanceId: String?

                    public var originalPrice: Double?

                    public var ruleIdSet: DescribePriceResponseBody.PriceInfo.Order.SubOrders.SubOrder.RuleIdSet?

                    public var tradePrice: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.ruleIdSet?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.discountPrice != nil {
                            map["DiscountPrice"] = self.discountPrice!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.originalPrice != nil {
                            map["OriginalPrice"] = self.originalPrice!
                        }
                        if self.ruleIdSet != nil {
                            map["RuleIdSet"] = self.ruleIdSet?.toMap()
                        }
                        if self.tradePrice != nil {
                            map["TradePrice"] = self.tradePrice!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DiscountPrice") {
                            self.discountPrice = dict["DiscountPrice"] as! Double
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("OriginalPrice") {
                            self.originalPrice = dict["OriginalPrice"] as! Double
                        }
                        if dict.keys.contains("RuleIdSet") {
                            var model = DescribePriceResponseBody.PriceInfo.Order.SubOrders.SubOrder.RuleIdSet()
                            model.fromMap(dict["RuleIdSet"] as! [String: Any])
                            self.ruleIdSet = model
                        }
                        if dict.keys.contains("TradePrice") {
                            self.tradePrice = dict["TradePrice"] as! Double
                        }
                    }
                }
                public var subOrder: [DescribePriceResponseBody.PriceInfo.Order.SubOrders.SubOrder]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.subOrder != nil {
                        var tmp : [Any] = []
                        for k in self.subOrder! {
                            tmp.append(k.toMap())
                        }
                        map["SubOrder"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SubOrder") {
                        self.subOrder = dict["SubOrder"] as! [DescribePriceResponseBody.PriceInfo.Order.SubOrders.SubOrder]
                    }
                }
            }
            public var coupons: DescribePriceResponseBody.PriceInfo.Order.Coupons?

            public var currency: String?

            public var detailInfos: DescribePriceResponseBody.PriceInfo.Order.DetailInfos?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var ruleIdSet: DescribePriceResponseBody.PriceInfo.Order.RuleIdSet?

            public var spotInstanceTypeOriginalPrice: Double?

            public var spotInstanceTypePrice: Double?

            public var subOrders: DescribePriceResponseBody.PriceInfo.Order.SubOrders?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.coupons?.validate()
                try self.detailInfos?.validate()
                try self.ruleIdSet?.validate()
                try self.subOrders?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coupons != nil {
                    map["Coupons"] = self.coupons?.toMap()
                }
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.detailInfos != nil {
                    map["DetailInfos"] = self.detailInfos?.toMap()
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.ruleIdSet != nil {
                    map["RuleIdSet"] = self.ruleIdSet?.toMap()
                }
                if self.spotInstanceTypeOriginalPrice != nil {
                    map["SpotInstanceTypeOriginalPrice"] = self.spotInstanceTypeOriginalPrice!
                }
                if self.spotInstanceTypePrice != nil {
                    map["SpotInstanceTypePrice"] = self.spotInstanceTypePrice!
                }
                if self.subOrders != nil {
                    map["SubOrders"] = self.subOrders?.toMap()
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Coupons") {
                    var model = DescribePriceResponseBody.PriceInfo.Order.Coupons()
                    model.fromMap(dict["Coupons"] as! [String: Any])
                    self.coupons = model
                }
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DetailInfos") {
                    var model = DescribePriceResponseBody.PriceInfo.Order.DetailInfos()
                    model.fromMap(dict["DetailInfos"] as! [String: Any])
                    self.detailInfos = model
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("RuleIdSet") {
                    var model = DescribePriceResponseBody.PriceInfo.Order.RuleIdSet()
                    model.fromMap(dict["RuleIdSet"] as! [String: Any])
                    self.ruleIdSet = model
                }
                if dict.keys.contains("SpotInstanceTypeOriginalPrice") {
                    self.spotInstanceTypeOriginalPrice = dict["SpotInstanceTypeOriginalPrice"] as! Double
                }
                if dict.keys.contains("SpotInstanceTypePrice") {
                    self.spotInstanceTypePrice = dict["SpotInstanceTypePrice"] as! Double
                }
                if dict.keys.contains("SubOrders") {
                    var model = DescribePriceResponseBody.PriceInfo.Order.SubOrders()
                    model.fromMap(dict["SubOrders"] as! [String: Any])
                    self.subOrders = model
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class OrderParams : Tea.TeaModel {
            public var orderParam: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.orderParam != nil {
                    map["OrderParam"] = self.orderParam!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OrderParam") {
                    self.orderParam = dict["OrderParam"] as! [String]
                }
            }
        }
        public class PriceWarning : Tea.TeaModel {
            public var code: String?

            public var msg: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.msg != nil {
                    map["Msg"] = self.msg!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Msg") {
                    self.msg = dict["Msg"] as! String
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var name: String?

                public var ruleId: Int64?

                public var title: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    if self.title != nil {
                        map["Title"] = self.title!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! Int64
                    }
                    if dict.keys.contains("Title") {
                        self.title = dict["Title"] as! String
                    }
                }
            }
            public var rule: [DescribePriceResponseBody.PriceInfo.Rules.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Rule") {
                    self.rule = dict["Rule"] as! [DescribePriceResponseBody.PriceInfo.Rules.Rule]
                }
            }
        }
        public var order: DescribePriceResponseBody.PriceInfo.Order?

        public var orderParams: DescribePriceResponseBody.PriceInfo.OrderParams?

        public var priceWarning: DescribePriceResponseBody.PriceInfo.PriceWarning?

        public var rules: DescribePriceResponseBody.PriceInfo.Rules?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.order?.validate()
            try self.orderParams?.validate()
            try self.priceWarning?.validate()
            try self.rules?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.order != nil {
                map["Order"] = self.order?.toMap()
            }
            if self.orderParams != nil {
                map["OrderParams"] = self.orderParams?.toMap()
            }
            if self.priceWarning != nil {
                map["PriceWarning"] = self.priceWarning?.toMap()
            }
            if self.rules != nil {
                map["Rules"] = self.rules?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Order") {
                var model = DescribePriceResponseBody.PriceInfo.Order()
                model.fromMap(dict["Order"] as! [String: Any])
                self.order = model
            }
            if dict.keys.contains("OrderParams") {
                var model = DescribePriceResponseBody.PriceInfo.OrderParams()
                model.fromMap(dict["OrderParams"] as! [String: Any])
                self.orderParams = model
            }
            if dict.keys.contains("PriceWarning") {
                var model = DescribePriceResponseBody.PriceInfo.PriceWarning()
                model.fromMap(dict["PriceWarning"] as! [String: Any])
                self.priceWarning = model
            }
            if dict.keys.contains("Rules") {
                var model = DescribePriceResponseBody.PriceInfo.Rules()
                model.fromMap(dict["Rules"] as! [String: Any])
                self.rules = model
            }
        }
    }
    public var priceInfo: DescribePriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribePriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrivatePoolsRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var ids: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ids != nil {
                map["Ids"] = self.ids!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ids") {
                self.ids = dict["Ids"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var privatePoolOptions: DescribePrivatePoolsRequest.PrivatePoolOptions?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTimeType: String?

    public var status: String?

    public var tag: [DescribePrivatePoolsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTimeType != nil {
            map["StartTimeType"] = self.startTimeType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = DescribePrivatePoolsRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTimeType") {
            self.startTimeType = dict["StartTimeType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribePrivatePoolsRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribePrivatePoolsResponseBody : Tea.TeaModel {
    public class PrivatePoolSet : Tea.TeaModel {
        public class PrivatePoolItem : Tea.TeaModel {
            public class AllocatedResources : Tea.TeaModel {
                public class AllocatedResource : Tea.TeaModel {
                    public var instanceType: String?

                    public var totalAmount: Int32?

                    public var usedAmount: Int32?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.totalAmount != nil {
                            map["TotalAmount"] = self.totalAmount!
                        }
                        if self.usedAmount != nil {
                            map["UsedAmount"] = self.usedAmount!
                        }
                        if self.zoneId != nil {
                            map["zoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("TotalAmount") {
                            self.totalAmount = dict["TotalAmount"] as! Int32
                        }
                        if dict.keys.contains("UsedAmount") {
                            self.usedAmount = dict["UsedAmount"] as! Int32
                        }
                        if dict.keys.contains("zoneId") {
                            self.zoneId = dict["zoneId"] as! String
                        }
                    }
                }
                public var allocatedResource: [DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem.AllocatedResources.AllocatedResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocatedResource != nil {
                        var tmp : [Any] = []
                        for k in self.allocatedResource! {
                            tmp.append(k.toMap())
                        }
                        map["AllocatedResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllocatedResource") {
                        self.allocatedResource = dict["AllocatedResource"] as! [DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem.AllocatedResources.AllocatedResource]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem.Tags.Tag]
                    }
                }
            }
            public var allocatedResources: DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem.AllocatedResources?

            public var description_: String?

            public var endTime: String?

            public var endTimeType: String?

            public var instanceChargeType: String?

            public var latestStartTime: String?

            public var platform: String?

            public var privatePoolOptionsId: String?

            public var privatePoolOptionsMatchCriteria: String?

            public var privatePoolOptionsName: String?

            public var privatePoolOptionsType: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var startTime: String?

            public var startTimeType: String?

            public var status: String?

            public var tags: DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem.Tags?

            public var totalAssuranceTimes: String?

            public var usedAssuranceTimes: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.allocatedResources?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocatedResources != nil {
                    map["AllocatedResources"] = self.allocatedResources?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.endTimeType != nil {
                    map["EndTimeType"] = self.endTimeType!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.latestStartTime != nil {
                    map["LatestStartTime"] = self.latestStartTime!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.privatePoolOptionsId != nil {
                    map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                }
                if self.privatePoolOptionsMatchCriteria != nil {
                    map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
                }
                if self.privatePoolOptionsName != nil {
                    map["PrivatePoolOptionsName"] = self.privatePoolOptionsName!
                }
                if self.privatePoolOptionsType != nil {
                    map["PrivatePoolOptionsType"] = self.privatePoolOptionsType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.startTimeType != nil {
                    map["StartTimeType"] = self.startTimeType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.totalAssuranceTimes != nil {
                    map["TotalAssuranceTimes"] = self.totalAssuranceTimes!
                }
                if self.usedAssuranceTimes != nil {
                    map["UsedAssuranceTimes"] = self.usedAssuranceTimes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocatedResources") {
                    var model = DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem.AllocatedResources()
                    model.fromMap(dict["AllocatedResources"] as! [String: Any])
                    self.allocatedResources = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("EndTimeType") {
                    self.endTimeType = dict["EndTimeType"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("LatestStartTime") {
                    self.latestStartTime = dict["LatestStartTime"] as! String
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsId") {
                    self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsMatchCriteria") {
                    self.privatePoolOptionsMatchCriteria = dict["PrivatePoolOptionsMatchCriteria"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsName") {
                    self.privatePoolOptionsName = dict["PrivatePoolOptionsName"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsType") {
                    self.privatePoolOptionsType = dict["PrivatePoolOptionsType"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StartTimeType") {
                    self.startTimeType = dict["StartTimeType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TotalAssuranceTimes") {
                    self.totalAssuranceTimes = dict["TotalAssuranceTimes"] as! String
                }
                if dict.keys.contains("UsedAssuranceTimes") {
                    self.usedAssuranceTimes = dict["UsedAssuranceTimes"] as! Int32
                }
            }
        }
        public var privatePoolItem: [DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privatePoolItem != nil {
                var tmp : [Any] = []
                for k in self.privatePoolItem! {
                    tmp.append(k.toMap())
                }
                map["PrivatePoolItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrivatePoolItem") {
                self.privatePoolItem = dict["PrivatePoolItem"] as! [DescribePrivatePoolsResponseBody.PrivatePoolSet.PrivatePoolItem]
            }
        }
    }
    public var maxResults: Int32?

    public var nextToken: String?

    public var privatePoolSet: DescribePrivatePoolsResponseBody.PrivatePoolSet?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.privatePoolSet != nil {
            map["PrivatePoolSet"] = self.privatePoolSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PrivatePoolSet") {
            var model = DescribePrivatePoolsResponseBody.PrivatePoolSet()
            model.fromMap(dict["PrivatePoolSet"] as! [String: Any])
            self.privatePoolSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePrivatePoolsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrivatePoolsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePrivatePoolsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecommendProductRequest : Tea.TeaModel {
    public var amount: Int32?

    public var cores: Int32?

    public var instanceChargeType: String?

    public var instanceFamilyLevel: String?

    public var instanceType: String?

    public var instanceTypeFamily: [String]?

    public var instanceTypeSupportIPv6: Bool?

    public var ioOptimized: String?

    public var maxPrice: Double?

    public var memory: Double?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priorityStrategy: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotStrategy: String?

    public var systemDiskCategory: String?

    public var zoneId: String?

    public var zoneMatchMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypeSupportIPv6 != nil {
            map["InstanceTypeSupportIPv6"] = self.instanceTypeSupportIPv6!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.maxPrice != nil {
            map["MaxPrice"] = self.maxPrice!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priorityStrategy != nil {
            map["PriorityStrategy"] = self.priorityStrategy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskCategory != nil {
            map["SystemDiskCategory"] = self.systemDiskCategory!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneMatchMode != nil {
            map["ZoneMatchMode"] = self.zoneMatchMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceFamilyLevel") {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! [String]
        }
        if dict.keys.contains("InstanceTypeSupportIPv6") {
            self.instanceTypeSupportIPv6 = dict["InstanceTypeSupportIPv6"] as! Bool
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("MaxPrice") {
            self.maxPrice = dict["MaxPrice"] as! Double
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PriorityStrategy") {
            self.priorityStrategy = dict["PriorityStrategy"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDiskCategory") {
            self.systemDiskCategory = dict["SystemDiskCategory"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
        if dict.keys.contains("ZoneMatchMode") {
            self.zoneMatchMode = dict["ZoneMatchMode"] as! String
        }
    }
}

public class DescribeRecommendProductResponseBody : Tea.TeaModel {
    public class RecommendProducts : Tea.TeaModel {
        public class RecommendProduct : Tea.TeaModel {
            public class RecommendInstanceTypes : Tea.TeaModel {
                public class RecommendInstanceType : Tea.TeaModel {
                    public class InstanceType : Tea.TeaModel {
                        public var cores: Int32?

                        public var generation: String?

                        public var instanceFamilyLevel: String?

                        public var instanceType: String?

                        public var instanceTypeFamily: String?

                        public var memory: Int32?

                        public var supportIoOptimized: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.cores != nil {
                                map["Cores"] = self.cores!
                            }
                            if self.generation != nil {
                                map["Generation"] = self.generation!
                            }
                            if self.instanceFamilyLevel != nil {
                                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
                            }
                            if self.instanceType != nil {
                                map["InstanceType"] = self.instanceType!
                            }
                            if self.instanceTypeFamily != nil {
                                map["InstanceTypeFamily"] = self.instanceTypeFamily!
                            }
                            if self.memory != nil {
                                map["Memory"] = self.memory!
                            }
                            if self.supportIoOptimized != nil {
                                map["SupportIoOptimized"] = self.supportIoOptimized!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Cores") {
                                self.cores = dict["Cores"] as! Int32
                            }
                            if dict.keys.contains("Generation") {
                                self.generation = dict["Generation"] as! String
                            }
                            if dict.keys.contains("InstanceFamilyLevel") {
                                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
                            }
                            if dict.keys.contains("InstanceType") {
                                self.instanceType = dict["InstanceType"] as! String
                            }
                            if dict.keys.contains("InstanceTypeFamily") {
                                self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                            }
                            if dict.keys.contains("Memory") {
                                self.memory = dict["Memory"] as! Int32
                            }
                            if dict.keys.contains("SupportIoOptimized") {
                                self.supportIoOptimized = dict["SupportIoOptimized"] as! String
                            }
                        }
                    }
                    public var capacitySpecification: String?

                    public var instanceChargeType: String?

                    public var instanceType: DescribeRecommendProductResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceTypes.RecommendInstanceType.InstanceType?

                    public var networkType: String?

                    public var price: Double?

                    public var priority: Int32?

                    public var spotStrategy: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.instanceType?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.capacitySpecification != nil {
                            map["CapacitySpecification"] = self.capacitySpecification!
                        }
                        if self.instanceChargeType != nil {
                            map["InstanceChargeType"] = self.instanceChargeType!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType?.toMap()
                        }
                        if self.networkType != nil {
                            map["NetworkType"] = self.networkType!
                        }
                        if self.price != nil {
                            map["Price"] = self.price!
                        }
                        if self.priority != nil {
                            map["Priority"] = self.priority!
                        }
                        if self.spotStrategy != nil {
                            map["SpotStrategy"] = self.spotStrategy!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CapacitySpecification") {
                            self.capacitySpecification = dict["CapacitySpecification"] as! String
                        }
                        if dict.keys.contains("InstanceChargeType") {
                            self.instanceChargeType = dict["InstanceChargeType"] as! String
                        }
                        if dict.keys.contains("InstanceType") {
                            var model = DescribeRecommendProductResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceTypes.RecommendInstanceType.InstanceType()
                            model.fromMap(dict["InstanceType"] as! [String: Any])
                            self.instanceType = model
                        }
                        if dict.keys.contains("NetworkType") {
                            self.networkType = dict["NetworkType"] as! String
                        }
                        if dict.keys.contains("Price") {
                            self.price = dict["Price"] as! Double
                        }
                        if dict.keys.contains("Priority") {
                            self.priority = dict["Priority"] as! Int32
                        }
                        if dict.keys.contains("SpotStrategy") {
                            self.spotStrategy = dict["SpotStrategy"] as! String
                        }
                    }
                }
                public var recommendInstanceType: [DescribeRecommendProductResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceTypes.RecommendInstanceType]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recommendInstanceType != nil {
                        var tmp : [Any] = []
                        for k in self.recommendInstanceType! {
                            tmp.append(k.toMap())
                        }
                        map["RecommendInstanceType"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RecommendInstanceType") {
                        self.recommendInstanceType = dict["RecommendInstanceType"] as! [DescribeRecommendProductResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceTypes.RecommendInstanceType]
                    }
                }
            }
            public var recommendInstanceTypes: DescribeRecommendProductResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceTypes?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.recommendInstanceTypes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.recommendInstanceTypes != nil {
                    map["RecommendInstanceTypes"] = self.recommendInstanceTypes?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RecommendInstanceTypes") {
                    var model = DescribeRecommendProductResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceTypes()
                    model.fromMap(dict["RecommendInstanceTypes"] as! [String: Any])
                    self.recommendInstanceTypes = model
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var recommendProduct: [DescribeRecommendProductResponseBody.RecommendProducts.RecommendProduct]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recommendProduct != nil {
                var tmp : [Any] = []
                for k in self.recommendProduct! {
                    tmp.append(k.toMap())
                }
                map["RecommendProduct"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecommendProduct") {
                self.recommendProduct = dict["RecommendProduct"] as! [DescribeRecommendProductResponseBody.RecommendProducts.RecommendProduct]
            }
        }
    }
    public var recommendProducts: DescribeRecommendProductResponseBody.RecommendProducts?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recommendProducts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recommendProducts != nil {
            map["RecommendProducts"] = self.recommendProducts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecommendProducts") {
            var model = DescribeRecommendProductResponseBody.RecommendProducts()
            model.fromMap(dict["RecommendProducts"] as! [String: Any])
            self.recommendProducts = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRecommendProductResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecommendProductResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecommendProductResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservationDemandCommittedAmountRequest : Tea.TeaModel {
    public class DemandPlan : Tea.TeaModel {
        public var amount: Int64?

        public var instanceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Amount") {
                self.amount = dict["Amount"] as! Int64
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
        }
    }
    public var demandPlan: [DescribeReservationDemandCommittedAmountRequest.DemandPlan]?

    public var instanceFamily: String?

    public var instanceFamilySet: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var planType: String?

    public var platform: String?

    public var purchaseMethod: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demandPlan != nil {
            var tmp : [Any] = []
            for k in self.demandPlan! {
                tmp.append(k.toMap())
            }
            map["DemandPlan"] = tmp
        }
        if self.instanceFamily != nil {
            map["InstanceFamily"] = self.instanceFamily!
        }
        if self.instanceFamilySet != nil {
            map["InstanceFamilySet"] = self.instanceFamilySet!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.purchaseMethod != nil {
            map["PurchaseMethod"] = self.purchaseMethod!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemandPlan") {
            self.demandPlan = dict["DemandPlan"] as! [DescribeReservationDemandCommittedAmountRequest.DemandPlan]
        }
        if dict.keys.contains("InstanceFamily") {
            self.instanceFamily = dict["InstanceFamily"] as! String
        }
        if dict.keys.contains("InstanceFamilySet") {
            self.instanceFamilySet = dict["InstanceFamilySet"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PlanType") {
            self.planType = dict["PlanType"] as! String
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("PurchaseMethod") {
            self.purchaseMethod = dict["PurchaseMethod"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
    }
}

public class DescribeReservationDemandCommittedAmountResponseBody : Tea.TeaModel {
    public class CommittedAmountInfo : Tea.TeaModel {
        public var committedAmount: Double?

        public var currency: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.committedAmount != nil {
                map["CommittedAmount"] = self.committedAmount!
            }
            if self.currency != nil {
                map["Currency"] = self.currency!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommittedAmount") {
                self.committedAmount = dict["CommittedAmount"] as! Double
            }
            if dict.keys.contains("Currency") {
                self.currency = dict["Currency"] as! String
            }
        }
    }
    public var committedAmountInfo: DescribeReservationDemandCommittedAmountResponseBody.CommittedAmountInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.committedAmountInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.committedAmountInfo != nil {
            map["CommittedAmountInfo"] = self.committedAmountInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommittedAmountInfo") {
            var model = DescribeReservationDemandCommittedAmountResponseBody.CommittedAmountInfo()
            model.fromMap(dict["CommittedAmountInfo"] as! [String: Any])
            self.committedAmountInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeReservationDemandCommittedAmountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservationDemandCommittedAmountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeReservationDemandCommittedAmountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservationDemandsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var demandId: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeReservationDemandsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demandId != nil {
            map["DemandId"] = self.demandId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemandId") {
            self.demandId = dict["DemandId"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeReservationDemandsRequest.Tag]
        }
    }
}

public class DescribeReservationDemandsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DemandOrders : Tea.TeaModel {
            public class RecommendResource : Tea.TeaModel {
                public class CapacityReservations : Tea.TeaModel {
                    public var instanceAmount: Int32?

                    public var instanceType: String?

                    public var matchCriteria: String?

                    public var planId: String?

                    public var privatePoolOptionsId: String?

                    public var startTime: String?

                    public var status: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceAmount != nil {
                            map["InstanceAmount"] = self.instanceAmount!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.matchCriteria != nil {
                            map["MatchCriteria"] = self.matchCriteria!
                        }
                        if self.planId != nil {
                            map["PlanId"] = self.planId!
                        }
                        if self.privatePoolOptionsId != nil {
                            map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceAmount") {
                            self.instanceAmount = dict["InstanceAmount"] as! Int32
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("MatchCriteria") {
                            self.matchCriteria = dict["MatchCriteria"] as! String
                        }
                        if dict.keys.contains("PlanId") {
                            self.planId = dict["PlanId"] as! String
                        }
                        if dict.keys.contains("PrivatePoolOptionsId") {
                            self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                        if dict.keys.contains("ZoneId") {
                            self.zoneId = dict["ZoneId"] as! String
                        }
                    }
                }
                public var capacityReservations: [DescribeReservationDemandsResponseBody.Data.DemandOrders.RecommendResource.CapacityReservations]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.capacityReservations != nil {
                        var tmp : [Any] = []
                        for k in self.capacityReservations! {
                            tmp.append(k.toMap())
                        }
                        map["CapacityReservations"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CapacityReservations") {
                        self.capacityReservations = dict["CapacityReservations"] as! [DescribeReservationDemandsResponseBody.Data.DemandOrders.RecommendResource.CapacityReservations]
                    }
                }
            }
            public class ReservationResource : Tea.TeaModel {
                public class CapacityReservations : Tea.TeaModel {
                    public var approveCode: String?

                    public var approveNotes: String?

                    public var instanceAmount: Int32?

                    public var instanceType: String?

                    public var matchCriteria: String?

                    public var planId: String?

                    public var privatePoolOptionsId: String?

                    public var startTime: String?

                    public var status: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.approveCode != nil {
                            map["ApproveCode"] = self.approveCode!
                        }
                        if self.approveNotes != nil {
                            map["ApproveNotes"] = self.approveNotes!
                        }
                        if self.instanceAmount != nil {
                            map["InstanceAmount"] = self.instanceAmount!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.matchCriteria != nil {
                            map["MatchCriteria"] = self.matchCriteria!
                        }
                        if self.planId != nil {
                            map["PlanId"] = self.planId!
                        }
                        if self.privatePoolOptionsId != nil {
                            map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ApproveCode") {
                            self.approveCode = dict["ApproveCode"] as! String
                        }
                        if dict.keys.contains("ApproveNotes") {
                            self.approveNotes = dict["ApproveNotes"] as! String
                        }
                        if dict.keys.contains("InstanceAmount") {
                            self.instanceAmount = dict["InstanceAmount"] as! Int32
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("MatchCriteria") {
                            self.matchCriteria = dict["MatchCriteria"] as! String
                        }
                        if dict.keys.contains("PlanId") {
                            self.planId = dict["PlanId"] as! String
                        }
                        if dict.keys.contains("PrivatePoolOptionsId") {
                            self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                        if dict.keys.contains("ZoneId") {
                            self.zoneId = dict["ZoneId"] as! String
                        }
                    }
                }
                public var capacityReservations: [DescribeReservationDemandsResponseBody.Data.DemandOrders.ReservationResource.CapacityReservations]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.capacityReservations != nil {
                        var tmp : [Any] = []
                        for k in self.capacityReservations! {
                            tmp.append(k.toMap())
                        }
                        map["CapacityReservations"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CapacityReservations") {
                        self.capacityReservations = dict["CapacityReservations"] as! [DescribeReservationDemandsResponseBody.Data.DemandOrders.ReservationResource.CapacityReservations]
                    }
                }
            }
            public var confirmType: String?

            public var couponAuto: String?

            public var couponType: String?

            public var demandId: String?

            public var description_: String?

            public var instanceChargeType: String?

            public var instanceCpuCoreCount: Int32?

            public var instanceTypes: String?

            public var matchCriteria: String?

            public var name: String?

            public var period: Int32?

            public var periodUnit: String?

            public var phoneNumber: String?

            public var platform: String?

            public var productType: String?

            public var recommendResource: DescribeReservationDemandsResponseBody.Data.DemandOrders.RecommendResource?

            public var regionId: String?

            public var reservationResource: DescribeReservationDemandsResponseBody.Data.DemandOrders.ReservationResource?

            public var reservedInstanceDescription: String?

            public var reservedInstanceId: String?

            public var reservedInstanceName: String?

            public var reservedInstanceOfferingType: String?

            public var resourceSupplyType: String?

            public var savingPlanDescription: String?

            public var savingPlanHourFee: Double?

            public var savingPlanId: String?

            public var savingPlanInstanceTypeFamilyGroup: String?

            public var savingPlanName: String?

            public var savingPlanPayMode: String?

            public var savingPlanSavingType: String?

            public var savingPlanSpecType: String?

            public var startTime: String?

            public var status: String?

            public var zoneIds: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.recommendResource?.validate()
                try self.reservationResource?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.confirmType != nil {
                    map["ConfirmType"] = self.confirmType!
                }
                if self.couponAuto != nil {
                    map["CouponAuto"] = self.couponAuto!
                }
                if self.couponType != nil {
                    map["CouponType"] = self.couponType!
                }
                if self.demandId != nil {
                    map["DemandId"] = self.demandId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceCpuCoreCount != nil {
                    map["InstanceCpuCoreCount"] = self.instanceCpuCoreCount!
                }
                if self.instanceTypes != nil {
                    map["InstanceTypes"] = self.instanceTypes!
                }
                if self.matchCriteria != nil {
                    map["MatchCriteria"] = self.matchCriteria!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productType != nil {
                    map["ProductType"] = self.productType!
                }
                if self.recommendResource != nil {
                    map["RecommendResource"] = self.recommendResource?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservationResource != nil {
                    map["ReservationResource"] = self.reservationResource?.toMap()
                }
                if self.reservedInstanceDescription != nil {
                    map["ReservedInstanceDescription"] = self.reservedInstanceDescription!
                }
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                if self.reservedInstanceName != nil {
                    map["ReservedInstanceName"] = self.reservedInstanceName!
                }
                if self.reservedInstanceOfferingType != nil {
                    map["ReservedInstanceOfferingType"] = self.reservedInstanceOfferingType!
                }
                if self.resourceSupplyType != nil {
                    map["ResourceSupplyType"] = self.resourceSupplyType!
                }
                if self.savingPlanDescription != nil {
                    map["SavingPlanDescription"] = self.savingPlanDescription!
                }
                if self.savingPlanHourFee != nil {
                    map["SavingPlanHourFee"] = self.savingPlanHourFee!
                }
                if self.savingPlanId != nil {
                    map["SavingPlanId"] = self.savingPlanId!
                }
                if self.savingPlanInstanceTypeFamilyGroup != nil {
                    map["SavingPlanInstanceTypeFamilyGroup"] = self.savingPlanInstanceTypeFamilyGroup!
                }
                if self.savingPlanName != nil {
                    map["SavingPlanName"] = self.savingPlanName!
                }
                if self.savingPlanPayMode != nil {
                    map["SavingPlanPayMode"] = self.savingPlanPayMode!
                }
                if self.savingPlanSavingType != nil {
                    map["SavingPlanSavingType"] = self.savingPlanSavingType!
                }
                if self.savingPlanSpecType != nil {
                    map["SavingPlanSpecType"] = self.savingPlanSpecType!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.zoneIds != nil {
                    map["ZoneIds"] = self.zoneIds!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfirmType") {
                    self.confirmType = dict["ConfirmType"] as! String
                }
                if dict.keys.contains("CouponAuto") {
                    self.couponAuto = dict["CouponAuto"] as! String
                }
                if dict.keys.contains("CouponType") {
                    self.couponType = dict["CouponType"] as! String
                }
                if dict.keys.contains("DemandId") {
                    self.demandId = dict["DemandId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InstanceCpuCoreCount") {
                    self.instanceCpuCoreCount = dict["InstanceCpuCoreCount"] as! Int32
                }
                if dict.keys.contains("InstanceTypes") {
                    self.instanceTypes = dict["InstanceTypes"] as! String
                }
                if dict.keys.contains("MatchCriteria") {
                    self.matchCriteria = dict["MatchCriteria"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! Int32
                }
                if dict.keys.contains("PeriodUnit") {
                    self.periodUnit = dict["PeriodUnit"] as! String
                }
                if dict.keys.contains("PhoneNumber") {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("ProductType") {
                    self.productType = dict["ProductType"] as! String
                }
                if dict.keys.contains("RecommendResource") {
                    var model = DescribeReservationDemandsResponseBody.Data.DemandOrders.RecommendResource()
                    model.fromMap(dict["RecommendResource"] as! [String: Any])
                    self.recommendResource = model
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReservationResource") {
                    var model = DescribeReservationDemandsResponseBody.Data.DemandOrders.ReservationResource()
                    model.fromMap(dict["ReservationResource"] as! [String: Any])
                    self.reservationResource = model
                }
                if dict.keys.contains("ReservedInstanceDescription") {
                    self.reservedInstanceDescription = dict["ReservedInstanceDescription"] as! String
                }
                if dict.keys.contains("ReservedInstanceId") {
                    self.reservedInstanceId = dict["ReservedInstanceId"] as! String
                }
                if dict.keys.contains("ReservedInstanceName") {
                    self.reservedInstanceName = dict["ReservedInstanceName"] as! String
                }
                if dict.keys.contains("ReservedInstanceOfferingType") {
                    self.reservedInstanceOfferingType = dict["ReservedInstanceOfferingType"] as! String
                }
                if dict.keys.contains("ResourceSupplyType") {
                    self.resourceSupplyType = dict["ResourceSupplyType"] as! String
                }
                if dict.keys.contains("SavingPlanDescription") {
                    self.savingPlanDescription = dict["SavingPlanDescription"] as! String
                }
                if dict.keys.contains("SavingPlanHourFee") {
                    self.savingPlanHourFee = dict["SavingPlanHourFee"] as! Double
                }
                if dict.keys.contains("SavingPlanId") {
                    self.savingPlanId = dict["SavingPlanId"] as! String
                }
                if dict.keys.contains("SavingPlanInstanceTypeFamilyGroup") {
                    self.savingPlanInstanceTypeFamilyGroup = dict["SavingPlanInstanceTypeFamilyGroup"] as! String
                }
                if dict.keys.contains("SavingPlanName") {
                    self.savingPlanName = dict["SavingPlanName"] as! String
                }
                if dict.keys.contains("SavingPlanPayMode") {
                    self.savingPlanPayMode = dict["SavingPlanPayMode"] as! String
                }
                if dict.keys.contains("SavingPlanSavingType") {
                    self.savingPlanSavingType = dict["SavingPlanSavingType"] as! String
                }
                if dict.keys.contains("SavingPlanSpecType") {
                    self.savingPlanSpecType = dict["SavingPlanSpecType"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("ZoneIds") {
                    self.zoneIds = dict["ZoneIds"] as! String
                }
            }
        }
        public var demandOrders: [DescribeReservationDemandsResponseBody.Data.DemandOrders]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.demandOrders != nil {
                var tmp : [Any] = []
                for k in self.demandOrders! {
                    tmp.append(k.toMap())
                }
                map["DemandOrders"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DemandOrders") {
                self.demandOrders = dict["DemandOrders"] as! [DescribeReservationDemandsResponseBody.Data.DemandOrders]
            }
        }
    }
    public var data: DescribeReservationDemandsResponseBody.Data?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeReservationDemandsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeReservationDemandsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservationDemandsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeReservationDemandsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservedInstanceAllocationsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var reservedInstanceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeReservedInstanceAllocationsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeReservedInstanceAllocationsRequest.Tag]
        }
    }
}

public class DescribeReservedInstanceAllocationsResponseBody : Tea.TeaModel {
    public class Allocations : Tea.TeaModel {
        public class Allocation : Tea.TeaModel {
            public var beAllocatedAccountId: String?

            public var reservedInstanceId: String?

            public var resourceOwnerId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beAllocatedAccountId != nil {
                    map["BeAllocatedAccountId"] = self.beAllocatedAccountId!
                }
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                if self.resourceOwnerId != nil {
                    map["ResourceOwnerId"] = self.resourceOwnerId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeAllocatedAccountId") {
                    self.beAllocatedAccountId = dict["BeAllocatedAccountId"] as! String
                }
                if dict.keys.contains("ReservedInstanceId") {
                    self.reservedInstanceId = dict["ReservedInstanceId"] as! String
                }
                if dict.keys.contains("ResourceOwnerId") {
                    self.resourceOwnerId = dict["ResourceOwnerId"] as! String
                }
            }
        }
        public var allocation: [DescribeReservedInstanceAllocationsResponseBody.Allocations.Allocation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocation != nil {
                var tmp : [Any] = []
                for k in self.allocation! {
                    tmp.append(k.toMap())
                }
                map["Allocation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Allocation") {
                self.allocation = dict["Allocation"] as! [DescribeReservedInstanceAllocationsResponseBody.Allocations.Allocation]
            }
        }
    }
    public var allocations: DescribeReservedInstanceAllocationsResponseBody.Allocations?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.allocations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocations != nil {
            map["Allocations"] = self.allocations?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Allocations") {
            var model = DescribeReservedInstanceAllocationsResponseBody.Allocations()
            model.fromMap(dict["Allocations"] as! [String: Any])
            self.allocations = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeReservedInstanceAllocationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedInstanceAllocationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeReservedInstanceAllocationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservedInstanceCategoriesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scope: String?

    public var tag: [DescribeReservedInstanceCategoriesRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeReservedInstanceCategoriesRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeReservedInstanceCategoriesResponseBody : Tea.TeaModel {
    public class ReservedInstanceCategories : Tea.TeaModel {
        public class ReservedInstanceCategory : Tea.TeaModel {
            public var amount: Int32?

            public var instanceAmount: Int32?

            public var instanceType: String?

            public var platform: String?

            public var regionId: String?

            public var scope: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.instanceAmount != nil {
                    map["InstanceAmount"] = self.instanceAmount!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Amount") {
                    self.amount = dict["Amount"] as! Int32
                }
                if dict.keys.contains("InstanceAmount") {
                    self.instanceAmount = dict["InstanceAmount"] as! Int32
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Scope") {
                    self.scope = dict["Scope"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var reservedInstanceCategory: [DescribeReservedInstanceCategoriesResponseBody.ReservedInstanceCategories.ReservedInstanceCategory]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceCategory != nil {
                var tmp : [Any] = []
                for k in self.reservedInstanceCategory! {
                    tmp.append(k.toMap())
                }
                map["ReservedInstanceCategory"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservedInstanceCategory") {
                self.reservedInstanceCategory = dict["ReservedInstanceCategory"] as! [DescribeReservedInstanceCategoriesResponseBody.ReservedInstanceCategories.ReservedInstanceCategory]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var reservedInstanceCategories: DescribeReservedInstanceCategoriesResponseBody.ReservedInstanceCategories?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceCategories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceCategories != nil {
            map["ReservedInstanceCategories"] = self.reservedInstanceCategories?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedInstanceCategories") {
            var model = DescribeReservedInstanceCategoriesResponseBody.ReservedInstanceCategories()
            model.fromMap(dict["ReservedInstanceCategories"] as! [String: Any])
            self.reservedInstanceCategories = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeReservedInstanceCategoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedInstanceCategoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeReservedInstanceCategoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservedInstancePriceRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeReservedInstancePriceRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeReservedInstancePriceRequest.Tag]
        }
    }
}

public class DescribeReservedInstancePriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Order : Tea.TeaModel {
            public var currency: String?

            public var reservedInstanceHourPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.reservedInstanceHourPrice != nil {
                    map["ReservedInstanceHourPrice"] = self.reservedInstanceHourPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("ReservedInstanceHourPrice") {
                    self.reservedInstanceHourPrice = dict["ReservedInstanceHourPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public var order: DescribeReservedInstancePriceResponseBody.PriceInfo.Order?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.order?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.order != nil {
                map["Order"] = self.order?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Order") {
                var model = DescribeReservedInstancePriceResponseBody.PriceInfo.Order()
                model.fromMap(dict["Order"] as! [String: Any])
                self.order = model
            }
        }
    }
    public var priceInfo: DescribeReservedInstancePriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribeReservedInstancePriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeReservedInstancePriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedInstancePriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeReservedInstancePriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservedInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var allocationType: String?

    public var expiredTime: String?

    public var instanceType: String?

    public var instanceTypeFamily: String?

    public var lockReason: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var reservedInstanceName: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scope: String?

    public var status: [String]?

    public var tag: [DescribeReservedInstancesRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationType != nil {
            map["AllocationType"] = self.allocationType!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationType") {
            self.allocationType = dict["AllocationType"] as! String
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
        }
        if dict.keys.contains("ReservedInstanceName") {
            self.reservedInstanceName = dict["ReservedInstanceName"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! [String]
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeReservedInstancesRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeReservedInstancesResponseBody : Tea.TeaModel {
    public class ReservedInstances : Tea.TeaModel {
        public class ReservedInstance : Tea.TeaModel {
            public class OperationLocks : Tea.TeaModel {
                public class OperationLock : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LockReason") {
                            self.lockReason = dict["LockReason"] as! String
                        }
                    }
                }
                public var operationLock: [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks.OperationLock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operationLock != nil {
                        var tmp : [Any] = []
                        for k in self.operationLock! {
                            tmp.append(k.toMap())
                        }
                        map["OperationLock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OperationLock") {
                        self.operationLock = dict["OperationLock"] as! [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks.OperationLock]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags.Tag]
                    }
                }
            }
            public var allocationStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var expiredTime: String?

            public var instanceAmount: Int32?

            public var instanceType: String?

            public var offeringType: String?

            public var operationLocks: DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks?

            public var platform: String?

            public var regionId: String?

            public var reservedInstanceId: String?

            public var reservedInstanceName: String?

            public var resourceGroupId: String?

            public var scope: String?

            public var startTime: String?

            public var status: String?

            public var tags: DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.operationLocks?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationStatus != nil {
                    map["AllocationStatus"] = self.allocationStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.instanceAmount != nil {
                    map["InstanceAmount"] = self.instanceAmount!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.offeringType != nil {
                    map["OfferingType"] = self.offeringType!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                if self.reservedInstanceName != nil {
                    map["ReservedInstanceName"] = self.reservedInstanceName!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocationStatus") {
                    self.allocationStatus = dict["AllocationStatus"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("InstanceAmount") {
                    self.instanceAmount = dict["InstanceAmount"] as! Int32
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("OfferingType") {
                    self.offeringType = dict["OfferingType"] as! String
                }
                if dict.keys.contains("OperationLocks") {
                    var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks()
                    model.fromMap(dict["OperationLocks"] as! [String: Any])
                    self.operationLocks = model
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReservedInstanceId") {
                    self.reservedInstanceId = dict["ReservedInstanceId"] as! String
                }
                if dict.keys.contains("ReservedInstanceName") {
                    self.reservedInstanceName = dict["ReservedInstanceName"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Scope") {
                    self.scope = dict["Scope"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var reservedInstance: [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstance != nil {
                var tmp : [Any] = []
                for k in self.reservedInstance! {
                    tmp.append(k.toMap())
                }
                map["ReservedInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservedInstance") {
                self.reservedInstance = dict["ReservedInstance"] as! [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var reservedInstances: DescribeReservedInstancesResponseBody.ReservedInstances?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstances != nil {
            map["ReservedInstances"] = self.reservedInstances?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedInstances") {
            var model = DescribeReservedInstancesResponseBody.ReservedInstances()
            model.fromMap(dict["ReservedInstances"] as! [String: Any])
            self.reservedInstances = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeReservedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeReservedInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceAggregationsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var attributeName: String?

        public var attributeValue: String?

        public var operation: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attributeName != nil {
                map["AttributeName"] = self.attributeName!
            }
            if self.attributeValue != nil {
                map["AttributeValue"] = self.attributeValue!
            }
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttributeName") {
                self.attributeName = dict["AttributeName"] as! String
            }
            if dict.keys.contains("AttributeValue") {
                self.attributeValue = dict["AttributeValue"] as! String
            }
            if dict.keys.contains("Operation") {
                self.operation = dict["Operation"] as! String
            }
        }
    }
    public class TagFilter : Tea.TeaModel {
        public var operation: String?

        public var tagKey: String?

        public var tagValues: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValues != nil {
                map["TagValues"] = self.tagValues!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Operation") {
                self.operation = dict["Operation"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValues") {
                self.tagValues = dict["TagValues"] as! [String]
            }
        }
    }
    public var aggregators: [String]?

    public var filter: [DescribeResourceAggregationsRequest.Filter]?

    public var global: String?

    public var keyword: String?

    public var marker: String?

    public var maxItems: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var product: String?

    public var regionId: String?

    public var regionNo: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagFilter: [DescribeResourceAggregationsRequest.TagFilter]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregators != nil {
            map["Aggregators"] = self.aggregators!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.global != nil {
            map["Global"] = self.global!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.marker != nil {
            map["Marker"] = self.marker!
        }
        if self.maxItems != nil {
            map["MaxItems"] = self.maxItems!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.regionNo != nil {
            map["RegionNo"] = self.regionNo!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagFilter != nil {
            var tmp : [Any] = []
            for k in self.tagFilter! {
                tmp.append(k.toMap())
            }
            map["TagFilter"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Aggregators") {
            self.aggregators = dict["Aggregators"] as! [String]
        }
        if dict.keys.contains("Filter") {
            self.filter = dict["Filter"] as! [DescribeResourceAggregationsRequest.Filter]
        }
        if dict.keys.contains("Global") {
            self.global = dict["Global"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Marker") {
            self.marker = dict["Marker"] as! String
        }
        if dict.keys.contains("MaxItems") {
            self.maxItems = dict["MaxItems"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Product") {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RegionNo") {
            self.regionNo = dict["RegionNo"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagFilter") {
            self.tagFilter = dict["TagFilter"] as! [DescribeResourceAggregationsRequest.TagFilter]
        }
    }
}

public class DescribeResourceAggregationsResponseBody : Tea.TeaModel {
    public class Aggregations : Tea.TeaModel {
        public class Aggregation : Tea.TeaModel {
            public var count: String?

            public var keys: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.keys != nil {
                    map["Keys"] = self.keys!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! String
                }
                if dict.keys.contains("Keys") {
                    self.keys = dict["Keys"] as! String
                }
            }
        }
        public var aggregation: [DescribeResourceAggregationsResponseBody.Aggregations.Aggregation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aggregation != nil {
                var tmp : [Any] = []
                for k in self.aggregation! {
                    tmp.append(k.toMap())
                }
                map["Aggregation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Aggregation") {
                self.aggregation = dict["Aggregation"] as! [DescribeResourceAggregationsResponseBody.Aggregations.Aggregation]
            }
        }
    }
    public var aggregations: DescribeResourceAggregationsResponseBody.Aggregations?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aggregations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aggregations != nil {
            map["Aggregations"] = self.aggregations?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Aggregations") {
            var model = DescribeResourceAggregationsResponseBody.Aggregations()
            model.fromMap(dict["Aggregations"] as! [String: Any])
            self.aggregations = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeResourceAggregationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceAggregationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceAggregationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceAllocationRequest : Tea.TeaModel {
    public class InstanceTypeModel : Tea.TeaModel {
        public var instanceType: String?

        public var maxPrice: Double?

        public var spotStrategy: String?

        public var weightedCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("MaxPrice") {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("SpotStrategy") {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Double
            }
        }
    }
    public var cores: Int32?

    public var dataDiskCategory: [String]?

    public var defaultTargetCapacityType: String?

    public var instanceFamilyLevel: String?

    public var instanceTypeModel: [DescribeResourceAllocationRequest.InstanceTypeModel]?

    public var instanceTypeSupportIPv6: Bool?

    public var ioOptimized: String?

    public var maxPrice: Double?

    public var memory: Double?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var postPaidBaseCapacity: Int32?

    public var priorityStrategy: String?

    public var regionId: String?

    public var resourceAmountType: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotBaseCapacity: Int32?

    public var spotInstancePools: Int32?

    public var spotStrategy: String?

    public var strictSatisfiedTargetCapacity: Bool?

    public var systemDiskCategory: String?

    public var targetCapacity: Int32?

    public var zoneId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.dataDiskCategory != nil {
            map["DataDiskCategory"] = self.dataDiskCategory!
        }
        if self.defaultTargetCapacityType != nil {
            map["DefaultTargetCapacityType"] = self.defaultTargetCapacityType!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypeModel != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeModel! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeModel"] = tmp
        }
        if self.instanceTypeSupportIPv6 != nil {
            map["InstanceTypeSupportIPv6"] = self.instanceTypeSupportIPv6!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.maxPrice != nil {
            map["MaxPrice"] = self.maxPrice!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.postPaidBaseCapacity != nil {
            map["PostPaidBaseCapacity"] = self.postPaidBaseCapacity!
        }
        if self.priorityStrategy != nil {
            map["PriorityStrategy"] = self.priorityStrategy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceAmountType != nil {
            map["ResourceAmountType"] = self.resourceAmountType!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotBaseCapacity != nil {
            map["SpotBaseCapacity"] = self.spotBaseCapacity!
        }
        if self.spotInstancePools != nil {
            map["SpotInstancePools"] = self.spotInstancePools!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.strictSatisfiedTargetCapacity != nil {
            map["StrictSatisfiedTargetCapacity"] = self.strictSatisfiedTargetCapacity!
        }
        if self.systemDiskCategory != nil {
            map["SystemDiskCategory"] = self.systemDiskCategory!
        }
        if self.targetCapacity != nil {
            map["TargetCapacity"] = self.targetCapacity!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("DataDiskCategory") {
            self.dataDiskCategory = dict["DataDiskCategory"] as! [String]
        }
        if dict.keys.contains("DefaultTargetCapacityType") {
            self.defaultTargetCapacityType = dict["DefaultTargetCapacityType"] as! String
        }
        if dict.keys.contains("InstanceFamilyLevel") {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceTypeModel") {
            self.instanceTypeModel = dict["InstanceTypeModel"] as! [DescribeResourceAllocationRequest.InstanceTypeModel]
        }
        if dict.keys.contains("InstanceTypeSupportIPv6") {
            self.instanceTypeSupportIPv6 = dict["InstanceTypeSupportIPv6"] as! Bool
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("MaxPrice") {
            self.maxPrice = dict["MaxPrice"] as! Double
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PostPaidBaseCapacity") {
            self.postPaidBaseCapacity = dict["PostPaidBaseCapacity"] as! Int32
        }
        if dict.keys.contains("PriorityStrategy") {
            self.priorityStrategy = dict["PriorityStrategy"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceAmountType") {
            self.resourceAmountType = dict["ResourceAmountType"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SpotBaseCapacity") {
            self.spotBaseCapacity = dict["SpotBaseCapacity"] as! Int32
        }
        if dict.keys.contains("SpotInstancePools") {
            self.spotInstancePools = dict["SpotInstancePools"] as! Int32
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StrictSatisfiedTargetCapacity") {
            self.strictSatisfiedTargetCapacity = dict["StrictSatisfiedTargetCapacity"] as! Bool
        }
        if dict.keys.contains("SystemDiskCategory") {
            self.systemDiskCategory = dict["SystemDiskCategory"] as! String
        }
        if dict.keys.contains("TargetCapacity") {
            self.targetCapacity = dict["TargetCapacity"] as! Int32
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! [String]
        }
    }
}

public class DescribeResourceAllocationResponseBody : Tea.TeaModel {
    public class ResourcePlanningResponse : Tea.TeaModel {
        public class ResourceModels : Tea.TeaModel {
            public class ResourceModel : Tea.TeaModel {
                public var amount: Int32?

                public var instanceChargeType: String?

                public var instanceType: String?

                public var ioOptimized: String?

                public var networkType: String?

                public var price: Double?

                public var regionId: String?

                public var spotStrategy: String?

                public var zoneId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.amount != nil {
                        map["Amount"] = self.amount!
                    }
                    if self.instanceChargeType != nil {
                        map["InstanceChargeType"] = self.instanceChargeType!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.ioOptimized != nil {
                        map["IoOptimized"] = self.ioOptimized!
                    }
                    if self.networkType != nil {
                        map["NetworkType"] = self.networkType!
                    }
                    if self.price != nil {
                        map["Price"] = self.price!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.spotStrategy != nil {
                        map["SpotStrategy"] = self.spotStrategy!
                    }
                    if self.zoneId != nil {
                        map["ZoneId"] = self.zoneId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Amount") {
                        self.amount = dict["Amount"] as! Int32
                    }
                    if dict.keys.contains("InstanceChargeType") {
                        self.instanceChargeType = dict["InstanceChargeType"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("IoOptimized") {
                        self.ioOptimized = dict["IoOptimized"] as! String
                    }
                    if dict.keys.contains("NetworkType") {
                        self.networkType = dict["NetworkType"] as! String
                    }
                    if dict.keys.contains("Price") {
                        self.price = dict["Price"] as! Double
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("SpotStrategy") {
                        self.spotStrategy = dict["SpotStrategy"] as! String
                    }
                    if dict.keys.contains("ZoneId") {
                        self.zoneId = dict["ZoneId"] as! String
                    }
                }
            }
            public var resourceModel: [DescribeResourceAllocationResponseBody.ResourcePlanningResponse.ResourceModels.ResourceModel]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceModel != nil {
                    var tmp : [Any] = []
                    for k in self.resourceModel! {
                        tmp.append(k.toMap())
                    }
                    map["ResourceModel"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceModel") {
                    self.resourceModel = dict["ResourceModel"] as! [DescribeResourceAllocationResponseBody.ResourcePlanningResponse.ResourceModels.ResourceModel]
                }
            }
        }
        public var resourceModels: DescribeResourceAllocationResponseBody.ResourcePlanningResponse.ResourceModels?

        public var satisfiedAmount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.resourceModels?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceModels != nil {
                map["ResourceModels"] = self.resourceModels?.toMap()
            }
            if self.satisfiedAmount != nil {
                map["SatisfiedAmount"] = self.satisfiedAmount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceModels") {
                var model = DescribeResourceAllocationResponseBody.ResourcePlanningResponse.ResourceModels()
                model.fromMap(dict["ResourceModels"] as! [String: Any])
                self.resourceModels = model
            }
            if dict.keys.contains("SatisfiedAmount") {
                self.satisfiedAmount = dict["SatisfiedAmount"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var resourcePlanningResponse: DescribeResourceAllocationResponseBody.ResourcePlanningResponse?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourcePlanningResponse?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourcePlanningResponse != nil {
            map["ResourcePlanningResponse"] = self.resourcePlanningResponse?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourcePlanningResponse") {
            var model = DescribeResourceAllocationResponseBody.ResourcePlanningResponse()
            model.fromMap(dict["ResourcePlanningResponse"] as! [String: Any])
            self.resourcePlanningResponse = model
        }
    }
}

public class DescribeResourceAllocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceAllocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceAllocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceDisplayRequest : Tea.TeaModel {
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var chargeType: String?

    public var firstBizLevel: String?

    public var instanceCategoryType: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var secondBizLevel: String?

    public var spotStrategy: String?

    public var templateTag: [DescribeResourceDisplayRequest.TemplateTag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.firstBizLevel != nil {
            map["FirstBizLevel"] = self.firstBizLevel!
        }
        if self.instanceCategoryType != nil {
            map["InstanceCategoryType"] = self.instanceCategoryType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.secondBizLevel != nil {
            map["SecondBizLevel"] = self.secondBizLevel!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("FirstBizLevel") {
            self.firstBizLevel = dict["FirstBizLevel"] as! String
        }
        if dict.keys.contains("InstanceCategoryType") {
            self.instanceCategoryType = dict["InstanceCategoryType"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecondBizLevel") {
            self.secondBizLevel = dict["SecondBizLevel"] as! String
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("TemplateTag") {
            self.templateTag = dict["TemplateTag"] as! [DescribeResourceDisplayRequest.TemplateTag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeResourceDisplayResponseBody : Tea.TeaModel {
    public class ResourceDisplay : Tea.TeaModel {
        public class InstanceCategories : Tea.TeaModel {
            public class InstanceCategory : Tea.TeaModel {
                public class InstanceTopCategories : Tea.TeaModel {
                    public class InstanceTopCategory : Tea.TeaModel {
                        public class InstanceSecondCategories : Tea.TeaModel {
                            public class InstanceSecondCategory : Tea.TeaModel {
                                public class InstanceTypeFamilies : Tea.TeaModel {
                                    public class InstanceTypeFamily : Tea.TeaModel {
                                        public class Tags : Tea.TeaModel {
                                            public var tag: [String]?

                                            public override init() {
                                                super.init()
                                            }

                                            public init(_ dict: [String: Any]) {
                                                super.init()
                                                self.fromMap(dict)
                                            }

                                            public override func validate() throws -> Void {
                                            }

                                            public override func toMap() -> [String : Any] {
                                                var map = super.toMap()
                                                if self.tag != nil {
                                                    map["Tag"] = self.tag!
                                                }
                                                return map
                                            }

                                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                                if dict.keys.contains("Tag") {
                                                    self.tag = dict["Tag"] as! [String]
                                                }
                                            }
                                        }
                                        public var instanceTypeFamilyId: String?

                                        public var tags: DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories.InstanceSecondCategory.InstanceTypeFamilies.InstanceTypeFamily.Tags?

                                        public override init() {
                                            super.init()
                                        }

                                        public init(_ dict: [String: Any]) {
                                            super.init()
                                            self.fromMap(dict)
                                        }

                                        public override func validate() throws -> Void {
                                            try self.tags?.validate()
                                        }

                                        public override func toMap() -> [String : Any] {
                                            var map = super.toMap()
                                            if self.instanceTypeFamilyId != nil {
                                                map["InstanceTypeFamilyId"] = self.instanceTypeFamilyId!
                                            }
                                            if self.tags != nil {
                                                map["Tags"] = self.tags?.toMap()
                                            }
                                            return map
                                        }

                                        public override func fromMap(_ dict: [String: Any]) -> Void {
                                            if dict.keys.contains("InstanceTypeFamilyId") {
                                                self.instanceTypeFamilyId = dict["InstanceTypeFamilyId"] as! String
                                            }
                                            if dict.keys.contains("Tags") {
                                                var model = DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories.InstanceSecondCategory.InstanceTypeFamilies.InstanceTypeFamily.Tags()
                                                model.fromMap(dict["Tags"] as! [String: Any])
                                                self.tags = model
                                            }
                                        }
                                    }
                                    public var instanceTypeFamily: [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories.InstanceSecondCategory.InstanceTypeFamilies.InstanceTypeFamily]?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.instanceTypeFamily != nil {
                                            var tmp : [Any] = []
                                            for k in self.instanceTypeFamily! {
                                                tmp.append(k.toMap())
                                            }
                                            map["InstanceTypeFamily"] = tmp
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("InstanceTypeFamily") {
                                            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories.InstanceSecondCategory.InstanceTypeFamilies.InstanceTypeFamily]
                                        }
                                    }
                                }
                                public var instanceTypeFamilies: DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories.InstanceSecondCategory.InstanceTypeFamilies?

                                public var secondCategoryLevel: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.instanceTypeFamilies?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.instanceTypeFamilies != nil {
                                        map["InstanceTypeFamilies"] = self.instanceTypeFamilies?.toMap()
                                    }
                                    if self.secondCategoryLevel != nil {
                                        map["SecondCategoryLevel"] = self.secondCategoryLevel!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("InstanceTypeFamilies") {
                                        var model = DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories.InstanceSecondCategory.InstanceTypeFamilies()
                                        model.fromMap(dict["InstanceTypeFamilies"] as! [String: Any])
                                        self.instanceTypeFamilies = model
                                    }
                                    if dict.keys.contains("SecondCategoryLevel") {
                                        self.secondCategoryLevel = dict["SecondCategoryLevel"] as! String
                                    }
                                }
                            }
                            public var instanceSecondCategory: [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories.InstanceSecondCategory]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.instanceSecondCategory != nil {
                                    var tmp : [Any] = []
                                    for k in self.instanceSecondCategory! {
                                        tmp.append(k.toMap())
                                    }
                                    map["InstanceSecondCategory"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("InstanceSecondCategory") {
                                    self.instanceSecondCategory = dict["InstanceSecondCategory"] as! [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories.InstanceSecondCategory]
                                }
                            }
                        }
                        public var instanceSecondCategories: DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories?

                        public var topCategoryLevel: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.instanceSecondCategories?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.instanceSecondCategories != nil {
                                map["InstanceSecondCategories"] = self.instanceSecondCategories?.toMap()
                            }
                            if self.topCategoryLevel != nil {
                                map["TopCategoryLevel"] = self.topCategoryLevel!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("InstanceSecondCategories") {
                                var model = DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory.InstanceSecondCategories()
                                model.fromMap(dict["InstanceSecondCategories"] as! [String: Any])
                                self.instanceSecondCategories = model
                            }
                            if dict.keys.contains("TopCategoryLevel") {
                                self.topCategoryLevel = dict["TopCategoryLevel"] as! String
                            }
                        }
                    }
                    public var instanceTopCategory: [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceTopCategory != nil {
                            var tmp : [Any] = []
                            for k in self.instanceTopCategory! {
                                tmp.append(k.toMap())
                            }
                            map["InstanceTopCategory"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceTopCategory") {
                            self.instanceTopCategory = dict["InstanceTopCategory"] as! [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories.InstanceTopCategory]
                        }
                    }
                }
                public class ZoneIds : Tea.TeaModel {
                    public var zoneId: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ZoneId") {
                            self.zoneId = dict["ZoneId"] as! [String]
                        }
                    }
                }
                public var categoryType: String?

                public var instanceTopCategories: DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories?

                public var zoneIds: DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.ZoneIds?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.instanceTopCategories?.validate()
                    try self.zoneIds?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.categoryType != nil {
                        map["CategoryType"] = self.categoryType!
                    }
                    if self.instanceTopCategories != nil {
                        map["InstanceTopCategories"] = self.instanceTopCategories?.toMap()
                    }
                    if self.zoneIds != nil {
                        map["ZoneIds"] = self.zoneIds?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CategoryType") {
                        self.categoryType = dict["CategoryType"] as! String
                    }
                    if dict.keys.contains("InstanceTopCategories") {
                        var model = DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.InstanceTopCategories()
                        model.fromMap(dict["InstanceTopCategories"] as! [String: Any])
                        self.instanceTopCategories = model
                    }
                    if dict.keys.contains("ZoneIds") {
                        var model = DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory.ZoneIds()
                        model.fromMap(dict["ZoneIds"] as! [String: Any])
                        self.zoneIds = model
                    }
                }
            }
            public var instanceCategory: [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceCategory != nil {
                    var tmp : [Any] = []
                    for k in self.instanceCategory! {
                        tmp.append(k.toMap())
                    }
                    map["InstanceCategory"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceCategory") {
                    self.instanceCategory = dict["InstanceCategory"] as! [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories.InstanceCategory]
                }
            }
        }
        public class InstanceChargeTypes : Tea.TeaModel {
            public class InstanceChargeType : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var tag: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tag != nil {
                            map["Tag"] = self.tag!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Tag") {
                            self.tag = dict["Tag"] as! [String]
                        }
                    }
                }
                public var chargeType: String?

                public var spotStrategy: String?

                public var tags: DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceChargeTypes.InstanceChargeType.Tags?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.tags?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.chargeType != nil {
                        map["ChargeType"] = self.chargeType!
                    }
                    if self.spotStrategy != nil {
                        map["SpotStrategy"] = self.spotStrategy!
                    }
                    if self.tags != nil {
                        map["Tags"] = self.tags?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ChargeType") {
                        self.chargeType = dict["ChargeType"] as! String
                    }
                    if dict.keys.contains("SpotStrategy") {
                        self.spotStrategy = dict["SpotStrategy"] as! String
                    }
                    if dict.keys.contains("Tags") {
                        var model = DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceChargeTypes.InstanceChargeType.Tags()
                        model.fromMap(dict["Tags"] as! [String: Any])
                        self.tags = model
                    }
                }
            }
            public var instanceChargeType: [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceChargeTypes.InstanceChargeType]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceChargeType != nil {
                    var tmp : [Any] = []
                    for k in self.instanceChargeType! {
                        tmp.append(k.toMap())
                    }
                    map["InstanceChargeType"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! [DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceChargeTypes.InstanceChargeType]
                }
            }
        }
        public class ProductCategories : Tea.TeaModel {
            public class ProductCategory : Tea.TeaModel {
                public class InstanceFamilyGroups : Tea.TeaModel {
                    public class InstanceFamilyGroup : Tea.TeaModel {
                        public class InstanceTypeFamilies : Tea.TeaModel {
                            public class InstanceTypeFamily : Tea.TeaModel {
                                public class Tags : Tea.TeaModel {
                                    public var tag: [String]?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.tag != nil {
                                            map["Tag"] = self.tag!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Tag") {
                                            self.tag = dict["Tag"] as! [String]
                                        }
                                    }
                                }
                                public var instanceTypeFamilyId: String?

                                public var tags: DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups.InstanceFamilyGroup.InstanceTypeFamilies.InstanceTypeFamily.Tags?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.tags?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.instanceTypeFamilyId != nil {
                                        map["InstanceTypeFamilyId"] = self.instanceTypeFamilyId!
                                    }
                                    if self.tags != nil {
                                        map["Tags"] = self.tags?.toMap()
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("InstanceTypeFamilyId") {
                                        self.instanceTypeFamilyId = dict["InstanceTypeFamilyId"] as! String
                                    }
                                    if dict.keys.contains("Tags") {
                                        var model = DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups.InstanceFamilyGroup.InstanceTypeFamilies.InstanceTypeFamily.Tags()
                                        model.fromMap(dict["Tags"] as! [String: Any])
                                        self.tags = model
                                    }
                                }
                            }
                            public var instanceTypeFamily: [DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups.InstanceFamilyGroup.InstanceTypeFamilies.InstanceTypeFamily]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.instanceTypeFamily != nil {
                                    var tmp : [Any] = []
                                    for k in self.instanceTypeFamily! {
                                        tmp.append(k.toMap())
                                    }
                                    map["InstanceTypeFamily"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("InstanceTypeFamily") {
                                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! [DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups.InstanceFamilyGroup.InstanceTypeFamilies.InstanceTypeFamily]
                                }
                            }
                        }
                        public var instanceFamilyGroupName: String?

                        public var instanceTypeFamilies: DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups.InstanceFamilyGroup.InstanceTypeFamilies?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.instanceTypeFamilies?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.instanceFamilyGroupName != nil {
                                map["InstanceFamilyGroupName"] = self.instanceFamilyGroupName!
                            }
                            if self.instanceTypeFamilies != nil {
                                map["InstanceTypeFamilies"] = self.instanceTypeFamilies?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("InstanceFamilyGroupName") {
                                self.instanceFamilyGroupName = dict["InstanceFamilyGroupName"] as! String
                            }
                            if dict.keys.contains("InstanceTypeFamilies") {
                                var model = DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups.InstanceFamilyGroup.InstanceTypeFamilies()
                                model.fromMap(dict["InstanceTypeFamilies"] as! [String: Any])
                                self.instanceTypeFamilies = model
                            }
                        }
                    }
                    public var instanceFamilyGroup: [DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups.InstanceFamilyGroup]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceFamilyGroup != nil {
                            var tmp : [Any] = []
                            for k in self.instanceFamilyGroup! {
                                tmp.append(k.toMap())
                            }
                            map["InstanceFamilyGroup"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceFamilyGroup") {
                            self.instanceFamilyGroup = dict["InstanceFamilyGroup"] as! [DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups.InstanceFamilyGroup]
                        }
                    }
                }
                public var instanceFamilyGroups: DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups?

                public var productName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.instanceFamilyGroups?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceFamilyGroups != nil {
                        map["InstanceFamilyGroups"] = self.instanceFamilyGroups?.toMap()
                    }
                    if self.productName != nil {
                        map["ProductName"] = self.productName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceFamilyGroups") {
                        var model = DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory.InstanceFamilyGroups()
                        model.fromMap(dict["InstanceFamilyGroups"] as! [String: Any])
                        self.instanceFamilyGroups = model
                    }
                    if dict.keys.contains("ProductName") {
                        self.productName = dict["ProductName"] as! String
                    }
                }
            }
            public var productCategory: [DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.productCategory != nil {
                    var tmp : [Any] = []
                    for k in self.productCategory! {
                        tmp.append(k.toMap())
                    }
                    map["ProductCategory"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ProductCategory") {
                    self.productCategory = dict["ProductCategory"] as! [DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories.ProductCategory]
                }
            }
        }
        public class Zones : Tea.TeaModel {
            public class Zone : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var tag: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tag != nil {
                            map["Tag"] = self.tag!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Tag") {
                            self.tag = dict["Tag"] as! [String]
                        }
                    }
                }
                public var tags: DescribeResourceDisplayResponseBody.ResourceDisplay.Zones.Zone.Tags?

                public var zoneId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.tags?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tags != nil {
                        map["Tags"] = self.tags?.toMap()
                    }
                    if self.zoneId != nil {
                        map["ZoneId"] = self.zoneId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tags") {
                        var model = DescribeResourceDisplayResponseBody.ResourceDisplay.Zones.Zone.Tags()
                        model.fromMap(dict["Tags"] as! [String: Any])
                        self.tags = model
                    }
                    if dict.keys.contains("ZoneId") {
                        self.zoneId = dict["ZoneId"] as! String
                    }
                }
            }
            public var zone: [DescribeResourceDisplayResponseBody.ResourceDisplay.Zones.Zone]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.zone != nil {
                    var tmp : [Any] = []
                    for k in self.zone! {
                        tmp.append(k.toMap())
                    }
                    map["Zone"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Zone") {
                    self.zone = dict["Zone"] as! [DescribeResourceDisplayResponseBody.ResourceDisplay.Zones.Zone]
                }
            }
        }
        public var instanceCategories: DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories?

        public var instanceChargeTypes: DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceChargeTypes?

        public var productCategories: DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories?

        public var zones: DescribeResourceDisplayResponseBody.ResourceDisplay.Zones?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.instanceCategories?.validate()
            try self.instanceChargeTypes?.validate()
            try self.productCategories?.validate()
            try self.zones?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceCategories != nil {
                map["InstanceCategories"] = self.instanceCategories?.toMap()
            }
            if self.instanceChargeTypes != nil {
                map["InstanceChargeTypes"] = self.instanceChargeTypes?.toMap()
            }
            if self.productCategories != nil {
                map["ProductCategories"] = self.productCategories?.toMap()
            }
            if self.zones != nil {
                map["Zones"] = self.zones?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceCategories") {
                var model = DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceCategories()
                model.fromMap(dict["InstanceCategories"] as! [String: Any])
                self.instanceCategories = model
            }
            if dict.keys.contains("InstanceChargeTypes") {
                var model = DescribeResourceDisplayResponseBody.ResourceDisplay.InstanceChargeTypes()
                model.fromMap(dict["InstanceChargeTypes"] as! [String: Any])
                self.instanceChargeTypes = model
            }
            if dict.keys.contains("ProductCategories") {
                var model = DescribeResourceDisplayResponseBody.ResourceDisplay.ProductCategories()
                model.fromMap(dict["ProductCategories"] as! [String: Any])
                self.productCategories = model
            }
            if dict.keys.contains("Zones") {
                var model = DescribeResourceDisplayResponseBody.ResourceDisplay.Zones()
                model.fromMap(dict["Zones"] as! [String: Any])
                self.zones = model
            }
        }
    }
    public var requestId: String?

    public var resourceDisplay: DescribeResourceDisplayResponseBody.ResourceDisplay?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceDisplay?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceDisplay != nil {
            map["ResourceDisplay"] = self.resourceDisplay?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceDisplay") {
            var model = DescribeResourceDisplayResponseBody.ResourceDisplay()
            model.fromMap(dict["ResourceDisplay"] as! [String: Any])
            self.resourceDisplay = model
        }
    }
}

public class DescribeResourceDisplayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceDisplayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceDisplayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceFilterAttributesRequest : Tea.TeaModel {
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var product: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var templateTag: [DescribeResourceFilterAttributesRequest.TemplateTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Product") {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TemplateTag") {
            self.templateTag = dict["TemplateTag"] as! [DescribeResourceFilterAttributesRequest.TemplateTag]
        }
    }
}

public class DescribeResourceFilterAttributesResponseBody : Tea.TeaModel {
    public class FilterAttributes : Tea.TeaModel {
        public class FilterAttribute : Tea.TeaModel {
            public class SupportOperations : Tea.TeaModel {
                public var supportOperation: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportOperation != nil {
                        map["SupportOperation"] = self.supportOperation!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportOperation") {
                        self.supportOperation = dict["SupportOperation"] as! [String]
                    }
                }
            }
            public class Values : Tea.TeaModel {
                public var value: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! [String]
                    }
                }
            }
            public var name: String?

            public var supportOperations: DescribeResourceFilterAttributesResponseBody.FilterAttributes.FilterAttribute.SupportOperations?

            public var type: String?

            public var values: DescribeResourceFilterAttributesResponseBody.FilterAttributes.FilterAttribute.Values?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.supportOperations?.validate()
                try self.values?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.supportOperations != nil {
                    map["SupportOperations"] = self.supportOperations?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.values != nil {
                    map["Values"] = self.values?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SupportOperations") {
                    var model = DescribeResourceFilterAttributesResponseBody.FilterAttributes.FilterAttribute.SupportOperations()
                    model.fromMap(dict["SupportOperations"] as! [String: Any])
                    self.supportOperations = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Values") {
                    var model = DescribeResourceFilterAttributesResponseBody.FilterAttributes.FilterAttribute.Values()
                    model.fromMap(dict["Values"] as! [String: Any])
                    self.values = model
                }
            }
        }
        public var filterAttribute: [DescribeResourceFilterAttributesResponseBody.FilterAttributes.FilterAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.filterAttribute != nil {
                var tmp : [Any] = []
                for k in self.filterAttribute! {
                    tmp.append(k.toMap())
                }
                map["FilterAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FilterAttribute") {
                self.filterAttribute = dict["FilterAttribute"] as! [DescribeResourceFilterAttributesResponseBody.FilterAttributes.FilterAttribute]
            }
        }
    }
    public var filterAttributes: DescribeResourceFilterAttributesResponseBody.FilterAttributes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filterAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterAttributes != nil {
            map["FilterAttributes"] = self.filterAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilterAttributes") {
            var model = DescribeResourceFilterAttributesResponseBody.FilterAttributes()
            model.fromMap(dict["FilterAttributes"] as! [String: Any])
            self.filterAttributes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeResourceFilterAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceFilterAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceFilterAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceRecommendFiltersRequest : Tea.TeaModel {
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var attributeName: String?

    public var attributeValue: String?

    public var global: String?

    public var maxItems: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var product: String?

    public var regionId: String?

    public var regionNo: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var templateTag: [DescribeResourceRecommendFiltersRequest.TemplateTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeName != nil {
            map["AttributeName"] = self.attributeName!
        }
        if self.attributeValue != nil {
            map["AttributeValue"] = self.attributeValue!
        }
        if self.global != nil {
            map["Global"] = self.global!
        }
        if self.maxItems != nil {
            map["MaxItems"] = self.maxItems!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.regionNo != nil {
            map["RegionNo"] = self.regionNo!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttributeName") {
            self.attributeName = dict["AttributeName"] as! String
        }
        if dict.keys.contains("AttributeValue") {
            self.attributeValue = dict["AttributeValue"] as! String
        }
        if dict.keys.contains("Global") {
            self.global = dict["Global"] as! String
        }
        if dict.keys.contains("MaxItems") {
            self.maxItems = dict["MaxItems"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Product") {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RegionNo") {
            self.regionNo = dict["RegionNo"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TemplateTag") {
            self.templateTag = dict["TemplateTag"] as! [DescribeResourceRecommendFiltersRequest.TemplateTag]
        }
    }
}

public class DescribeResourceRecommendFiltersResponseBody : Tea.TeaModel {
    public class RecommendFilters : Tea.TeaModel {
        public class RecommendFilter : Tea.TeaModel {
            public var attributeName: String?

            public var attributeValue: String?

            public var product: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attributeName != nil {
                    map["AttributeName"] = self.attributeName!
                }
                if self.attributeValue != nil {
                    map["AttributeValue"] = self.attributeValue!
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AttributeName") {
                    self.attributeName = dict["AttributeName"] as! String
                }
                if dict.keys.contains("AttributeValue") {
                    self.attributeValue = dict["AttributeValue"] as! String
                }
                if dict.keys.contains("Product") {
                    self.product = dict["Product"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
            }
        }
        public var recommendFilter: [DescribeResourceRecommendFiltersResponseBody.RecommendFilters.RecommendFilter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recommendFilter != nil {
                var tmp : [Any] = []
                for k in self.recommendFilter! {
                    tmp.append(k.toMap())
                }
                map["RecommendFilter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecommendFilter") {
                self.recommendFilter = dict["RecommendFilter"] as! [DescribeResourceRecommendFiltersResponseBody.RecommendFilters.RecommendFilter]
            }
        }
    }
    public var recommendFilters: DescribeResourceRecommendFiltersResponseBody.RecommendFilters?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recommendFilters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recommendFilters != nil {
            map["RecommendFilters"] = self.recommendFilters?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecommendFilters") {
            var model = DescribeResourceRecommendFiltersResponseBody.RecommendFilters()
            model.fromMap(dict["RecommendFilters"] as! [String: Any])
            self.recommendFilters = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeResourceRecommendFiltersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceRecommendFiltersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceRecommendFiltersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceSolutionsRequest : Tea.TeaModel {
    public class InstanceTypeModel : Tea.TeaModel {
        public var instanceType: String?

        public var weightedCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Double
            }
        }
    }
    public var cores: Int32?

    public var instanceChargeType: String?

    public var instanceFamilyLevel: String?

    public var instanceTypeModel: [DescribeResourceSolutionsRequest.InstanceTypeModel]?

    public var instanceTypeSupportIPv6: Bool?

    public var matchOpenInstances: Bool?

    public var maxPrice: Double?

    public var memory: Double?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceAmountType: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotStrategy: String?

    public var systemDiskCategory: String?

    public var targetCapacity: Int32?

    public var zoneId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypeModel != nil {
            var tmp : [Any] = []
            for k in self.instanceTypeModel! {
                tmp.append(k.toMap())
            }
            map["InstanceTypeModel"] = tmp
        }
        if self.instanceTypeSupportIPv6 != nil {
            map["InstanceTypeSupportIPv6"] = self.instanceTypeSupportIPv6!
        }
        if self.matchOpenInstances != nil {
            map["MatchOpenInstances"] = self.matchOpenInstances!
        }
        if self.maxPrice != nil {
            map["MaxPrice"] = self.maxPrice!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceAmountType != nil {
            map["ResourceAmountType"] = self.resourceAmountType!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskCategory != nil {
            map["SystemDiskCategory"] = self.systemDiskCategory!
        }
        if self.targetCapacity != nil {
            map["TargetCapacity"] = self.targetCapacity!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceFamilyLevel") {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceTypeModel") {
            self.instanceTypeModel = dict["InstanceTypeModel"] as! [DescribeResourceSolutionsRequest.InstanceTypeModel]
        }
        if dict.keys.contains("InstanceTypeSupportIPv6") {
            self.instanceTypeSupportIPv6 = dict["InstanceTypeSupportIPv6"] as! Bool
        }
        if dict.keys.contains("MatchOpenInstances") {
            self.matchOpenInstances = dict["MatchOpenInstances"] as! Bool
        }
        if dict.keys.contains("MaxPrice") {
            self.maxPrice = dict["MaxPrice"] as! Double
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceAmountType") {
            self.resourceAmountType = dict["ResourceAmountType"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDiskCategory") {
            self.systemDiskCategory = dict["SystemDiskCategory"] as! String
        }
        if dict.keys.contains("TargetCapacity") {
            self.targetCapacity = dict["TargetCapacity"] as! Int32
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! [String]
        }
    }
}

public class DescribeResourceSolutionsResponseBody : Tea.TeaModel {
    public class ResourcePlanningResponses : Tea.TeaModel {
        public class ResourcePlanningResponse : Tea.TeaModel {
            public class RecommendReasons : Tea.TeaModel {
                public var recommendReason: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recommendReason != nil {
                        map["RecommendReason"] = self.recommendReason!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RecommendReason") {
                        self.recommendReason = dict["RecommendReason"] as! [String]
                    }
                }
            }
            public class ResourceModels : Tea.TeaModel {
                public class ResourceModel : Tea.TeaModel {
                    public var amount: Int32?

                    public var deliveryTime: String?

                    public var instanceType: String?

                    public var regionId: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.amount != nil {
                            map["Amount"] = self.amount!
                        }
                        if self.deliveryTime != nil {
                            map["DeliveryTime"] = self.deliveryTime!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Amount") {
                            self.amount = dict["Amount"] as! Int32
                        }
                        if dict.keys.contains("DeliveryTime") {
                            self.deliveryTime = dict["DeliveryTime"] as! String
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("RegionId") {
                            self.regionId = dict["RegionId"] as! String
                        }
                        if dict.keys.contains("ZoneId") {
                            self.zoneId = dict["ZoneId"] as! String
                        }
                    }
                }
                public var resourceModel: [DescribeResourceSolutionsResponseBody.ResourcePlanningResponses.ResourcePlanningResponse.ResourceModels.ResourceModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceModel != nil {
                        var tmp : [Any] = []
                        for k in self.resourceModel! {
                            tmp.append(k.toMap())
                        }
                        map["ResourceModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceModel") {
                        self.resourceModel = dict["ResourceModel"] as! [DescribeResourceSolutionsResponseBody.ResourcePlanningResponses.ResourcePlanningResponse.ResourceModels.ResourceModel]
                    }
                }
            }
            public var recommendReasons: DescribeResourceSolutionsResponseBody.ResourcePlanningResponses.ResourcePlanningResponse.RecommendReasons?

            public var resourceModels: DescribeResourceSolutionsResponseBody.ResourcePlanningResponses.ResourcePlanningResponse.ResourceModels?

            public var satisfiedAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.recommendReasons?.validate()
                try self.resourceModels?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.recommendReasons != nil {
                    map["RecommendReasons"] = self.recommendReasons?.toMap()
                }
                if self.resourceModels != nil {
                    map["ResourceModels"] = self.resourceModels?.toMap()
                }
                if self.satisfiedAmount != nil {
                    map["SatisfiedAmount"] = self.satisfiedAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RecommendReasons") {
                    var model = DescribeResourceSolutionsResponseBody.ResourcePlanningResponses.ResourcePlanningResponse.RecommendReasons()
                    model.fromMap(dict["RecommendReasons"] as! [String: Any])
                    self.recommendReasons = model
                }
                if dict.keys.contains("ResourceModels") {
                    var model = DescribeResourceSolutionsResponseBody.ResourcePlanningResponses.ResourcePlanningResponse.ResourceModels()
                    model.fromMap(dict["ResourceModels"] as! [String: Any])
                    self.resourceModels = model
                }
                if dict.keys.contains("SatisfiedAmount") {
                    self.satisfiedAmount = dict["SatisfiedAmount"] as! Int32
                }
            }
        }
        public var resourcePlanningResponse: [DescribeResourceSolutionsResponseBody.ResourcePlanningResponses.ResourcePlanningResponse]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourcePlanningResponse != nil {
                var tmp : [Any] = []
                for k in self.resourcePlanningResponse! {
                    tmp.append(k.toMap())
                }
                map["ResourcePlanningResponse"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourcePlanningResponse") {
                self.resourcePlanningResponse = dict["ResourcePlanningResponse"] as! [DescribeResourceSolutionsResponseBody.ResourcePlanningResponses.ResourcePlanningResponse]
            }
        }
    }
    public var requestId: String?

    public var resourcePlanningResponses: DescribeResourceSolutionsResponseBody.ResourcePlanningResponses?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourcePlanningResponses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourcePlanningResponses != nil {
            map["ResourcePlanningResponses"] = self.resourcePlanningResponses?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourcePlanningResponses") {
            var model = DescribeResourceSolutionsResponseBody.ResourcePlanningResponses()
            model.fromMap(dict["ResourcePlanningResponses"] as! [String: Any])
            self.resourcePlanningResponses = model
        }
    }
}

public class DescribeResourceSolutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceSolutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceSolutionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourcesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var attributeName: String?

        public var attributeValue: String?

        public var operation: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attributeName != nil {
                map["AttributeName"] = self.attributeName!
            }
            if self.attributeValue != nil {
                map["AttributeValue"] = self.attributeValue!
            }
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttributeName") {
                self.attributeName = dict["AttributeName"] as! String
            }
            if dict.keys.contains("AttributeValue") {
                self.attributeValue = dict["AttributeValue"] as! String
            }
            if dict.keys.contains("Operation") {
                self.operation = dict["Operation"] as! String
            }
        }
    }
    public class TagFilter : Tea.TeaModel {
        public var operation: String?

        public var tagKey: String?

        public var tagValues: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValues != nil {
                map["TagValues"] = self.tagValues!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Operation") {
                self.operation = dict["Operation"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValues") {
                self.tagValues = dict["TagValues"] as! [String]
            }
        }
    }
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var filter: [DescribeResourcesRequest.Filter]?

    public var global: String?

    public var keyword: String?

    public var marker: String?

    public var maxItems: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var product: String?

    public var regionId: String?

    public var regionNo: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagFilter: [DescribeResourcesRequest.TagFilter]?

    public var templateTag: [DescribeResourcesRequest.TemplateTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.global != nil {
            map["Global"] = self.global!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.marker != nil {
            map["Marker"] = self.marker!
        }
        if self.maxItems != nil {
            map["MaxItems"] = self.maxItems!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.product != nil {
            map["Product"] = self.product!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.regionNo != nil {
            map["RegionNo"] = self.regionNo!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagFilter != nil {
            var tmp : [Any] = []
            for k in self.tagFilter! {
                tmp.append(k.toMap())
            }
            map["TagFilter"] = tmp
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            self.filter = dict["Filter"] as! [DescribeResourcesRequest.Filter]
        }
        if dict.keys.contains("Global") {
            self.global = dict["Global"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Marker") {
            self.marker = dict["Marker"] as! String
        }
        if dict.keys.contains("MaxItems") {
            self.maxItems = dict["MaxItems"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Product") {
            self.product = dict["Product"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RegionNo") {
            self.regionNo = dict["RegionNo"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagFilter") {
            self.tagFilter = dict["TagFilter"] as! [DescribeResourcesRequest.TagFilter]
        }
        if dict.keys.contains("TemplateTag") {
            self.templateTag = dict["TemplateTag"] as! [DescribeResourcesRequest.TemplateTag]
        }
    }
}

public class DescribeResourcesResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public var arn: String?

            public var createTime: String?

            public var matchedAttributes: String?

            public var product: String?

            public var regionId: String?

            public var resourceId: String?

            public var resourceName: String?

            public var resourceType: String?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.arn != nil {
                    map["Arn"] = self.arn!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.matchedAttributes != nil {
                    map["MatchedAttributes"] = self.matchedAttributes!
                }
                if self.product != nil {
                    map["Product"] = self.product!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Arn") {
                    self.arn = dict["Arn"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("MatchedAttributes") {
                    self.matchedAttributes = dict["MatchedAttributes"] as! String
                }
                if dict.keys.contains("Product") {
                    self.product = dict["Product"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceName") {
                    self.resourceName = dict["ResourceName"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
            }
        }
        public var resource: [DescribeResourcesResponseBody.Resources.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") {
                self.resource = dict["Resource"] as! [DescribeResourcesResponseBody.Resources.Resource]
            }
        }
    }
    public var estimatedTotal: Int32?

    public var marker: String?

    public var requestId: String?

    public var resources: DescribeResourcesResponseBody.Resources?

    public var truncated: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.estimatedTotal != nil {
            map["EstimatedTotal"] = self.estimatedTotal!
        }
        if self.marker != nil {
            map["Marker"] = self.marker!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.truncated != nil {
            map["Truncated"] = self.truncated!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EstimatedTotal") {
            self.estimatedTotal = dict["EstimatedTotal"] as! Int32
        }
        if dict.keys.contains("Marker") {
            self.marker = dict["Marker"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resources") {
            var model = DescribeResourcesResponseBody.Resources()
            model.fromMap(dict["Resources"] as! [String: Any])
            self.resources = model
        }
        if dict.keys.contains("Truncated") {
            self.truncated = dict["Truncated"] as! Bool
        }
    }
}

public class DescribeResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRiUtilizationRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeRiUtilizationRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeRiUtilizationRequest.Tag]
        }
    }
}

public class DescribeRiUtilizationResponseBody : Tea.TeaModel {
    public class Utilizations : Tea.TeaModel {
        public class Utilization : Tea.TeaModel {
            public var reservedInstanceId: String?

            public var utilization: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                if self.utilization != nil {
                    map["Utilization"] = self.utilization!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReservedInstanceId") {
                    self.reservedInstanceId = dict["ReservedInstanceId"] as! String
                }
                if dict.keys.contains("Utilization") {
                    self.utilization = dict["Utilization"] as! String
                }
            }
        }
        public var utilization: [DescribeRiUtilizationResponseBody.Utilizations.Utilization]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.utilization != nil {
                var tmp : [Any] = []
                for k in self.utilization! {
                    tmp.append(k.toMap())
                }
                map["Utilization"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Utilization") {
                self.utilization = dict["Utilization"] as! [DescribeRiUtilizationResponseBody.Utilizations.Utilization]
            }
        }
    }
    public var requestId: String?

    public var utilizations: DescribeRiUtilizationResponseBody.Utilizations?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.utilizations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.utilizations != nil {
            map["Utilizations"] = self.utilizations?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Utilizations") {
            var model = DescribeRiUtilizationResponseBody.Utilizations()
            model.fromMap(dict["Utilizations"] as! [String: Any])
            self.utilizations = model
        }
    }
}

public class DescribeRiUtilizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRiUtilizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRiUtilizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScenePurchaseRecommendRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SchedulerOptions : Tea.TeaModel {
        public var dedicatedHostClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostClusterId != nil {
                map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostClusterId") {
                self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StorageClusterId") {
                self.storageClusterId = dict["StorageClusterId"] as! String
            }
        }
    }
    public var privatePoolOptions: DescribeScenePurchaseRecommendRequest.PrivatePoolOptions?

    public var schedulerOptions: DescribeScenePurchaseRecommendRequest.SchedulerOptions?

    public var amount: Int32?

    public var dataDisk: [DescribeScenePurchaseRecommendRequest.DataDisk]?

    public var dedicatedHostId: String?

    public var imageId: String?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var productId: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sceneId: Int32?

    public var spotStrategy: String?

    public var systemDisk: DescribeScenePurchaseRecommendRequest.SystemDisk?

    public var tenancy: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
        try self.schedulerOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.productId != nil {
            map["ProductId"] = self.productId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = DescribeScenePurchaseRecommendRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SchedulerOptions") {
            var model = DescribeScenePurchaseRecommendRequest.SchedulerOptions()
            model.fromMap(dict["SchedulerOptions"] as! [String: Any])
            self.schedulerOptions = model
        }
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("DataDisk") {
            self.dataDisk = dict["DataDisk"] as! [DescribeScenePurchaseRecommendRequest.DataDisk]
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("ProductId") {
            self.productId = dict["ProductId"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! Int32
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDisk") {
            var model = DescribeScenePurchaseRecommendRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeScenePurchaseRecommendResponseBody : Tea.TeaModel {
    public class RecommendProducts : Tea.TeaModel {
        public class RecommendProduct : Tea.TeaModel {
            public class RecommendSpSpecs : Tea.TeaModel {
                public class RecommendSpSpec : Tea.TeaModel {
                    public var duration: Int32?

                    public var effectiveDate: String?

                    public var payMode: String?

                    public var pricingCycle: String?

                    public var recommendReason: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.effectiveDate != nil {
                            map["EffectiveDate"] = self.effectiveDate!
                        }
                        if self.payMode != nil {
                            map["PayMode"] = self.payMode!
                        }
                        if self.pricingCycle != nil {
                            map["PricingCycle"] = self.pricingCycle!
                        }
                        if self.recommendReason != nil {
                            map["RecommendReason"] = self.recommendReason!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Int32
                        }
                        if dict.keys.contains("EffectiveDate") {
                            self.effectiveDate = dict["EffectiveDate"] as! String
                        }
                        if dict.keys.contains("PayMode") {
                            self.payMode = dict["PayMode"] as! String
                        }
                        if dict.keys.contains("PricingCycle") {
                            self.pricingCycle = dict["PricingCycle"] as! String
                        }
                        if dict.keys.contains("RecommendReason") {
                            self.recommendReason = dict["RecommendReason"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var recommendSpSpec: [DescribeScenePurchaseRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendSpSpecs.RecommendSpSpec]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recommendSpSpec != nil {
                        var tmp : [Any] = []
                        for k in self.recommendSpSpec! {
                            tmp.append(k.toMap())
                        }
                        map["RecommendSpSpec"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RecommendSpSpec") {
                        self.recommendSpSpec = dict["RecommendSpSpec"] as! [DescribeScenePurchaseRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendSpSpecs.RecommendSpSpec]
                    }
                }
            }
            public var recommendSpSpecs: DescribeScenePurchaseRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendSpSpecs?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.recommendSpSpecs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.recommendSpSpecs != nil {
                    map["RecommendSpSpecs"] = self.recommendSpSpecs?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RecommendSpSpecs") {
                    var model = DescribeScenePurchaseRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendSpSpecs()
                    model.fromMap(dict["RecommendSpSpecs"] as! [String: Any])
                    self.recommendSpSpecs = model
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var recommendProduct: [DescribeScenePurchaseRecommendResponseBody.RecommendProducts.RecommendProduct]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recommendProduct != nil {
                var tmp : [Any] = []
                for k in self.recommendProduct! {
                    tmp.append(k.toMap())
                }
                map["RecommendProduct"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecommendProduct") {
                self.recommendProduct = dict["RecommendProduct"] as! [DescribeScenePurchaseRecommendResponseBody.RecommendProducts.RecommendProduct]
            }
        }
    }
    public var recommendProducts: DescribeScenePurchaseRecommendResponseBody.RecommendProducts?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recommendProducts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recommendProducts != nil {
            map["RecommendProducts"] = self.recommendProducts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecommendProducts") {
            var model = DescribeScenePurchaseRecommendResponseBody.RecommendProducts()
            model.fromMap(dict["RecommendProducts"] as! [String: Any])
            self.recommendProducts = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeScenePurchaseRecommendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScenePurchaseRecommendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeScenePurchaseRecommendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSceneResourceRecommendRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var productId: Int32?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sceneId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.productId != nil {
            map["ProductId"] = self.productId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProductId") {
            self.productId = dict["ProductId"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! Int32
        }
    }
}

public class DescribeSceneResourceRecommendResponseBody : Tea.TeaModel {
    public class RecommendProducts : Tea.TeaModel {
        public class RecommendProduct : Tea.TeaModel {
            public class RecommendInstanceSpecs : Tea.TeaModel {
                public class RecommendInstanceSpec : Tea.TeaModel {
                    public class InstanceTypes : Tea.TeaModel {
                        public class InstanceType : Tea.TeaModel {
                            public var instanceTypeFamily: String?

                            public var instanceTypeName: String?

                            public var priority: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.instanceTypeFamily != nil {
                                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                                }
                                if self.instanceTypeName != nil {
                                    map["InstanceTypeName"] = self.instanceTypeName!
                                }
                                if self.priority != nil {
                                    map["Priority"] = self.priority!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("InstanceTypeFamily") {
                                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                                }
                                if dict.keys.contains("InstanceTypeName") {
                                    self.instanceTypeName = dict["InstanceTypeName"] as! String
                                }
                                if dict.keys.contains("Priority") {
                                    self.priority = dict["Priority"] as! Int32
                                }
                            }
                        }
                        public var instanceType: [DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceSpecs.RecommendInstanceSpec.InstanceTypes.InstanceType]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.instanceType != nil {
                                var tmp : [Any] = []
                                for k in self.instanceType! {
                                    tmp.append(k.toMap())
                                }
                                map["InstanceType"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("InstanceType") {
                                self.instanceType = dict["InstanceType"] as! [DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceSpecs.RecommendInstanceSpec.InstanceTypes.InstanceType]
                            }
                        }
                    }
                    public var cores: Int32?

                    public var instanceTypes: DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceSpecs.RecommendInstanceSpec.InstanceTypes?

                    public var memory: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.instanceTypes?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cores != nil {
                            map["Cores"] = self.cores!
                        }
                        if self.instanceTypes != nil {
                            map["InstanceTypes"] = self.instanceTypes?.toMap()
                        }
                        if self.memory != nil {
                            map["Memory"] = self.memory!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Cores") {
                            self.cores = dict["Cores"] as! Int32
                        }
                        if dict.keys.contains("InstanceTypes") {
                            var model = DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceSpecs.RecommendInstanceSpec.InstanceTypes()
                            model.fromMap(dict["InstanceTypes"] as! [String: Any])
                            self.instanceTypes = model
                        }
                        if dict.keys.contains("Memory") {
                            self.memory = dict["Memory"] as! Double
                        }
                    }
                }
                public var recommendInstanceSpec: [DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceSpecs.RecommendInstanceSpec]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recommendInstanceSpec != nil {
                        var tmp : [Any] = []
                        for k in self.recommendInstanceSpec! {
                            tmp.append(k.toMap())
                        }
                        map["RecommendInstanceSpec"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RecommendInstanceSpec") {
                        self.recommendInstanceSpec = dict["RecommendInstanceSpec"] as! [DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceSpecs.RecommendInstanceSpec]
                    }
                }
            }
            public var recommendInstanceSpecs: DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceSpecs?

            public var recommendReason: String?

            public var regionId: String?

            public var resourceId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.recommendInstanceSpecs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.recommendInstanceSpecs != nil {
                    map["RecommendInstanceSpecs"] = self.recommendInstanceSpecs?.toMap()
                }
                if self.recommendReason != nil {
                    map["RecommendReason"] = self.recommendReason!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RecommendInstanceSpecs") {
                    var model = DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct.RecommendInstanceSpecs()
                    model.fromMap(dict["RecommendInstanceSpecs"] as! [String: Any])
                    self.recommendInstanceSpecs = model
                }
                if dict.keys.contains("RecommendReason") {
                    self.recommendReason = dict["RecommendReason"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var recommendProduct: [DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recommendProduct != nil {
                var tmp : [Any] = []
                for k in self.recommendProduct! {
                    tmp.append(k.toMap())
                }
                map["RecommendProduct"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecommendProduct") {
                self.recommendProduct = dict["RecommendProduct"] as! [DescribeSceneResourceRecommendResponseBody.RecommendProducts.RecommendProduct]
            }
        }
    }
    public var recommendProducts: DescribeSceneResourceRecommendResponseBody.RecommendProducts?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recommendProducts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recommendProducts != nil {
            map["RecommendProducts"] = self.recommendProducts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecommendProducts") {
            var model = DescribeSceneResourceRecommendResponseBody.RecommendProducts()
            model.fromMap(dict["RecommendProducts"] as! [String: Any])
            self.recommendProducts = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSceneResourceRecommendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSceneResourceRecommendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSceneResourceRecommendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSpotInstanceAdviceRequest : Tea.TeaModel {
    public var cores: Int32?

    public var ioOptimized: String?

    public var memory: Double?

    public var minCores: Int32?

    public var minMemory: Double?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.minCores != nil {
            map["MinCores"] = self.minCores!
        }
        if self.minMemory != nil {
            map["MinMemory"] = self.minMemory!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("MinCores") {
            self.minCores = dict["MinCores"] as! Int32
        }
        if dict.keys.contains("MinMemory") {
            self.minMemory = dict["MinMemory"] as! Double
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeSpotInstanceAdviceResponseBody : Tea.TeaModel {
    public class AvailableSpotZones : Tea.TeaModel {
        public var availableSpotZone: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableSpotZone != nil {
                map["AvailableSpotZone"] = self.availableSpotZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableSpotZone") {
                self.availableSpotZone = dict["AvailableSpotZone"] as! [String]
            }
        }
    }
    public var availableSpotZones: DescribeSpotInstanceAdviceResponseBody.AvailableSpotZones?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableSpotZones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableSpotZones != nil {
            map["AvailableSpotZones"] = self.availableSpotZones?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableSpotZones") {
            var model = DescribeSpotInstanceAdviceResponseBody.AvailableSpotZones()
            model.fromMap(dict["AvailableSpotZones"] as! [String: Any])
            self.availableSpotZones = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSpotInstanceAdviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSpotInstanceAdviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSpotInstanceAdviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStorageCapacityUnitAllocationsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageCapacityUnitId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageCapacityUnitId != nil {
            map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageCapacityUnitId") {
            self.storageCapacityUnitId = dict["StorageCapacityUnitId"] as! String
        }
    }
}

public class DescribeStorageCapacityUnitAllocationsResponseBody : Tea.TeaModel {
    public class Allocations : Tea.TeaModel {
        public class Allocation : Tea.TeaModel {
            public var beAllocatedAccountId: String?

            public var resourceOwnerId: String?

            public var storageCapacityUnitId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beAllocatedAccountId != nil {
                    map["BeAllocatedAccountId"] = self.beAllocatedAccountId!
                }
                if self.resourceOwnerId != nil {
                    map["ResourceOwnerId"] = self.resourceOwnerId!
                }
                if self.storageCapacityUnitId != nil {
                    map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeAllocatedAccountId") {
                    self.beAllocatedAccountId = dict["BeAllocatedAccountId"] as! String
                }
                if dict.keys.contains("ResourceOwnerId") {
                    self.resourceOwnerId = dict["ResourceOwnerId"] as! String
                }
                if dict.keys.contains("StorageCapacityUnitId") {
                    self.storageCapacityUnitId = dict["StorageCapacityUnitId"] as! String
                }
            }
        }
        public var allocation: [DescribeStorageCapacityUnitAllocationsResponseBody.Allocations.Allocation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocation != nil {
                var tmp : [Any] = []
                for k in self.allocation! {
                    tmp.append(k.toMap())
                }
                map["Allocation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Allocation") {
                self.allocation = dict["Allocation"] as! [DescribeStorageCapacityUnitAllocationsResponseBody.Allocations.Allocation]
            }
        }
    }
    public var allocations: DescribeStorageCapacityUnitAllocationsResponseBody.Allocations?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.allocations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocations != nil {
            map["Allocations"] = self.allocations?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Allocations") {
            var model = DescribeStorageCapacityUnitAllocationsResponseBody.Allocations()
            model.fromMap(dict["Allocations"] as! [String: Any])
            self.allocations = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeStorageCapacityUnitAllocationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageCapacityUnitAllocationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStorageCapacityUnitAllocationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStorageCapacityUnitDeductFactorRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var deductField: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var performanceLevel: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageType: String?

    public var tag: [DescribeStorageCapacityUnitDeductFactorRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deductField != nil {
            map["DeductField"] = self.deductField!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageType != nil {
            map["StorageType"] = self.storageType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeductField") {
            self.deductField = dict["DeductField"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageType") {
            self.storageType = dict["StorageType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeStorageCapacityUnitDeductFactorRequest.Tag]
        }
    }
}

public class DescribeStorageCapacityUnitDeductFactorResponseBody : Tea.TeaModel {
    public var deductFactor: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deductFactor != nil {
            map["DeductFactor"] = self.deductFactor!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeductFactor") {
            self.deductFactor = dict["DeductFactor"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeStorageCapacityUnitDeductFactorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageCapacityUnitDeductFactorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStorageCapacityUnitDeductFactorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStorageSetDetailsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var diskIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DiskIds") {
            self.diskIds = dict["DiskIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
    }
}

public class DescribeStorageSetDetailsResponseBody : Tea.TeaModel {
    public class Disks : Tea.TeaModel {
        public class Disk : Tea.TeaModel {
            public var category: String?

            public var creationTime: String?

            public var diskId: String?

            public var diskName: String?

            public var regionId: String?

            public var storageSetId: String?

            public var storageSetPartitionNumber: Int32?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.storageSetId != nil {
                    map["StorageSetId"] = self.storageSetId!
                }
                if self.storageSetPartitionNumber != nil {
                    map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskName") {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StorageSetId") {
                    self.storageSetId = dict["StorageSetId"] as! String
                }
                if dict.keys.contains("StorageSetPartitionNumber") {
                    self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var disk: [DescribeStorageSetDetailsResponseBody.Disks.Disk]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                var tmp : [Any] = []
                for k in self.disk! {
                    tmp.append(k.toMap())
                }
                map["Disk"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Disk") {
                self.disk = dict["Disk"] as! [DescribeStorageSetDetailsResponseBody.Disks.Disk]
            }
        }
    }
    public var disks: DescribeStorageSetDetailsResponseBody.Disks?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.disks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disks != nil {
            map["Disks"] = self.disks?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Disks") {
            var model = DescribeStorageSetDetailsResponseBody.Disks()
            model.fromMap(dict["Disks"] as! [String: Any])
            self.disks = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeStorageSetDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageSetDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStorageSetDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStorageSetsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetIds: String?

    public var storageSetName: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetIds != nil {
            map["StorageSetIds"] = self.storageSetIds!
        }
        if self.storageSetName != nil {
            map["StorageSetName"] = self.storageSetName!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetIds") {
            self.storageSetIds = dict["StorageSetIds"] as! String
        }
        if dict.keys.contains("StorageSetName") {
            self.storageSetName = dict["StorageSetName"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeStorageSetsResponseBody : Tea.TeaModel {
    public class StorageSets : Tea.TeaModel {
        public class StorageSet : Tea.TeaModel {
            public var creationTime: String?

            public var description_: String?

            public var regionId: String?

            public var storageSetId: String?

            public var storageSetName: String?

            public var storageSetPartitionNumber: Int32?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.storageSetId != nil {
                    map["StorageSetId"] = self.storageSetId!
                }
                if self.storageSetName != nil {
                    map["StorageSetName"] = self.storageSetName!
                }
                if self.storageSetPartitionNumber != nil {
                    map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StorageSetId") {
                    self.storageSetId = dict["StorageSetId"] as! String
                }
                if dict.keys.contains("StorageSetName") {
                    self.storageSetName = dict["StorageSetName"] as! String
                }
                if dict.keys.contains("StorageSetPartitionNumber") {
                    self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var storageSet: [DescribeStorageSetsResponseBody.StorageSets.StorageSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageSet != nil {
                var tmp : [Any] = []
                for k in self.storageSet! {
                    tmp.append(k.toMap())
                }
                map["StorageSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StorageSet") {
                self.storageSet = dict["StorageSet"] as! [DescribeStorageSetsResponseBody.StorageSets.StorageSet]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var storageSets: DescribeStorageSetsResponseBody.StorageSets?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageSets != nil {
            map["StorageSets"] = self.storageSets?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageSets") {
            var model = DescribeStorageSetsResponseBody.StorageSets()
            model.fromMap(dict["StorageSets"] as! [String: Any])
            self.storageSets = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeStorageSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStorageSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTransitionVSwitchesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeTransitionVSwitchesResponseBody : Tea.TeaModel {
    public class VSwitchModels : Tea.TeaModel {
        public class Model : Tea.TeaModel {
            public var CIDR: String?

            public var description_: String?

            public var izNo: String?

            public var name: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.CIDR != nil {
                    map["CIDR"] = self.CIDR!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.izNo != nil {
                    map["IzNo"] = self.izNo!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CIDR") {
                    self.CIDR = dict["CIDR"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("IzNo") {
                    self.izNo = dict["IzNo"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var model: [DescribeTransitionVSwitchesResponseBody.VSwitchModels.Model]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.model != nil {
                var tmp : [Any] = []
                for k in self.model! {
                    tmp.append(k.toMap())
                }
                map["Model"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Model") {
                self.model = dict["Model"] as! [DescribeTransitionVSwitchesResponseBody.VSwitchModels.Model]
            }
        }
    }
    public var code: String?

    public var requestId: String?

    public var success: Bool?

    public var vSwitchModels: DescribeTransitionVSwitchesResponseBody.VSwitchModels?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vSwitchModels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.vSwitchModels != nil {
            map["VSwitchModels"] = self.vSwitchModels?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("VSwitchModels") {
            var model = DescribeTransitionVSwitchesResponseBody.VSwitchModels()
            model.fromMap(dict["VSwitchModels"] as! [String: Any])
            self.vSwitchModels = model
        }
    }
}

public class DescribeTransitionVSwitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransitionVSwitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTransitionVSwitchesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTransitionVpcAndVSwitchRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeTransitionVpcAndVSwitchResponseBody : Tea.TeaModel {
    public class VmTransitionModels : Tea.TeaModel {
        public class Model : Tea.TeaModel {
            public var code: String?

            public var instanceId: String?

            public var message: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var model: [DescribeTransitionVpcAndVSwitchResponseBody.VmTransitionModels.Model]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.model != nil {
                var tmp : [Any] = []
                for k in self.model! {
                    tmp.append(k.toMap())
                }
                map["Model"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Model") {
                self.model = dict["Model"] as! [DescribeTransitionVpcAndVSwitchResponseBody.VmTransitionModels.Model]
            }
        }
    }
    public var requestId: String?

    public var vmTransitionModels: DescribeTransitionVpcAndVSwitchResponseBody.VmTransitionModels?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vmTransitionModels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vmTransitionModels != nil {
            map["VmTransitionModels"] = self.vmTransitionModels?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VmTransitionModels") {
            var model = DescribeTransitionVpcAndVSwitchResponseBody.VmTransitionModels()
            model.fromMap(dict["VmTransitionModels"] as! [String: Any])
            self.vmTransitionModels = model
        }
    }
}

public class DescribeTransitionVpcAndVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransitionVpcAndVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTransitionVpcAndVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTransitionVpcsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeTransitionVpcsResponseBody : Tea.TeaModel {
    public class VpcModels : Tea.TeaModel {
        public class Model : Tea.TeaModel {
            public var config: String?

            public var regionId: String?

            public var status: Int32?

            public var type: Int32?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.config != nil {
                    map["Config"] = self.config!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Config") {
                    self.config = dict["Config"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcName") {
                    self.vpcName = dict["VpcName"] as! String
                }
            }
        }
        public var model: [DescribeTransitionVpcsResponseBody.VpcModels.Model]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.model != nil {
                var tmp : [Any] = []
                for k in self.model! {
                    tmp.append(k.toMap())
                }
                map["Model"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Model") {
                self.model = dict["Model"] as! [DescribeTransitionVpcsResponseBody.VpcModels.Model]
            }
        }
    }
    public var code: String?

    public var requestId: String?

    public var success: Bool?

    public var vpcModels: DescribeTransitionVpcsResponseBody.VpcModels?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcModels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.vpcModels != nil {
            map["VpcModels"] = self.vpcModels?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("VpcModels") {
            var model = DescribeTransitionVpcsResponseBody.VpcModels()
            model.fromMap(dict["VpcModels"] as! [String: Any])
            self.vpcModels = model
        }
    }
}

public class DescribeTransitionVpcsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransitionVpcsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTransitionVpcsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserAvailableIpServiceProvidersRequest : Tea.TeaModel {
    public var aliUid: Int64?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliUid != nil {
            map["AliUid"] = self.aliUid!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AliUid") {
            self.aliUid = dict["AliUid"] as! Int64
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeUserAvailableIpServiceProvidersResponseBody : Tea.TeaModel {
    public class IpServiceProviders : Tea.TeaModel {
        public class IpServiceProvider : Tea.TeaModel {
            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var ipServiceProvider: [DescribeUserAvailableIpServiceProvidersResponseBody.IpServiceProviders.IpServiceProvider]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipServiceProvider != nil {
                var tmp : [Any] = []
                for k in self.ipServiceProvider! {
                    tmp.append(k.toMap())
                }
                map["IpServiceProvider"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpServiceProvider") {
                self.ipServiceProvider = dict["IpServiceProvider"] as! [DescribeUserAvailableIpServiceProvidersResponseBody.IpServiceProviders.IpServiceProvider]
            }
        }
    }
    public var ipServiceProviders: DescribeUserAvailableIpServiceProvidersResponseBody.IpServiceProviders?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipServiceProviders?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipServiceProviders != nil {
            map["IpServiceProviders"] = self.ipServiceProviders?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpServiceProviders") {
            var model = DescribeUserAvailableIpServiceProvidersResponseBody.IpServiceProviders()
            model.fromMap(dict["IpServiceProviders"] as! [String: Any])
            self.ipServiceProviders = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUserAvailableIpServiceProvidersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserAvailableIpServiceProvidersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUserAvailableIpServiceProvidersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserQuotaApplicationsRequest : Tea.TeaModel {
    public var applicationId: String?

    public var chargeType: String?

    public var clientToken: String?

    public var instanceType: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var quotaType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var zoneId: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.quotaType != nil {
            map["QuotaType"] = self.quotaType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationId") {
            self.applicationId = dict["ApplicationId"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("QuotaType") {
            self.quotaType = dict["QuotaType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
    }
}

public class DescribeUserQuotaApplicationsResponseBody : Tea.TeaModel {
    public class UserQuotaApplications : Tea.TeaModel {
        public class UserQuotaApplication : Tea.TeaModel {
            public var applicationId: String?

            public var chargeType: String?

            public var comment: String?

            public var creationTime: String?

            public var description_: String?

            public var expireTime: String?

            public var instanceType: String?

            public var quotaType: String?

            public var quotaValue: Int64?

            public var resultCode: String?

            public var startTime: String?

            public var status: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationId != nil {
                    map["ApplicationId"] = self.applicationId!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.quotaType != nil {
                    map["QuotaType"] = self.quotaType!
                }
                if self.quotaValue != nil {
                    map["QuotaValue"] = self.quotaValue!
                }
                if self.resultCode != nil {
                    map["ResultCode"] = self.resultCode!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplicationId") {
                    self.applicationId = dict["ApplicationId"] as! String
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("QuotaType") {
                    self.quotaType = dict["QuotaType"] as! String
                }
                if dict.keys.contains("QuotaValue") {
                    self.quotaValue = dict["QuotaValue"] as! Int64
                }
                if dict.keys.contains("ResultCode") {
                    self.resultCode = dict["ResultCode"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var userQuotaApplication: [DescribeUserQuotaApplicationsResponseBody.UserQuotaApplications.UserQuotaApplication]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userQuotaApplication != nil {
                var tmp : [Any] = []
                for k in self.userQuotaApplication! {
                    tmp.append(k.toMap())
                }
                map["UserQuotaApplication"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserQuotaApplication") {
                self.userQuotaApplication = dict["UserQuotaApplication"] as! [DescribeUserQuotaApplicationsResponseBody.UserQuotaApplications.UserQuotaApplication]
            }
        }
    }
    public var nextToken: String?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int32?

    public var userQuotaApplications: DescribeUserQuotaApplicationsResponseBody.UserQuotaApplications?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.userQuotaApplications?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.userQuotaApplications != nil {
            map["UserQuotaApplications"] = self.userQuotaApplications?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("UserQuotaApplications") {
            var model = DescribeUserQuotaApplicationsResponseBody.UserQuotaApplications()
            model.fromMap(dict["UserQuotaApplications"] as! [String: Any])
            self.userQuotaApplications = model
        }
    }
}

public class DescribeUserQuotaApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserQuotaApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUserQuotaApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpcHavsInstancesRequest : Tea.TeaModel {
    public var maxResultSize: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResultSize != nil {
            map["MaxResultSize"] = self.maxResultSize!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcIdList != nil {
            map["VpcIdList"] = self.vpcIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResultSize") {
            self.maxResultSize = dict["MaxResultSize"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcIdList") {
            self.vpcIdList = dict["VpcIdList"] as! [String]
        }
    }
}

public class DescribeVpcHavsInstancesResponseBody : Tea.TeaModel {
    public class VpcHavsInstances : Tea.TeaModel {
        public class VpcHavsInstance : Tea.TeaModel {
            public class HavsInstances : Tea.TeaModel {
                public class HavsInstance : Tea.TeaModel {
                    public var ecsInstanceId: String?

                    public var reason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ecsInstanceId != nil {
                            map["EcsInstanceId"] = self.ecsInstanceId!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EcsInstanceId") {
                            self.ecsInstanceId = dict["EcsInstanceId"] as! String
                        }
                        if dict.keys.contains("Reason") {
                            self.reason = dict["Reason"] as! String
                        }
                    }
                }
                public var havsInstance: [DescribeVpcHavsInstancesResponseBody.VpcHavsInstances.VpcHavsInstance.HavsInstances.HavsInstance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.havsInstance != nil {
                        var tmp : [Any] = []
                        for k in self.havsInstance! {
                            tmp.append(k.toMap())
                        }
                        map["HavsInstance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HavsInstance") {
                        self.havsInstance = dict["HavsInstance"] as! [DescribeVpcHavsInstancesResponseBody.VpcHavsInstances.VpcHavsInstance.HavsInstances.HavsInstance]
                    }
                }
            }
            public var havsInstances: DescribeVpcHavsInstancesResponseBody.VpcHavsInstances.VpcHavsInstance.HavsInstances?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.havsInstances?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.havsInstances != nil {
                    map["HavsInstances"] = self.havsInstances?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HavsInstances") {
                    var model = DescribeVpcHavsInstancesResponseBody.VpcHavsInstances.VpcHavsInstance.HavsInstances()
                    model.fromMap(dict["HavsInstances"] as! [String: Any])
                    self.havsInstances = model
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var vpcHavsInstance: [DescribeVpcHavsInstancesResponseBody.VpcHavsInstances.VpcHavsInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpcHavsInstance != nil {
                var tmp : [Any] = []
                for k in self.vpcHavsInstance! {
                    tmp.append(k.toMap())
                }
                map["VpcHavsInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpcHavsInstance") {
                self.vpcHavsInstance = dict["VpcHavsInstance"] as! [DescribeVpcHavsInstancesResponseBody.VpcHavsInstances.VpcHavsInstance]
            }
        }
    }
    public var requestId: String?

    public var vpcHavsInstances: DescribeVpcHavsInstancesResponseBody.VpcHavsInstances?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcHavsInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vpcHavsInstances != nil {
            map["VpcHavsInstances"] = self.vpcHavsInstances?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VpcHavsInstances") {
            var model = DescribeVpcHavsInstancesResponseBody.VpcHavsInstances()
            model.fromMap(dict["VpcHavsInstances"] as! [String: Any])
            self.vpcHavsInstances = model
        }
    }
}

public class DescribeVpcHavsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcHavsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpcHavsInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeWaitingOrdersRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var ownerAccount: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var status: String?

    public var tag: [DescribeWaitingOrdersRequest.Tag]?

    public var waitingOrderId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.waitingOrderId != nil {
            map["WaitingOrderId"] = self.waitingOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeWaitingOrdersRequest.Tag]
        }
        if dict.keys.contains("WaitingOrderId") {
            self.waitingOrderId = dict["WaitingOrderId"] as! [String]
        }
    }
}

public class DescribeWaitingOrdersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class InstanceInfos : Tea.TeaModel {
            public var instanceId: String?

            public var resultCode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.resultCode != nil {
                    map["ResultCode"] = self.resultCode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("ResultCode") {
                    self.resultCode = dict["ResultCode"] as! String
                }
            }
        }
        public var chargeType: String?

        public var createTime: String?

        public var expireTime: String?

        public var failedMessage: String?

        public var instanceAmount: Int64?

        public var instanceInfos: [DescribeWaitingOrdersResponseBody.Data.InstanceInfos]?

        public var instanceType: String?

        public var lxCreateParam: String?

        public var regionId: String?

        public var status: String?

        public var successAmount: Int64?

        public var waitingOrderId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.failedMessage != nil {
                map["FailedMessage"] = self.failedMessage!
            }
            if self.instanceAmount != nil {
                map["InstanceAmount"] = self.instanceAmount!
            }
            if self.instanceInfos != nil {
                var tmp : [Any] = []
                for k in self.instanceInfos! {
                    tmp.append(k.toMap())
                }
                map["InstanceInfos"] = tmp
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.lxCreateParam != nil {
                map["LxCreateParam"] = self.lxCreateParam!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.successAmount != nil {
                map["SuccessAmount"] = self.successAmount!
            }
            if self.waitingOrderId != nil {
                map["WaitingOrderId"] = self.waitingOrderId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChargeType") {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("FailedMessage") {
                self.failedMessage = dict["FailedMessage"] as! String
            }
            if dict.keys.contains("InstanceAmount") {
                self.instanceAmount = dict["InstanceAmount"] as! Int64
            }
            if dict.keys.contains("InstanceInfos") {
                self.instanceInfos = dict["InstanceInfos"] as! [DescribeWaitingOrdersResponseBody.Data.InstanceInfos]
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("LxCreateParam") {
                self.lxCreateParam = dict["LxCreateParam"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("SuccessAmount") {
                self.successAmount = dict["SuccessAmount"] as! Int64
            }
            if dict.keys.contains("WaitingOrderId") {
                self.waitingOrderId = dict["WaitingOrderId"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var data: [DescribeWaitingOrdersResponseBody.Data]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeWaitingOrdersResponseBody.Data]
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeWaitingOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWaitingOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeWaitingOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FeedbackDiagnoseRequest : Tea.TeaModel {
    public var diagnoseId: String?

    public var mark: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var star: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.mark != nil {
            map["Mark"] = self.mark!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.star != nil {
            map["Star"] = self.star!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiagnoseId") {
            self.diagnoseId = dict["DiagnoseId"] as! String
        }
        if dict.keys.contains("Mark") {
            self.mark = dict["Mark"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Star") {
            self.star = dict["Star"] as! Int32
        }
    }
}

public class FeedbackDiagnoseResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class FeedbackDiagnoseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FeedbackDiagnoseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = FeedbackDiagnoseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLaunchTemplateDataRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetLaunchTemplateDataResponseBody : Tea.TeaModel {
    public class LaunchTemplateData : Tea.TeaModel {
        public class SystemDisk : Tea.TeaModel {
            public var category: String?

            public var description_: String?

            public var diskName: String?

            public var iops: Int32?

            public var size: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.iops != nil {
                    map["Iops"] = self.iops!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DiskName") {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("Iops") {
                    self.iops = dict["Iops"] as! Int32
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int32
                }
            }
        }
        public class DataDisks : Tea.TeaModel {
            public class DataDisk : Tea.TeaModel {
                public var category: String?

                public var deleteWithInstance: Bool?

                public var description_: String?

                public var device: String?

                public var diskName: String?

                public var encrypted: String?

                public var size: Int32?

                public var snapshotId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.deleteWithInstance != nil {
                        map["DeleteWithInstance"] = self.deleteWithInstance!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.device != nil {
                        map["Device"] = self.device!
                    }
                    if self.diskName != nil {
                        map["DiskName"] = self.diskName!
                    }
                    if self.encrypted != nil {
                        map["Encrypted"] = self.encrypted!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.snapshotId != nil {
                        map["SnapshotId"] = self.snapshotId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("DeleteWithInstance") {
                        self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Device") {
                        self.device = dict["Device"] as! String
                    }
                    if dict.keys.contains("DiskName") {
                        self.diskName = dict["DiskName"] as! String
                    }
                    if dict.keys.contains("Encrypted") {
                        self.encrypted = dict["Encrypted"] as! String
                    }
                    if dict.keys.contains("Size") {
                        self.size = dict["Size"] as! Int32
                    }
                    if dict.keys.contains("SnapshotId") {
                        self.snapshotId = dict["SnapshotId"] as! String
                    }
                }
            }
            public var dataDisk: [GetLaunchTemplateDataResponseBody.LaunchTemplateData.DataDisks.DataDisk]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataDisk != nil {
                    var tmp : [Any] = []
                    for k in self.dataDisk! {
                        tmp.append(k.toMap())
                    }
                    map["DataDisk"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DataDisk") {
                    self.dataDisk = dict["DataDisk"] as! [GetLaunchTemplateDataResponseBody.LaunchTemplateData.DataDisks.DataDisk]
                }
            }
        }
        public class NetworkInterfaces : Tea.TeaModel {
            public class NetworkInterface : Tea.TeaModel {
                public var description_: String?

                public var networkInterfaceName: String?

                public var primaryIpAddress: String?

                public var securityGroupId: String?

                public var vSwitchId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.networkInterfaceName != nil {
                        map["NetworkInterfaceName"] = self.networkInterfaceName!
                    }
                    if self.primaryIpAddress != nil {
                        map["PrimaryIpAddress"] = self.primaryIpAddress!
                    }
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("NetworkInterfaceName") {
                        self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
                    }
                    if dict.keys.contains("PrimaryIpAddress") {
                        self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
                    }
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! String
                    }
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! String
                    }
                }
            }
            public var networkInterface: [GetLaunchTemplateDataResponseBody.LaunchTemplateData.NetworkInterfaces.NetworkInterface]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.networkInterface != nil {
                    var tmp : [Any] = []
                    for k in self.networkInterface! {
                        tmp.append(k.toMap())
                    }
                    map["NetworkInterface"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("NetworkInterface") {
                    self.networkInterface = dict["NetworkInterface"] as! [GetLaunchTemplateDataResponseBody.LaunchTemplateData.NetworkInterfaces.NetworkInterface]
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public class InstanceTag : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var instanceTag: [GetLaunchTemplateDataResponseBody.LaunchTemplateData.Tags.InstanceTag]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceTag != nil {
                    var tmp : [Any] = []
                    for k in self.instanceTag! {
                        tmp.append(k.toMap())
                    }
                    map["InstanceTag"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceTag") {
                    self.instanceTag = dict["InstanceTag"] as! [GetLaunchTemplateDataResponseBody.LaunchTemplateData.Tags.InstanceTag]
                }
            }
        }
        public var systemDisk: GetLaunchTemplateDataResponseBody.LaunchTemplateData.SystemDisk?

        public var autoReleaseTime: String?

        public var dataDisks: GetLaunchTemplateDataResponseBody.LaunchTemplateData.DataDisks?

        public var description_: String?

        public var enableVmOsConfig: Bool?

        public var hostName: String?

        public var imageId: String?

        public var imageOwnerAlias: String?

        public var instanceChargeType: String?

        public var instanceName: String?

        public var instanceType: String?

        public var internetChargeType: String?

        public var internetMaxBandwidthIn: Int32?

        public var internetMaxBandwidthOut: Int32?

        public var ioOptimized: String?

        public var keyPairName: String?

        public var networkInterfaces: GetLaunchTemplateDataResponseBody.LaunchTemplateData.NetworkInterfaces?

        public var networkType: String?

        public var passwordInherit: Bool?

        public var period: Int32?

        public var ramRoleName: String?

        public var resourceGroupId: String?

        public var securityEnhancementStrategy: Bool?

        public var securityGroupId: String?

        public var spotDuration: Int32?

        public var spotPriceLimit: Double?

        public var spotStrategy: String?

        public var tags: GetLaunchTemplateDataResponseBody.LaunchTemplateData.Tags?

        public var userData: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.validateRequired(self.systemDisk, "systemDisk")
            try self.systemDisk?.validate()
            try self.dataDisks?.validate()
            try self.networkInterfaces?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.systemDisk != nil {
                map["SystemDisk"] = self.systemDisk?.toMap()
            }
            if self.autoReleaseTime != nil {
                map["AutoReleaseTime"] = self.autoReleaseTime!
            }
            if self.dataDisks != nil {
                map["DataDisks"] = self.dataDisks?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enableVmOsConfig != nil {
                map["EnableVmOsConfig"] = self.enableVmOsConfig!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageOwnerAlias != nil {
                map["ImageOwnerAlias"] = self.imageOwnerAlias!
            }
            if self.instanceChargeType != nil {
                map["InstanceChargeType"] = self.instanceChargeType!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.internetMaxBandwidthIn != nil {
                map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.networkInterfaces != nil {
                map["NetworkInterfaces"] = self.networkInterfaces?.toMap()
            }
            if self.networkType != nil {
                map["NetworkType"] = self.networkType!
            }
            if self.passwordInherit != nil {
                map["PasswordInherit"] = self.passwordInherit!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityEnhancementStrategy != nil {
                map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.spotDuration != nil {
                map["SpotDuration"] = self.spotDuration!
            }
            if self.spotPriceLimit != nil {
                map["SpotPriceLimit"] = self.spotPriceLimit!
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SystemDisk") {
                var model = GetLaunchTemplateDataResponseBody.LaunchTemplateData.SystemDisk()
                model.fromMap(dict["SystemDisk"] as! [String: Any])
                self.systemDisk = model
            }
            if dict.keys.contains("AutoReleaseTime") {
                self.autoReleaseTime = dict["AutoReleaseTime"] as! String
            }
            if dict.keys.contains("DataDisks") {
                var model = GetLaunchTemplateDataResponseBody.LaunchTemplateData.DataDisks()
                model.fromMap(dict["DataDisks"] as! [String: Any])
                self.dataDisks = model
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EnableVmOsConfig") {
                self.enableVmOsConfig = dict["EnableVmOsConfig"] as! Bool
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageOwnerAlias") {
                self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
            }
            if dict.keys.contains("InstanceChargeType") {
                self.instanceChargeType = dict["InstanceChargeType"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("InternetChargeType") {
                self.internetChargeType = dict["InternetChargeType"] as! String
            }
            if dict.keys.contains("InternetMaxBandwidthIn") {
                self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
            }
            if dict.keys.contains("InternetMaxBandwidthOut") {
                self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
            }
            if dict.keys.contains("IoOptimized") {
                self.ioOptimized = dict["IoOptimized"] as! String
            }
            if dict.keys.contains("KeyPairName") {
                self.keyPairName = dict["KeyPairName"] as! String
            }
            if dict.keys.contains("NetworkInterfaces") {
                var model = GetLaunchTemplateDataResponseBody.LaunchTemplateData.NetworkInterfaces()
                model.fromMap(dict["NetworkInterfaces"] as! [String: Any])
                self.networkInterfaces = model
            }
            if dict.keys.contains("NetworkType") {
                self.networkType = dict["NetworkType"] as! String
            }
            if dict.keys.contains("PasswordInherit") {
                self.passwordInherit = dict["PasswordInherit"] as! Bool
            }
            if dict.keys.contains("Period") {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("RamRoleName") {
                self.ramRoleName = dict["RamRoleName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SecurityEnhancementStrategy") {
                self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! Bool
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SpotDuration") {
                self.spotDuration = dict["SpotDuration"] as! Int32
            }
            if dict.keys.contains("SpotPriceLimit") {
                self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
            }
            if dict.keys.contains("SpotStrategy") {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("Tags") {
                var model = GetLaunchTemplateDataResponseBody.LaunchTemplateData.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var launchTemplateData: GetLaunchTemplateDataResponseBody.LaunchTemplateData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchTemplateData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateData != nil {
            map["LaunchTemplateData"] = self.launchTemplateData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateData") {
            var model = GetLaunchTemplateDataResponseBody.LaunchTemplateData()
            model.fromMap(dict["LaunchTemplateData"] as! [String: Any])
            self.launchTemplateData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLaunchTemplateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLaunchTemplateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLaunchTemplateDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InnerDescribeNetworkInterfaceInGroupRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class InnerDescribeNetworkInterfaceInGroupResponseBody : Tea.TeaModel {
    public class NetworkInterfaceSets : Tea.TeaModel {
        public class NetworkInterfaceSet : Tea.TeaModel {
            public class AssociatedPublicIp : Tea.TeaModel {
                public var allocationId: String?

                public var publicIpAddress: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationId != nil {
                        map["AllocationId"] = self.allocationId!
                    }
                    if self.publicIpAddress != nil {
                        map["PublicIpAddress"] = self.publicIpAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllocationId") {
                        self.allocationId = dict["AllocationId"] as! String
                    }
                    if dict.keys.contains("PublicIpAddress") {
                        self.publicIpAddress = dict["PublicIpAddress"] as! String
                    }
                }
            }
            public class Attachment : Tea.TeaModel {
                public var deviceIndex: Int32?

                public var instanceId: String?

                public var trunkNetworkInterfaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.deviceIndex != nil {
                        map["DeviceIndex"] = self.deviceIndex!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.trunkNetworkInterfaceId != nil {
                        map["TrunkNetworkInterfaceId"] = self.trunkNetworkInterfaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DeviceIndex") {
                        self.deviceIndex = dict["DeviceIndex"] as! Int32
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("TrunkNetworkInterfaceId") {
                        self.trunkNetworkInterfaceId = dict["TrunkNetworkInterfaceId"] as! String
                    }
                }
            }
            public class Ipv6Sets : Tea.TeaModel {
                public class Ipv6Set : Tea.TeaModel {
                    public var ipv6Address: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv6Address != nil {
                            map["Ipv6Address"] = self.ipv6Address!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Ipv6Address") {
                            self.ipv6Address = dict["Ipv6Address"] as! String
                        }
                    }
                }
                public var ipv6Set: [InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6Set != nil {
                        var tmp : [Any] = []
                        for k in self.ipv6Set! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv6Set"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ipv6Set") {
                        self.ipv6Set = dict["Ipv6Set"] as! [InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set]
                    }
                }
            }
            public class PrivateIpSets : Tea.TeaModel {
                public class PrivateIpSet : Tea.TeaModel {
                    public class AssociatedPublicIp : Tea.TeaModel {
                        public var allocationId: String?

                        public var publicIpAddress: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.allocationId != nil {
                                map["AllocationId"] = self.allocationId!
                            }
                            if self.publicIpAddress != nil {
                                map["PublicIpAddress"] = self.publicIpAddress!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AllocationId") {
                                self.allocationId = dict["AllocationId"] as! String
                            }
                            if dict.keys.contains("PublicIpAddress") {
                                self.publicIpAddress = dict["PublicIpAddress"] as! String
                            }
                        }
                    }
                    public var associatedPublicIp: InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet.AssociatedPublicIp?

                    public var primary: Bool?

                    public var privateIpAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.associatedPublicIp?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.associatedPublicIp != nil {
                            map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
                        }
                        if self.primary != nil {
                            map["Primary"] = self.primary!
                        }
                        if self.privateIpAddress != nil {
                            map["PrivateIpAddress"] = self.privateIpAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AssociatedPublicIp") {
                            var model = InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet.AssociatedPublicIp()
                            model.fromMap(dict["AssociatedPublicIp"] as! [String: Any])
                            self.associatedPublicIp = model
                        }
                        if dict.keys.contains("Primary") {
                            self.primary = dict["Primary"] as! Bool
                        }
                        if dict.keys.contains("PrivateIpAddress") {
                            self.privateIpAddress = dict["PrivateIpAddress"] as! String
                        }
                    }
                }
                public var privateIpSet: [InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateIpSet != nil {
                        var tmp : [Any] = []
                        for k in self.privateIpSet! {
                            tmp.append(k.toMap())
                        }
                        map["PrivateIpSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateIpSet") {
                        self.privateIpSet = dict["PrivateIpSet"] as! [InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet]
                    }
                }
            }
            public class SecurityGroupIds : Tea.TeaModel {
                public var securityGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags.Tag]
                    }
                }
            }
            public var associatedPublicIp: InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.AssociatedPublicIp?

            public var attachment: InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Attachment?

            public var creationTime: String?

            public var description_: String?

            public var instanceId: String?

            public var ipv6Sets: InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets?

            public var macAddress: String?

            public var networkInterfaceId: String?

            public var networkInterfaceName: String?

            public var networkInterfaceTrafficMode: String?

            public var ownerId: String?

            public var privateIpAddress: String?

            public var privateIpSets: InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets?

            public var queueNumber: Int32?

            public var queuePairNumber: Int32?

            public var resourceGroupId: String?

            public var securityGroupIds: InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.SecurityGroupIds?

            public var serviceID: Int64?

            public var serviceManaged: Bool?

            public var status: String?

            public var tags: InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags?

            public var type: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedPublicIp?.validate()
                try self.attachment?.validate()
                try self.ipv6Sets?.validate()
                try self.privateIpSets?.validate()
                try self.securityGroupIds?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedPublicIp != nil {
                    map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
                }
                if self.attachment != nil {
                    map["Attachment"] = self.attachment?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipv6Sets != nil {
                    map["Ipv6Sets"] = self.ipv6Sets?.toMap()
                }
                if self.macAddress != nil {
                    map["MacAddress"] = self.macAddress!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.networkInterfaceName != nil {
                    map["NetworkInterfaceName"] = self.networkInterfaceName!
                }
                if self.networkInterfaceTrafficMode != nil {
                    map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                if self.privateIpSets != nil {
                    map["PrivateIpSets"] = self.privateIpSets?.toMap()
                }
                if self.queueNumber != nil {
                    map["QueueNumber"] = self.queueNumber!
                }
                if self.queuePairNumber != nil {
                    map["QueuePairNumber"] = self.queuePairNumber!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                }
                if self.serviceID != nil {
                    map["ServiceID"] = self.serviceID!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssociatedPublicIp") {
                    var model = InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.AssociatedPublicIp()
                    model.fromMap(dict["AssociatedPublicIp"] as! [String: Any])
                    self.associatedPublicIp = model
                }
                if dict.keys.contains("Attachment") {
                    var model = InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Attachment()
                    model.fromMap(dict["Attachment"] as! [String: Any])
                    self.attachment = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Ipv6Sets") {
                    var model = InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets()
                    model.fromMap(dict["Ipv6Sets"] as! [String: Any])
                    self.ipv6Sets = model
                }
                if dict.keys.contains("MacAddress") {
                    self.macAddress = dict["MacAddress"] as! String
                }
                if dict.keys.contains("NetworkInterfaceId") {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                }
                if dict.keys.contains("NetworkInterfaceName") {
                    self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
                }
                if dict.keys.contains("NetworkInterfaceTrafficMode") {
                    self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("PrivateIpAddress") {
                    self.privateIpAddress = dict["PrivateIpAddress"] as! String
                }
                if dict.keys.contains("PrivateIpSets") {
                    var model = InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets()
                    model.fromMap(dict["PrivateIpSets"] as! [String: Any])
                    self.privateIpSets = model
                }
                if dict.keys.contains("QueueNumber") {
                    self.queueNumber = dict["QueueNumber"] as! Int32
                }
                if dict.keys.contains("QueuePairNumber") {
                    self.queuePairNumber = dict["QueuePairNumber"] as! Int32
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SecurityGroupIds") {
                    var model = InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.SecurityGroupIds()
                    model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
                    self.securityGroupIds = model
                }
                if dict.keys.contains("ServiceID") {
                    self.serviceID = dict["ServiceID"] as! Int64
                }
                if dict.keys.contains("ServiceManaged") {
                    self.serviceManaged = dict["ServiceManaged"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var networkInterfaceSet: [InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceSet != nil {
                var tmp : [Any] = []
                for k in self.networkInterfaceSet! {
                    tmp.append(k.toMap())
                }
                map["NetworkInterfaceSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceSet") {
                self.networkInterfaceSet = dict["NetworkInterfaceSet"] as! [InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets.NetworkInterfaceSet]
            }
        }
    }
    public var networkInterfaceSets: InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInterfaceSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceSets != nil {
            map["NetworkInterfaceSets"] = self.networkInterfaceSets?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceSets") {
            var model = InnerDescribeNetworkInterfaceInGroupResponseBody.NetworkInterfaceSets()
            model.fromMap(dict["NetworkInterfaceSets"] as! [String: Any])
            self.networkInterfaceSets = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InnerDescribeNetworkInterfaceInGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InnerDescribeNetworkInterfaceInGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InnerDescribeNetworkInterfaceInGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinEniQosGroupRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var ownerId: Int64?

    public var qosGroupName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosGroupName != nil {
            map["QosGroupName"] = self.qosGroupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosGroupName") {
            self.qosGroupName = dict["QosGroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class JoinEniQosGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinEniQosGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinEniQosGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinEniQosGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LeaveEniQosGroupRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class LeaveEniQosGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class LeaveEniQosGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LeaveEniQosGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LeaveEniQosGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAccountEcsQuotasRequest : Tea.TeaModel {
    public var chargeType: String?

    public var networkType: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var quotaResourceName: String?

    public var quotaResourceType: String?

    public var quotaUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sortField: String?

    public var sortOrder: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.quotaResourceName != nil {
            map["QuotaResourceName"] = self.quotaResourceName!
        }
        if self.quotaResourceType != nil {
            map["QuotaResourceType"] = self.quotaResourceType!
        }
        if self.quotaUnit != nil {
            map["QuotaUnit"] = self.quotaUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sortField != nil {
            map["SortField"] = self.sortField!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QuotaResourceName") {
            self.quotaResourceName = dict["QuotaResourceName"] as! String
        }
        if dict.keys.contains("QuotaResourceType") {
            self.quotaResourceType = dict["QuotaResourceType"] as! String
        }
        if dict.keys.contains("QuotaUnit") {
            self.quotaUnit = dict["QuotaUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SortField") {
            self.sortField = dict["SortField"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ListAccountEcsQuotasResponseBody : Tea.TeaModel {
    public class EcsQuotas : Tea.TeaModel {
        public class EcsQuota : Tea.TeaModel {
            public var applicationStatus: String?

            public var baseQuota: Int64?

            public var baseQuotaUsage: Int64?

            public var chargeType: String?

            public var networkType: String?

            public var quotaResourceName: String?

            public var quotaResourceType: String?

            public var quotaUnit: String?

            public var regionId: String?

            public var reservedQuota: Int64?

            public var reservedQuotaUsage: Int64?

            public var totalQuota: Int64?

            public var totalQuotaUsage: Int64?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationStatus != nil {
                    map["ApplicationStatus"] = self.applicationStatus!
                }
                if self.baseQuota != nil {
                    map["BaseQuota"] = self.baseQuota!
                }
                if self.baseQuotaUsage != nil {
                    map["BaseQuotaUsage"] = self.baseQuotaUsage!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.quotaResourceName != nil {
                    map["QuotaResourceName"] = self.quotaResourceName!
                }
                if self.quotaResourceType != nil {
                    map["QuotaResourceType"] = self.quotaResourceType!
                }
                if self.quotaUnit != nil {
                    map["QuotaUnit"] = self.quotaUnit!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservedQuota != nil {
                    map["ReservedQuota"] = self.reservedQuota!
                }
                if self.reservedQuotaUsage != nil {
                    map["ReservedQuotaUsage"] = self.reservedQuotaUsage!
                }
                if self.totalQuota != nil {
                    map["TotalQuota"] = self.totalQuota!
                }
                if self.totalQuotaUsage != nil {
                    map["TotalQuotaUsage"] = self.totalQuotaUsage!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplicationStatus") {
                    self.applicationStatus = dict["ApplicationStatus"] as! String
                }
                if dict.keys.contains("BaseQuota") {
                    self.baseQuota = dict["BaseQuota"] as! Int64
                }
                if dict.keys.contains("BaseQuotaUsage") {
                    self.baseQuotaUsage = dict["BaseQuotaUsage"] as! Int64
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("QuotaResourceName") {
                    self.quotaResourceName = dict["QuotaResourceName"] as! String
                }
                if dict.keys.contains("QuotaResourceType") {
                    self.quotaResourceType = dict["QuotaResourceType"] as! String
                }
                if dict.keys.contains("QuotaUnit") {
                    self.quotaUnit = dict["QuotaUnit"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReservedQuota") {
                    self.reservedQuota = dict["ReservedQuota"] as! Int64
                }
                if dict.keys.contains("ReservedQuotaUsage") {
                    self.reservedQuotaUsage = dict["ReservedQuotaUsage"] as! Int64
                }
                if dict.keys.contains("TotalQuota") {
                    self.totalQuota = dict["TotalQuota"] as! Int64
                }
                if dict.keys.contains("TotalQuotaUsage") {
                    self.totalQuotaUsage = dict["TotalQuotaUsage"] as! Int64
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var ecsQuota: [ListAccountEcsQuotasResponseBody.EcsQuotas.EcsQuota]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecsQuota != nil {
                var tmp : [Any] = []
                for k in self.ecsQuota! {
                    tmp.append(k.toMap())
                }
                map["EcsQuota"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EcsQuota") {
                self.ecsQuota = dict["EcsQuota"] as! [ListAccountEcsQuotasResponseBody.EcsQuotas.EcsQuota]
            }
        }
    }
    public var ecsQuotas: ListAccountEcsQuotasResponseBody.EcsQuotas?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ecsQuotas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ecsQuotas != nil {
            map["EcsQuotas"] = self.ecsQuotas?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EcsQuotas") {
            var model = ListAccountEcsQuotasResponseBody.EcsQuotas()
            model.fromMap(dict["EcsQuotas"] as! [String: Any])
            self.ecsQuotas = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAccountEcsQuotasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAccountEcsQuotasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAccountEcsQuotasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListServiceSettingsRequest : Tea.TeaModel {
    public var cloudAssistantDeliverySettings: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloudAssistantDeliverySettings != nil {
            map["CloudAssistantDeliverySettings"] = self.cloudAssistantDeliverySettings!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloudAssistantDeliverySettings") {
            self.cloudAssistantDeliverySettings = dict["CloudAssistantDeliverySettings"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListServiceSettingsResponseBody : Tea.TeaModel {
    public class CloudAssistantDeliverySettings : Tea.TeaModel {
        public var ossBucketName: String?

        public var ossEnabled: Bool?

        public var ossKeyPrefix: String?

        public var slsEnabled: Bool?

        public var slsLogstoreName: String?

        public var slsProjectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ossBucketName != nil {
                map["OssBucketName"] = self.ossBucketName!
            }
            if self.ossEnabled != nil {
                map["OssEnabled"] = self.ossEnabled!
            }
            if self.ossKeyPrefix != nil {
                map["OssKeyPrefix"] = self.ossKeyPrefix!
            }
            if self.slsEnabled != nil {
                map["SlsEnabled"] = self.slsEnabled!
            }
            if self.slsLogstoreName != nil {
                map["SlsLogstoreName"] = self.slsLogstoreName!
            }
            if self.slsProjectName != nil {
                map["SlsProjectName"] = self.slsProjectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OssBucketName") {
                self.ossBucketName = dict["OssBucketName"] as! String
            }
            if dict.keys.contains("OssEnabled") {
                self.ossEnabled = dict["OssEnabled"] as! Bool
            }
            if dict.keys.contains("OssKeyPrefix") {
                self.ossKeyPrefix = dict["OssKeyPrefix"] as! String
            }
            if dict.keys.contains("SlsEnabled") {
                self.slsEnabled = dict["SlsEnabled"] as! Bool
            }
            if dict.keys.contains("SlsLogstoreName") {
                self.slsLogstoreName = dict["SlsLogstoreName"] as! String
            }
            if dict.keys.contains("SlsProjectName") {
                self.slsProjectName = dict["SlsProjectName"] as! String
            }
        }
    }
    public var cloudAssistantDeliverySettings: ListServiceSettingsResponseBody.CloudAssistantDeliverySettings?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cloudAssistantDeliverySettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloudAssistantDeliverySettings != nil {
            map["CloudAssistantDeliverySettings"] = self.cloudAssistantDeliverySettings?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloudAssistantDeliverySettings") {
            var model = ListServiceSettingsResponseBody.CloudAssistantDeliverySettings()
            model.fromMap(dict["CloudAssistantDeliverySettings"] as! [String: Any])
            self.cloudAssistantDeliverySettings = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListServiceSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListServiceSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListServiceSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCapacityReservationRequest : Tea.TeaModel {
    public var capacityReservationId: String?

    public var instanceCount: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationId != nil {
            map["CapacityReservationId"] = self.capacityReservationId!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CapacityReservationId") {
            self.capacityReservationId = dict["CapacityReservationId"] as! String
        }
        if dict.keys.contains("InstanceCount") {
            self.instanceCount = dict["InstanceCount"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class ModifyCapacityReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCapacityReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCapacityReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCapacityReservationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedHostAttributeRequest : Tea.TeaModel {
    public class NetworkAttributes : Tea.TeaModel {
        public var slbUdpTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbUdpTimeout != nil {
                map["SlbUdpTimeout"] = self.slbUdpTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbUdpTimeout") {
                self.slbUdpTimeout = dict["SlbUdpTimeout"] as! Int32
            }
            if dict.keys.contains("UdpTimeout") {
                self.udpTimeout = dict["UdpTimeout"] as! Int32
            }
        }
    }
    public var networkAttributes: ModifyDedicatedHostAttributeRequest.NetworkAttributes?

    public var actionOnMaintenance: String?

    public var autoPlacement: String?

    public var cpuOverCommitRatio: Double?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var dedicatedHostName: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAttributes != nil {
            map["NetworkAttributes"] = self.networkAttributes?.toMap()
        }
        if self.actionOnMaintenance != nil {
            map["ActionOnMaintenance"] = self.actionOnMaintenance!
        }
        if self.autoPlacement != nil {
            map["AutoPlacement"] = self.autoPlacement!
        }
        if self.cpuOverCommitRatio != nil {
            map["CpuOverCommitRatio"] = self.cpuOverCommitRatio!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.dedicatedHostName != nil {
            map["DedicatedHostName"] = self.dedicatedHostName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAttributes") {
            var model = ModifyDedicatedHostAttributeRequest.NetworkAttributes()
            model.fromMap(dict["NetworkAttributes"] as! [String: Any])
            self.networkAttributes = model
        }
        if dict.keys.contains("ActionOnMaintenance") {
            self.actionOnMaintenance = dict["ActionOnMaintenance"] as! String
        }
        if dict.keys.contains("AutoPlacement") {
            self.autoPlacement = dict["AutoPlacement"] as! String
        }
        if dict.keys.contains("CpuOverCommitRatio") {
            self.cpuOverCommitRatio = dict["CpuOverCommitRatio"] as! Double
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DedicatedHostName") {
            self.dedicatedHostName = dict["DedicatedHostName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDedicatedHostAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDedicatedHostAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedHostAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedHostAutoReleaseTimeRequest : Tea.TeaModel {
    public var autoReleaseTime: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDedicatedHostAutoReleaseTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDedicatedHostAutoReleaseTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostAutoReleaseTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedHostAutoReleaseTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedHostAutoRenewAttributeRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var duration: Int32?

    public var instanceIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var periodUnit: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RenewalStatus") {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ModifyDedicatedHostAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDedicatedHostAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedHostAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedHostClusterAttributeRequest : Tea.TeaModel {
    public var dedicatedHostClusterId: String?

    public var dedicatedHostClusterName: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostClusterName != nil {
            map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostClusterName") {
            self.dedicatedHostClusterName = dict["DedicatedHostClusterName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDedicatedHostClusterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDedicatedHostClusterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostClusterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedHostClusterAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDiagnoseRequest : Tea.TeaModel {
    public var diagnoseId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnoseId != nil {
            map["DiagnoseId"] = self.diagnoseId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiagnoseId") {
            self.diagnoseId = dict["DiagnoseId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ModifyDiagnoseResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var data: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.data != nil {
            map["data"] = self.data!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("data") {
            self.data = dict["data"] as! Int32
        }
    }
}

public class ModifyDiagnoseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiagnoseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDiagnoseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDiskSpecRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var diskCategory: String?

    public var diskId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var performanceLevel: String?

    public var provisionedIops: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.provisionedIops != nil {
            map["ProvisionedIops"] = self.provisionedIops!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("DiskCategory") {
            self.diskCategory = dict["DiskCategory"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("ProvisionedIops") {
            self.provisionedIops = dict["ProvisionedIops"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDiskSpecResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDiskSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDiskSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEniQosGroupRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var qosGroupName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var rx: Int32?

    public var rxPps: Int32?

    public var tx: Int32?

    public var txPps: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.qosGroupName != nil {
            map["QosGroupName"] = self.qosGroupName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.rx != nil {
            map["Rx"] = self.rx!
        }
        if self.rxPps != nil {
            map["RxPps"] = self.rxPps!
        }
        if self.tx != nil {
            map["Tx"] = self.tx!
        }
        if self.txPps != nil {
            map["TxPps"] = self.txPps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QosGroupName") {
            self.qosGroupName = dict["QosGroupName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Rx") {
            self.rx = dict["Rx"] as! Int32
        }
        if dict.keys.contains("RxPps") {
            self.rxPps = dict["RxPps"] as! Int32
        }
        if dict.keys.contains("Tx") {
            self.tx = dict["Tx"] as! Int32
        }
        if dict.keys.contains("TxPps") {
            self.txPps = dict["TxPps"] as! Int32
        }
    }
}

public class ModifyEniQosGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEniQosGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEniQosGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEniQosGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageAdvancedAttributeRequest : Tea.TeaModel {
    public class Flag : Tea.TeaModel {
        public var name: String?

        public var value: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! Bool
            }
        }
    }
    public var flag: [ModifyImageAdvancedAttributeRequest.Flag]?

    public var imageId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var supportIoOptimized: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flag != nil {
            var tmp : [Any] = []
            for k in self.flag! {
                tmp.append(k.toMap())
            }
            map["Flag"] = tmp
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.supportIoOptimized != nil {
            map["SupportIoOptimized"] = self.supportIoOptimized!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Flag") {
            self.flag = dict["Flag"] as! [ModifyImageAdvancedAttributeRequest.Flag]
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SupportIoOptimized") {
            self.supportIoOptimized = dict["SupportIoOptimized"] as! String
        }
    }
}

public class ModifyImageAdvancedAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageAdvancedAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageAdvancedAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyImageAdvancedAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAutoRebootTimeRequest : Tea.TeaModel {
    public var autoRebootTime: String?

    public var instanceIds: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRebootTime != nil {
            map["AutoRebootTime"] = self.autoRebootTime!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRebootTime") {
            self.autoRebootTime = dict["AutoRebootTime"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceAutoRebootTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAutoRebootTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAutoRebootTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceAutoRebootTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceCapacityReservationAttributesRequest : Tea.TeaModel {
    public var capacityReservationId: String?

    public var capacityReservationPreference: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationId != nil {
            map["CapacityReservationId"] = self.capacityReservationId!
        }
        if self.capacityReservationPreference != nil {
            map["CapacityReservationPreference"] = self.capacityReservationPreference!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CapacityReservationId") {
            self.capacityReservationId = dict["CapacityReservationId"] as! String
        }
        if dict.keys.contains("CapacityReservationPreference") {
            self.capacityReservationPreference = dict["CapacityReservationPreference"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceCapacityReservationAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceCapacityReservationAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceCapacityReservationAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceCapacityReservationAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var couponNo: String?

    public var dryRun: Bool?

    public var includeDataDisks: Bool?

    public var instanceChargeType: String?

    public var instanceIds: String?

    public var isDetailFee: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.couponNo != nil {
            map["CouponNo"] = self.couponNo!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.includeDataDisks != nil {
            map["IncludeDataDisks"] = self.includeDataDisks!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.isDetailFee != nil {
            map["IsDetailFee"] = self.isDetailFee!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CouponNo") {
            self.couponNo = dict["CouponNo"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("IncludeDataDisks") {
            self.includeDataDisks = dict["IncludeDataDisks"] as! Bool
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("IsDetailFee") {
            self.isDetailFee = dict["IsDetailFee"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceChargeTypeResponseBody : Tea.TeaModel {
    public class FeeOfInstances : Tea.TeaModel {
        public class FeeOfInstance : Tea.TeaModel {
            public var currency: String?

            public var fee: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.fee != nil {
                    map["Fee"] = self.fee!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("Fee") {
                    self.fee = dict["Fee"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var feeOfInstance: [ModifyInstanceChargeTypeResponseBody.FeeOfInstances.FeeOfInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feeOfInstance != nil {
                var tmp : [Any] = []
                for k in self.feeOfInstance! {
                    tmp.append(k.toMap())
                }
                map["FeeOfInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FeeOfInstance") {
                self.feeOfInstance = dict["FeeOfInstance"] as! [ModifyInstanceChargeTypeResponseBody.FeeOfInstances.FeeOfInstance]
            }
        }
    }
    public var feeOfInstances: ModifyInstanceChargeTypeResponseBody.FeeOfInstances?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.feeOfInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.feeOfInstances != nil {
            map["FeeOfInstances"] = self.feeOfInstances?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FeeOfInstances") {
            var model = ModifyInstanceChargeTypeResponseBody.FeeOfInstances()
            model.fromMap(dict["FeeOfInstances"] as! [String: Any])
            self.feeOfInstances = model
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceDeploymentRequest : Tea.TeaModel {
    public var affinity: String?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var instanceId: String?

    public var migrationType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tenancy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MigrationType") {
            self.migrationType = dict["MigrationType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
    }
}

public class ModifyInstanceDeploymentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceDeploymentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceMaintenanceAttributesRequest : Tea.TeaModel {
    public class MaintenanceWindow : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var actionOnMaintenance: String?

    public var instanceId: [String]?

    public var liveMigration: Bool?

    public var maintenanceWindow: [ModifyInstanceMaintenanceAttributesRequest.MaintenanceWindow]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionOnMaintenance != nil {
            map["ActionOnMaintenance"] = self.actionOnMaintenance!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.liveMigration != nil {
            map["LiveMigration"] = self.liveMigration!
        }
        if self.maintenanceWindow != nil {
            var tmp : [Any] = []
            for k in self.maintenanceWindow! {
                tmp.append(k.toMap())
            }
            map["MaintenanceWindow"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionOnMaintenance") {
            self.actionOnMaintenance = dict["ActionOnMaintenance"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("LiveMigration") {
            self.liveMigration = dict["LiveMigration"] as! Bool
        }
        if dict.keys.contains("MaintenanceWindow") {
            self.maintenanceWindow = dict["MaintenanceWindow"] as! [ModifyInstanceMaintenanceAttributesRequest.MaintenanceWindow]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceMaintenanceAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceMaintenanceAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceMaintenanceAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceMaintenanceAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyMigratableInstancesRequest : Tea.TeaModel {
    public var businessMigrationType: Int32?

    public var instanceId: [String]?

    public var networkMigrationType: Int32?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessMigrationType != nil {
            map["BusinessMigrationType"] = self.businessMigrationType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkMigrationType != nil {
            map["NetworkMigrationType"] = self.networkMigrationType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessMigrationType") {
            self.businessMigrationType = dict["BusinessMigrationType"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("NetworkMigrationType") {
            self.networkMigrationType = dict["NetworkMigrationType"] as! Int32
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ModifyMigratableInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyMigratableInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyMigratableInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyMigratableInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyMigrationInstancesRequest : Tea.TeaModel {
    public var globalMigrationTime: String?

    public var instanceId: [String]?

    public var networkMigrationType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.globalMigrationTime != nil {
            map["GlobalMigrationTime"] = self.globalMigrationTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkMigrationType != nil {
            map["NetworkMigrationType"] = self.networkMigrationType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GlobalMigrationTime") {
            self.globalMigrationTime = dict["GlobalMigrationTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("NetworkMigrationType") {
            self.networkMigrationType = dict["NetworkMigrationType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyMigrationInstancesResponseBody : Tea.TeaModel {
    public class InstancesFailModels : Tea.TeaModel {
        public class InstancesFailModel : Tea.TeaModel {
            public class FailModels : Tea.TeaModel {
                public class FailModel : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                    }
                }
                public var failModel: [ModifyMigrationInstancesResponseBody.InstancesFailModels.InstancesFailModel.FailModels.FailModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.failModel != nil {
                        var tmp : [Any] = []
                        for k in self.failModel! {
                            tmp.append(k.toMap())
                        }
                        map["FailModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FailModel") {
                        self.failModel = dict["FailModel"] as! [ModifyMigrationInstancesResponseBody.InstancesFailModels.InstancesFailModel.FailModels.FailModel]
                    }
                }
            }
            public var failModels: ModifyMigrationInstancesResponseBody.InstancesFailModels.InstancesFailModel.FailModels?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.failModels?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failModels != nil {
                    map["FailModels"] = self.failModels?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailModels") {
                    var model = ModifyMigrationInstancesResponseBody.InstancesFailModels.InstancesFailModel.FailModels()
                    model.fromMap(dict["FailModels"] as! [String: Any])
                    self.failModels = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var instancesFailModel: [ModifyMigrationInstancesResponseBody.InstancesFailModels.InstancesFailModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instancesFailModel != nil {
                var tmp : [Any] = []
                for k in self.instancesFailModel! {
                    tmp.append(k.toMap())
                }
                map["InstancesFailModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstancesFailModel") {
                self.instancesFailModel = dict["InstancesFailModel"] as! [ModifyMigrationInstancesResponseBody.InstancesFailModels.InstancesFailModel]
            }
        }
    }
    public var instancesFailModels: ModifyMigrationInstancesResponseBody.InstancesFailModels?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instancesFailModels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instancesFailModels != nil {
            map["InstancesFailModels"] = self.instancesFailModels?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstancesFailModels") {
            var model = ModifyMigrationInstancesResponseBody.InstancesFailModels()
            model.fromMap(dict["InstancesFailModels"] as! [String: Any])
            self.instancesFailModels = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyMigrationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyMigrationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyMigrationInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyMigrationPlanRequest : Tea.TeaModel {
    public var migrationPlanId: String?

    public var name: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationPlanId != nil {
            map["MigrationPlanId"] = self.migrationPlanId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MigrationPlanId") {
            self.migrationPlanId = dict["MigrationPlanId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyMigrationPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyMigrationPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyMigrationPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyMigrationPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyOrderAutoRebootTimeRequest : Tea.TeaModel {
    public var autoRebootTime: String?

    public var orderId: Int64?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRebootTime != nil {
            map["AutoRebootTime"] = self.autoRebootTime!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRebootTime") {
            self.autoRebootTime = dict["AutoRebootTime"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyOrderAutoRebootTimeResponseBody : Tea.TeaModel {
    public class ModifyOrderAutoRebootTimeInfo : Tea.TeaModel {
        public var autoRebootTime: String?

        public var orderId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRebootTime != nil {
                map["AutoRebootTime"] = self.autoRebootTime!
            }
            if self.orderId != nil {
                map["OrderId"] = self.orderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoRebootTime") {
                self.autoRebootTime = dict["AutoRebootTime"] as! String
            }
            if dict.keys.contains("OrderId") {
                self.orderId = dict["OrderId"] as! Int64
            }
        }
    }
    public var modifyOrderAutoRebootTimeInfo: ModifyOrderAutoRebootTimeResponseBody.ModifyOrderAutoRebootTimeInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.modifyOrderAutoRebootTimeInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modifyOrderAutoRebootTimeInfo != nil {
            map["ModifyOrderAutoRebootTimeInfo"] = self.modifyOrderAutoRebootTimeInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ModifyOrderAutoRebootTimeInfo") {
            var model = ModifyOrderAutoRebootTimeResponseBody.ModifyOrderAutoRebootTimeInfo()
            model.fromMap(dict["ModifyOrderAutoRebootTimeInfo"] as! [String: Any])
            self.modifyOrderAutoRebootTimeInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyOrderAutoRebootTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyOrderAutoRebootTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyOrderAutoRebootTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPrivatePoolRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var privatePoolOptions: ModifyPrivatePoolRequest.PrivatePoolOptions?

    public var description_: String?

    public var endTime: String?

    public var endTimeType: String?

    public var instanceAmount: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endTimeType != nil {
            map["EndTimeType"] = self.endTimeType!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = ModifyPrivatePoolRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndTimeType") {
            self.endTimeType = dict["EndTimeType"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ModifyPrivatePoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPrivatePoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPrivatePoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPrivatePoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyReservationDemandRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var instanceAmount: Int32?

        public var instanceType: String?

        public var matchCriteria: String?

        public var planId: String?

        public var startTime: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceAmount != nil {
                map["InstanceAmount"] = self.instanceAmount!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            if self.planId != nil {
                map["PlanId"] = self.planId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceAmount") {
                self.instanceAmount = dict["InstanceAmount"] as! Int32
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
            if dict.keys.contains("PlanId") {
                self.planId = dict["PlanId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var confirmType: String?

    public var couponAuto: Bool?

    public var couponType: String?

    public var demandId: String?

    public var description_: String?

    public var instanceAmount: Int32?

    public var instanceChargeType: String?

    public var instanceCpuCoreCount: Int32?

    public var instanceTypeFamily: String?

    public var instanceTypes: String?

    public var matchCriteria: String?

    public var name: String?

    public var period: Int32?

    public var periodUnit: String?

    public var phoneNumber: String?

    public var platform: String?

    public var privatePoolOptions: [ModifyReservationDemandRequest.PrivatePoolOptions]?

    public var productType: String?

    public var regionId: String?

    public var reservedInstanceDescription: String?

    public var reservedInstanceGroupId: String?

    public var reservedInstanceName: String?

    public var reservedInstanceOfferingType: String?

    public var reservedInstanceScope: String?

    public var resourceOwnerId: Int64?

    public var resourceSupplyType: String?

    public var savingPlanDescription: String?

    public var savingPlanHourFee: Double?

    public var savingPlanId: String?

    public var savingPlanInstanceTypeFamilyGroup: String?

    public var savingPlanName: String?

    public var savingPlanPayMode: String?

    public var savingPlanSavingType: String?

    public var startTime: String?

    public var tag: [ModifyReservationDemandRequest.Tag]?

    public var zoneIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.confirmType != nil {
            map["ConfirmType"] = self.confirmType!
        }
        if self.couponAuto != nil {
            map["CouponAuto"] = self.couponAuto!
        }
        if self.couponType != nil {
            map["CouponType"] = self.couponType!
        }
        if self.demandId != nil {
            map["DemandId"] = self.demandId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceCpuCoreCount != nil {
            map["InstanceCpuCoreCount"] = self.instanceCpuCoreCount!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.matchCriteria != nil {
            map["MatchCriteria"] = self.matchCriteria!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.privatePoolOptions != nil {
            var tmp : [Any] = []
            for k in self.privatePoolOptions! {
                tmp.append(k.toMap())
            }
            map["PrivatePoolOptions"] = tmp
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceDescription != nil {
            map["ReservedInstanceDescription"] = self.reservedInstanceDescription!
        }
        if self.reservedInstanceGroupId != nil {
            map["ReservedInstanceGroupId"] = self.reservedInstanceGroupId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.reservedInstanceOfferingType != nil {
            map["ReservedInstanceOfferingType"] = self.reservedInstanceOfferingType!
        }
        if self.reservedInstanceScope != nil {
            map["ReservedInstanceScope"] = self.reservedInstanceScope!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceSupplyType != nil {
            map["ResourceSupplyType"] = self.resourceSupplyType!
        }
        if self.savingPlanDescription != nil {
            map["SavingPlanDescription"] = self.savingPlanDescription!
        }
        if self.savingPlanHourFee != nil {
            map["SavingPlanHourFee"] = self.savingPlanHourFee!
        }
        if self.savingPlanId != nil {
            map["SavingPlanId"] = self.savingPlanId!
        }
        if self.savingPlanInstanceTypeFamilyGroup != nil {
            map["SavingPlanInstanceTypeFamilyGroup"] = self.savingPlanInstanceTypeFamilyGroup!
        }
        if self.savingPlanName != nil {
            map["SavingPlanName"] = self.savingPlanName!
        }
        if self.savingPlanPayMode != nil {
            map["SavingPlanPayMode"] = self.savingPlanPayMode!
        }
        if self.savingPlanSavingType != nil {
            map["SavingPlanSavingType"] = self.savingPlanSavingType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneIds != nil {
            map["ZoneIds"] = self.zoneIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConfirmType") {
            self.confirmType = dict["ConfirmType"] as! String
        }
        if dict.keys.contains("CouponAuto") {
            self.couponAuto = dict["CouponAuto"] as! Bool
        }
        if dict.keys.contains("CouponType") {
            self.couponType = dict["CouponType"] as! String
        }
        if dict.keys.contains("DemandId") {
            self.demandId = dict["DemandId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceCpuCoreCount") {
            self.instanceCpuCoreCount = dict["InstanceCpuCoreCount"] as! Int32
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! String
        }
        if dict.keys.contains("MatchCriteria") {
            self.matchCriteria = dict["MatchCriteria"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PhoneNumber") {
            self.phoneNumber = dict["PhoneNumber"] as! String
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("PrivatePoolOptions") {
            self.privatePoolOptions = dict["PrivatePoolOptions"] as! [ModifyReservationDemandRequest.PrivatePoolOptions]
        }
        if dict.keys.contains("ProductType") {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceDescription") {
            self.reservedInstanceDescription = dict["ReservedInstanceDescription"] as! String
        }
        if dict.keys.contains("ReservedInstanceGroupId") {
            self.reservedInstanceGroupId = dict["ReservedInstanceGroupId"] as! String
        }
        if dict.keys.contains("ReservedInstanceName") {
            self.reservedInstanceName = dict["ReservedInstanceName"] as! String
        }
        if dict.keys.contains("ReservedInstanceOfferingType") {
            self.reservedInstanceOfferingType = dict["ReservedInstanceOfferingType"] as! String
        }
        if dict.keys.contains("ReservedInstanceScope") {
            self.reservedInstanceScope = dict["ReservedInstanceScope"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceSupplyType") {
            self.resourceSupplyType = dict["ResourceSupplyType"] as! String
        }
        if dict.keys.contains("SavingPlanDescription") {
            self.savingPlanDescription = dict["SavingPlanDescription"] as! String
        }
        if dict.keys.contains("SavingPlanHourFee") {
            self.savingPlanHourFee = dict["SavingPlanHourFee"] as! Double
        }
        if dict.keys.contains("SavingPlanId") {
            self.savingPlanId = dict["SavingPlanId"] as! String
        }
        if dict.keys.contains("SavingPlanInstanceTypeFamilyGroup") {
            self.savingPlanInstanceTypeFamilyGroup = dict["SavingPlanInstanceTypeFamilyGroup"] as! String
        }
        if dict.keys.contains("SavingPlanName") {
            self.savingPlanName = dict["SavingPlanName"] as! String
        }
        if dict.keys.contains("SavingPlanPayMode") {
            self.savingPlanPayMode = dict["SavingPlanPayMode"] as! String
        }
        if dict.keys.contains("SavingPlanSavingType") {
            self.savingPlanSavingType = dict["SavingPlanSavingType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ModifyReservationDemandRequest.Tag]
        }
        if dict.keys.contains("ZoneIds") {
            self.zoneIds = dict["ZoneIds"] as! String
        }
    }
}

public class ModifyReservationDemandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyReservationDemandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReservationDemandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyReservationDemandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyReservedInstanceAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reservedInstanceId: String?

    public var reservedInstanceName: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! String
        }
        if dict.keys.contains("ReservedInstanceName") {
            self.reservedInstanceName = dict["ReservedInstanceName"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyReservedInstanceAttributeResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyReservedInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReservedInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyReservedInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyReservedInstancesRequest : Tea.TeaModel {
    public class Configuration : Tea.TeaModel {
        public var instanceAmount: Int32?

        public var instanceType: String?

        public var reservedInstanceName: String?

        public var scope: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceAmount != nil {
                map["InstanceAmount"] = self.instanceAmount!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.reservedInstanceName != nil {
                map["ReservedInstanceName"] = self.reservedInstanceName!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceAmount") {
                self.instanceAmount = dict["InstanceAmount"] as! Int32
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("ReservedInstanceName") {
                self.reservedInstanceName = dict["ReservedInstanceName"] as! String
            }
            if dict.keys.contains("Scope") {
                self.scope = dict["Scope"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var configuration: [ModifyReservedInstancesRequest.Configuration]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [ModifyReservedInstancesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configuration != nil {
            var tmp : [Any] = []
            for k in self.configuration! {
                tmp.append(k.toMap())
            }
            map["Configuration"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configuration") {
            self.configuration = dict["Configuration"] as! [ModifyReservedInstancesRequest.Configuration]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ModifyReservedInstancesRequest.Tag]
        }
    }
}

public class ModifyReservedInstancesResponseBody : Tea.TeaModel {
    public class ReservedInstanceIdSets : Tea.TeaModel {
        public var reservedInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceId != nil {
                map["ReservedInstanceId"] = self.reservedInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservedInstanceId") {
                self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
            }
        }
    }
    public var orderId: String?

    public var requestId: String?

    public var reservedInstanceIdSets: ModifyReservedInstancesResponseBody.ReservedInstanceIdSets?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceIdSets != nil {
            map["ReservedInstanceIdSets"] = self.reservedInstanceIdSets?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedInstanceIdSets") {
            var model = ModifyReservedInstancesResponseBody.ReservedInstanceIdSets()
            model.fromMap(dict["ReservedInstanceIdSets"] as! [String: Any])
            self.reservedInstanceIdSets = model
        }
    }
}

public class ModifyReservedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReservedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyReservedInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyResourceDiagnosisStatusRequest : Tea.TeaModel {
    public var diagnosisStatus: String?

    public var errorCode: String?

    public var instanceType: String?

    public var ownerId: Int64?

    public var payType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnosisStatus != nil {
            map["DiagnosisStatus"] = self.diagnosisStatus!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiagnosisStatus") {
            self.diagnosisStatus = dict["DiagnosisStatus"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PayType") {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ModifyResourceDiagnosisStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyResourceDiagnosisStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyResourceDiagnosisStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyResourceDiagnosisStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyResourceMetaRequest : Tea.TeaModel {
    public class Meta : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("key") {
                self.key = dict["key"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var meta: [ModifyResourceMetaRequest.Meta]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.meta != nil {
            var tmp : [Any] = []
            for k in self.meta! {
                tmp.append(k.toMap())
            }
            map["Meta"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Meta") {
            self.meta = dict["Meta"] as! [ModifyResourceMetaRequest.Meta]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ModifyResourceMetaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyResourceMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyResourceMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyResourceMetaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyStorageSetAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetId: String?

    public var storageSetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetName != nil {
            map["StorageSetName"] = self.storageSetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetName") {
            self.storageSetName = dict["StorageSetName"] as! String
        }
    }
}

public class ModifyStorageSetAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyStorageSetAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStorageSetAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyStorageSetAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWaitingOrderRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var instanceAmount: Int64?

    public var ownerAccount: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [ModifyWaitingOrderRequest.Tag]?

    public var waitingOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.waitingOrderId != nil {
            map["WaitingOrderId"] = self.waitingOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int64
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [ModifyWaitingOrderRequest.Tag]
        }
        if dict.keys.contains("WaitingOrderId") {
            self.waitingOrderId = dict["WaitingOrderId"] as! String
        }
    }
}

public class ModifyWaitingOrderResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyWaitingOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWaitingOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyWaitingOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PurchaseReservedInstancesOfferingRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoPay: Bool?

    public var businessInfo: String?

    public var chargeType: String?

    public var clientToken: String?

    public var description_: String?

    public var fromApp: String?

    public var instanceAmount: Int32?

    public var instanceType: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var platform: String?

    public var regionId: String?

    public var reservedInstanceName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scope: String?

    public var startTime: String?

    public var tag: [PurchaseReservedInstancesOfferingRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("BusinessInfo") {
            self.businessInfo = dict["BusinessInfo"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FromApp") {
            self.fromApp = dict["FromApp"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceName") {
            self.reservedInstanceName = dict["ReservedInstanceName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [PurchaseReservedInstancesOfferingRequest.Tag]
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class PurchaseReservedInstancesOfferingResponseBody : Tea.TeaModel {
    public class ReservedInstanceIdSets : Tea.TeaModel {
        public var reservedInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceId != nil {
                map["ReservedInstanceId"] = self.reservedInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservedInstanceId") {
                self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
            }
        }
    }
    public var orderId: String?

    public var requestId: String?

    public var reservedInstanceIdSets: PurchaseReservedInstancesOfferingResponseBody.ReservedInstanceIdSets?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceIdSets != nil {
            map["ReservedInstanceIdSets"] = self.reservedInstanceIdSets?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedInstanceIdSets") {
            var model = PurchaseReservedInstancesOfferingResponseBody.ReservedInstanceIdSets()
            model.fromMap(dict["ReservedInstanceIdSets"] as! [String: Any])
            self.reservedInstanceIdSets = model
        }
    }
}

public class PurchaseReservedInstancesOfferingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurchaseReservedInstancesOfferingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PurchaseReservedInstancesOfferingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PurchaseSavingPlanOfferingRequest : Tea.TeaModel {
    public var chargeType: String?

    public var clientToken: String?

    public var committedAmount: String?

    public var description_: String?

    public var instanceFamily: String?

    public var instanceFamilySet: String?

    public var name: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var planType: String?

    public var purchaseMethod: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.committedAmount != nil {
            map["CommittedAmount"] = self.committedAmount!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceFamily != nil {
            map["InstanceFamily"] = self.instanceFamily!
        }
        if self.instanceFamilySet != nil {
            map["InstanceFamilySet"] = self.instanceFamilySet!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.purchaseMethod != nil {
            map["PurchaseMethod"] = self.purchaseMethod!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CommittedAmount") {
            self.committedAmount = dict["CommittedAmount"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceFamily") {
            self.instanceFamily = dict["InstanceFamily"] as! String
        }
        if dict.keys.contains("InstanceFamilySet") {
            self.instanceFamilySet = dict["InstanceFamilySet"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PlanType") {
            self.planType = dict["PlanType"] as! String
        }
        if dict.keys.contains("PurchaseMethod") {
            self.purchaseMethod = dict["PurchaseMethod"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class PurchaseSavingPlanOfferingResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public var savingPlanIdSets: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.savingPlanIdSets != nil {
            map["SavingPlanIdSets"] = self.savingPlanIdSets!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SavingPlanIdSets") {
            self.savingPlanIdSets = dict["SavingPlanIdSets"] as! [String]
        }
    }
}

public class PurchaseSavingPlanOfferingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurchaseSavingPlanOfferingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PurchaseSavingPlanOfferingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PurchaseStorageCapacityUnitRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var amount: Int32?

    public var capacity: Int32?

    public var clientToken: String?

    public var description_: String?

    public var extendParams: String?

    public var fromApp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var tag: [PurchaseStorageCapacityUnitRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.capacity != nil {
            map["Capacity"] = self.capacity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.extendParams != nil {
            map["ExtendParams"] = self.extendParams!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("Capacity") {
            self.capacity = dict["Capacity"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExtendParams") {
            self.extendParams = dict["ExtendParams"] as! String
        }
        if dict.keys.contains("FromApp") {
            self.fromApp = dict["FromApp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [PurchaseStorageCapacityUnitRequest.Tag]
        }
    }
}

public class PurchaseStorageCapacityUnitResponseBody : Tea.TeaModel {
    public class StorageCapacityUnitIds : Tea.TeaModel {
        public var storageCapacityUnitId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageCapacityUnitId != nil {
                map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StorageCapacityUnitId") {
                self.storageCapacityUnitId = dict["StorageCapacityUnitId"] as! [String]
            }
        }
    }
    public var orderId: String?

    public var requestId: String?

    public var storageCapacityUnitIds: PurchaseStorageCapacityUnitResponseBody.StorageCapacityUnitIds?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageCapacityUnitIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageCapacityUnitIds != nil {
            map["StorageCapacityUnitIds"] = self.storageCapacityUnitIds?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageCapacityUnitIds") {
            var model = PurchaseStorageCapacityUnitResponseBody.StorageCapacityUnitIds()
            model.fromMap(dict["StorageCapacityUnitIds"] as! [String: Any])
            self.storageCapacityUnitIds = model
        }
    }
}

public class PurchaseStorageCapacityUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurchaseStorageCapacityUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PurchaseStorageCapacityUnitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryEniQosGroupByEniRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryEniQosGroupByEniResponseBody : Tea.TeaModel {
    public var qosGroupName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.qosGroupName != nil {
            map["QosGroupName"] = self.qosGroupName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QosGroupName") {
            self.qosGroupName = dict["QosGroupName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryEniQosGroupByEniResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryEniQosGroupByEniResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryEniQosGroupByEniResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryEniQosGroupByInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryEniQosGroupByInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var eniQosGroups: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eniQosGroups != nil {
                map["EniQosGroups"] = self.eniQosGroups!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EniQosGroups") {
                self.eniQosGroups = dict["EniQosGroups"] as! [String]
            }
        }
    }
    public var data: QueryEniQosGroupByInstanceResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryEniQosGroupByInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryEniQosGroupByInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryEniQosGroupByInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryEniQosGroupByInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReAddMigrationTaskInPlanRequest : Tea.TeaModel {
    public var instanceId: String?

    public var migrationPlanId: String?

    public var migrationTime: String?

    public var networkMigrationType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.migrationPlanId != nil {
            map["MigrationPlanId"] = self.migrationPlanId!
        }
        if self.migrationTime != nil {
            map["MigrationTime"] = self.migrationTime!
        }
        if self.networkMigrationType != nil {
            map["NetworkMigrationType"] = self.networkMigrationType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MigrationPlanId") {
            self.migrationPlanId = dict["MigrationPlanId"] as! String
        }
        if dict.keys.contains("MigrationTime") {
            self.migrationTime = dict["MigrationTime"] as! String
        }
        if dict.keys.contains("NetworkMigrationType") {
            self.networkMigrationType = dict["NetworkMigrationType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ReAddMigrationTaskInPlanResponseBody : Tea.TeaModel {
    public class FailModels : Tea.TeaModel {
        public class FailModels : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
            }
        }
        public var failModels: [ReAddMigrationTaskInPlanResponseBody.FailModels.FailModels]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failModels != nil {
                var tmp : [Any] = []
                for k in self.failModels! {
                    tmp.append(k.toMap())
                }
                map["FailModels"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailModels") {
                self.failModels = dict["FailModels"] as! [ReAddMigrationTaskInPlanResponseBody.FailModels.FailModels]
            }
        }
    }
    public var failModels: ReAddMigrationTaskInPlanResponseBody.FailModels?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.failModels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failModels != nil {
            map["FailModels"] = self.failModels?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailModels") {
            var model = ReAddMigrationTaskInPlanResponseBody.FailModels()
            model.fromMap(dict["FailModels"] as! [String: Any])
            self.failModels = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReAddMigrationTaskInPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReAddMigrationTaskInPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReAddMigrationTaskInPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseCapacityReservationRequest : Tea.TeaModel {
    public var capacityReservationId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationId != nil {
            map["CapacityReservationId"] = self.capacityReservationId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CapacityReservationId") {
            self.capacityReservationId = dict["CapacityReservationId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class ReleaseCapacityReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseCapacityReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseCapacityReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseCapacityReservationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseDedicatedHostRequest : Tea.TeaModel {
    public var dedicatedHostId: String?

    public var force: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class ReleaseDedicatedHostResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseDedicatedHostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseDedicatedHostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseDedicatedHostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewDedicatedHostsRequest : Tea.TeaModel {
    public var businessInfo: String?

    public var clientToken: String?

    public var dedicatedHostIds: String?

    public var fromApp: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessInfo") {
            self.businessInfo = dict["BusinessInfo"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DedicatedHostIds") {
            self.dedicatedHostIds = dict["DedicatedHostIds"] as! String
        }
        if dict.keys.contains("FromApp") {
            self.fromApp = dict["FromApp"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RenewDedicatedHostsResponseBody : Tea.TeaModel {
    public class DedicatedHostIdSets : Tea.TeaModel {
        public var dedicatedHostId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostId") {
                self.dedicatedHostId = dict["DedicatedHostId"] as! [String]
            }
        }
    }
    public var dedicatedHostIdSets: RenewDedicatedHostsResponseBody.DedicatedHostIdSets?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostIdSets != nil {
            map["DedicatedHostIdSets"] = self.dedicatedHostIdSets?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostIdSets") {
            var model = RenewDedicatedHostsResponseBody.DedicatedHostIdSets()
            model.fromMap(dict["DedicatedHostIdSets"] as! [String: Any])
            self.dedicatedHostIdSets = model
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewDedicatedHostsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReviewDiagnosticReportRequest : Tea.TeaModel {
    public var category: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sourceSystem: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceSystem != nil {
            map["SourceSystem"] = self.sourceSystem!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceSystem") {
            self.sourceSystem = dict["SourceSystem"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ReviewDiagnosticReportResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ReviewDiagnosticReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReviewDiagnosticReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReviewDiagnosticReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunInstancesRequest : Tea.TeaModel {
    public class HibernationOptions : Tea.TeaModel {
        public var configured: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configured != nil {
                map["Configured"] = self.configured!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Configured") {
                self.configured = dict["Configured"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SchedulerOptions : Tea.TeaModel {
        public var managedPrivateSpaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.managedPrivateSpaceId != nil {
                map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ManagedPrivateSpaceId") {
                self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public var trustedSystemMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            if self.trustedSystemMode != nil {
                map["TrustedSystemMode"] = self.trustedSystemMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfidentialComputingMode") {
                self.confidentialComputingMode = dict["ConfidentialComputingMode"] as! String
            }
            if dict.keys.contains("TrustedSystemMode") {
                self.trustedSystemMode = dict["TrustedSystemMode"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var diskName: String?

        public var performanceLevel: String?

        public var size: String?

        public var burstingEnabled: Bool?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var provisionedIops: Int64?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("StorageClusterId") {
                self.storageClusterId = dict["StorageClusterId"] as! String
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
            if dict.keys.contains("StorageClusterId") {
                self.storageClusterId = dict["StorageClusterId"] as! String
            }
        }
    }
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class Instance : Tea.TeaModel {
        public var privateIpAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrivateIpAddress") {
                self.privateIpAddress = dict["PrivateIpAddress"] as! String
            }
        }
    }
    public class NetworkInterface : Tea.TeaModel {
        public var description_: String?

        public var instanceType: String?

        public var ipv6Address: [String]?

        public var ipv6AddressCount: Int64?

        public var networkInterfaceName: String?

        public var networkInterfaceTrafficMode: String?

        public var primaryIpAddress: String?

        public var queuePairNumber: Int64?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6Address != nil {
                map["Ipv6Address"] = self.ipv6Address!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkInterfaceName != nil {
                map["NetworkInterfaceName"] = self.networkInterfaceName!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.primaryIpAddress != nil {
                map["PrimaryIpAddress"] = self.primaryIpAddress!
            }
            if self.queuePairNumber != nil {
                map["QueuePairNumber"] = self.queuePairNumber!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Ipv6Address") {
                self.ipv6Address = dict["Ipv6Address"] as! [String]
            }
            if dict.keys.contains("Ipv6AddressCount") {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int64
            }
            if dict.keys.contains("NetworkInterfaceName") {
                self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
            }
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("PrimaryIpAddress") {
                self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
            }
            if dict.keys.contains("QueuePairNumber") {
                self.queuePairNumber = dict["QueuePairNumber"] as! Int64
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public class SecurityGroupRule : Tea.TeaModel {
        public var ipProtocol: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("NicType") {
                self.nicType = dict["NicType"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var hibernationOptions: RunInstancesRequest.HibernationOptions?

    public var privatePoolOptions: RunInstancesRequest.PrivatePoolOptions?

    public var schedulerOptions: RunInstancesRequest.SchedulerOptions?

    public var securityOptions: RunInstancesRequest.SecurityOptions?

    public var systemDisk: RunInstancesRequest.SystemDisk?

    public var affinity: String?

    public var autoReleaseTime: String?

    public var businessInfo: String?

    public var clientToken: String?

    public var clusterId: String?

    public var creditSpecification: String?

    public var dataDisk: [RunInstancesRequest.DataDisk]?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var defaultVpc: String?

    public var deletionProtection: Bool?

    public var deploymentSetGroupNo: String?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var fromApp: String?

    public var hostName: String?

    public var hostNames: [String]?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageOptions: RunInstancesRequest.ImageOptions?

    public var instance: [RunInstancesRequest.Instance]?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6Address: [String]?

    public var ipv6AddressCount: Int32?

    public var isp: String?

    public var keyPairName: String?

    public var maxAmount: Int32?

    public var minAmount: Int32?

    public var networkInterface: [RunInstancesRequest.NetworkInterface]?

    public var networkType: String?

    public var nodeControllerId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var recycleBinResourceId: String?

    public var regionId: String?

    public var relationOrderId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var securityGroupRule: [RunInstancesRequest.SecurityGroupRule]?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [RunInstancesRequest.Tag]?

    public var tenancy: String?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hibernationOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.schedulerOptions?.validate()
        try self.securityOptions?.validate()
        try self.systemDisk?.validate()
        try self.imageOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hibernationOptions != nil {
            map["HibernationOptions"] = self.hibernationOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.businessInfo != nil {
            map["BusinessInfo"] = self.businessInfo!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.defaultVpc != nil {
            map["DefaultVpc"] = self.defaultVpc!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetGroupNo != nil {
            map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hostNames != nil {
            map["HostNames"] = self.hostNames!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.instance != nil {
            var tmp : [Any] = []
            for k in self.instance! {
                tmp.append(k.toMap())
            }
            map["Instance"] = tmp
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.maxAmount != nil {
            map["MaxAmount"] = self.maxAmount!
        }
        if self.minAmount != nil {
            map["MinAmount"] = self.minAmount!
        }
        if self.networkInterface != nil {
            var tmp : [Any] = []
            for k in self.networkInterface! {
                tmp.append(k.toMap())
            }
            map["NetworkInterface"] = tmp
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.nodeControllerId != nil {
            map["NodeControllerId"] = self.nodeControllerId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.recycleBinResourceId != nil {
            map["RecycleBinResourceId"] = self.recycleBinResourceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.relationOrderId != nil {
            map["RelationOrderId"] = self.relationOrderId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityGroupRule != nil {
            var tmp : [Any] = []
            for k in self.securityGroupRule! {
                tmp.append(k.toMap())
            }
            map["SecurityGroupRule"] = tmp
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HibernationOptions") {
            var model = RunInstancesRequest.HibernationOptions()
            model.fromMap(dict["HibernationOptions"] as! [String: Any])
            self.hibernationOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") {
            var model = RunInstancesRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SchedulerOptions") {
            var model = RunInstancesRequest.SchedulerOptions()
            model.fromMap(dict["SchedulerOptions"] as! [String: Any])
            self.schedulerOptions = model
        }
        if dict.keys.contains("SecurityOptions") {
            var model = RunInstancesRequest.SecurityOptions()
            model.fromMap(dict["SecurityOptions"] as! [String: Any])
            self.securityOptions = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = RunInstancesRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("BusinessInfo") {
            self.businessInfo = dict["BusinessInfo"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("DataDisk") {
            self.dataDisk = dict["DataDisk"] as! [RunInstancesRequest.DataDisk]
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DefaultVpc") {
            self.defaultVpc = dict["DefaultVpc"] as! String
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetGroupNo") {
            self.deploymentSetGroupNo = dict["DeploymentSetGroupNo"] as! String
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("FromApp") {
            self.fromApp = dict["FromApp"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HostNames") {
            self.hostNames = dict["HostNames"] as! [String]
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpPutResponseHopLimit") {
            self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageOptions") {
            var model = RunInstancesRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("Instance") {
            self.instance = dict["Instance"] as! [RunInstancesRequest.Instance]
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("MaxAmount") {
            self.maxAmount = dict["MaxAmount"] as! Int32
        }
        if dict.keys.contains("MinAmount") {
            self.minAmount = dict["MinAmount"] as! Int32
        }
        if dict.keys.contains("NetworkInterface") {
            self.networkInterface = dict["NetworkInterface"] as! [RunInstancesRequest.NetworkInterface]
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("NodeControllerId") {
            self.nodeControllerId = dict["NodeControllerId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RecycleBinResourceId") {
            self.recycleBinResourceId = dict["RecycleBinResourceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RelationOrderId") {
            self.relationOrderId = dict["RelationOrderId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SecurityGroupRule") {
            self.securityGroupRule = dict["SecurityGroupRule"] as! [RunInstancesRequest.SecurityGroupRule]
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimit") {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [RunInstancesRequest.Tag]
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UniqueSuffix") {
            self.uniqueSuffix = dict["UniqueSuffix"] as! Bool
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class RunInstancesResponseBody : Tea.TeaModel {
    public class InstanceIdSets : Tea.TeaModel {
        public var instanceIdSet: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIdSet != nil {
                map["InstanceIdSet"] = self.instanceIdSet!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceIdSet") {
                self.instanceIdSet = dict["InstanceIdSet"] as! [String]
            }
        }
    }
    public var instanceIdSets: RunInstancesResponseBody.InstanceIdSets?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdSets != nil {
            map["InstanceIdSets"] = self.instanceIdSets?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIdSets") {
            var model = RunInstancesResponseBody.InstanceIdSets()
            model.fromMap(dict["InstanceIdSets"] as! [String: Any])
            self.instanceIdSets = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class RunInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetInstanceAutoReleaseTimeRequest : Tea.TeaModel {
    public var autoReleaseTime: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class SetInstanceAutoReleaseTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetInstanceAutoReleaseTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetInstanceAutoReleaseTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetInstanceAutoReleaseTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartNetworkInsightsAnalysisRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var networkInsightsPathId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.networkInsightsPathId != nil {
            map["NetworkInsightsPathId"] = self.networkInsightsPathId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("NetworkInsightsPathId") {
            self.networkInsightsPathId = dict["NetworkInsightsPathId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class StartNetworkInsightsAnalysisResponseBody : Tea.TeaModel {
    public var networkInsightsAnalysisId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInsightsAnalysisId != nil {
            map["NetworkInsightsAnalysisId"] = self.networkInsightsAnalysisId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInsightsAnalysisId") {
            self.networkInsightsAnalysisId = dict["NetworkInsightsAnalysisId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartNetworkInsightsAnalysisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartNetworkInsightsAnalysisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartNetworkInsightsAnalysisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateServiceSettingsRequest : Tea.TeaModel {
    public class CloudAssistantDeliverySettings : Tea.TeaModel {
        public var ossBucketName: String?

        public var ossEnabled: Bool?

        public var ossKeyPrefix: String?

        public var slsEnabled: Bool?

        public var slsLogstoreName: String?

        public var slsProjectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ossBucketName != nil {
                map["OssBucketName"] = self.ossBucketName!
            }
            if self.ossEnabled != nil {
                map["OssEnabled"] = self.ossEnabled!
            }
            if self.ossKeyPrefix != nil {
                map["OssKeyPrefix"] = self.ossKeyPrefix!
            }
            if self.slsEnabled != nil {
                map["SlsEnabled"] = self.slsEnabled!
            }
            if self.slsLogstoreName != nil {
                map["SlsLogstoreName"] = self.slsLogstoreName!
            }
            if self.slsProjectName != nil {
                map["SlsProjectName"] = self.slsProjectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OssBucketName") {
                self.ossBucketName = dict["OssBucketName"] as! String
            }
            if dict.keys.contains("OssEnabled") {
                self.ossEnabled = dict["OssEnabled"] as! Bool
            }
            if dict.keys.contains("OssKeyPrefix") {
                self.ossKeyPrefix = dict["OssKeyPrefix"] as! String
            }
            if dict.keys.contains("SlsEnabled") {
                self.slsEnabled = dict["SlsEnabled"] as! Bool
            }
            if dict.keys.contains("SlsLogstoreName") {
                self.slsLogstoreName = dict["SlsLogstoreName"] as! String
            }
            if dict.keys.contains("SlsProjectName") {
                self.slsProjectName = dict["SlsProjectName"] as! String
            }
        }
    }
    public var cloudAssistantDeliverySettings: UpdateServiceSettingsRequest.CloudAssistantDeliverySettings?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cloudAssistantDeliverySettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cloudAssistantDeliverySettings != nil {
            map["CloudAssistantDeliverySettings"] = self.cloudAssistantDeliverySettings?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CloudAssistantDeliverySettings") {
            var model = UpdateServiceSettingsRequest.CloudAssistantDeliverySettings()
            model.fromMap(dict["CloudAssistantDeliverySettings"] as! [String: Any])
            self.cloudAssistantDeliverySettings = model
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateServiceSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateServiceSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateServiceSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateServiceSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnmountPEDiskRequest : Tea.TeaModel {
    public var category: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sourceSystem: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sourceSystem != nil {
            map["SourceSystem"] = self.sourceSystem!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SourceSystem") {
            self.sourceSystem = dict["SourceSystem"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UnmountPEDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class UnmountPEDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnmountPEDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnmountPEDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
