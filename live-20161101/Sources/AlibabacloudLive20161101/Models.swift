import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddCasterComponentRequest : Tea.TeaModel {
    public var captionLayerContent: String?

    public var casterId: String?

    public var componentLayer: String?

    public var componentName: String?

    public var componentType: String?

    public var effect: String?

    public var htmlLayerContent: String?

    public var imageLayerContent: String?

    public var layerOrder: String?

    public var locationId: String?

    public var ownerId: Int64?

    public var textLayerContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.captionLayerContent != nil {
            map["CaptionLayerContent"] = self.captionLayerContent!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentLayer != nil {
            map["ComponentLayer"] = self.componentLayer!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.componentType != nil {
            map["ComponentType"] = self.componentType!
        }
        if self.effect != nil {
            map["Effect"] = self.effect!
        }
        if self.htmlLayerContent != nil {
            map["HtmlLayerContent"] = self.htmlLayerContent!
        }
        if self.imageLayerContent != nil {
            map["ImageLayerContent"] = self.imageLayerContent!
        }
        if self.layerOrder != nil {
            map["LayerOrder"] = self.layerOrder!
        }
        if self.locationId != nil {
            map["LocationId"] = self.locationId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.textLayerContent != nil {
            map["TextLayerContent"] = self.textLayerContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CaptionLayerContent") {
            self.captionLayerContent = dict["CaptionLayerContent"] as! String
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ComponentLayer") {
            self.componentLayer = dict["ComponentLayer"] as! String
        }
        if dict.keys.contains("ComponentName") {
            self.componentName = dict["ComponentName"] as! String
        }
        if dict.keys.contains("ComponentType") {
            self.componentType = dict["ComponentType"] as! String
        }
        if dict.keys.contains("Effect") {
            self.effect = dict["Effect"] as! String
        }
        if dict.keys.contains("HtmlLayerContent") {
            self.htmlLayerContent = dict["HtmlLayerContent"] as! String
        }
        if dict.keys.contains("ImageLayerContent") {
            self.imageLayerContent = dict["ImageLayerContent"] as! String
        }
        if dict.keys.contains("LayerOrder") {
            self.layerOrder = dict["LayerOrder"] as! String
        }
        if dict.keys.contains("LocationId") {
            self.locationId = dict["LocationId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("TextLayerContent") {
            self.textLayerContent = dict["TextLayerContent"] as! String
        }
    }
}

public class AddCasterComponentResponseBody : Tea.TeaModel {
    public var componentId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCasterComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCasterComponentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCasterEpisodeRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: [String]?

    public var endTime: String?

    public var episodeName: String?

    public var episodeType: String?

    public var ownerId: Int64?

    public var resourceId: String?

    public var startTime: String?

    public var switchType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.episodeName != nil {
            map["EpisodeName"] = self.episodeName!
        }
        if self.episodeType != nil {
            map["EpisodeType"] = self.episodeType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.switchType != nil {
            map["SwitchType"] = self.switchType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EpisodeName") {
            self.episodeName = dict["EpisodeName"] as! String
        }
        if dict.keys.contains("EpisodeType") {
            self.episodeType = dict["EpisodeType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("SwitchType") {
            self.switchType = dict["SwitchType"] as! String
        }
    }
}

public class AddCasterEpisodeResponseBody : Tea.TeaModel {
    public var episodeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EpisodeId") {
            self.episodeId = dict["EpisodeId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCasterEpisodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterEpisodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCasterEpisodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCasterEpisodeGroupRequest : Tea.TeaModel {
    public class Item : Tea.TeaModel {
        public var itemName: String?

        public var vodUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemName != nil {
                map["ItemName"] = self.itemName!
            }
            if self.vodUrl != nil {
                map["VodUrl"] = self.vodUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemName") {
                self.itemName = dict["ItemName"] as! String
            }
            if dict.keys.contains("VodUrl") {
                self.vodUrl = dict["VodUrl"] as! String
            }
        }
    }
    public var callbackUrl: String?

    public var clientToken: String?

    public var domainName: String?

    public var item: [AddCasterEpisodeGroupRequest.Item]?

    public var ownerId: Int64?

    public var repeatNum: Int32?

    public var sideOutputUrl: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.item != nil {
            var tmp : [Any] = []
            for k in self.item! {
                tmp.append(k.toMap())
            }
            map["Item"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.repeatNum != nil {
            map["RepeatNum"] = self.repeatNum!
        }
        if self.sideOutputUrl != nil {
            map["SideOutputUrl"] = self.sideOutputUrl!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Item") {
            self.item = dict["Item"] as! [AddCasterEpisodeGroupRequest.Item]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RepeatNum") {
            self.repeatNum = dict["RepeatNum"] as! Int32
        }
        if dict.keys.contains("SideOutputUrl") {
            self.sideOutputUrl = dict["SideOutputUrl"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class AddCasterEpisodeGroupResponseBody : Tea.TeaModel {
    public class ItemIds : Tea.TeaModel {
        public var itemId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") {
                self.itemId = dict["ItemId"] as! [String]
            }
        }
    }
    public var itemIds: AddCasterEpisodeGroupResponseBody.ItemIds?

    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds?.toMap()
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ItemIds") {
            var model = AddCasterEpisodeGroupResponseBody.ItemIds()
            model.fromMap(dict["ItemIds"] as! [String: Any])
            self.itemIds = model
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCasterEpisodeGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterEpisodeGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCasterEpisodeGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCasterEpisodeGroupContentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var content: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class AddCasterEpisodeGroupContentResponseBody : Tea.TeaModel {
    public class ItemIds : Tea.TeaModel {
        public var itemId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ItemId") {
                self.itemId = dict["ItemId"] as! [String]
            }
        }
    }
    public var itemIds: AddCasterEpisodeGroupContentResponseBody.ItemIds?

    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds?.toMap()
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ItemIds") {
            var model = AddCasterEpisodeGroupContentResponseBody.ItemIds()
            model.fromMap(dict["ItemIds"] as! [String: Any])
            self.itemIds = model
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCasterEpisodeGroupContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterEpisodeGroupContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCasterEpisodeGroupContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCasterLayoutRequest : Tea.TeaModel {
    public class AudioLayer : Tea.TeaModel {
        public var fixedDelayDuration: Int32?

        public var validChannel: String?

        public var volumeRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.validChannel != nil {
                map["ValidChannel"] = self.validChannel!
            }
            if self.volumeRate != nil {
                map["VolumeRate"] = self.volumeRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FixedDelayDuration") {
                self.fixedDelayDuration = dict["FixedDelayDuration"] as! Int32
            }
            if dict.keys.contains("ValidChannel") {
                self.validChannel = dict["ValidChannel"] as! String
            }
            if dict.keys.contains("VolumeRate") {
                self.volumeRate = dict["VolumeRate"] as! Double
            }
        }
    }
    public class VideoLayer : Tea.TeaModel {
        public var fillMode: String?

        public var fixedDelayDuration: Int32?

        public var heightNormalized: Double?

        public var positionNormalized: [Double]?

        public var positionRefer: String?

        public var widthNormalized: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fillMode != nil {
                map["FillMode"] = self.fillMode!
            }
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.heightNormalized != nil {
                map["HeightNormalized"] = self.heightNormalized!
            }
            if self.positionNormalized != nil {
                map["PositionNormalized"] = self.positionNormalized!
            }
            if self.positionRefer != nil {
                map["PositionRefer"] = self.positionRefer!
            }
            if self.widthNormalized != nil {
                map["WidthNormalized"] = self.widthNormalized!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FillMode") {
                self.fillMode = dict["FillMode"] as! String
            }
            if dict.keys.contains("FixedDelayDuration") {
                self.fixedDelayDuration = dict["FixedDelayDuration"] as! Int32
            }
            if dict.keys.contains("HeightNormalized") {
                self.heightNormalized = dict["HeightNormalized"] as! Double
            }
            if dict.keys.contains("PositionNormalized") {
                self.positionNormalized = dict["PositionNormalized"] as! [Double]
            }
            if dict.keys.contains("PositionRefer") {
                self.positionRefer = dict["PositionRefer"] as! String
            }
            if dict.keys.contains("WidthNormalized") {
                self.widthNormalized = dict["WidthNormalized"] as! Double
            }
        }
    }
    public var audioLayer: [AddCasterLayoutRequest.AudioLayer]?

    public var blendList: [String]?

    public var casterId: String?

    public var mixList: [String]?

    public var ownerId: Int64?

    public var videoLayer: [AddCasterLayoutRequest.VideoLayer]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioLayer != nil {
            var tmp : [Any] = []
            for k in self.audioLayer! {
                tmp.append(k.toMap())
            }
            map["AudioLayer"] = tmp
        }
        if self.blendList != nil {
            map["BlendList"] = self.blendList!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.mixList != nil {
            map["MixList"] = self.mixList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.videoLayer != nil {
            var tmp : [Any] = []
            for k in self.videoLayer! {
                tmp.append(k.toMap())
            }
            map["VideoLayer"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioLayer") {
            self.audioLayer = dict["AudioLayer"] as! [AddCasterLayoutRequest.AudioLayer]
        }
        if dict.keys.contains("BlendList") {
            self.blendList = dict["BlendList"] as! [String]
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("MixList") {
            self.mixList = dict["MixList"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("VideoLayer") {
            self.videoLayer = dict["VideoLayer"] as! [AddCasterLayoutRequest.VideoLayer]
        }
    }
}

public class AddCasterLayoutResponseBody : Tea.TeaModel {
    public var layoutId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCasterLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCasterLayoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCasterProgramRequest : Tea.TeaModel {
    public class Episode : Tea.TeaModel {
        public var componentId: [String]?

        public var endTime: String?

        public var episodeName: String?

        public var episodeType: String?

        public var resourceId: String?

        public var startTime: String?

        public var switchType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentId != nil {
                map["ComponentId"] = self.componentId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.episodeName != nil {
                map["EpisodeName"] = self.episodeName!
            }
            if self.episodeType != nil {
                map["EpisodeType"] = self.episodeType!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.switchType != nil {
                map["SwitchType"] = self.switchType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentId") {
                self.componentId = dict["ComponentId"] as! [String]
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("EpisodeName") {
                self.episodeName = dict["EpisodeName"] as! String
            }
            if dict.keys.contains("EpisodeType") {
                self.episodeType = dict["EpisodeType"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("SwitchType") {
                self.switchType = dict["SwitchType"] as! String
            }
        }
    }
    public var casterId: String?

    public var episode: [AddCasterProgramRequest.Episode]?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episode != nil {
            var tmp : [Any] = []
            for k in self.episode! {
                tmp.append(k.toMap())
            }
            map["Episode"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("Episode") {
            self.episode = dict["Episode"] as! [AddCasterProgramRequest.Episode]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class AddCasterProgramResponseBody : Tea.TeaModel {
    public class EpisodeIds : Tea.TeaModel {
        public class EpisodeId : Tea.TeaModel {
            public var episodeId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.episodeId != nil {
                    map["EpisodeId"] = self.episodeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EpisodeId") {
                    self.episodeId = dict["EpisodeId"] as! String
                }
            }
        }
        public var episodeId: [AddCasterProgramResponseBody.EpisodeIds.EpisodeId]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.episodeId != nil {
                var tmp : [Any] = []
                for k in self.episodeId! {
                    tmp.append(k.toMap())
                }
                map["EpisodeId"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EpisodeId") {
                self.episodeId = dict["EpisodeId"] as! [AddCasterProgramResponseBody.EpisodeIds.EpisodeId]
            }
        }
    }
    public var episodeIds: AddCasterProgramResponseBody.EpisodeIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.episodeIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.episodeIds != nil {
            map["EpisodeIds"] = self.episodeIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EpisodeIds") {
            var model = AddCasterProgramResponseBody.EpisodeIds()
            model.fromMap(dict["EpisodeIds"] as! [String: Any])
            self.episodeIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCasterProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCasterProgramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCasterVideoResourceRequest : Tea.TeaModel {
    public var beginOffset: Int32?

    public var casterId: String?

    public var endOffset: Int32?

    public var fixedDelayDuration: Int32?

    public var liveStreamUrl: String?

    public var locationId: String?

    public var materialId: String?

    public var ownerId: Int64?

    public var ptsCallbackInterval: Int32?

    public var repeatNum: Int32?

    public var resourceName: String?

    public var streamId: String?

    public var vodUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginOffset != nil {
            map["BeginOffset"] = self.beginOffset!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.endOffset != nil {
            map["EndOffset"] = self.endOffset!
        }
        if self.fixedDelayDuration != nil {
            map["FixedDelayDuration"] = self.fixedDelayDuration!
        }
        if self.liveStreamUrl != nil {
            map["LiveStreamUrl"] = self.liveStreamUrl!
        }
        if self.locationId != nil {
            map["LocationId"] = self.locationId!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ptsCallbackInterval != nil {
            map["PtsCallbackInterval"] = self.ptsCallbackInterval!
        }
        if self.repeatNum != nil {
            map["RepeatNum"] = self.repeatNum!
        }
        if self.resourceName != nil {
            map["ResourceName"] = self.resourceName!
        }
        if self.streamId != nil {
            map["StreamId"] = self.streamId!
        }
        if self.vodUrl != nil {
            map["VodUrl"] = self.vodUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginOffset") {
            self.beginOffset = dict["BeginOffset"] as! Int32
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("EndOffset") {
            self.endOffset = dict["EndOffset"] as! Int32
        }
        if dict.keys.contains("FixedDelayDuration") {
            self.fixedDelayDuration = dict["FixedDelayDuration"] as! Int32
        }
        if dict.keys.contains("LiveStreamUrl") {
            self.liveStreamUrl = dict["LiveStreamUrl"] as! String
        }
        if dict.keys.contains("LocationId") {
            self.locationId = dict["LocationId"] as! String
        }
        if dict.keys.contains("MaterialId") {
            self.materialId = dict["MaterialId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PtsCallbackInterval") {
            self.ptsCallbackInterval = dict["PtsCallbackInterval"] as! Int32
        }
        if dict.keys.contains("RepeatNum") {
            self.repeatNum = dict["RepeatNum"] as! Int32
        }
        if dict.keys.contains("ResourceName") {
            self.resourceName = dict["ResourceName"] as! String
        }
        if dict.keys.contains("StreamId") {
            self.streamId = dict["StreamId"] as! String
        }
        if dict.keys.contains("VodUrl") {
            self.vodUrl = dict["VodUrl"] as! String
        }
    }
}

public class AddCasterVideoResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class AddCasterVideoResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterVideoResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCasterVideoResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCustomLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var audioBitrate: Int32?

    public var audioChannelNum: Int32?

    public var audioCodec: String?

    public var audioProfile: String?

    public var audioRate: Int32?

    public var domain: String?

    public var encryptParameters: String?

    public var FPS: Int32?

    public var gop: String?

    public var height: Int32?

    public var kmsKeyExpireInterval: String?

    public var kmsKeyID: String?

    public var kmsUID: String?

    public var ownerId: Int64?

    public var profile: Int32?

    public var template: String?

    public var templateType: String?

    public var videoBitrate: Int32?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.audioBitrate != nil {
            map["AudioBitrate"] = self.audioBitrate!
        }
        if self.audioChannelNum != nil {
            map["AudioChannelNum"] = self.audioChannelNum!
        }
        if self.audioCodec != nil {
            map["AudioCodec"] = self.audioCodec!
        }
        if self.audioProfile != nil {
            map["AudioProfile"] = self.audioProfile!
        }
        if self.audioRate != nil {
            map["AudioRate"] = self.audioRate!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.encryptParameters != nil {
            map["EncryptParameters"] = self.encryptParameters!
        }
        if self.FPS != nil {
            map["FPS"] = self.FPS!
        }
        if self.gop != nil {
            map["Gop"] = self.gop!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.kmsKeyExpireInterval != nil {
            map["KmsKeyExpireInterval"] = self.kmsKeyExpireInterval!
        }
        if self.kmsKeyID != nil {
            map["KmsKeyID"] = self.kmsKeyID!
        }
        if self.kmsUID != nil {
            map["KmsUID"] = self.kmsUID!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.profile != nil {
            map["Profile"] = self.profile!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.videoBitrate != nil {
            map["VideoBitrate"] = self.videoBitrate!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("AudioBitrate") {
            self.audioBitrate = dict["AudioBitrate"] as! Int32
        }
        if dict.keys.contains("AudioChannelNum") {
            self.audioChannelNum = dict["AudioChannelNum"] as! Int32
        }
        if dict.keys.contains("AudioCodec") {
            self.audioCodec = dict["AudioCodec"] as! String
        }
        if dict.keys.contains("AudioProfile") {
            self.audioProfile = dict["AudioProfile"] as! String
        }
        if dict.keys.contains("AudioRate") {
            self.audioRate = dict["AudioRate"] as! Int32
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("EncryptParameters") {
            self.encryptParameters = dict["EncryptParameters"] as! String
        }
        if dict.keys.contains("FPS") {
            self.FPS = dict["FPS"] as! Int32
        }
        if dict.keys.contains("Gop") {
            self.gop = dict["Gop"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! Int32
        }
        if dict.keys.contains("KmsKeyExpireInterval") {
            self.kmsKeyExpireInterval = dict["KmsKeyExpireInterval"] as! String
        }
        if dict.keys.contains("KmsKeyID") {
            self.kmsKeyID = dict["KmsKeyID"] as! String
        }
        if dict.keys.contains("KmsUID") {
            self.kmsUID = dict["KmsUID"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Profile") {
            self.profile = dict["Profile"] as! Int32
        }
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("VideoBitrate") {
            self.videoBitrate = dict["VideoBitrate"] as! Int32
        }
        if dict.keys.contains("Width") {
            self.width = dict["Width"] as! Int32
        }
    }
}

public class AddCustomLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCustomLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCustomLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCustomLiveStreamTranscodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveAppRecordConfigRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public class TranscodeRecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CycleDuration") {
                self.cycleDuration = dict["CycleDuration"] as! Int32
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OssObjectPrefix") {
                self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
            }
            if dict.keys.contains("SliceDuration") {
                self.sliceDuration = dict["SliceDuration"] as! Int32
            }
            if dict.keys.contains("SliceOssObjectPrefix") {
                self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
            }
        }
    }
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var onDemand: Int32?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ownerId: Int64?

    public var recordFormat: [AddLiveAppRecordConfigRequest.RecordFormat]?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public var transcodeRecordFormat: [AddLiveAppRecordConfigRequest.TranscodeRecordFormat]?

    public var transcodeTemplates: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.onDemand != nil {
            map["OnDemand"] = self.onDemand!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.transcodeRecordFormat != nil {
            var tmp : [Any] = []
            for k in self.transcodeRecordFormat! {
                tmp.append(k.toMap())
            }
            map["TranscodeRecordFormat"] = tmp
        }
        if self.transcodeTemplates != nil {
            map["TranscodeTemplates"] = self.transcodeTemplates!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OnDemand") {
            self.onDemand = dict["OnDemand"] as! Int32
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssEndpoint") {
            self.ossEndpoint = dict["OssEndpoint"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RecordFormat") {
            self.recordFormat = dict["RecordFormat"] as! [AddLiveAppRecordConfigRequest.RecordFormat]
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
        if dict.keys.contains("TranscodeRecordFormat") {
            self.transcodeRecordFormat = dict["TranscodeRecordFormat"] as! [AddLiveAppRecordConfigRequest.TranscodeRecordFormat]
        }
        if dict.keys.contains("TranscodeTemplates") {
            self.transcodeTemplates = dict["TranscodeTemplates"] as! [String]
        }
    }
}

public class AddLiveAppRecordConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveAppRecordConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAppRecordConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveAppRecordConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveAppSnapshotConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var callback: String?

    public var domainName: String?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var overwriteOssObject: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var sequenceOssObject: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.callback != nil {
            map["Callback"] = self.callback!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.overwriteOssObject != nil {
            map["OverwriteOssObject"] = self.overwriteOssObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sequenceOssObject != nil {
            map["SequenceOssObject"] = self.sequenceOssObject!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Callback") {
            self.callback = dict["Callback"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssEndpoint") {
            self.ossEndpoint = dict["OssEndpoint"] as! String
        }
        if dict.keys.contains("OverwriteOssObject") {
            self.overwriteOssObject = dict["OverwriteOssObject"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SequenceOssObject") {
            self.sequenceOssObject = dict["SequenceOssObject"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class AddLiveAppSnapshotConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveAppSnapshotConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAppSnapshotConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveAppSnapshotConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveAudioAuditConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var bizType: String?

    public var domainName: String?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BizType") {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssEndpoint") {
            self.ossEndpoint = dict["OssEndpoint"] as! String
        }
        if dict.keys.contains("OssObject") {
            self.ossObject = dict["OssObject"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class AddLiveAudioAuditConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveAudioAuditConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAudioAuditConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveAudioAuditConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveAudioAuditNotifyConfigRequest : Tea.TeaModel {
    public var callback: String?

    public var callbackTemplate: String?

    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callback != nil {
            map["Callback"] = self.callback!
        }
        if self.callbackTemplate != nil {
            map["CallbackTemplate"] = self.callbackTemplate!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callback") {
            self.callback = dict["Callback"] as! String
        }
        if dict.keys.contains("CallbackTemplate") {
            self.callbackTemplate = dict["CallbackTemplate"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class AddLiveAudioAuditNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveAudioAuditNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAudioAuditNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveAudioAuditNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveDetectNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class AddLiveDetectNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveDetectNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveDetectNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveDetectNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveDomainRequest : Tea.TeaModel {
    public var checkUrl: String?

    public var domainName: String?

    public var liveDomainType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var region: String?

    public var scope: String?

    public var securityToken: String?

    public var topLevelDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkUrl != nil {
            map["CheckUrl"] = self.checkUrl!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.liveDomainType != nil {
            map["LiveDomainType"] = self.liveDomainType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.topLevelDomain != nil {
            map["TopLevelDomain"] = self.topLevelDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CheckUrl") {
            self.checkUrl = dict["CheckUrl"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("LiveDomainType") {
            self.liveDomainType = dict["LiveDomainType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TopLevelDomain") {
            self.topLevelDomain = dict["TopLevelDomain"] as! String
        }
    }
}

public class AddLiveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveDomainMappingRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var pullDomain: String?

    public var pushDomain: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pullDomain != nil {
            map["PullDomain"] = self.pullDomain!
        }
        if self.pushDomain != nil {
            map["PushDomain"] = self.pushDomain!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PullDomain") {
            self.pullDomain = dict["PullDomain"] as! String
        }
        if dict.keys.contains("PushDomain") {
            self.pushDomain = dict["PushDomain"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class AddLiveDomainMappingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveDomainMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveDomainMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveDomainMappingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveDomainPlayMappingRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var playDomain: String?

    public var pullDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.playDomain != nil {
            map["PlayDomain"] = self.playDomain!
        }
        if self.pullDomain != nil {
            map["PullDomain"] = self.pullDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PlayDomain") {
            self.playDomain = dict["PlayDomain"] as! String
        }
        if dict.keys.contains("PullDomain") {
            self.pullDomain = dict["PullDomain"] as! String
        }
    }
}

public class AddLiveDomainPlayMappingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveDomainPlayMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveDomainPlayMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveDomainPlayMappingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLivePullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var sourceUrl: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sourceUrl != nil {
            map["SourceUrl"] = self.sourceUrl!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SourceUrl") {
            self.sourceUrl = dict["SourceUrl"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class AddLivePullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLivePullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLivePullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLivePullStreamInfoConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveRecordNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var needStatusNotify: Bool?

    public var notifyUrl: String?

    public var onDemandUrl: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.needStatusNotify != nil {
            map["NeedStatusNotify"] = self.needStatusNotify!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.onDemandUrl != nil {
            map["OnDemandUrl"] = self.onDemandUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("NeedStatusNotify") {
            self.needStatusNotify = dict["NeedStatusNotify"] as! Bool
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("OnDemandUrl") {
            self.onDemandUrl = dict["OnDemandUrl"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class AddLiveRecordNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveRecordNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveRecordNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveRecordNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveRecordVodConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var autoCompose: String?

    public var composeVodTranscodeGroupId: String?

    public var cycleDuration: Int32?

    public var domainName: String?

    public var ownerId: Int64?

    public var storageLocation: String?

    public var streamName: String?

    public var vodTranscodeGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.autoCompose != nil {
            map["AutoCompose"] = self.autoCompose!
        }
        if self.composeVodTranscodeGroupId != nil {
            map["ComposeVodTranscodeGroupId"] = self.composeVodTranscodeGroupId!
        }
        if self.cycleDuration != nil {
            map["CycleDuration"] = self.cycleDuration!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.vodTranscodeGroupId != nil {
            map["VodTranscodeGroupId"] = self.vodTranscodeGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AutoCompose") {
            self.autoCompose = dict["AutoCompose"] as! String
        }
        if dict.keys.contains("ComposeVodTranscodeGroupId") {
            self.composeVodTranscodeGroupId = dict["ComposeVodTranscodeGroupId"] as! String
        }
        if dict.keys.contains("CycleDuration") {
            self.cycleDuration = dict["CycleDuration"] as! Int32
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StorageLocation") {
            self.storageLocation = dict["StorageLocation"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
        if dict.keys.contains("VodTranscodeGroupId") {
            self.vodTranscodeGroupId = dict["VodTranscodeGroupId"] as! String
        }
    }
}

public class AddLiveRecordVodConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveRecordVodConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveRecordVodConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveRecordVodConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveSnapshotDetectPornConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var interval: Int32?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var scene: [String]?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssEndpoint") {
            self.ossEndpoint = dict["OssEndpoint"] as! String
        }
        if dict.keys.contains("OssObject") {
            self.ossObject = dict["OssObject"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! [String]
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class AddLiveSnapshotDetectPornConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveSnapshotDetectPornConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveSnapshotDetectPornConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveSnapshotDetectPornConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveSnapshotNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var notifyAuthKey: String?

    public var notifyReqAuth: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("NotifyAuthKey") {
            self.notifyAuthKey = dict["NotifyAuthKey"] as! String
        }
        if dict.keys.contains("NotifyReqAuth") {
            self.notifyReqAuth = dict["NotifyReqAuth"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class AddLiveSnapshotNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveSnapshotNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveSnapshotNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveSnapshotNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var encryptParameters: String?

    public var lazy_: String?

    public var ownerId: Int64?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.encryptParameters != nil {
            map["EncryptParameters"] = self.encryptParameters!
        }
        if self.lazy_ != nil {
            map["Lazy"] = self.lazy_!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("EncryptParameters") {
            self.encryptParameters = dict["EncryptParameters"] as! String
        }
        if dict.keys.contains("Lazy") {
            self.lazy_ = dict["Lazy"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
    }
}

public class AddLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveStreamTranscodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveStreamWatermarkRequest : Tea.TeaModel {
    public var description_: String?

    public var height: Int32?

    public var name: String?

    public var offsetCorner: String?

    public var ownerId: Int64?

    public var pictureUrl: String?

    public var refHeight: Int32?

    public var refWidth: Int32?

    public var transparency: Int32?

    public var type: Int32?

    public var XOffset: Double?

    public var YOffset: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.offsetCorner != nil {
            map["OffsetCorner"] = self.offsetCorner!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pictureUrl != nil {
            map["PictureUrl"] = self.pictureUrl!
        }
        if self.refHeight != nil {
            map["RefHeight"] = self.refHeight!
        }
        if self.refWidth != nil {
            map["RefWidth"] = self.refWidth!
        }
        if self.transparency != nil {
            map["Transparency"] = self.transparency!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.XOffset != nil {
            map["XOffset"] = self.XOffset!
        }
        if self.YOffset != nil {
            map["YOffset"] = self.YOffset!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OffsetCorner") {
            self.offsetCorner = dict["OffsetCorner"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PictureUrl") {
            self.pictureUrl = dict["PictureUrl"] as! String
        }
        if dict.keys.contains("RefHeight") {
            self.refHeight = dict["RefHeight"] as! Int32
        }
        if dict.keys.contains("RefWidth") {
            self.refWidth = dict["RefWidth"] as! Int32
        }
        if dict.keys.contains("Transparency") {
            self.transparency = dict["Transparency"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
        if dict.keys.contains("XOffset") {
            self.XOffset = dict["XOffset"] as! Double
        }
        if dict.keys.contains("YOffset") {
            self.YOffset = dict["YOffset"] as! Double
        }
    }
}

public class AddLiveStreamWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class AddLiveStreamWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveStreamWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveStreamWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddLiveStreamWatermarkRuleRequest : Tea.TeaModel {
    public var app: String?

    public var description_: String?

    public var domain: String?

    public var name: String?

    public var ownerId: Int64?

    public var stream: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Stream") {
            self.stream = dict["Stream"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class AddLiveStreamWatermarkRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
    }
}

public class AddLiveStreamWatermarkRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveStreamWatermarkRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddLiveStreamWatermarkRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMultiRateConfigRequest : Tea.TeaModel {
    public var app: String?

    public var avFormat: String?

    public var domainName: String?

    public var groupId: String?

    public var isLazy: String?

    public var isTimeAlign: String?

    public var ownerId: Int64?

    public var templates: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.avFormat != nil {
            map["AvFormat"] = self.avFormat!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isLazy != nil {
            map["IsLazy"] = self.isLazy!
        }
        if self.isTimeAlign != nil {
            map["IsTimeAlign"] = self.isTimeAlign!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.templates != nil {
            map["Templates"] = self.templates!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("AvFormat") {
            self.avFormat = dict["AvFormat"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IsLazy") {
            self.isLazy = dict["IsLazy"] as! String
        }
        if dict.keys.contains("IsTimeAlign") {
            self.isTimeAlign = dict["IsTimeAlign"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Templates") {
            self.templates = dict["Templates"] as! String
        }
    }
}

public class AddMultiRateConfigResponseBody : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public class FailedTemplates : Tea.TeaModel {
            public var audioBitrate: Int32?

            public var audioChannelNum: Int32?

            public var audioCodec: String?

            public var audioProfile: String?

            public var audioRate: Int32?

            public var bandWidth: Int32?

            public var fps: Int32?

            public var gop: String?

            public var height: Int32?

            public var profile: Int32?

            public var template: String?

            public var templateType: String?

            public var videoBitrate: Int32?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioBitrate != nil {
                    map["AudioBitrate"] = self.audioBitrate!
                }
                if self.audioChannelNum != nil {
                    map["AudioChannelNum"] = self.audioChannelNum!
                }
                if self.audioCodec != nil {
                    map["AudioCodec"] = self.audioCodec!
                }
                if self.audioProfile != nil {
                    map["AudioProfile"] = self.audioProfile!
                }
                if self.audioRate != nil {
                    map["AudioRate"] = self.audioRate!
                }
                if self.bandWidth != nil {
                    map["BandWidth"] = self.bandWidth!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.template != nil {
                    map["Template"] = self.template!
                }
                if self.templateType != nil {
                    map["TemplateType"] = self.templateType!
                }
                if self.videoBitrate != nil {
                    map["VideoBitrate"] = self.videoBitrate!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioBitrate") {
                    self.audioBitrate = dict["AudioBitrate"] as! Int32
                }
                if dict.keys.contains("AudioChannelNum") {
                    self.audioChannelNum = dict["AudioChannelNum"] as! Int32
                }
                if dict.keys.contains("AudioCodec") {
                    self.audioCodec = dict["AudioCodec"] as! String
                }
                if dict.keys.contains("AudioProfile") {
                    self.audioProfile = dict["AudioProfile"] as! String
                }
                if dict.keys.contains("AudioRate") {
                    self.audioRate = dict["AudioRate"] as! Int32
                }
                if dict.keys.contains("BandWidth") {
                    self.bandWidth = dict["BandWidth"] as! Int32
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! Int32
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! Int32
                }
                if dict.keys.contains("Template") {
                    self.template = dict["Template"] as! String
                }
                if dict.keys.contains("TemplateType") {
                    self.templateType = dict["TemplateType"] as! String
                }
                if dict.keys.contains("VideoBitrate") {
                    self.videoBitrate = dict["VideoBitrate"] as! Int32
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var failedTemplates: [AddMultiRateConfigResponseBody.Body.FailedTemplates]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedTemplates != nil {
                var tmp : [Any] = []
                for k in self.failedTemplates! {
                    tmp.append(k.toMap())
                }
                map["FailedTemplates"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedTemplates") {
                self.failedTemplates = dict["FailedTemplates"] as! [AddMultiRateConfigResponseBody.Body.FailedTemplates]
            }
        }
    }
    public var body: AddMultiRateConfigResponseBody.Body?

    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["Body"] = self.body?.toMap()
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Body") {
            var model = AddMultiRateConfigResponseBody.Body()
            model.fromMap(dict["Body"] as! [String: Any])
            self.body = model
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMultiRateConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMultiRateConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMultiRateConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPlaylistItemsRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var programConfig: String?

    public var programId: String?

    public var programItems: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programConfig != nil {
            map["ProgramConfig"] = self.programConfig!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.programItems != nil {
            map["ProgramItems"] = self.programItems!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProgramConfig") {
            self.programConfig = dict["ProgramConfig"] as! String
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("ProgramItems") {
            self.programItems = dict["ProgramItems"] as! String
        }
    }
}

public class AddPlaylistItemsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class FailedItems : Tea.TeaModel {
            public var itemId: String?

            public var itemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") {
                    self.itemId = dict["ItemId"] as! String
                }
                if dict.keys.contains("ItemName") {
                    self.itemName = dict["ItemName"] as! String
                }
            }
        }
        public class SuccessItems : Tea.TeaModel {
            public var itemId: String?

            public var itemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") {
                    self.itemId = dict["ItemId"] as! String
                }
                if dict.keys.contains("ItemName") {
                    self.itemName = dict["ItemName"] as! String
                }
            }
        }
        public var failedItems: [AddPlaylistItemsResponseBody.Items.FailedItems]?

        public var successItems: [AddPlaylistItemsResponseBody.Items.SuccessItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedItems != nil {
                var tmp : [Any] = []
                for k in self.failedItems! {
                    tmp.append(k.toMap())
                }
                map["FailedItems"] = tmp
            }
            if self.successItems != nil {
                var tmp : [Any] = []
                for k in self.successItems! {
                    tmp.append(k.toMap())
                }
                map["SuccessItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedItems") {
                self.failedItems = dict["FailedItems"] as! [AddPlaylistItemsResponseBody.Items.FailedItems]
            }
            if dict.keys.contains("SuccessItems") {
                self.successItems = dict["SuccessItems"] as! [AddPlaylistItemsResponseBody.Items.SuccessItems]
            }
        }
    }
    public var items: AddPlaylistItemsResponseBody.Items?

    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Items") {
            var model = AddPlaylistItemsResponseBody.Items()
            model.fromMap(dict["Items"] as! [String: Any])
            self.items = model
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPlaylistItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPlaylistItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPlaylistItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddRtsLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var audioBitrate: Int32?

    public var audioChannelNum: Int32?

    public var audioCodec: String?

    public var audioProfile: String?

    public var audioRate: Int32?

    public var deleteBframes: Bool?

    public var domain: String?

    public var FPS: Int32?

    public var gop: String?

    public var height: Int32?

    public var lazy_: String?

    public var opus: Bool?

    public var ownerId: Int64?

    public var profile: Int32?

    public var template: String?

    public var templateType: String?

    public var videoBitrate: Int32?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.audioBitrate != nil {
            map["AudioBitrate"] = self.audioBitrate!
        }
        if self.audioChannelNum != nil {
            map["AudioChannelNum"] = self.audioChannelNum!
        }
        if self.audioCodec != nil {
            map["AudioCodec"] = self.audioCodec!
        }
        if self.audioProfile != nil {
            map["AudioProfile"] = self.audioProfile!
        }
        if self.audioRate != nil {
            map["AudioRate"] = self.audioRate!
        }
        if self.deleteBframes != nil {
            map["DeleteBframes"] = self.deleteBframes!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.FPS != nil {
            map["FPS"] = self.FPS!
        }
        if self.gop != nil {
            map["Gop"] = self.gop!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.lazy_ != nil {
            map["Lazy"] = self.lazy_!
        }
        if self.opus != nil {
            map["Opus"] = self.opus!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.profile != nil {
            map["Profile"] = self.profile!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.videoBitrate != nil {
            map["VideoBitrate"] = self.videoBitrate!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("AudioBitrate") {
            self.audioBitrate = dict["AudioBitrate"] as! Int32
        }
        if dict.keys.contains("AudioChannelNum") {
            self.audioChannelNum = dict["AudioChannelNum"] as! Int32
        }
        if dict.keys.contains("AudioCodec") {
            self.audioCodec = dict["AudioCodec"] as! String
        }
        if dict.keys.contains("AudioProfile") {
            self.audioProfile = dict["AudioProfile"] as! String
        }
        if dict.keys.contains("AudioRate") {
            self.audioRate = dict["AudioRate"] as! Int32
        }
        if dict.keys.contains("DeleteBframes") {
            self.deleteBframes = dict["DeleteBframes"] as! Bool
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("FPS") {
            self.FPS = dict["FPS"] as! Int32
        }
        if dict.keys.contains("Gop") {
            self.gop = dict["Gop"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! Int32
        }
        if dict.keys.contains("Lazy") {
            self.lazy_ = dict["Lazy"] as! String
        }
        if dict.keys.contains("Opus") {
            self.opus = dict["Opus"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Profile") {
            self.profile = dict["Profile"] as! Int32
        }
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
        if dict.keys.contains("TemplateType") {
            self.templateType = dict["TemplateType"] as! String
        }
        if dict.keys.contains("VideoBitrate") {
            self.videoBitrate = dict["VideoBitrate"] as! Int32
        }
        if dict.keys.contains("Width") {
            self.width = dict["Width"] as! Int32
        }
    }
}

public class AddRtsLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddRtsLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRtsLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddRtsLiveStreamTranscodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddShowIntoShowListRequest : Tea.TeaModel {
    public class ShowList : Tea.TeaModel {
        public var duration: Int64?

        public var liveInputType: Int32?

        public var repeatTimes: Int32?

        public var resourceId: String?

        public var resourceType: String?

        public var resourceUrl: String?

        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["duration"] = self.duration!
            }
            if self.liveInputType != nil {
                map["liveInputType"] = self.liveInputType!
            }
            if self.repeatTimes != nil {
                map["repeatTimes"] = self.repeatTimes!
            }
            if self.resourceId != nil {
                map["resourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.resourceUrl != nil {
                map["resourceUrl"] = self.resourceUrl!
            }
            if self.showName != nil {
                map["showName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("duration") {
                self.duration = dict["duration"] as! Int64
            }
            if dict.keys.contains("liveInputType") {
                self.liveInputType = dict["liveInputType"] as! Int32
            }
            if dict.keys.contains("repeatTimes") {
                self.repeatTimes = dict["repeatTimes"] as! Int32
            }
            if dict.keys.contains("resourceId") {
                self.resourceId = dict["resourceId"] as! String
            }
            if dict.keys.contains("resourceType") {
                self.resourceType = dict["resourceType"] as! String
            }
            if dict.keys.contains("resourceUrl") {
                self.resourceUrl = dict["resourceUrl"] as! String
            }
            if dict.keys.contains("showName") {
                self.showName = dict["showName"] as! String
            }
        }
    }
    public var casterId: String?

    public var duration: Int64?

    public var liveInputType: Int32?

    public var ownerId: Int64?

    public var repeatTimes: Int32?

    public var resourceId: String?

    public var resourceType: String?

    public var resourceUrl: String?

    public var showName: String?

    public var spot: Int32?

    public var isBatchMode: Bool?

    public var showList: [AddShowIntoShowListRequest.ShowList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.liveInputType != nil {
            map["LiveInputType"] = self.liveInputType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.repeatTimes != nil {
            map["RepeatTimes"] = self.repeatTimes!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.resourceUrl != nil {
            map["ResourceUrl"] = self.resourceUrl!
        }
        if self.showName != nil {
            map["ShowName"] = self.showName!
        }
        if self.spot != nil {
            map["Spot"] = self.spot!
        }
        if self.isBatchMode != nil {
            map["isBatchMode"] = self.isBatchMode!
        }
        if self.showList != nil {
            var tmp : [Any] = []
            for k in self.showList! {
                tmp.append(k.toMap())
            }
            map["showList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int64
        }
        if dict.keys.contains("LiveInputType") {
            self.liveInputType = dict["LiveInputType"] as! Int32
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RepeatTimes") {
            self.repeatTimes = dict["RepeatTimes"] as! Int32
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("ResourceUrl") {
            self.resourceUrl = dict["ResourceUrl"] as! String
        }
        if dict.keys.contains("ShowName") {
            self.showName = dict["ShowName"] as! String
        }
        if dict.keys.contains("Spot") {
            self.spot = dict["Spot"] as! Int32
        }
        if dict.keys.contains("isBatchMode") {
            self.isBatchMode = dict["isBatchMode"] as! Bool
        }
        if dict.keys.contains("showList") {
            self.showList = dict["showList"] as! [AddShowIntoShowListRequest.ShowList]
        }
    }
}

public class AddShowIntoShowListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var showId: String?

    public var failedList: String?

    public var successfulShowIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.failedList != nil {
            map["failedList"] = self.failedList!
        }
        if self.successfulShowIds != nil {
            map["successfulShowIds"] = self.successfulShowIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ShowId") {
            self.showId = dict["ShowId"] as! String
        }
        if dict.keys.contains("failedList") {
            self.failedList = dict["failedList"] as! String
        }
        if dict.keys.contains("successfulShowIds") {
            self.successfulShowIds = dict["successfulShowIds"] as! String
        }
    }
}

public class AddShowIntoShowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddShowIntoShowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddShowIntoShowListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddStudioLayoutRequest : Tea.TeaModel {
    public var bgImageConfig: String?

    public var casterId: String?

    public var commonConfig: String?

    public var layerOrderConfigList: String?

    public var layoutName: String?

    public var layoutType: String?

    public var mediaInputConfigList: String?

    public var ownerId: Int64?

    public var screenInputConfigList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgImageConfig != nil {
            map["BgImageConfig"] = self.bgImageConfig!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.commonConfig != nil {
            map["CommonConfig"] = self.commonConfig!
        }
        if self.layerOrderConfigList != nil {
            map["LayerOrderConfigList"] = self.layerOrderConfigList!
        }
        if self.layoutName != nil {
            map["LayoutName"] = self.layoutName!
        }
        if self.layoutType != nil {
            map["LayoutType"] = self.layoutType!
        }
        if self.mediaInputConfigList != nil {
            map["MediaInputConfigList"] = self.mediaInputConfigList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.screenInputConfigList != nil {
            map["ScreenInputConfigList"] = self.screenInputConfigList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgImageConfig") {
            self.bgImageConfig = dict["BgImageConfig"] as! String
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("CommonConfig") {
            self.commonConfig = dict["CommonConfig"] as! String
        }
        if dict.keys.contains("LayerOrderConfigList") {
            self.layerOrderConfigList = dict["LayerOrderConfigList"] as! String
        }
        if dict.keys.contains("LayoutName") {
            self.layoutName = dict["LayoutName"] as! String
        }
        if dict.keys.contains("LayoutType") {
            self.layoutType = dict["LayoutType"] as! String
        }
        if dict.keys.contains("MediaInputConfigList") {
            self.mediaInputConfigList = dict["MediaInputConfigList"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ScreenInputConfigList") {
            self.screenInputConfigList = dict["ScreenInputConfigList"] as! String
        }
    }
}

public class AddStudioLayoutResponseBody : Tea.TeaModel {
    public var layoutId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddStudioLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddStudioLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddStudioLayoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTrancodeSEIRequest : Tea.TeaModel {
    public var appName: String?

    public var delay: Int32?

    public var domainName: String?

    public var ownerId: Int64?

    public var pattern: String?

    public var repeat_: Int32?

    public var streamName: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.delay != nil {
            map["Delay"] = self.delay!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pattern != nil {
            map["Pattern"] = self.pattern!
        }
        if self.repeat_ != nil {
            map["Repeat"] = self.repeat_!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Delay") {
            self.delay = dict["Delay"] as! Int32
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Pattern") {
            self.pattern = dict["Pattern"] as! String
        }
        if dict.keys.contains("Repeat") {
            self.repeat_ = dict["Repeat"] as! Int32
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
        if dict.keys.contains("Text") {
            self.text = dict["Text"] as! String
        }
    }
}

public class AddTrancodeSEIResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddTrancodeSEIResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTrancodeSEIResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTrancodeSEIResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllowPushStreamRequest : Tea.TeaModel {
    public var appId: String?

    public var ownerId: Int64?

    public var roomId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
    }
}

public class AllowPushStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AllowPushStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllowPushStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllowPushStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchDeleteLiveDomainConfigsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var functionNames: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.functionNames != nil {
            map["FunctionNames"] = self.functionNames!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("FunctionNames") {
            self.functionNames = dict["FunctionNames"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchDeleteLiveDomainConfigsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchDeleteLiveDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchDeleteLiveDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchDeleteLiveDomainConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchSetLiveDomainConfigsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var functions: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.functions != nil {
            map["Functions"] = self.functions!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainNames") {
            self.domainNames = dict["DomainNames"] as! String
        }
        if dict.keys.contains("Functions") {
            self.functions = dict["Functions"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class BatchSetLiveDomainConfigsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BatchSetLiveDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchSetLiveDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchSetLiveDomainConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelMuteAllGroupUserRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var operatorUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OperatorUserId") {
            self.operatorUserId = dict["OperatorUserId"] as! String
        }
    }
}

public class CancelMuteAllGroupUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: CancelMuteAllGroupUserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CancelMuteAllGroupUserResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CancelMuteAllGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelMuteAllGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelMuteAllGroupUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseLiveShiftRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class CloseLiveShiftResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CloseLiveShiftResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseLiveShiftResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloseLiveShiftResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyCasterRequest : Tea.TeaModel {
    public var casterName: String?

    public var clientToken: String?

    public var ownerId: Int64?

    public var srcCasterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.srcCasterId != nil {
            map["SrcCasterId"] = self.srcCasterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterName") {
            self.casterName = dict["CasterName"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SrcCasterId") {
            self.srcCasterId = dict["SrcCasterId"] as! String
        }
    }
}

public class CopyCasterResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CopyCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyCasterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyCasterSceneConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var fromSceneId: String?

    public var ownerId: Int64?

    public var toSceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.fromSceneId != nil {
            map["FromSceneId"] = self.fromSceneId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.toSceneId != nil {
            map["ToSceneId"] = self.toSceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("FromSceneId") {
            self.fromSceneId = dict["FromSceneId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ToSceneId") {
            self.toSceneId = dict["ToSceneId"] as! String
        }
    }
}

public class CopyCasterSceneConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CopyCasterSceneConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyCasterSceneConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyCasterSceneConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCasterRequest : Tea.TeaModel {
    public var casterName: String?

    public var casterTemplate: String?

    public var chargeType: String?

    public var clientToken: String?

    public var expireTime: String?

    public var normType: Int32?

    public var ownerId: Int64?

    public var purchaseTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.casterTemplate != nil {
            map["CasterTemplate"] = self.casterTemplate!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.normType != nil {
            map["NormType"] = self.normType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.purchaseTime != nil {
            map["PurchaseTime"] = self.purchaseTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterName") {
            self.casterName = dict["CasterName"] as! String
        }
        if dict.keys.contains("CasterTemplate") {
            self.casterTemplate = dict["CasterTemplate"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ExpireTime") {
            self.expireTime = dict["ExpireTime"] as! String
        }
        if dict.keys.contains("NormType") {
            self.normType = dict["NormType"] as! Int32
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PurchaseTime") {
            self.purchaseTime = dict["PurchaseTime"] as! String
        }
    }
}

public class CreateCasterResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCasterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomTemplateRequest : Tea.TeaModel {
    public var customTemplate: String?

    public var ownerId: Int64?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") {
            self.customTemplate = dict["CustomTemplate"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
    }
}

public class CreateCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveRealTimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Logstore") {
            self.logstore = dict["Logstore"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Project") {
            self.project = dict["Project"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class CreateLiveRealTimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLiveRealTimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveRealTimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveRealTimeLogDeliveryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveStreamMonitorRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var inputList: String?

    public var monitorName: String?

    public var outputTemplate: String?

    public var ownerId: Int64?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.inputList != nil {
            map["InputList"] = self.inputList!
        }
        if self.monitorName != nil {
            map["MonitorName"] = self.monitorName!
        }
        if self.outputTemplate != nil {
            map["OutputTemplate"] = self.outputTemplate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("InputList") {
            self.inputList = dict["InputList"] as! String
        }
        if dict.keys.contains("MonitorName") {
            self.monitorName = dict["MonitorName"] as! String
        }
        if dict.keys.contains("OutputTemplate") {
            self.outputTemplate = dict["OutputTemplate"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Stream") {
            self.stream = dict["Stream"] as! String
        }
    }
}

public class CreateLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var monitorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorId") {
            self.monitorId = dict["MonitorId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveStreamMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveStreamRecordIndexFilesRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssEndpoint") {
            self.ossEndpoint = dict["OssEndpoint"] as! String
        }
        if dict.keys.contains("OssObject") {
            self.ossObject = dict["OssObject"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class CreateLiveStreamRecordIndexFilesResponseBody : Tea.TeaModel {
    public class RecordInfo : Tea.TeaModel {
        public var appName: String?

        public var createTime: String?

        public var domainName: String?

        public var duration: Double?

        public var endTime: String?

        public var height: Int32?

        public var ossBucket: String?

        public var ossEndpoint: String?

        public var ossObject: String?

        public var recordId: String?

        public var recordUrl: String?

        public var startTime: String?

        public var streamName: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.ossObject != nil {
                map["OssObject"] = self.ossObject!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordUrl != nil {
                map["RecordUrl"] = self.recordUrl!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("OssBucket") {
                self.ossBucket = dict["OssBucket"] as! String
            }
            if dict.keys.contains("OssEndpoint") {
                self.ossEndpoint = dict["OssEndpoint"] as! String
            }
            if dict.keys.contains("OssObject") {
                self.ossObject = dict["OssObject"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RecordUrl") {
                self.recordUrl = dict["RecordUrl"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var recordInfo: CreateLiveStreamRecordIndexFilesResponseBody.RecordInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordInfo != nil {
            map["RecordInfo"] = self.recordInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordInfo") {
            var model = CreateLiveStreamRecordIndexFilesResponseBody.RecordInfo()
            model.fromMap(dict["RecordInfo"] as! [String: Any])
            self.recordInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLiveStreamRecordIndexFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveStreamRecordIndexFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveStreamRecordIndexFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLiveTranscodeTemplateRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var securityToken: String?

    public var templateConfig: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.templateConfig != nil {
            map["TemplateConfig"] = self.templateConfig!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TemplateConfig") {
            self.templateConfig = dict["TemplateConfig"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class CreateLiveTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLiveTranscodeTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMessageAppRequest : Tea.TeaModel {
    public var appConfig: [String: String]?

    public var appName: String?

    public var extension_: [String: String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appConfig != nil {
            map["AppConfig"] = self.appConfig!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppConfig") {
            self.appConfig = dict["AppConfig"] as! [String: String]
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Extension") {
            self.extension_ = dict["Extension"] as! [String: String]
        }
    }
}

public class CreateMessageAppShrinkRequest : Tea.TeaModel {
    public var appConfigShrink: String?

    public var appName: String?

    public var extensionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appConfigShrink != nil {
            map["AppConfig"] = self.appConfigShrink!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extensionShrink != nil {
            map["Extension"] = self.extensionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppConfig") {
            self.appConfigShrink = dict["AppConfig"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Extension") {
            self.extensionShrink = dict["Extension"] as! String
        }
    }
}

public class CreateMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var appId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateMessageAppResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMessageAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var creatorId: String?

    public var extension_: [String: String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CreatorId") {
            self.creatorId = dict["CreatorId"] as! String
        }
        if dict.keys.contains("Extension") {
            self.extension_ = dict["Extension"] as! [String: String]
        }
    }
}

public class CreateMessageGroupShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var creatorId: String?

    public var extensionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.extensionShrink != nil {
            map["Extension"] = self.extensionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CreatorId") {
            self.creatorId = dict["CreatorId"] as! String
        }
        if dict.keys.contains("Extension") {
            self.extensionShrink = dict["Extension"] as! String
        }
    }
}

public class CreateMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var extension_: [String: Any]?

        public var groupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! [String: Any]
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateMessageGroupResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMessageGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateMixStreamRequest : Tea.TeaModel {
    public var callbackConfig: String?

    public var domainName: String?

    public var inputStreamList: String?

    public var layoutId: String?

    public var outputConfig: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackConfig != nil {
            map["CallbackConfig"] = self.callbackConfig!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.inputStreamList != nil {
            map["InputStreamList"] = self.inputStreamList!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackConfig") {
            self.callbackConfig = dict["CallbackConfig"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("InputStreamList") {
            self.inputStreamList = dict["InputStreamList"] as! String
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("OutputConfig") {
            self.outputConfig = dict["OutputConfig"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class CreateMixStreamResponseBody : Tea.TeaModel {
    public var mixStreamId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MixStreamId") {
            self.mixStreamId = dict["MixStreamId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateMixStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMixStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateMixStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCasterRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteCasterResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCasterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCasterComponentRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteCasterComponentResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var componentId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCasterComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCasterComponentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCasterEpisodeRequest : Tea.TeaModel {
    public var casterId: String?

    public var episodeId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("EpisodeId") {
            self.episodeId = dict["EpisodeId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteCasterEpisodeResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var episodeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("EpisodeId") {
            self.episodeId = dict["EpisodeId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCasterEpisodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterEpisodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCasterEpisodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCasterEpisodeGroupRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
    }
}

public class DeleteCasterEpisodeGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCasterEpisodeGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterEpisodeGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCasterEpisodeGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCasterLayoutRequest : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteCasterLayoutResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCasterLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCasterLayoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCasterProgramRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteCasterProgramResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCasterProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCasterProgramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCasterSceneConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var sceneId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DeleteCasterSceneConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCasterSceneConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterSceneConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCasterSceneConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCasterVideoResourceRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class DeleteCasterVideoResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCasterVideoResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterVideoResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCasterVideoResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomTemplateRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
    }
}

public class DeleteCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveAppRecordConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DeleteLiveAppRecordConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveAppRecordConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAppRecordConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveAppRecordConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveAppSnapshotConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteLiveAppSnapshotConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveAppSnapshotConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAppSnapshotConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveAppSnapshotConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveAudioAuditConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DeleteLiveAudioAuditConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveAudioAuditConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAudioAuditConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveAudioAuditConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveAudioAuditNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteLiveAudioAuditNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveAudioAuditNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAudioAuditNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveAudioAuditNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveDetectNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteLiveDetectNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveDetectNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveDetectNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveDetectNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteLiveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveDomainMappingRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var pullDomain: String?

    public var pushDomain: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pullDomain != nil {
            map["PullDomain"] = self.pullDomain!
        }
        if self.pushDomain != nil {
            map["PushDomain"] = self.pushDomain!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PullDomain") {
            self.pullDomain = dict["PullDomain"] as! String
        }
        if dict.keys.contains("PushDomain") {
            self.pushDomain = dict["PushDomain"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteLiveDomainMappingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveDomainMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveDomainMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveDomainMappingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveDomainPlayMappingRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var playDomain: String?

    public var pullDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.playDomain != nil {
            map["PlayDomain"] = self.playDomain!
        }
        if self.pullDomain != nil {
            map["PullDomain"] = self.pullDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PlayDomain") {
            self.playDomain = dict["PlayDomain"] as! String
        }
        if dict.keys.contains("PullDomain") {
            self.pullDomain = dict["PullDomain"] as! String
        }
    }
}

public class DeleteLiveDomainPlayMappingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveDomainPlayMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveDomainPlayMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveDomainPlayMappingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveEdgeTransferRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteLiveEdgeTransferResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveEdgeTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveEdgeTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveEdgeTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveLazyPullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteLiveLazyPullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveLazyPullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveLazyPullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveLazyPullStreamInfoConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLivePullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DeleteLivePullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLivePullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLivePullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLivePullStreamInfoConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRealTimeLogLogstoreRequest : Tea.TeaModel {
    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logstore") {
            self.logstore = dict["Logstore"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Project") {
            self.project = dict["Project"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class DeleteLiveRealTimeLogLogstoreResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRealTimeLogLogstoreResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRealTimeLogLogstoreResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRealTimeLogLogstoreResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Logstore") {
            self.logstore = dict["Logstore"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Project") {
            self.project = dict["Project"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class DeleteLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteLiveRecordNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRecordNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveRecordVodConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DeleteLiveRecordVodConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveRecordVodConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordVodConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveRecordVodConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotDetectPornConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteLiveSnapshotDetectPornConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotDetectPornConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotDetectPornConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveSnapshotDetectPornConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteLiveSnapshotNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSnapshotNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveSnapshotNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveSpecificStagingConfigRequest : Tea.TeaModel {
    public var configId: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigId") {
            self.configId = dict["ConfigId"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DeleteLiveSpecificStagingConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveSpecificStagingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSpecificStagingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveSpecificStagingConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveStreamMonitorRequest : Tea.TeaModel {
    public var monitorId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorId") {
            self.monitorId = dict["MonitorId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveStreamMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveStreamRecordIndexFilesRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var recordId: [String]?

    public var removeFile: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.removeFile != nil {
            map["RemoveFile"] = self.removeFile!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! [String]
        }
        if dict.keys.contains("RemoveFile") {
            self.removeFile = dict["RemoveFile"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DeleteLiveStreamRecordIndexFilesResponseBody : Tea.TeaModel {
    public class RecordDeleteInfoList : Tea.TeaModel {
        public class RecordDeleteInfo : Tea.TeaModel {
            public var message: String?

            public var recordId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("RecordId") {
                    self.recordId = dict["RecordId"] as! String
                }
            }
        }
        public var recordDeleteInfo: [DeleteLiveStreamRecordIndexFilesResponseBody.RecordDeleteInfoList.RecordDeleteInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordDeleteInfo != nil {
                var tmp : [Any] = []
                for k in self.recordDeleteInfo! {
                    tmp.append(k.toMap())
                }
                map["RecordDeleteInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordDeleteInfo") {
                self.recordDeleteInfo = dict["RecordDeleteInfo"] as! [DeleteLiveStreamRecordIndexFilesResponseBody.RecordDeleteInfoList.RecordDeleteInfo]
            }
        }
    }
    public var code: String?

    public var message: String?

    public var recordDeleteInfoList: DeleteLiveStreamRecordIndexFilesResponseBody.RecordDeleteInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordDeleteInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.recordDeleteInfoList != nil {
            map["RecordDeleteInfoList"] = self.recordDeleteInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RecordDeleteInfoList") {
            var model = DeleteLiveStreamRecordIndexFilesResponseBody.RecordDeleteInfoList()
            model.fromMap(dict["RecordDeleteInfoList"] as! [String: Any])
            self.recordDeleteInfoList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveStreamRecordIndexFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamRecordIndexFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveStreamRecordIndexFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
    }
}

public class DeleteLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveStreamTranscodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveStreamWatermarkRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteLiveStreamWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveStreamWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveStreamWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveStreamWatermarkRuleRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var ruleId: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("Stream") {
            self.stream = dict["Stream"] as! String
        }
    }
}

public class DeleteLiveStreamWatermarkRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveStreamWatermarkRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamWatermarkRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveStreamWatermarkRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLiveStreamsNotifyUrlConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteLiveStreamsNotifyUrlConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLiveStreamsNotifyUrlConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamsNotifyUrlConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLiveStreamsNotifyUrlConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMessageAppRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DeleteMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: DeleteMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DeleteMessageAppResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DeleteMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMessageAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMixStreamRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var mixStreamId: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("MixStreamId") {
            self.mixStreamId = dict["MixStreamId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DeleteMixStreamResponseBody : Tea.TeaModel {
    public var mixStreamId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MixStreamId") {
            self.mixStreamId = dict["MixStreamId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMixStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMixStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMixStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMultiRateConfigRequest : Tea.TeaModel {
    public var app: String?

    public var deleteAll: String?

    public var domainName: String?

    public var groupId: String?

    public var ownerId: Int64?

    public var templates: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.deleteAll != nil {
            map["DeleteAll"] = self.deleteAll!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.templates != nil {
            map["Templates"] = self.templates!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("DeleteAll") {
            self.deleteAll = dict["DeleteAll"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Templates") {
            self.templates = dict["Templates"] as! String
        }
    }
}

public class DeleteMultiRateConfigResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMultiRateConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMultiRateConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMultiRateConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePlaylistRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
    }
}

public class DeletePlaylistResponseBody : Tea.TeaModel {
    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePlaylistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePlaylistItemsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public var programItemIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.programItemIds != nil {
            map["ProgramItemIds"] = self.programItemIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("ProgramItemIds") {
            self.programItemIds = dict["ProgramItemIds"] as! String
        }
    }
}

public class DeletePlaylistItemsResponseBody : Tea.TeaModel {
    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePlaylistItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePlaylistItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePlaylistItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRoomRequest : Tea.TeaModel {
    public var appId: String?

    public var ownerId: Int64?

    public var roomId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
    }
}

public class DeleteRoomResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteRoomResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRoomResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRoomResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnapshotCallbackAuthRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteSnapshotCallbackAuthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSnapshotCallbackAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotCallbackAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnapshotCallbackAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnapshotFilesRequest : Tea.TeaModel {
    public var appName: String?

    public var createTimestampList: [Int64]?

    public var domainName: String?

    public var ownerId: Int64?

    public var removeFile: Bool?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.createTimestampList != nil {
            map["CreateTimestampList"] = self.createTimestampList!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.removeFile != nil {
            map["RemoveFile"] = self.removeFile!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("CreateTimestampList") {
            self.createTimestampList = dict["CreateTimestampList"] as! [Int64]
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RemoveFile") {
            self.removeFile = dict["RemoveFile"] as! Bool
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DeleteSnapshotFilesResponseBody : Tea.TeaModel {
    public class SnapshotDeleteInfoList : Tea.TeaModel {
        public class SnapshotDeleteInfo : Tea.TeaModel {
            public var createTimestamp: Int64?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
            }
        }
        public var snapshotDeleteInfo: [DeleteSnapshotFilesResponseBody.SnapshotDeleteInfoList.SnapshotDeleteInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotDeleteInfo != nil {
                var tmp : [Any] = []
                for k in self.snapshotDeleteInfo! {
                    tmp.append(k.toMap())
                }
                map["SnapshotDeleteInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnapshotDeleteInfo") {
                self.snapshotDeleteInfo = dict["SnapshotDeleteInfo"] as! [DeleteSnapshotFilesResponseBody.SnapshotDeleteInfoList.SnapshotDeleteInfo]
            }
        }
    }
    public var failureCount: Int32?

    public var requestId: String?

    public var snapshotDeleteInfoList: DeleteSnapshotFilesResponseBody.SnapshotDeleteInfoList?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotDeleteInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failureCount != nil {
            map["FailureCount"] = self.failureCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotDeleteInfoList != nil {
            map["SnapshotDeleteInfoList"] = self.snapshotDeleteInfoList?.toMap()
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailureCount") {
            self.failureCount = dict["FailureCount"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotDeleteInfoList") {
            var model = DeleteSnapshotFilesResponseBody.SnapshotDeleteInfoList()
            model.fromMap(dict["SnapshotDeleteInfoList"] as! [String: Any])
            self.snapshotDeleteInfoList = model
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
    }
}

public class DeleteSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnapshotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStudioLayoutRequest : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DeleteStudioLayoutResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteStudioLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStudioLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteStudioLayoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoShowListTasksRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeAutoShowListTasksResponseBody : Tea.TeaModel {
    public var autoShowListTasks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoShowListTasks != nil {
            map["AutoShowListTasks"] = self.autoShowListTasks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoShowListTasks") {
            self.autoShowListTasks = dict["AutoShowListTasks"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAutoShowListTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoShowListTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAutoShowListTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterChannelsRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeCasterChannelsResponseBody : Tea.TeaModel {
    public class Channels : Tea.TeaModel {
        public class Channel : Tea.TeaModel {
            public var channelId: String?

            public var faceBeauty: String?

            public var resourceId: String?

            public var rtmpUrl: String?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.faceBeauty != nil {
                    map["FaceBeauty"] = self.faceBeauty!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.rtmpUrl != nil {
                    map["RtmpUrl"] = self.rtmpUrl!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelId") {
                    self.channelId = dict["ChannelId"] as! String
                }
                if dict.keys.contains("FaceBeauty") {
                    self.faceBeauty = dict["FaceBeauty"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("RtmpUrl") {
                    self.rtmpUrl = dict["RtmpUrl"] as! String
                }
                if dict.keys.contains("StreamUrl") {
                    self.streamUrl = dict["StreamUrl"] as! String
                }
            }
        }
        public var channel: [DescribeCasterChannelsResponseBody.Channels.Channel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channel != nil {
                var tmp : [Any] = []
                for k in self.channel! {
                    tmp.append(k.toMap())
                }
                map["Channel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Channel") {
                self.channel = dict["Channel"] as! [DescribeCasterChannelsResponseBody.Channels.Channel]
            }
        }
    }
    public var channels: DescribeCasterChannelsResponseBody.Channels?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.channels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channels != nil {
            map["Channels"] = self.channels?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Channels") {
            var model = DescribeCasterChannelsResponseBody.Channels()
            model.fromMap(dict["Channels"] as! [String: Any])
            self.channels = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeCasterChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterChannelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterComponentsRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeCasterComponentsResponseBody : Tea.TeaModel {
    public class Components : Tea.TeaModel {
        public class Component : Tea.TeaModel {
            public class CaptionLayerContent : Tea.TeaModel {
                public var borderColor: String?

                public var borderWidthNormalized: Double?

                public var color: String?

                public var fontName: String?

                public var lineSpaceNormalized: Double?

                public var locationId: String?

                public var ptsOffset: Int32?

                public var showSourceLan: Bool?

                public var sizeNormalized: Double?

                public var sourceLan: String?

                public var targetLan: String?

                public var wordCountPerLine: Int32?

                public var wordSpaceNormalized: Double?

                public var wordsCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.borderColor != nil {
                        map["BorderColor"] = self.borderColor!
                    }
                    if self.borderWidthNormalized != nil {
                        map["BorderWidthNormalized"] = self.borderWidthNormalized!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.fontName != nil {
                        map["FontName"] = self.fontName!
                    }
                    if self.lineSpaceNormalized != nil {
                        map["LineSpaceNormalized"] = self.lineSpaceNormalized!
                    }
                    if self.locationId != nil {
                        map["LocationId"] = self.locationId!
                    }
                    if self.ptsOffset != nil {
                        map["PtsOffset"] = self.ptsOffset!
                    }
                    if self.showSourceLan != nil {
                        map["ShowSourceLan"] = self.showSourceLan!
                    }
                    if self.sizeNormalized != nil {
                        map["SizeNormalized"] = self.sizeNormalized!
                    }
                    if self.sourceLan != nil {
                        map["SourceLan"] = self.sourceLan!
                    }
                    if self.targetLan != nil {
                        map["TargetLan"] = self.targetLan!
                    }
                    if self.wordCountPerLine != nil {
                        map["WordCountPerLine"] = self.wordCountPerLine!
                    }
                    if self.wordSpaceNormalized != nil {
                        map["WordSpaceNormalized"] = self.wordSpaceNormalized!
                    }
                    if self.wordsCount != nil {
                        map["WordsCount"] = self.wordsCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BorderColor") {
                        self.borderColor = dict["BorderColor"] as! String
                    }
                    if dict.keys.contains("BorderWidthNormalized") {
                        self.borderWidthNormalized = dict["BorderWidthNormalized"] as! Double
                    }
                    if dict.keys.contains("Color") {
                        self.color = dict["Color"] as! String
                    }
                    if dict.keys.contains("FontName") {
                        self.fontName = dict["FontName"] as! String
                    }
                    if dict.keys.contains("LineSpaceNormalized") {
                        self.lineSpaceNormalized = dict["LineSpaceNormalized"] as! Double
                    }
                    if dict.keys.contains("LocationId") {
                        self.locationId = dict["LocationId"] as! String
                    }
                    if dict.keys.contains("PtsOffset") {
                        self.ptsOffset = dict["PtsOffset"] as! Int32
                    }
                    if dict.keys.contains("ShowSourceLan") {
                        self.showSourceLan = dict["ShowSourceLan"] as! Bool
                    }
                    if dict.keys.contains("SizeNormalized") {
                        self.sizeNormalized = dict["SizeNormalized"] as! Double
                    }
                    if dict.keys.contains("SourceLan") {
                        self.sourceLan = dict["SourceLan"] as! String
                    }
                    if dict.keys.contains("TargetLan") {
                        self.targetLan = dict["TargetLan"] as! String
                    }
                    if dict.keys.contains("WordCountPerLine") {
                        self.wordCountPerLine = dict["WordCountPerLine"] as! Int32
                    }
                    if dict.keys.contains("WordSpaceNormalized") {
                        self.wordSpaceNormalized = dict["WordSpaceNormalized"] as! Double
                    }
                    if dict.keys.contains("WordsCount") {
                        self.wordsCount = dict["WordsCount"] as! Int32
                    }
                }
            }
            public class ComponentLayer : Tea.TeaModel {
                public class PositionNormalizeds : Tea.TeaModel {
                    public var position: [Double]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.position != nil {
                            map["Position"] = self.position!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Position") {
                            self.position = dict["Position"] as! [Double]
                        }
                    }
                }
                public var heightNormalized: Double?

                public var positionNormalizeds: DescribeCasterComponentsResponseBody.Components.Component.ComponentLayer.PositionNormalizeds?

                public var positionRefer: String?

                public var transparency: Int32?

                public var widthNormalized: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.positionNormalizeds?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.heightNormalized != nil {
                        map["HeightNormalized"] = self.heightNormalized!
                    }
                    if self.positionNormalizeds != nil {
                        map["PositionNormalizeds"] = self.positionNormalizeds?.toMap()
                    }
                    if self.positionRefer != nil {
                        map["PositionRefer"] = self.positionRefer!
                    }
                    if self.transparency != nil {
                        map["Transparency"] = self.transparency!
                    }
                    if self.widthNormalized != nil {
                        map["WidthNormalized"] = self.widthNormalized!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HeightNormalized") {
                        self.heightNormalized = dict["HeightNormalized"] as! Double
                    }
                    if dict.keys.contains("PositionNormalizeds") {
                        var model = DescribeCasterComponentsResponseBody.Components.Component.ComponentLayer.PositionNormalizeds()
                        model.fromMap(dict["PositionNormalizeds"] as! [String: Any])
                        self.positionNormalizeds = model
                    }
                    if dict.keys.contains("PositionRefer") {
                        self.positionRefer = dict["PositionRefer"] as! String
                    }
                    if dict.keys.contains("Transparency") {
                        self.transparency = dict["Transparency"] as! Int32
                    }
                    if dict.keys.contains("WidthNormalized") {
                        self.widthNormalized = dict["WidthNormalized"] as! Double
                    }
                }
            }
            public class ImageLayerContent : Tea.TeaModel {
                public var materialId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.materialId != nil {
                        map["MaterialId"] = self.materialId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaterialId") {
                        self.materialId = dict["MaterialId"] as! String
                    }
                }
            }
            public class TextLayerContent : Tea.TeaModel {
                public var borderColor: String?

                public var borderWidthNormalized: Double?

                public var color: String?

                public var fontName: String?

                public var sizeNormalized: Double?

                public var text: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.borderColor != nil {
                        map["BorderColor"] = self.borderColor!
                    }
                    if self.borderWidthNormalized != nil {
                        map["BorderWidthNormalized"] = self.borderWidthNormalized!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.fontName != nil {
                        map["FontName"] = self.fontName!
                    }
                    if self.sizeNormalized != nil {
                        map["SizeNormalized"] = self.sizeNormalized!
                    }
                    if self.text != nil {
                        map["Text"] = self.text!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BorderColor") {
                        self.borderColor = dict["BorderColor"] as! String
                    }
                    if dict.keys.contains("BorderWidthNormalized") {
                        self.borderWidthNormalized = dict["BorderWidthNormalized"] as! Double
                    }
                    if dict.keys.contains("Color") {
                        self.color = dict["Color"] as! String
                    }
                    if dict.keys.contains("FontName") {
                        self.fontName = dict["FontName"] as! String
                    }
                    if dict.keys.contains("SizeNormalized") {
                        self.sizeNormalized = dict["SizeNormalized"] as! Double
                    }
                    if dict.keys.contains("Text") {
                        self.text = dict["Text"] as! String
                    }
                }
            }
            public var captionLayerContent: DescribeCasterComponentsResponseBody.Components.Component.CaptionLayerContent?

            public var componentId: String?

            public var componentLayer: DescribeCasterComponentsResponseBody.Components.Component.ComponentLayer?

            public var componentName: String?

            public var componentType: String?

            public var effect: String?

            public var imageLayerContent: DescribeCasterComponentsResponseBody.Components.Component.ImageLayerContent?

            public var locationId: String?

            public var textLayerContent: DescribeCasterComponentsResponseBody.Components.Component.TextLayerContent?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.captionLayerContent?.validate()
                try self.componentLayer?.validate()
                try self.imageLayerContent?.validate()
                try self.textLayerContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.captionLayerContent != nil {
                    map["CaptionLayerContent"] = self.captionLayerContent?.toMap()
                }
                if self.componentId != nil {
                    map["ComponentId"] = self.componentId!
                }
                if self.componentLayer != nil {
                    map["ComponentLayer"] = self.componentLayer?.toMap()
                }
                if self.componentName != nil {
                    map["ComponentName"] = self.componentName!
                }
                if self.componentType != nil {
                    map["ComponentType"] = self.componentType!
                }
                if self.effect != nil {
                    map["Effect"] = self.effect!
                }
                if self.imageLayerContent != nil {
                    map["ImageLayerContent"] = self.imageLayerContent?.toMap()
                }
                if self.locationId != nil {
                    map["LocationId"] = self.locationId!
                }
                if self.textLayerContent != nil {
                    map["TextLayerContent"] = self.textLayerContent?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CaptionLayerContent") {
                    var model = DescribeCasterComponentsResponseBody.Components.Component.CaptionLayerContent()
                    model.fromMap(dict["CaptionLayerContent"] as! [String: Any])
                    self.captionLayerContent = model
                }
                if dict.keys.contains("ComponentId") {
                    self.componentId = dict["ComponentId"] as! String
                }
                if dict.keys.contains("ComponentLayer") {
                    var model = DescribeCasterComponentsResponseBody.Components.Component.ComponentLayer()
                    model.fromMap(dict["ComponentLayer"] as! [String: Any])
                    self.componentLayer = model
                }
                if dict.keys.contains("ComponentName") {
                    self.componentName = dict["ComponentName"] as! String
                }
                if dict.keys.contains("ComponentType") {
                    self.componentType = dict["ComponentType"] as! String
                }
                if dict.keys.contains("Effect") {
                    self.effect = dict["Effect"] as! String
                }
                if dict.keys.contains("ImageLayerContent") {
                    var model = DescribeCasterComponentsResponseBody.Components.Component.ImageLayerContent()
                    model.fromMap(dict["ImageLayerContent"] as! [String: Any])
                    self.imageLayerContent = model
                }
                if dict.keys.contains("LocationId") {
                    self.locationId = dict["LocationId"] as! String
                }
                if dict.keys.contains("TextLayerContent") {
                    var model = DescribeCasterComponentsResponseBody.Components.Component.TextLayerContent()
                    model.fromMap(dict["TextLayerContent"] as! [String: Any])
                    self.textLayerContent = model
                }
            }
        }
        public var component: [DescribeCasterComponentsResponseBody.Components.Component]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.component != nil {
                var tmp : [Any] = []
                for k in self.component! {
                    tmp.append(k.toMap())
                }
                map["Component"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Component") {
                self.component = dict["Component"] as! [DescribeCasterComponentsResponseBody.Components.Component]
            }
        }
    }
    public var components: DescribeCasterComponentsResponseBody.Components?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.components?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.components != nil {
            map["Components"] = self.components?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Components") {
            var model = DescribeCasterComponentsResponseBody.Components()
            model.fromMap(dict["Components"] as! [String: Any])
            self.components = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeCasterComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterComponentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeCasterConfigResponseBody : Tea.TeaModel {
    public class RecordConfig : Tea.TeaModel {
        public class RecordFormat : Tea.TeaModel {
            public class RecordFormat : Tea.TeaModel {
                public var cycleDuration: Int32?

                public var format: String?

                public var ossObjectPrefix: String?

                public var sliceOssObjectPrefix: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleDuration != nil {
                        map["CycleDuration"] = self.cycleDuration!
                    }
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    if self.ossObjectPrefix != nil {
                        map["OssObjectPrefix"] = self.ossObjectPrefix!
                    }
                    if self.sliceOssObjectPrefix != nil {
                        map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CycleDuration") {
                        self.cycleDuration = dict["CycleDuration"] as! Int32
                    }
                    if dict.keys.contains("Format") {
                        self.format = dict["Format"] as! String
                    }
                    if dict.keys.contains("OssObjectPrefix") {
                        self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                    }
                    if dict.keys.contains("SliceOssObjectPrefix") {
                        self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                    }
                }
            }
            public var recordFormat: [DescribeCasterConfigResponseBody.RecordConfig.RecordFormat.RecordFormat]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.recordFormat != nil {
                    var tmp : [Any] = []
                    for k in self.recordFormat! {
                        tmp.append(k.toMap())
                    }
                    map["RecordFormat"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RecordFormat") {
                    self.recordFormat = dict["RecordFormat"] as! [DescribeCasterConfigResponseBody.RecordConfig.RecordFormat.RecordFormat]
                }
            }
        }
        public var ossBucket: String?

        public var ossEndpoint: String?

        public var recordFormat: DescribeCasterConfigResponseBody.RecordConfig.RecordFormat?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordFormat?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.recordFormat != nil {
                map["RecordFormat"] = self.recordFormat?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OssBucket") {
                self.ossBucket = dict["OssBucket"] as! String
            }
            if dict.keys.contains("OssEndpoint") {
                self.ossEndpoint = dict["OssEndpoint"] as! String
            }
            if dict.keys.contains("RecordFormat") {
                var model = DescribeCasterConfigResponseBody.RecordConfig.RecordFormat()
                model.fromMap(dict["RecordFormat"] as! [String: Any])
                self.recordFormat = model
            }
        }
    }
    public class SyncGroupsConfig : Tea.TeaModel {
        public class SyncGroup : Tea.TeaModel {
            public class ResourceIds : Tea.TeaModel {
                public var resourceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceId != nil {
                        map["ResourceId"] = self.resourceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceId") {
                        self.resourceId = dict["ResourceId"] as! [String]
                    }
                }
            }
            public var hostResourceId: String?

            public var mode: Int32?

            public var resourceIds: DescribeCasterConfigResponseBody.SyncGroupsConfig.SyncGroup.ResourceIds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.resourceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostResourceId != nil {
                    map["HostResourceId"] = self.hostResourceId!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.resourceIds != nil {
                    map["ResourceIds"] = self.resourceIds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HostResourceId") {
                    self.hostResourceId = dict["HostResourceId"] as! String
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! Int32
                }
                if dict.keys.contains("ResourceIds") {
                    var model = DescribeCasterConfigResponseBody.SyncGroupsConfig.SyncGroup.ResourceIds()
                    model.fromMap(dict["ResourceIds"] as! [String: Any])
                    self.resourceIds = model
                }
            }
        }
        public var syncGroup: [DescribeCasterConfigResponseBody.SyncGroupsConfig.SyncGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.syncGroup != nil {
                var tmp : [Any] = []
                for k in self.syncGroup! {
                    tmp.append(k.toMap())
                }
                map["SyncGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SyncGroup") {
                self.syncGroup = dict["SyncGroup"] as! [DescribeCasterConfigResponseBody.SyncGroupsConfig.SyncGroup]
            }
        }
    }
    public class TranscodeConfig : Tea.TeaModel {
        public class LiveTemplateIds : Tea.TeaModel {
            public var locationId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.locationId != nil {
                    map["LocationId"] = self.locationId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocationId") {
                    self.locationId = dict["LocationId"] as! [String]
                }
            }
        }
        public var casterTemplate: String?

        public var liveTemplateIds: DescribeCasterConfigResponseBody.TranscodeConfig.LiveTemplateIds?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.liveTemplateIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.casterTemplate != nil {
                map["CasterTemplate"] = self.casterTemplate!
            }
            if self.liveTemplateIds != nil {
                map["LiveTemplateIds"] = self.liveTemplateIds?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CasterTemplate") {
                self.casterTemplate = dict["CasterTemplate"] as! String
            }
            if dict.keys.contains("LiveTemplateIds") {
                var model = DescribeCasterConfigResponseBody.TranscodeConfig.LiveTemplateIds()
                model.fromMap(dict["LiveTemplateIds"] as! [String: Any])
                self.liveTemplateIds = model
            }
        }
    }
    public var callbackUrl: String?

    public var casterId: String?

    public var casterName: String?

    public var channelEnable: Int32?

    public var delay: Double?

    public var domainName: String?

    public var programEffect: Int32?

    public var programName: String?

    public var recordConfig: DescribeCasterConfigResponseBody.RecordConfig?

    public var requestId: String?

    public var sideOutputUrl: String?

    public var sideOutputUrlList: String?

    public var syncGroupsConfig: DescribeCasterConfigResponseBody.SyncGroupsConfig?

    public var transcodeConfig: DescribeCasterConfigResponseBody.TranscodeConfig?

    public var urgentLiveStreamUrl: String?

    public var urgentMaterialId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordConfig?.validate()
        try self.syncGroupsConfig?.validate()
        try self.transcodeConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.channelEnable != nil {
            map["ChannelEnable"] = self.channelEnable!
        }
        if self.delay != nil {
            map["Delay"] = self.delay!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.programEffect != nil {
            map["ProgramEffect"] = self.programEffect!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.recordConfig != nil {
            map["RecordConfig"] = self.recordConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sideOutputUrl != nil {
            map["SideOutputUrl"] = self.sideOutputUrl!
        }
        if self.sideOutputUrlList != nil {
            map["SideOutputUrlList"] = self.sideOutputUrlList!
        }
        if self.syncGroupsConfig != nil {
            map["SyncGroupsConfig"] = self.syncGroupsConfig?.toMap()
        }
        if self.transcodeConfig != nil {
            map["TranscodeConfig"] = self.transcodeConfig?.toMap()
        }
        if self.urgentLiveStreamUrl != nil {
            map["UrgentLiveStreamUrl"] = self.urgentLiveStreamUrl!
        }
        if self.urgentMaterialId != nil {
            map["UrgentMaterialId"] = self.urgentMaterialId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("CasterName") {
            self.casterName = dict["CasterName"] as! String
        }
        if dict.keys.contains("ChannelEnable") {
            self.channelEnable = dict["ChannelEnable"] as! Int32
        }
        if dict.keys.contains("Delay") {
            self.delay = dict["Delay"] as! Double
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ProgramEffect") {
            self.programEffect = dict["ProgramEffect"] as! Int32
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("RecordConfig") {
            var model = DescribeCasterConfigResponseBody.RecordConfig()
            model.fromMap(dict["RecordConfig"] as! [String: Any])
            self.recordConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SideOutputUrl") {
            self.sideOutputUrl = dict["SideOutputUrl"] as! String
        }
        if dict.keys.contains("SideOutputUrlList") {
            self.sideOutputUrlList = dict["SideOutputUrlList"] as! String
        }
        if dict.keys.contains("SyncGroupsConfig") {
            var model = DescribeCasterConfigResponseBody.SyncGroupsConfig()
            model.fromMap(dict["SyncGroupsConfig"] as! [String: Any])
            self.syncGroupsConfig = model
        }
        if dict.keys.contains("TranscodeConfig") {
            var model = DescribeCasterConfigResponseBody.TranscodeConfig()
            model.fromMap(dict["TranscodeConfig"] as! [String: Any])
            self.transcodeConfig = model
        }
        if dict.keys.contains("UrgentLiveStreamUrl") {
            self.urgentLiveStreamUrl = dict["UrgentLiveStreamUrl"] as! String
        }
        if dict.keys.contains("UrgentMaterialId") {
            self.urgentMaterialId = dict["UrgentMaterialId"] as! String
        }
    }
}

public class DescribeCasterConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterLayoutsRequest : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeCasterLayoutsResponseBody : Tea.TeaModel {
    public class Layouts : Tea.TeaModel {
        public class Layout : Tea.TeaModel {
            public class AudioLayers : Tea.TeaModel {
                public class AudioLayer : Tea.TeaModel {
                    public var fixedDelayDuration: Int32?

                    public var validChannel: String?

                    public var volumeRate: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fixedDelayDuration != nil {
                            map["FixedDelayDuration"] = self.fixedDelayDuration!
                        }
                        if self.validChannel != nil {
                            map["ValidChannel"] = self.validChannel!
                        }
                        if self.volumeRate != nil {
                            map["VolumeRate"] = self.volumeRate!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FixedDelayDuration") {
                            self.fixedDelayDuration = dict["FixedDelayDuration"] as! Int32
                        }
                        if dict.keys.contains("ValidChannel") {
                            self.validChannel = dict["ValidChannel"] as! String
                        }
                        if dict.keys.contains("VolumeRate") {
                            self.volumeRate = dict["VolumeRate"] as! Double
                        }
                    }
                }
                public var audioLayer: [DescribeCasterLayoutsResponseBody.Layouts.Layout.AudioLayers.AudioLayer]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioLayer != nil {
                        var tmp : [Any] = []
                        for k in self.audioLayer! {
                            tmp.append(k.toMap())
                        }
                        map["AudioLayer"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioLayer") {
                        self.audioLayer = dict["AudioLayer"] as! [DescribeCasterLayoutsResponseBody.Layouts.Layout.AudioLayers.AudioLayer]
                    }
                }
            }
            public class BlendList : Tea.TeaModel {
                public var locationId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.locationId != nil {
                        map["LocationId"] = self.locationId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LocationId") {
                        self.locationId = dict["LocationId"] as! [String]
                    }
                }
            }
            public class MixList : Tea.TeaModel {
                public var locationId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.locationId != nil {
                        map["LocationId"] = self.locationId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LocationId") {
                        self.locationId = dict["LocationId"] as! [String]
                    }
                }
            }
            public class VideoLayers : Tea.TeaModel {
                public class VideoLayer : Tea.TeaModel {
                    public class PositionNormalizeds : Tea.TeaModel {
                        public var position: [Double]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.position != nil {
                                map["Position"] = self.position!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Position") {
                                self.position = dict["Position"] as! [Double]
                            }
                        }
                    }
                    public var fillMode: String?

                    public var fixedDelayDuration: Int32?

                    public var heightNormalized: Double?

                    public var positionNormalizeds: DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers.VideoLayer.PositionNormalizeds?

                    public var positionRefer: String?

                    public var widthNormalized: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.positionNormalizeds?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fillMode != nil {
                            map["FillMode"] = self.fillMode!
                        }
                        if self.fixedDelayDuration != nil {
                            map["FixedDelayDuration"] = self.fixedDelayDuration!
                        }
                        if self.heightNormalized != nil {
                            map["HeightNormalized"] = self.heightNormalized!
                        }
                        if self.positionNormalizeds != nil {
                            map["PositionNormalizeds"] = self.positionNormalizeds?.toMap()
                        }
                        if self.positionRefer != nil {
                            map["PositionRefer"] = self.positionRefer!
                        }
                        if self.widthNormalized != nil {
                            map["WidthNormalized"] = self.widthNormalized!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FillMode") {
                            self.fillMode = dict["FillMode"] as! String
                        }
                        if dict.keys.contains("FixedDelayDuration") {
                            self.fixedDelayDuration = dict["FixedDelayDuration"] as! Int32
                        }
                        if dict.keys.contains("HeightNormalized") {
                            self.heightNormalized = dict["HeightNormalized"] as! Double
                        }
                        if dict.keys.contains("PositionNormalizeds") {
                            var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers.VideoLayer.PositionNormalizeds()
                            model.fromMap(dict["PositionNormalizeds"] as! [String: Any])
                            self.positionNormalizeds = model
                        }
                        if dict.keys.contains("PositionRefer") {
                            self.positionRefer = dict["PositionRefer"] as! String
                        }
                        if dict.keys.contains("WidthNormalized") {
                            self.widthNormalized = dict["WidthNormalized"] as! Double
                        }
                    }
                }
                public var videoLayer: [DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers.VideoLayer]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoLayer != nil {
                        var tmp : [Any] = []
                        for k in self.videoLayer! {
                            tmp.append(k.toMap())
                        }
                        map["VideoLayer"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VideoLayer") {
                        self.videoLayer = dict["VideoLayer"] as! [DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers.VideoLayer]
                    }
                }
            }
            public var audioLayers: DescribeCasterLayoutsResponseBody.Layouts.Layout.AudioLayers?

            public var blendList: DescribeCasterLayoutsResponseBody.Layouts.Layout.BlendList?

            public var layoutId: String?

            public var mixList: DescribeCasterLayoutsResponseBody.Layouts.Layout.MixList?

            public var videoLayers: DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioLayers?.validate()
                try self.blendList?.validate()
                try self.mixList?.validate()
                try self.videoLayers?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioLayers != nil {
                    map["AudioLayers"] = self.audioLayers?.toMap()
                }
                if self.blendList != nil {
                    map["BlendList"] = self.blendList?.toMap()
                }
                if self.layoutId != nil {
                    map["LayoutId"] = self.layoutId!
                }
                if self.mixList != nil {
                    map["MixList"] = self.mixList?.toMap()
                }
                if self.videoLayers != nil {
                    map["VideoLayers"] = self.videoLayers?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioLayers") {
                    var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.AudioLayers()
                    model.fromMap(dict["AudioLayers"] as! [String: Any])
                    self.audioLayers = model
                }
                if dict.keys.contains("BlendList") {
                    var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.BlendList()
                    model.fromMap(dict["BlendList"] as! [String: Any])
                    self.blendList = model
                }
                if dict.keys.contains("LayoutId") {
                    self.layoutId = dict["LayoutId"] as! String
                }
                if dict.keys.contains("MixList") {
                    var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.MixList()
                    model.fromMap(dict["MixList"] as! [String: Any])
                    self.mixList = model
                }
                if dict.keys.contains("VideoLayers") {
                    var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers()
                    model.fromMap(dict["VideoLayers"] as! [String: Any])
                    self.videoLayers = model
                }
            }
        }
        public var layout: [DescribeCasterLayoutsResponseBody.Layouts.Layout]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.layout != nil {
                var tmp : [Any] = []
                for k in self.layout! {
                    tmp.append(k.toMap())
                }
                map["Layout"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Layout") {
                self.layout = dict["Layout"] as! [DescribeCasterLayoutsResponseBody.Layouts.Layout]
            }
        }
    }
    public var layouts: DescribeCasterLayoutsResponseBody.Layouts?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.layouts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.layouts != nil {
            map["Layouts"] = self.layouts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Layouts") {
            var model = DescribeCasterLayoutsResponseBody.Layouts()
            model.fromMap(dict["Layouts"] as! [String: Any])
            self.layouts = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeCasterLayoutsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterLayoutsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterLayoutsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterProgramRequest : Tea.TeaModel {
    public var casterId: String?

    public var endTime: String?

    public var episodeId: String?

    public var episodeType: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.episodeType != nil {
            map["EpisodeType"] = self.episodeType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EpisodeId") {
            self.episodeId = dict["EpisodeId"] as! String
        }
        if dict.keys.contains("EpisodeType") {
            self.episodeType = dict["EpisodeType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DescribeCasterProgramResponseBody : Tea.TeaModel {
    public class Episodes : Tea.TeaModel {
        public class Episode : Tea.TeaModel {
            public class ComponentIds : Tea.TeaModel {
                public var componentId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.componentId != nil {
                        map["ComponentId"] = self.componentId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComponentId") {
                        self.componentId = dict["ComponentId"] as! [String]
                    }
                }
            }
            public var componentIds: DescribeCasterProgramResponseBody.Episodes.Episode.ComponentIds?

            public var endTime: String?

            public var episodeId: String?

            public var episodeName: String?

            public var episodeType: String?

            public var resourceId: String?

            public var startTime: String?

            public var status: Int32?

            public var switchType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.componentIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.componentIds != nil {
                    map["ComponentIds"] = self.componentIds?.toMap()
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.episodeId != nil {
                    map["EpisodeId"] = self.episodeId!
                }
                if self.episodeName != nil {
                    map["EpisodeName"] = self.episodeName!
                }
                if self.episodeType != nil {
                    map["EpisodeType"] = self.episodeType!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.switchType != nil {
                    map["SwitchType"] = self.switchType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComponentIds") {
                    var model = DescribeCasterProgramResponseBody.Episodes.Episode.ComponentIds()
                    model.fromMap(dict["ComponentIds"] as! [String: Any])
                    self.componentIds = model
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("EpisodeId") {
                    self.episodeId = dict["EpisodeId"] as! String
                }
                if dict.keys.contains("EpisodeName") {
                    self.episodeName = dict["EpisodeName"] as! String
                }
                if dict.keys.contains("EpisodeType") {
                    self.episodeType = dict["EpisodeType"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("SwitchType") {
                    self.switchType = dict["SwitchType"] as! String
                }
            }
        }
        public var episode: [DescribeCasterProgramResponseBody.Episodes.Episode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.episode != nil {
                var tmp : [Any] = []
                for k in self.episode! {
                    tmp.append(k.toMap())
                }
                map["Episode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Episode") {
                self.episode = dict["Episode"] as! [DescribeCasterProgramResponseBody.Episodes.Episode]
            }
        }
    }
    public var casterId: String?

    public var episodes: DescribeCasterProgramResponseBody.Episodes?

    public var programEffect: Int32?

    public var programName: String?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.episodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episodes != nil {
            map["Episodes"] = self.episodes?.toMap()
        }
        if self.programEffect != nil {
            map["ProgramEffect"] = self.programEffect!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("Episodes") {
            var model = DescribeCasterProgramResponseBody.Episodes()
            model.fromMap(dict["Episodes"] as! [String: Any])
            self.episodes = model
        }
        if dict.keys.contains("ProgramEffect") {
            self.programEffect = dict["ProgramEffect"] as! Int32
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeCasterProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterProgramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterSceneAudioRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
    }
}

public class DescribeCasterSceneAudioResponseBody : Tea.TeaModel {
    public class AudioLayers : Tea.TeaModel {
        public class AudioLayer : Tea.TeaModel {
            public var fixedDelayDuration: Int32?

            public var validChannel: String?

            public var volumeRate: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fixedDelayDuration != nil {
                    map["FixedDelayDuration"] = self.fixedDelayDuration!
                }
                if self.validChannel != nil {
                    map["ValidChannel"] = self.validChannel!
                }
                if self.volumeRate != nil {
                    map["VolumeRate"] = self.volumeRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FixedDelayDuration") {
                    self.fixedDelayDuration = dict["FixedDelayDuration"] as! Int32
                }
                if dict.keys.contains("ValidChannel") {
                    self.validChannel = dict["ValidChannel"] as! String
                }
                if dict.keys.contains("VolumeRate") {
                    self.volumeRate = dict["VolumeRate"] as! Double
                }
            }
        }
        public var audioLayer: [DescribeCasterSceneAudioResponseBody.AudioLayers.AudioLayer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioLayer != nil {
                var tmp : [Any] = []
                for k in self.audioLayer! {
                    tmp.append(k.toMap())
                }
                map["AudioLayer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioLayer") {
                self.audioLayer = dict["AudioLayer"] as! [DescribeCasterSceneAudioResponseBody.AudioLayers.AudioLayer]
            }
        }
    }
    public class MixList : Tea.TeaModel {
        public var locationId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.locationId != nil {
                map["LocationId"] = self.locationId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LocationId") {
                self.locationId = dict["LocationId"] as! [String]
            }
        }
    }
    public var audioLayers: DescribeCasterSceneAudioResponseBody.AudioLayers?

    public var casterId: String?

    public var followEnable: Int32?

    public var mixList: DescribeCasterSceneAudioResponseBody.MixList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.audioLayers?.validate()
        try self.mixList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioLayers != nil {
            map["AudioLayers"] = self.audioLayers?.toMap()
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.followEnable != nil {
            map["FollowEnable"] = self.followEnable!
        }
        if self.mixList != nil {
            map["MixList"] = self.mixList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioLayers") {
            var model = DescribeCasterSceneAudioResponseBody.AudioLayers()
            model.fromMap(dict["AudioLayers"] as! [String: Any])
            self.audioLayers = model
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("FollowEnable") {
            self.followEnable = dict["FollowEnable"] as! Int32
        }
        if dict.keys.contains("MixList") {
            var model = DescribeCasterSceneAudioResponseBody.MixList()
            model.fromMap(dict["MixList"] as! [String: Any])
            self.mixList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCasterSceneAudioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterSceneAudioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterSceneAudioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterScenesRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
    }
}

public class DescribeCasterScenesResponseBody : Tea.TeaModel {
    public class SceneList : Tea.TeaModel {
        public class Scene : Tea.TeaModel {
            public class ComponentIds : Tea.TeaModel {
                public var componentId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.componentId != nil {
                        map["componentId"] = self.componentId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("componentId") {
                        self.componentId = dict["componentId"] as! [String]
                    }
                }
            }
            public class StreamInfos : Tea.TeaModel {
                public class StreamInfo : Tea.TeaModel {
                    public var outputStreamUrl: String?

                    public var transcodeConfig: String?

                    public var videoFormat: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outputStreamUrl != nil {
                            map["OutputStreamUrl"] = self.outputStreamUrl!
                        }
                        if self.transcodeConfig != nil {
                            map["TranscodeConfig"] = self.transcodeConfig!
                        }
                        if self.videoFormat != nil {
                            map["VideoFormat"] = self.videoFormat!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OutputStreamUrl") {
                            self.outputStreamUrl = dict["OutputStreamUrl"] as! String
                        }
                        if dict.keys.contains("TranscodeConfig") {
                            self.transcodeConfig = dict["TranscodeConfig"] as! String
                        }
                        if dict.keys.contains("VideoFormat") {
                            self.videoFormat = dict["VideoFormat"] as! String
                        }
                    }
                }
                public var streamInfo: [DescribeCasterScenesResponseBody.SceneList.Scene.StreamInfos.StreamInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.streamInfo != nil {
                        var tmp : [Any] = []
                        for k in self.streamInfo! {
                            tmp.append(k.toMap())
                        }
                        map["StreamInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StreamInfo") {
                        self.streamInfo = dict["StreamInfo"] as! [DescribeCasterScenesResponseBody.SceneList.Scene.StreamInfos.StreamInfo]
                    }
                }
            }
            public var componentIds: DescribeCasterScenesResponseBody.SceneList.Scene.ComponentIds?

            public var layoutId: String?

            public var outputType: String?

            public var sceneId: String?

            public var sceneName: String?

            public var status: Int32?

            public var streamInfos: DescribeCasterScenesResponseBody.SceneList.Scene.StreamInfos?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.componentIds?.validate()
                try self.streamInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.componentIds != nil {
                    map["ComponentIds"] = self.componentIds?.toMap()
                }
                if self.layoutId != nil {
                    map["LayoutId"] = self.layoutId!
                }
                if self.outputType != nil {
                    map["OutputType"] = self.outputType!
                }
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.sceneName != nil {
                    map["SceneName"] = self.sceneName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.streamInfos != nil {
                    map["StreamInfos"] = self.streamInfos?.toMap()
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComponentIds") {
                    var model = DescribeCasterScenesResponseBody.SceneList.Scene.ComponentIds()
                    model.fromMap(dict["ComponentIds"] as! [String: Any])
                    self.componentIds = model
                }
                if dict.keys.contains("LayoutId") {
                    self.layoutId = dict["LayoutId"] as! String
                }
                if dict.keys.contains("OutputType") {
                    self.outputType = dict["OutputType"] as! String
                }
                if dict.keys.contains("SceneId") {
                    self.sceneId = dict["SceneId"] as! String
                }
                if dict.keys.contains("SceneName") {
                    self.sceneName = dict["SceneName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("StreamInfos") {
                    var model = DescribeCasterScenesResponseBody.SceneList.Scene.StreamInfos()
                    model.fromMap(dict["StreamInfos"] as! [String: Any])
                    self.streamInfos = model
                }
                if dict.keys.contains("StreamUrl") {
                    self.streamUrl = dict["StreamUrl"] as! String
                }
            }
        }
        public var scene: [DescribeCasterScenesResponseBody.SceneList.Scene]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scene != nil {
                var tmp : [Any] = []
                for k in self.scene! {
                    tmp.append(k.toMap())
                }
                map["Scene"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Scene") {
                self.scene = dict["Scene"] as! [DescribeCasterScenesResponseBody.SceneList.Scene]
            }
        }
    }
    public var requestId: String?

    public var sceneList: DescribeCasterScenesResponseBody.SceneList?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sceneList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sceneList != nil {
            map["SceneList"] = self.sceneList?.toMap()
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SceneList") {
            var model = DescribeCasterScenesResponseBody.SceneList()
            model.fromMap(dict["SceneList"] as! [String: Any])
            self.sceneList = model
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeCasterScenesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterScenesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterScenesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterStreamUrlRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeCasterStreamUrlResponseBody : Tea.TeaModel {
    public class CasterStreams : Tea.TeaModel {
        public class CasterStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public class StreamInfo : Tea.TeaModel {
                    public var outputStreamUrl: String?

                    public var transcodeConfig: String?

                    public var videoFormat: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outputStreamUrl != nil {
                            map["OutputStreamUrl"] = self.outputStreamUrl!
                        }
                        if self.transcodeConfig != nil {
                            map["TranscodeConfig"] = self.transcodeConfig!
                        }
                        if self.videoFormat != nil {
                            map["VideoFormat"] = self.videoFormat!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OutputStreamUrl") {
                            self.outputStreamUrl = dict["OutputStreamUrl"] as! String
                        }
                        if dict.keys.contains("TranscodeConfig") {
                            self.transcodeConfig = dict["TranscodeConfig"] as! String
                        }
                        if dict.keys.contains("VideoFormat") {
                            self.videoFormat = dict["VideoFormat"] as! String
                        }
                    }
                }
                public var streamInfo: [DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream.StreamInfos.StreamInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.streamInfo != nil {
                        var tmp : [Any] = []
                        for k in self.streamInfo! {
                            tmp.append(k.toMap())
                        }
                        map["StreamInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StreamInfo") {
                        self.streamInfo = dict["StreamInfo"] as! [DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream.StreamInfos.StreamInfo]
                    }
                }
            }
            public var outputType: Int32?

            public var rtmpUrl: String?

            public var sceneId: String?

            public var streamInfos: DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream.StreamInfos?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.streamInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.outputType != nil {
                    map["OutputType"] = self.outputType!
                }
                if self.rtmpUrl != nil {
                    map["RtmpUrl"] = self.rtmpUrl!
                }
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.streamInfos != nil {
                    map["StreamInfos"] = self.streamInfos?.toMap()
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("OutputType") {
                    self.outputType = dict["OutputType"] as! Int32
                }
                if dict.keys.contains("RtmpUrl") {
                    self.rtmpUrl = dict["RtmpUrl"] as! String
                }
                if dict.keys.contains("SceneId") {
                    self.sceneId = dict["SceneId"] as! String
                }
                if dict.keys.contains("StreamInfos") {
                    var model = DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream.StreamInfos()
                    model.fromMap(dict["StreamInfos"] as! [String: Any])
                    self.streamInfos = model
                }
                if dict.keys.contains("StreamUrl") {
                    self.streamUrl = dict["StreamUrl"] as! String
                }
            }
        }
        public var casterStream: [DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.casterStream != nil {
                var tmp : [Any] = []
                for k in self.casterStream! {
                    tmp.append(k.toMap())
                }
                map["CasterStream"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CasterStream") {
                self.casterStream = dict["CasterStream"] as! [DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream]
            }
        }
    }
    public var casterId: String?

    public var casterStreams: DescribeCasterStreamUrlResponseBody.CasterStreams?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.casterStreams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.casterStreams != nil {
            map["CasterStreams"] = self.casterStreams?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("CasterStreams") {
            var model = DescribeCasterStreamUrlResponseBody.CasterStreams()
            model.fromMap(dict["CasterStreams"] as! [String: Any])
            self.casterStreams = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeCasterStreamUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterStreamUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterStreamUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterSyncGroupRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeCasterSyncGroupResponseBody : Tea.TeaModel {
    public class SyncGroups : Tea.TeaModel {
        public class SyncGroup : Tea.TeaModel {
            public class ResourceIds : Tea.TeaModel {
                public var resourceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceId != nil {
                        map["ResourceId"] = self.resourceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceId") {
                        self.resourceId = dict["ResourceId"] as! [String]
                    }
                }
            }
            public var hostResourceId: String?

            public var mode: Int32?

            public var resourceIds: DescribeCasterSyncGroupResponseBody.SyncGroups.SyncGroup.ResourceIds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.resourceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostResourceId != nil {
                    map["HostResourceId"] = self.hostResourceId!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.resourceIds != nil {
                    map["ResourceIds"] = self.resourceIds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HostResourceId") {
                    self.hostResourceId = dict["HostResourceId"] as! String
                }
                if dict.keys.contains("Mode") {
                    self.mode = dict["Mode"] as! Int32
                }
                if dict.keys.contains("ResourceIds") {
                    var model = DescribeCasterSyncGroupResponseBody.SyncGroups.SyncGroup.ResourceIds()
                    model.fromMap(dict["ResourceIds"] as! [String: Any])
                    self.resourceIds = model
                }
            }
        }
        public var syncGroup: [DescribeCasterSyncGroupResponseBody.SyncGroups.SyncGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.syncGroup != nil {
                var tmp : [Any] = []
                for k in self.syncGroup! {
                    tmp.append(k.toMap())
                }
                map["SyncGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SyncGroup") {
                self.syncGroup = dict["SyncGroup"] as! [DescribeCasterSyncGroupResponseBody.SyncGroups.SyncGroup]
            }
        }
    }
    public var casterId: String?

    public var requestId: String?

    public var syncGroups: DescribeCasterSyncGroupResponseBody.SyncGroups?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.syncGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.syncGroups != nil {
            map["SyncGroups"] = self.syncGroups?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SyncGroups") {
            var model = DescribeCasterSyncGroupResponseBody.SyncGroups()
            model.fromMap(dict["SyncGroups"] as! [String: Any])
            self.syncGroups = model
        }
    }
}

public class DescribeCasterSyncGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterSyncGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterSyncGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCasterVideoResourcesRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeCasterVideoResourcesResponseBody : Tea.TeaModel {
    public class VideoResources : Tea.TeaModel {
        public class VideoResource : Tea.TeaModel {
            public var beginOffset: Int32?

            public var endOffset: Int32?

            public var flvUrl: String?

            public var liveStreamUrl: String?

            public var locationId: String?

            public var materialId: String?

            public var ptsCallbackInterval: Int32?

            public var repeatNum: Int32?

            public var resourceId: String?

            public var resourceName: String?

            public var vodUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginOffset != nil {
                    map["BeginOffset"] = self.beginOffset!
                }
                if self.endOffset != nil {
                    map["EndOffset"] = self.endOffset!
                }
                if self.flvUrl != nil {
                    map["FlvUrl"] = self.flvUrl!
                }
                if self.liveStreamUrl != nil {
                    map["LiveStreamUrl"] = self.liveStreamUrl!
                }
                if self.locationId != nil {
                    map["LocationId"] = self.locationId!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                if self.ptsCallbackInterval != nil {
                    map["PtsCallbackInterval"] = self.ptsCallbackInterval!
                }
                if self.repeatNum != nil {
                    map["RepeatNum"] = self.repeatNum!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.vodUrl != nil {
                    map["VodUrl"] = self.vodUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeginOffset") {
                    self.beginOffset = dict["BeginOffset"] as! Int32
                }
                if dict.keys.contains("EndOffset") {
                    self.endOffset = dict["EndOffset"] as! Int32
                }
                if dict.keys.contains("FlvUrl") {
                    self.flvUrl = dict["FlvUrl"] as! String
                }
                if dict.keys.contains("LiveStreamUrl") {
                    self.liveStreamUrl = dict["LiveStreamUrl"] as! String
                }
                if dict.keys.contains("LocationId") {
                    self.locationId = dict["LocationId"] as! String
                }
                if dict.keys.contains("MaterialId") {
                    self.materialId = dict["MaterialId"] as! String
                }
                if dict.keys.contains("PtsCallbackInterval") {
                    self.ptsCallbackInterval = dict["PtsCallbackInterval"] as! Int32
                }
                if dict.keys.contains("RepeatNum") {
                    self.repeatNum = dict["RepeatNum"] as! Int32
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceName") {
                    self.resourceName = dict["ResourceName"] as! String
                }
                if dict.keys.contains("VodUrl") {
                    self.vodUrl = dict["VodUrl"] as! String
                }
            }
        }
        public var videoResource: [DescribeCasterVideoResourcesResponseBody.VideoResources.VideoResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.videoResource != nil {
                var tmp : [Any] = []
                for k in self.videoResource! {
                    tmp.append(k.toMap())
                }
                map["VideoResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VideoResource") {
                self.videoResource = dict["VideoResource"] as! [DescribeCasterVideoResourcesResponseBody.VideoResources.VideoResource]
            }
        }
    }
    public var requestId: String?

    public var total: Int32?

    public var videoResources: DescribeCasterVideoResourcesResponseBody.VideoResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.videoResources != nil {
            map["VideoResources"] = self.videoResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
        if dict.keys.contains("VideoResources") {
            var model = DescribeCasterVideoResourcesResponseBody.VideoResources()
            model.fromMap(dict["VideoResources"] as! [String: Any])
            self.videoResources = model
        }
    }
}

public class DescribeCasterVideoResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterVideoResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCasterVideoResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCastersRequest : Tea.TeaModel {
    public var casterId: String?

    public var casterName: String?

    public var chargeType: Int32?

    public var endTime: String?

    public var normType: String?

    public var orderByModifyAsc: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.normType != nil {
            map["NormType"] = self.normType!
        }
        if self.orderByModifyAsc != nil {
            map["OrderByModifyAsc"] = self.orderByModifyAsc!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("CasterName") {
            self.casterName = dict["CasterName"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! Int32
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("NormType") {
            self.normType = dict["NormType"] as! String
        }
        if dict.keys.contains("OrderByModifyAsc") {
            self.orderByModifyAsc = dict["OrderByModifyAsc"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DescribeCastersResponseBody : Tea.TeaModel {
    public class CasterList : Tea.TeaModel {
        public class Caster : Tea.TeaModel {
            public var casterId: String?

            public var casterName: String?

            public var casterTemplate: String?

            public var channelEnable: Int32?

            public var chargeType: String?

            public var createTime: String?

            public var duration: String?

            public var expireTime: String?

            public var lastModified: String?

            public var normType: Int32?

            public var purchaseTime: String?

            public var startTime: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.casterId != nil {
                    map["CasterId"] = self.casterId!
                }
                if self.casterName != nil {
                    map["CasterName"] = self.casterName!
                }
                if self.casterTemplate != nil {
                    map["CasterTemplate"] = self.casterTemplate!
                }
                if self.channelEnable != nil {
                    map["ChannelEnable"] = self.channelEnable!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.lastModified != nil {
                    map["LastModified"] = self.lastModified!
                }
                if self.normType != nil {
                    map["NormType"] = self.normType!
                }
                if self.purchaseTime != nil {
                    map["PurchaseTime"] = self.purchaseTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CasterId") {
                    self.casterId = dict["CasterId"] as! String
                }
                if dict.keys.contains("CasterName") {
                    self.casterName = dict["CasterName"] as! String
                }
                if dict.keys.contains("CasterTemplate") {
                    self.casterTemplate = dict["CasterTemplate"] as! String
                }
                if dict.keys.contains("ChannelEnable") {
                    self.channelEnable = dict["ChannelEnable"] as! Int32
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! String
                }
                if dict.keys.contains("LastModified") {
                    self.lastModified = dict["LastModified"] as! String
                }
                if dict.keys.contains("NormType") {
                    self.normType = dict["NormType"] as! Int32
                }
                if dict.keys.contains("PurchaseTime") {
                    self.purchaseTime = dict["PurchaseTime"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var caster: [DescribeCastersResponseBody.CasterList.Caster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caster != nil {
                var tmp : [Any] = []
                for k in self.caster! {
                    tmp.append(k.toMap())
                }
                map["Caster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Caster") {
                self.caster = dict["Caster"] as! [DescribeCastersResponseBody.CasterList.Caster]
            }
        }
    }
    public var casterList: DescribeCastersResponseBody.CasterList?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.casterList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterList != nil {
            map["CasterList"] = self.casterList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterList") {
            var model = DescribeCastersResponseBody.CasterList()
            model.fromMap(dict["CasterList"] as! [String: Any])
            self.casterList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeCastersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCastersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCastersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainUsageDataRequest : Tea.TeaModel {
    public var area: String?

    public var dataProtocol: String?

    public var domainName: String?

    public var endTime: String?

    public var field: String?

    public var interval: String?

    public var ownerId: Int64?

    public var startTime: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.dataProtocol != nil {
            map["DataProtocol"] = self.dataProtocol!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.field != nil {
            map["Field"] = self.field!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Area") {
            self.area = dict["Area"] as! String
        }
        if dict.keys.contains("DataProtocol") {
            self.dataProtocol = dict["DataProtocol"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Field") {
            self.field = dict["Field"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeDomainUsageDataResponseBody : Tea.TeaModel {
    public class UsageDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeDomainUsageDataResponseBody.UsageDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeDomainUsageDataResponseBody.UsageDataPerInterval.DataModule]
            }
        }
    }
    public var area: String?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var type: String?

    public var usageDataPerInterval: DescribeDomainUsageDataResponseBody.UsageDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.usageDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.usageDataPerInterval != nil {
            map["UsageDataPerInterval"] = self.usageDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Area") {
            self.area = dict["Area"] as! String
        }
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UsageDataPerInterval") {
            var model = DescribeDomainUsageDataResponseBody.UsageDataPerInterval()
            model.fromMap(dict["UsageDataPerInterval"] as! [String: Any])
            self.usageDataPerInterval = model
        }
    }
}

public class DescribeDomainUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainUsageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDomainWithIntegrityRequest : Tea.TeaModel {
    public var endTime: String?

    public var integrity: Double?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.integrity != nil {
            map["Integrity"] = self.integrity!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Integrity") {
            self.integrity = dict["Integrity"] as! Double
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeDomainWithIntegrityResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var columns: [String]?

        public var name: String?

        public var points: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columns != nil {
                map["Columns"] = self.columns!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.points != nil {
                map["Points"] = self.points!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Columns") {
                self.columns = dict["Columns"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Points") {
                self.points = dict["Points"] as! [String]
            }
        }
    }
    public var content: [DescribeDomainWithIntegrityResponseBody.Content]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["Content"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! [DescribeDomainWithIntegrityResponseBody.Content]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDomainWithIntegrityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainWithIntegrityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDomainWithIntegrityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeForbidPushStreamRoomListRequest : Tea.TeaModel {
    public var appId: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeForbidPushStreamRoomListResponseBody : Tea.TeaModel {
    public class RoomList : Tea.TeaModel {
        public var anchorId: String?

        public var opEndTime: String?

        public var opStartTime: String?

        public var roomId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.anchorId != nil {
                map["AnchorId"] = self.anchorId!
            }
            if self.opEndTime != nil {
                map["OpEndTime"] = self.opEndTime!
            }
            if self.opStartTime != nil {
                map["OpStartTime"] = self.opStartTime!
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AnchorId") {
                self.anchorId = dict["AnchorId"] as! String
            }
            if dict.keys.contains("OpEndTime") {
                self.opEndTime = dict["OpEndTime"] as! String
            }
            if dict.keys.contains("OpStartTime") {
                self.opStartTime = dict["OpStartTime"] as! String
            }
            if dict.keys.contains("RoomId") {
                self.roomId = dict["RoomId"] as! String
            }
        }
    }
    public var requestId: String?

    public var roomList: [DescribeForbidPushStreamRoomListResponseBody.RoomList]?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.roomList != nil {
            var tmp : [Any] = []
            for k in self.roomList! {
                tmp.append(k.toMap())
            }
            map["RoomList"] = tmp
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RoomList") {
            self.roomList = dict["RoomList"] as! [DescribeForbidPushStreamRoomListResponseBody.RoomList]
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeForbidPushStreamRoomListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeForbidPushStreamRoomListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeForbidPushStreamRoomListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHlsLiveStreamRealTimeBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! String
        }
    }
}

public class DescribeHlsLiveStreamRealTimeBpsDataResponseBody : Tea.TeaModel {
    public class UsageData : Tea.TeaModel {
        public class StreamInfos : Tea.TeaModel {
            public class Infos : Tea.TeaModel {
                public var downFlow: Double?

                public var online: Double?

                public var rate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.downFlow != nil {
                        map["DownFlow"] = self.downFlow!
                    }
                    if self.online != nil {
                        map["Online"] = self.online!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DownFlow") {
                        self.downFlow = dict["DownFlow"] as! Double
                    }
                    if dict.keys.contains("Online") {
                        self.online = dict["Online"] as! Double
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                }
            }
            public var infos: [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos.Infos]?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.infos != nil {
                    var tmp : [Any] = []
                    for k in self.infos! {
                        tmp.append(k.toMap())
                    }
                    map["Infos"] = tmp
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Infos") {
                    self.infos = dict["Infos"] as! [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos.Infos]
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public var domainName: String?

        public var streamInfos: [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.streamInfos != nil {
                var tmp : [Any] = []
                for k in self.streamInfos! {
                    tmp.append(k.toMap())
                }
                map["StreamInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("StreamInfos") {
                self.streamInfos = dict["StreamInfos"] as! [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos]
            }
        }
    }
    public var requestId: String?

    public var time: String?

    public var usageData: [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.usageData != nil {
            var tmp : [Any] = []
            for k in self.usageData! {
                tmp.append(k.toMap())
            }
            map["UsageData"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! String
        }
        if dict.keys.contains("UsageData") {
            self.usageData = dict["UsageData"] as! [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData]
        }
    }
}

public class DescribeHlsLiveStreamRealTimeBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHlsLiveStreamRealTimeBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHlsLiveStreamRealTimeBpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveAudioAuditConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveAudioAuditConfigResponseBody : Tea.TeaModel {
    public class LiveAudioAuditConfigList : Tea.TeaModel {
        public class LiveAudioAuditConfig : Tea.TeaModel {
            public class Scenes : Tea.TeaModel {
                public var scene: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.scene != nil {
                        map["scene"] = self.scene!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("scene") {
                        self.scene = dict["scene"] as! [String]
                    }
                }
            }
            public var appName: String?

            public var bizType: String?

            public var domainName: String?

            public var scenes: DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList.LiveAudioAuditConfig.Scenes?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scenes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.scenes != nil {
                    map["Scenes"] = self.scenes?.toMap()
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("BizType") {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Scenes") {
                    var model = DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList.LiveAudioAuditConfig.Scenes()
                    model.fromMap(dict["Scenes"] as! [String: Any])
                    self.scenes = model
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public var liveAudioAuditConfig: [DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList.LiveAudioAuditConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveAudioAuditConfig != nil {
                var tmp : [Any] = []
                for k in self.liveAudioAuditConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveAudioAuditConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveAudioAuditConfig") {
                self.liveAudioAuditConfig = dict["LiveAudioAuditConfig"] as! [DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList.LiveAudioAuditConfig]
            }
        }
    }
    public var liveAudioAuditConfigList: DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveAudioAuditConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveAudioAuditConfigList != nil {
            map["LiveAudioAuditConfigList"] = self.liveAudioAuditConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveAudioAuditConfigList") {
            var model = DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList()
            model.fromMap(dict["LiveAudioAuditConfigList"] as! [String: Any])
            self.liveAudioAuditConfigList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveAudioAuditConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveAudioAuditConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveAudioAuditConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveAudioAuditNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveAudioAuditNotifyConfigResponseBody : Tea.TeaModel {
    public class LiveAudioAuditNotifyConfigList : Tea.TeaModel {
        public class LiveAudioAuditNotifyConfig : Tea.TeaModel {
            public var callback: String?

            public var callbackTemplate: String?

            public var domainName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callback != nil {
                    map["Callback"] = self.callback!
                }
                if self.callbackTemplate != nil {
                    map["CallbackTemplate"] = self.callbackTemplate!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Callback") {
                    self.callback = dict["Callback"] as! String
                }
                if dict.keys.contains("CallbackTemplate") {
                    self.callbackTemplate = dict["CallbackTemplate"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
            }
        }
        public var liveAudioAuditNotifyConfig: [DescribeLiveAudioAuditNotifyConfigResponseBody.LiveAudioAuditNotifyConfigList.LiveAudioAuditNotifyConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveAudioAuditNotifyConfig != nil {
                var tmp : [Any] = []
                for k in self.liveAudioAuditNotifyConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveAudioAuditNotifyConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveAudioAuditNotifyConfig") {
                self.liveAudioAuditNotifyConfig = dict["LiveAudioAuditNotifyConfig"] as! [DescribeLiveAudioAuditNotifyConfigResponseBody.LiveAudioAuditNotifyConfigList.LiveAudioAuditNotifyConfig]
            }
        }
    }
    public var liveAudioAuditNotifyConfigList: DescribeLiveAudioAuditNotifyConfigResponseBody.LiveAudioAuditNotifyConfigList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveAudioAuditNotifyConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveAudioAuditNotifyConfigList != nil {
            map["LiveAudioAuditNotifyConfigList"] = self.liveAudioAuditNotifyConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveAudioAuditNotifyConfigList") {
            var model = DescribeLiveAudioAuditNotifyConfigResponseBody.LiveAudioAuditNotifyConfigList()
            model.fromMap(dict["LiveAudioAuditNotifyConfigList"] as! [String: Any])
            self.liveAudioAuditNotifyConfigList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveAudioAuditNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveAudioAuditNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveAudioAuditNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveCertificateDetailRequest : Tea.TeaModel {
    public var certName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertName") {
            self.certName = dict["CertName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLiveCertificateDetailResponseBody : Tea.TeaModel {
    public var cert: String?

    public var certId: Int64?

    public var certName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cert != nil {
            map["Cert"] = self.cert!
        }
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cert") {
            self.cert = dict["Cert"] as! String
        }
        if dict.keys.contains("CertId") {
            self.certId = dict["CertId"] as! Int64
        }
        if dict.keys.contains("CertName") {
            self.certName = dict["CertName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveCertificateDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveCertificateDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveCertificateDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveCertificateListRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLiveCertificateListResponseBody : Tea.TeaModel {
    public class CertificateListModel : Tea.TeaModel {
        public class CertList : Tea.TeaModel {
            public class Cert : Tea.TeaModel {
                public var certId: Int64?

                public var certName: String?

                public var common: String?

                public var fingerprint: String?

                public var issuer: String?

                public var lastTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.certId != nil {
                        map["CertId"] = self.certId!
                    }
                    if self.certName != nil {
                        map["CertName"] = self.certName!
                    }
                    if self.common != nil {
                        map["Common"] = self.common!
                    }
                    if self.fingerprint != nil {
                        map["Fingerprint"] = self.fingerprint!
                    }
                    if self.issuer != nil {
                        map["Issuer"] = self.issuer!
                    }
                    if self.lastTime != nil {
                        map["LastTime"] = self.lastTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CertId") {
                        self.certId = dict["CertId"] as! Int64
                    }
                    if dict.keys.contains("CertName") {
                        self.certName = dict["CertName"] as! String
                    }
                    if dict.keys.contains("Common") {
                        self.common = dict["Common"] as! String
                    }
                    if dict.keys.contains("Fingerprint") {
                        self.fingerprint = dict["Fingerprint"] as! String
                    }
                    if dict.keys.contains("Issuer") {
                        self.issuer = dict["Issuer"] as! String
                    }
                    if dict.keys.contains("LastTime") {
                        self.lastTime = dict["LastTime"] as! Int64
                    }
                }
            }
            public var cert: [DescribeLiveCertificateListResponseBody.CertificateListModel.CertList.Cert]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cert != nil {
                    var tmp : [Any] = []
                    for k in self.cert! {
                        tmp.append(k.toMap())
                    }
                    map["Cert"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cert") {
                    self.cert = dict["Cert"] as! [DescribeLiveCertificateListResponseBody.CertificateListModel.CertList.Cert]
                }
            }
        }
        public var certList: DescribeLiveCertificateListResponseBody.CertificateListModel.CertList?

        public var count: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.certList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certList != nil {
                map["CertList"] = self.certList?.toMap()
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertList") {
                var model = DescribeLiveCertificateListResponseBody.CertificateListModel.CertList()
                model.fromMap(dict["CertList"] as! [String: Any])
                self.certList = model
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int32
            }
        }
    }
    public var certificateListModel: DescribeLiveCertificateListResponseBody.CertificateListModel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certificateListModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateListModel != nil {
            map["CertificateListModel"] = self.certificateListModel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertificateListModel") {
            var model = DescribeLiveCertificateListResponseBody.CertificateListModel()
            model.fromMap(dict["CertificateListModel"] as! [String: Any])
            self.certificateListModel = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveCertificateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveCertificateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveCertificateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDetectNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLiveDetectNotifyConfigResponseBody : Tea.TeaModel {
    public class LiveDetectNotifyConfig : Tea.TeaModel {
        public var domainName: String?

        public var notifyUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("NotifyUrl") {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
        }
    }
    public var liveDetectNotifyConfig: DescribeLiveDetectNotifyConfigResponseBody.LiveDetectNotifyConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveDetectNotifyConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveDetectNotifyConfig != nil {
            map["LiveDetectNotifyConfig"] = self.liveDetectNotifyConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveDetectNotifyConfig") {
            var model = DescribeLiveDetectNotifyConfigResponseBody.LiveDetectNotifyConfig()
            model.fromMap(dict["LiveDetectNotifyConfig"] as! [String: Any])
            self.liveDetectNotifyConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDetectNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDetectNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDetectNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDetectPornDataRequest : Tea.TeaModel {
    public var app: String?

    public var domainName: String?

    public var endTime: String?

    public var fee: String?

    public var ownerId: Int64?

    public var region: String?

    public var scene: String?

    public var splitBy: String?

    public var startTime: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.fee != nil {
            map["Fee"] = self.fee!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Fee") {
            self.fee = dict["Fee"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
        if dict.keys.contains("SplitBy") {
            self.splitBy = dict["SplitBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Stream") {
            self.stream = dict["Stream"] as! String
        }
    }
}

public class DescribeLiveDetectPornDataResponseBody : Tea.TeaModel {
    public class DetectPornData : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var app: String?

            public var count: Int64?

            public var domain: String?

            public var fee: String?

            public var region: String?

            public var scene: String?

            public var stream: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.app != nil {
                    map["App"] = self.app!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.fee != nil {
                    map["Fee"] = self.fee!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.stream != nil {
                    map["Stream"] = self.stream!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("App") {
                    self.app = dict["App"] as! String
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Fee") {
                    self.fee = dict["Fee"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Stream") {
                    self.stream = dict["Stream"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDetectPornDataResponseBody.DetectPornData.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDetectPornDataResponseBody.DetectPornData.DataModule]
            }
        }
    }
    public var detectPornData: DescribeLiveDetectPornDataResponseBody.DetectPornData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detectPornData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detectPornData != nil {
            map["DetectPornData"] = self.detectPornData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DetectPornData") {
            var model = DescribeLiveDetectPornDataResponseBody.DetectPornData()
            model.fromMap(dict["DetectPornData"] as! [String: Any])
            self.detectPornData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDetectPornDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDetectPornDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDetectPornDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainBpsDataResponseBody : Tea.TeaModel {
    public class BpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var bpsValue: String?

            public var httpBpsValue: String?

            public var httpsBpsValue: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bpsValue != nil {
                    map["BpsValue"] = self.bpsValue!
                }
                if self.httpBpsValue != nil {
                    map["HttpBpsValue"] = self.httpBpsValue!
                }
                if self.httpsBpsValue != nil {
                    map["HttpsBpsValue"] = self.httpsBpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BpsValue") {
                    self.bpsValue = dict["BpsValue"] as! String
                }
                if dict.keys.contains("HttpBpsValue") {
                    self.httpBpsValue = dict["HttpBpsValue"] as! String
                }
                if dict.keys.contains("HttpsBpsValue") {
                    self.httpsBpsValue = dict["HttpsBpsValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDomainBpsDataResponseBody.BpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDomainBpsDataResponseBody.BpsDataPerInterval.DataModule]
            }
        }
    }
    public var bpsDataPerInterval: DescribeLiveDomainBpsDataResponseBody.BpsDataPerInterval?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataPerInterval != nil {
            map["BpsDataPerInterval"] = self.bpsDataPerInterval?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BpsDataPerInterval") {
            var model = DescribeLiveDomainBpsDataResponseBody.BpsDataPerInterval()
            model.fromMap(dict["BpsDataPerInterval"] as! [String: Any])
            self.bpsDataPerInterval = model
        }
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainBpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainBpsDataByLayerRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var layer: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.layer != nil {
            map["Layer"] = self.layer!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("Layer") {
            self.layer = dict["Layer"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainBpsDataByLayerResponseBody : Tea.TeaModel {
    public class BpsDataInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var trafficValue: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.trafficValue != nil {
                    map["TrafficValue"] = self.trafficValue!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("TrafficValue") {
                    self.trafficValue = dict["TrafficValue"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDomainBpsDataByLayerResponseBody.BpsDataInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDomainBpsDataByLayerResponseBody.BpsDataInterval.DataModule]
            }
        }
    }
    public var bpsDataInterval: DescribeLiveDomainBpsDataByLayerResponseBody.BpsDataInterval?

    public var dataInterval: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataInterval != nil {
            map["BpsDataInterval"] = self.bpsDataInterval?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BpsDataInterval") {
            var model = DescribeLiveDomainBpsDataByLayerResponseBody.BpsDataInterval()
            model.fromMap(dict["BpsDataInterval"] as! [String: Any])
            self.bpsDataInterval = model
        }
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainBpsDataByLayerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainBpsDataByLayerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainBpsDataByLayerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainBpsDataByTimeStampRequest : Tea.TeaModel {
    public var domainName: String?

    public var ispNames: String?

    public var locationNames: String?

    public var ownerId: Int64?

    public var timePoint: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ispNames != nil {
            map["IspNames"] = self.ispNames!
        }
        if self.locationNames != nil {
            map["LocationNames"] = self.locationNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.timePoint != nil {
            map["TimePoint"] = self.timePoint!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("IspNames") {
            self.ispNames = dict["IspNames"] as! String
        }
        if dict.keys.contains("LocationNames") {
            self.locationNames = dict["LocationNames"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("TimePoint") {
            self.timePoint = dict["TimePoint"] as! String
        }
    }
}

public class DescribeLiveDomainBpsDataByTimeStampResponseBody : Tea.TeaModel {
    public class BpsDataList : Tea.TeaModel {
        public class BpsDataModel : Tea.TeaModel {
            public var bps: Int64?

            public var ispName: String?

            public var locationName: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bps != nil {
                    map["Bps"] = self.bps!
                }
                if self.ispName != nil {
                    map["IspName"] = self.ispName!
                }
                if self.locationName != nil {
                    map["LocationName"] = self.locationName!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bps") {
                    self.bps = dict["Bps"] as! Int64
                }
                if dict.keys.contains("IspName") {
                    self.ispName = dict["IspName"] as! String
                }
                if dict.keys.contains("LocationName") {
                    self.locationName = dict["LocationName"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var bpsDataModel: [DescribeLiveDomainBpsDataByTimeStampResponseBody.BpsDataList.BpsDataModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bpsDataModel != nil {
                var tmp : [Any] = []
                for k in self.bpsDataModel! {
                    tmp.append(k.toMap())
                }
                map["BpsDataModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BpsDataModel") {
                self.bpsDataModel = dict["BpsDataModel"] as! [DescribeLiveDomainBpsDataByTimeStampResponseBody.BpsDataList.BpsDataModel]
            }
        }
    }
    public var bpsDataList: DescribeLiveDomainBpsDataByTimeStampResponseBody.BpsDataList?

    public var domainName: String?

    public var requestId: String?

    public var timeStamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataList != nil {
            map["BpsDataList"] = self.bpsDataList?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BpsDataList") {
            var model = DescribeLiveDomainBpsDataByTimeStampResponseBody.BpsDataList()
            model.fromMap(dict["BpsDataList"] as! [String: Any])
            self.bpsDataList = model
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeStamp") {
            self.timeStamp = dict["TimeStamp"] as! String
        }
    }
}

public class DescribeLiveDomainBpsDataByTimeStampResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainBpsDataByTimeStampResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainBpsDataByTimeStampResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainCertificateInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveDomainCertificateInfoResponseBody : Tea.TeaModel {
    public class CertInfos : Tea.TeaModel {
        public class CertInfo : Tea.TeaModel {
            public var certDomainName: String?

            public var certExpireTime: String?

            public var certLife: String?

            public var certName: String?

            public var certOrg: String?

            public var certType: String?

            public var domainName: String?

            public var SSLProtocol: String?

            public var SSLPub: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certDomainName != nil {
                    map["CertDomainName"] = self.certDomainName!
                }
                if self.certExpireTime != nil {
                    map["CertExpireTime"] = self.certExpireTime!
                }
                if self.certLife != nil {
                    map["CertLife"] = self.certLife!
                }
                if self.certName != nil {
                    map["CertName"] = self.certName!
                }
                if self.certOrg != nil {
                    map["CertOrg"] = self.certOrg!
                }
                if self.certType != nil {
                    map["CertType"] = self.certType!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.SSLProtocol != nil {
                    map["SSLProtocol"] = self.SSLProtocol!
                }
                if self.SSLPub != nil {
                    map["SSLPub"] = self.SSLPub!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CertDomainName") {
                    self.certDomainName = dict["CertDomainName"] as! String
                }
                if dict.keys.contains("CertExpireTime") {
                    self.certExpireTime = dict["CertExpireTime"] as! String
                }
                if dict.keys.contains("CertLife") {
                    self.certLife = dict["CertLife"] as! String
                }
                if dict.keys.contains("CertName") {
                    self.certName = dict["CertName"] as! String
                }
                if dict.keys.contains("CertOrg") {
                    self.certOrg = dict["CertOrg"] as! String
                }
                if dict.keys.contains("CertType") {
                    self.certType = dict["CertType"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("SSLProtocol") {
                    self.SSLProtocol = dict["SSLProtocol"] as! String
                }
                if dict.keys.contains("SSLPub") {
                    self.SSLPub = dict["SSLPub"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var certInfo: [DescribeLiveDomainCertificateInfoResponseBody.CertInfos.CertInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certInfo != nil {
                var tmp : [Any] = []
                for k in self.certInfo! {
                    tmp.append(k.toMap())
                }
                map["CertInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertInfo") {
                self.certInfo = dict["CertInfo"] as! [DescribeLiveDomainCertificateInfoResponseBody.CertInfos.CertInfo]
            }
        }
    }
    public var certInfos: DescribeLiveDomainCertificateInfoResponseBody.CertInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certInfos != nil {
            map["CertInfos"] = self.certInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertInfos") {
            var model = DescribeLiveDomainCertificateInfoResponseBody.CertInfos()
            model.fromMap(dict["CertInfos"] as! [String: Any])
            self.certInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainCertificateInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainCertificateInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainCertificateInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainConfigsRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionNames: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionNames != nil {
            map["FunctionNames"] = self.functionNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FunctionNames") {
            self.functionNames = dict["FunctionNames"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLiveDomainConfigsResponseBody : Tea.TeaModel {
    public class DomainConfigs : Tea.TeaModel {
        public class DomainConfig : Tea.TeaModel {
            public class FunctionArgs : Tea.TeaModel {
                public class FunctionArg : Tea.TeaModel {
                    public var argName: String?

                    public var argValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.argName != nil {
                            map["ArgName"] = self.argName!
                        }
                        if self.argValue != nil {
                            map["ArgValue"] = self.argValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ArgName") {
                            self.argName = dict["ArgName"] as! String
                        }
                        if dict.keys.contains("ArgValue") {
                            self.argValue = dict["ArgValue"] as! String
                        }
                    }
                }
                public var functionArg: [DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.functionArg != nil {
                        var tmp : [Any] = []
                        for k in self.functionArg! {
                            tmp.append(k.toMap())
                        }
                        map["FunctionArg"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FunctionArg") {
                        self.functionArg = dict["FunctionArg"] as! [DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg]
                    }
                }
            }
            public var configId: String?

            public var functionArgs: DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs?

            public var functionName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.functionArgs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.functionArgs != nil {
                    map["FunctionArgs"] = self.functionArgs?.toMap()
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigId") {
                    self.configId = dict["ConfigId"] as! String
                }
                if dict.keys.contains("FunctionArgs") {
                    var model = DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs()
                    model.fromMap(dict["FunctionArgs"] as! [String: Any])
                    self.functionArgs = model
                }
                if dict.keys.contains("FunctionName") {
                    self.functionName = dict["FunctionName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var domainConfig: [DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainConfig != nil {
                var tmp : [Any] = []
                for k in self.domainConfig! {
                    tmp.append(k.toMap())
                }
                map["DomainConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainConfig") {
                self.domainConfig = dict["DomainConfig"] as! [DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig]
            }
        }
    }
    public var domainConfigs: DescribeLiveDomainConfigsResponseBody.DomainConfigs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainConfigs != nil {
            map["DomainConfigs"] = self.domainConfigs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainConfigs") {
            var model = DescribeLiveDomainConfigsResponseBody.DomainConfigs()
            model.fromMap(dict["DomainConfigs"] as! [String: Any])
            self.domainConfigs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainDetailRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLiveDomainDetailResponseBody : Tea.TeaModel {
    public class DomainDetail : Tea.TeaModel {
        public var certName: String?

        public var cname: String?

        public var description_: String?

        public var domainName: String?

        public var domainStatus: String?

        public var gmtCreated: String?

        public var gmtModified: String?

        public var liveDomainType: String?

        public var region: String?

        public var SSLProtocol: String?

        public var SSLPub: String?

        public var scope: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.cname != nil {
                map["Cname"] = self.cname!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainStatus != nil {
                map["DomainStatus"] = self.domainStatus!
            }
            if self.gmtCreated != nil {
                map["GmtCreated"] = self.gmtCreated!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.liveDomainType != nil {
                map["LiveDomainType"] = self.liveDomainType!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.SSLProtocol != nil {
                map["SSLProtocol"] = self.SSLProtocol!
            }
            if self.SSLPub != nil {
                map["SSLPub"] = self.SSLPub!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertName") {
                self.certName = dict["CertName"] as! String
            }
            if dict.keys.contains("Cname") {
                self.cname = dict["Cname"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("DomainStatus") {
                self.domainStatus = dict["DomainStatus"] as! String
            }
            if dict.keys.contains("GmtCreated") {
                self.gmtCreated = dict["GmtCreated"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("LiveDomainType") {
                self.liveDomainType = dict["LiveDomainType"] as! String
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("SSLProtocol") {
                self.SSLProtocol = dict["SSLProtocol"] as! String
            }
            if dict.keys.contains("SSLPub") {
                self.SSLPub = dict["SSLPub"] as! String
            }
            if dict.keys.contains("Scope") {
                self.scope = dict["Scope"] as! String
            }
        }
    }
    public var domainDetail: DescribeLiveDomainDetailResponseBody.DomainDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainDetail != nil {
            map["DomainDetail"] = self.domainDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainDetail") {
            var model = DescribeLiveDomainDetailResponseBody.DomainDetail()
            model.fromMap(dict["DomainDetail"] as! [String: Any])
            self.domainDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainFrameRateAndBitRateDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var queryTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.queryTime != nil {
            map["QueryTime"] = self.queryTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QueryTime") {
            self.queryTime = dict["QueryTime"] as! String
        }
    }
}

public class DescribeLiveDomainFrameRateAndBitRateDataResponseBody : Tea.TeaModel {
    public class FrameRateAndBitRateInfos : Tea.TeaModel {
        public class FrameRateAndBitRateInfo : Tea.TeaModel {
            public var audioFrameRate: Double?

            public var bitRate: Double?

            public var streamUrl: String?

            public var videoFrameRate: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioFrameRate != nil {
                    map["AudioFrameRate"] = self.audioFrameRate!
                }
                if self.bitRate != nil {
                    map["BitRate"] = self.bitRate!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                if self.videoFrameRate != nil {
                    map["VideoFrameRate"] = self.videoFrameRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioFrameRate") {
                    self.audioFrameRate = dict["AudioFrameRate"] as! Double
                }
                if dict.keys.contains("BitRate") {
                    self.bitRate = dict["BitRate"] as! Double
                }
                if dict.keys.contains("StreamUrl") {
                    self.streamUrl = dict["StreamUrl"] as! String
                }
                if dict.keys.contains("VideoFrameRate") {
                    self.videoFrameRate = dict["VideoFrameRate"] as! Double
                }
            }
        }
        public var frameRateAndBitRateInfo: [DescribeLiveDomainFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.frameRateAndBitRateInfo != nil {
                var tmp : [Any] = []
                for k in self.frameRateAndBitRateInfo! {
                    tmp.append(k.toMap())
                }
                map["FrameRateAndBitRateInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FrameRateAndBitRateInfo") {
                self.frameRateAndBitRateInfo = dict["FrameRateAndBitRateInfo"] as! [DescribeLiveDomainFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo]
            }
        }
    }
    public var frameRateAndBitRateInfos: DescribeLiveDomainFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.frameRateAndBitRateInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.frameRateAndBitRateInfos != nil {
            map["FrameRateAndBitRateInfos"] = self.frameRateAndBitRateInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FrameRateAndBitRateInfos") {
            var model = DescribeLiveDomainFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos()
            model.fromMap(dict["FrameRateAndBitRateInfos"] as! [String: Any])
            self.frameRateAndBitRateInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainFrameRateAndBitRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainFrameRateAndBitRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainFrameRateAndBitRateDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainLimitRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveDomainLimitResponseBody : Tea.TeaModel {
    public class LiveDomainLimitList : Tea.TeaModel {
        public class LiveDomainLimit : Tea.TeaModel {
            public var domainName: String?

            public var limitNum: Int32?

            public var limitTranscodeNum: Int32?

            public var limitTransferNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.limitNum != nil {
                    map["LimitNum"] = self.limitNum!
                }
                if self.limitTranscodeNum != nil {
                    map["LimitTranscodeNum"] = self.limitTranscodeNum!
                }
                if self.limitTransferNum != nil {
                    map["LimitTransferNum"] = self.limitTransferNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("LimitNum") {
                    self.limitNum = dict["LimitNum"] as! Int32
                }
                if dict.keys.contains("LimitTranscodeNum") {
                    self.limitTranscodeNum = dict["LimitTranscodeNum"] as! Int32
                }
                if dict.keys.contains("LimitTransferNum") {
                    self.limitTransferNum = dict["LimitTransferNum"] as! Int32
                }
            }
        }
        public var liveDomainLimit: [DescribeLiveDomainLimitResponseBody.LiveDomainLimitList.LiveDomainLimit]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveDomainLimit != nil {
                var tmp : [Any] = []
                for k in self.liveDomainLimit! {
                    tmp.append(k.toMap())
                }
                map["LiveDomainLimit"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveDomainLimit") {
                self.liveDomainLimit = dict["LiveDomainLimit"] as! [DescribeLiveDomainLimitResponseBody.LiveDomainLimitList.LiveDomainLimit]
            }
        }
    }
    public var liveDomainLimitList: DescribeLiveDomainLimitResponseBody.LiveDomainLimitList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveDomainLimitList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveDomainLimitList != nil {
            map["LiveDomainLimitList"] = self.liveDomainLimitList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveDomainLimitList") {
            var model = DescribeLiveDomainLimitResponseBody.LiveDomainLimitList()
            model.fromMap(dict["LiveDomainLimitList"] as! [String: Any])
            self.liveDomainLimitList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainLimitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainLogRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainLogResponseBody : Tea.TeaModel {
    public class DomainLogDetails : Tea.TeaModel {
        public class DomainLogDetail : Tea.TeaModel {
            public class LogInfos : Tea.TeaModel {
                public class LogInfoDetail : Tea.TeaModel {
                    public var endTime: String?

                    public var logName: String?

                    public var logPath: String?

                    public var logSize: Int64?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.logName != nil {
                            map["LogName"] = self.logName!
                        }
                        if self.logPath != nil {
                            map["LogPath"] = self.logPath!
                        }
                        if self.logSize != nil {
                            map["LogSize"] = self.logSize!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("LogName") {
                            self.logName = dict["LogName"] as! String
                        }
                        if dict.keys.contains("LogPath") {
                            self.logPath = dict["LogPath"] as! String
                        }
                        if dict.keys.contains("LogSize") {
                            self.logSize = dict["LogSize"] as! Int64
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public var logInfoDetail: [DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logInfoDetail != nil {
                        var tmp : [Any] = []
                        for k in self.logInfoDetail! {
                            tmp.append(k.toMap())
                        }
                        map["LogInfoDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LogInfoDetail") {
                        self.logInfoDetail = dict["LogInfoDetail"] as! [DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]
                    }
                }
            }
            public class PageInfos : Tea.TeaModel {
                public var pageIndex: Int64?

                public var pageSize: Int64?

                public var total: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pageIndex != nil {
                        map["PageIndex"] = self.pageIndex!
                    }
                    if self.pageSize != nil {
                        map["PageSize"] = self.pageSize!
                    }
                    if self.total != nil {
                        map["Total"] = self.total!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PageIndex") {
                        self.pageIndex = dict["PageIndex"] as! Int64
                    }
                    if dict.keys.contains("PageSize") {
                        self.pageSize = dict["PageSize"] as! Int64
                    }
                    if dict.keys.contains("Total") {
                        self.total = dict["Total"] as! Int64
                    }
                }
            }
            public var logCount: Int64?

            public var logInfos: DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos?

            public var pageInfos: DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.logInfos?.validate()
                try self.pageInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.logInfos != nil {
                    map["LogInfos"] = self.logInfos?.toMap()
                }
                if self.pageInfos != nil {
                    map["PageInfos"] = self.pageInfos?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LogCount") {
                    self.logCount = dict["LogCount"] as! Int64
                }
                if dict.keys.contains("LogInfos") {
                    var model = DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos()
                    model.fromMap(dict["LogInfos"] as! [String: Any])
                    self.logInfos = model
                }
                if dict.keys.contains("PageInfos") {
                    var model = DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos()
                    model.fromMap(dict["PageInfos"] as! [String: Any])
                    self.pageInfos = model
                }
            }
        }
        public var domainLogDetail: [DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLogDetail != nil {
                var tmp : [Any] = []
                for k in self.domainLogDetail! {
                    tmp.append(k.toMap())
                }
                map["DomainLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainLogDetail") {
                self.domainLogDetail = dict["DomainLogDetail"] as! [DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail]
            }
        }
    }
    public var domainLogDetails: DescribeLiveDomainLogResponseBody.DomainLogDetails?

    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogDetails != nil {
            map["DomainLogDetails"] = self.domainLogDetails?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainLogDetails") {
            var model = DescribeLiveDomainLogResponseBody.DomainLogDetails()
            model.fromMap(dict["DomainLogDetails"] as! [String: Any])
            self.domainLogDetails = model
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainMappingRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveDomainMappingResponseBody : Tea.TeaModel {
    public class LiveDomainModels : Tea.TeaModel {
        public class LiveDomainModel : Tea.TeaModel {
            public var domainName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var liveDomainModel: [DescribeLiveDomainMappingResponseBody.LiveDomainModels.LiveDomainModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveDomainModel != nil {
                var tmp : [Any] = []
                for k in self.liveDomainModel! {
                    tmp.append(k.toMap())
                }
                map["LiveDomainModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveDomainModel") {
                self.liveDomainModel = dict["LiveDomainModel"] as! [DescribeLiveDomainMappingResponseBody.LiveDomainModels.LiveDomainModel]
            }
        }
    }
    public var liveDomainModels: DescribeLiveDomainMappingResponseBody.LiveDomainModels?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveDomainModels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveDomainModels != nil {
            map["LiveDomainModels"] = self.liveDomainModels?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveDomainModels") {
            var model = DescribeLiveDomainMappingResponseBody.LiveDomainModels()
            model.fromMap(dict["LiveDomainModels"] as! [String: Any])
            self.liveDomainModels = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainMappingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainOnlineUserNumRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var queryTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.queryTime != nil {
            map["QueryTime"] = self.queryTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QueryTime") {
            self.queryTime = dict["QueryTime"] as! String
        }
    }
}

public class DescribeLiveDomainOnlineUserNumResponseBody : Tea.TeaModel {
    public class OnlineUserInfo : Tea.TeaModel {
        public class LiveStreamOnlineUserNumInfo : Tea.TeaModel {
            public class Infos : Tea.TeaModel {
                public class Info : Tea.TeaModel {
                    public var transcodeTemplate: String?

                    public var userNumber: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.transcodeTemplate != nil {
                            map["TranscodeTemplate"] = self.transcodeTemplate!
                        }
                        if self.userNumber != nil {
                            map["UserNumber"] = self.userNumber!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TranscodeTemplate") {
                            self.transcodeTemplate = dict["TranscodeTemplate"] as! String
                        }
                        if dict.keys.contains("UserNumber") {
                            self.userNumber = dict["UserNumber"] as! Int64
                        }
                    }
                }
                public var info: [DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo.Infos.Info]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.info != nil {
                        var tmp : [Any] = []
                        for k in self.info! {
                            tmp.append(k.toMap())
                        }
                        map["Info"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Info") {
                        self.info = dict["Info"] as! [DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo.Infos.Info]
                    }
                }
            }
            public var infos: DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo.Infos?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.infos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.infos != nil {
                    map["Infos"] = self.infos?.toMap()
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Infos") {
                    var model = DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo.Infos()
                    model.fromMap(dict["Infos"] as! [String: Any])
                    self.infos = model
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public var liveStreamOnlineUserNumInfo: [DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamOnlineUserNumInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamOnlineUserNumInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamOnlineUserNumInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveStreamOnlineUserNumInfo") {
                self.liveStreamOnlineUserNumInfo = dict["LiveStreamOnlineUserNumInfo"] as! [DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo]
            }
        }
    }
    public var onlineUserInfo: DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo?

    public var requestId: String?

    public var streamCount: Int32?

    public var userCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.onlineUserInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onlineUserInfo != nil {
            map["OnlineUserInfo"] = self.onlineUserInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamCount != nil {
            map["StreamCount"] = self.streamCount!
        }
        if self.userCount != nil {
            map["UserCount"] = self.userCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OnlineUserInfo") {
            var model = DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo()
            model.fromMap(dict["OnlineUserInfo"] as! [String: Any])
            self.onlineUserInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StreamCount") {
            self.streamCount = dict["StreamCount"] as! Int32
        }
        if dict.keys.contains("UserCount") {
            self.userCount = dict["UserCount"] as! Int32
        }
    }
}

public class DescribeLiveDomainOnlineUserNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainOnlineUserNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainOnlineUserNumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainPushBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainPushBpsDataResponseBody : Tea.TeaModel {
    public class BpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var bpsValue: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bpsValue != nil {
                    map["BpsValue"] = self.bpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BpsValue") {
                    self.bpsValue = dict["BpsValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDomainPushBpsDataResponseBody.BpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDomainPushBpsDataResponseBody.BpsDataPerInterval.DataModule]
            }
        }
    }
    public var bpsDataPerInterval: DescribeLiveDomainPushBpsDataResponseBody.BpsDataPerInterval?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataPerInterval != nil {
            map["BpsDataPerInterval"] = self.bpsDataPerInterval?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BpsDataPerInterval") {
            var model = DescribeLiveDomainPushBpsDataResponseBody.BpsDataPerInterval()
            model.fromMap(dict["BpsDataPerInterval"] as! [String: Any])
            self.bpsDataPerInterval = model
        }
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainPushBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainPushBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainPushBpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainPushTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainPushTrafficDataResponseBody : Tea.TeaModel {
    public class TrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var trafficValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.trafficValue != nil {
                    map["TrafficValue"] = self.trafficValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("TrafficValue") {
                    self.trafficValue = dict["TrafficValue"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDomainPushTrafficDataResponseBody.TrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDomainPushTrafficDataResponseBody.TrafficDataPerInterval.DataModule]
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var trafficDataPerInterval: DescribeLiveDomainPushTrafficDataResponseBody.TrafficDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.trafficDataPerInterval != nil {
            map["TrafficDataPerInterval"] = self.trafficDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TrafficDataPerInterval") {
            var model = DescribeLiveDomainPushTrafficDataResponseBody.TrafficDataPerInterval()
            model.fromMap(dict["TrafficDataPerInterval"] as! [String: Any])
            self.trafficDataPerInterval = model
        }
    }
}

public class DescribeLiveDomainPushTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainPushTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainPushTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainPvUvDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainPvUvDataResponseBody : Tea.TeaModel {
    public class PvUvDataInfos : Tea.TeaModel {
        public class PvUvDataInfo : Tea.TeaModel {
            public var PV: String?

            public var timeStamp: String?

            public var UV: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.PV != nil {
                    map["PV"] = self.PV!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.UV != nil {
                    map["UV"] = self.UV!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PV") {
                    self.PV = dict["PV"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("UV") {
                    self.UV = dict["UV"] as! String
                }
            }
        }
        public var pvUvDataInfo: [DescribeLiveDomainPvUvDataResponseBody.PvUvDataInfos.PvUvDataInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pvUvDataInfo != nil {
                var tmp : [Any] = []
                for k in self.pvUvDataInfo! {
                    tmp.append(k.toMap())
                }
                map["PvUvDataInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PvUvDataInfo") {
                self.pvUvDataInfo = dict["PvUvDataInfo"] as! [DescribeLiveDomainPvUvDataResponseBody.PvUvDataInfos.PvUvDataInfo]
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var pvUvDataInfos: DescribeLiveDomainPvUvDataResponseBody.PvUvDataInfos?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pvUvDataInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pvUvDataInfos != nil {
            map["PvUvDataInfos"] = self.pvUvDataInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PvUvDataInfos") {
            var model = DescribeLiveDomainPvUvDataResponseBody.PvUvDataInfos()
            model.fromMap(dict["PvUvDataInfos"] as! [String: Any])
            self.pvUvDataInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainPvUvDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainPvUvDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainPvUvDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainRealTimeBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainRealTimeBpsDataResponseBody : Tea.TeaModel {
    public class RealTimeBpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDomainRealTimeBpsDataResponseBody.RealTimeBpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDomainRealTimeBpsDataResponseBody.RealTimeBpsDataPerInterval.DataModule]
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var realTimeBpsDataPerInterval: DescribeLiveDomainRealTimeBpsDataResponseBody.RealTimeBpsDataPerInterval?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeBpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.realTimeBpsDataPerInterval != nil {
            map["RealTimeBpsDataPerInterval"] = self.realTimeBpsDataPerInterval?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RealTimeBpsDataPerInterval") {
            var model = DescribeLiveDomainRealTimeBpsDataResponseBody.RealTimeBpsDataPerInterval()
            model.fromMap(dict["RealTimeBpsDataPerInterval"] as! [String: Any])
            self.realTimeBpsDataPerInterval = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainRealTimeBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRealTimeBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainRealTimeBpsDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainRealTimeHttpCodeDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainRealTimeHttpCodeDataResponseBody : Tea.TeaModel {
    public class RealTimeHttpCodeData : Tea.TeaModel {
        public class UsageData : Tea.TeaModel {
            public class Value : Tea.TeaModel {
                public class RealTimeCodeProportionData : Tea.TeaModel {
                    public var code: String?

                    public var count: String?

                    public var proportion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.proportion != nil {
                            map["Proportion"] = self.proportion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! String
                        }
                        if dict.keys.contains("Proportion") {
                            self.proportion = dict["Proportion"] as! String
                        }
                    }
                }
                public var realTimeCodeProportionData: [DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value.RealTimeCodeProportionData]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.realTimeCodeProportionData != nil {
                        var tmp : [Any] = []
                        for k in self.realTimeCodeProportionData! {
                            tmp.append(k.toMap())
                        }
                        map["RealTimeCodeProportionData"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RealTimeCodeProportionData") {
                        self.realTimeCodeProportionData = dict["RealTimeCodeProportionData"] as! [DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value.RealTimeCodeProportionData]
                    }
                }
            }
            public var timeStamp: String?

            public var value: DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.value?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    var model = DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value()
                    model.fromMap(dict["Value"] as! [String: Any])
                    self.value = model
                }
            }
        }
        public var usageData: [DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.usageData != nil {
                var tmp : [Any] = []
                for k in self.usageData! {
                    tmp.append(k.toMap())
                }
                map["UsageData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UsageData") {
                self.usageData = dict["UsageData"] as! [DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData]
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var realTimeHttpCodeData: DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeHttpCodeData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.realTimeHttpCodeData != nil {
            map["RealTimeHttpCodeData"] = self.realTimeHttpCodeData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RealTimeHttpCodeData") {
            var model = DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData()
            model.fromMap(dict["RealTimeHttpCodeData"] as! [String: Any])
            self.realTimeHttpCodeData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainRealTimeHttpCodeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRealTimeHttpCodeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainRealTimeHttpCodeDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainRealTimeTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainRealTimeTrafficDataResponseBody : Tea.TeaModel {
    public class RealTimeTrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval.DataModule]
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var realTimeTrafficDataPerInterval: DescribeLiveDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeTrafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.realTimeTrafficDataPerInterval != nil {
            map["RealTimeTrafficDataPerInterval"] = self.realTimeTrafficDataPerInterval?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RealTimeTrafficDataPerInterval") {
            var model = DescribeLiveDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval()
            model.fromMap(dict["RealTimeTrafficDataPerInterval"] as! [String: Any])
            self.realTimeTrafficDataPerInterval = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainRealTimeTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRealTimeTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainRealTimeTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveDomainRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var logstore: String?

    public var project: String?

    public var region: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logstore") {
            self.logstore = dict["Logstore"] as! String
        }
        if dict.keys.contains("Project") {
            self.project = dict["Project"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeLiveDomainRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainRealtimeLogDeliveryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainRecordDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var recordType: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recordType != nil {
            map["RecordType"] = self.recordType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RecordType") {
            self.recordType = dict["RecordType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainRecordDataResponseBody : Tea.TeaModel {
    public class RecordDataInfos : Tea.TeaModel {
        public class RecordDataInfo : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var FLV: Int32?

                public var MP4: Int32?

                public var TS: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.FLV != nil {
                        map["FLV"] = self.FLV!
                    }
                    if self.MP4 != nil {
                        map["MP4"] = self.MP4!
                    }
                    if self.TS != nil {
                        map["TS"] = self.TS!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FLV") {
                        self.FLV = dict["FLV"] as! Int32
                    }
                    if dict.keys.contains("MP4") {
                        self.MP4 = dict["MP4"] as! Int32
                    }
                    if dict.keys.contains("TS") {
                        self.TS = dict["TS"] as! Int32
                    }
                }
            }
            public var date: String?

            public var detail: DescribeLiveDomainRecordDataResponseBody.RecordDataInfos.RecordDataInfo.Detail?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.detail != nil {
                    map["Detail"] = self.detail?.toMap()
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("Detail") {
                    var model = DescribeLiveDomainRecordDataResponseBody.RecordDataInfos.RecordDataInfo.Detail()
                    model.fromMap(dict["Detail"] as! [String: Any])
                    self.detail = model
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var recordDataInfo: [DescribeLiveDomainRecordDataResponseBody.RecordDataInfos.RecordDataInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordDataInfo != nil {
                var tmp : [Any] = []
                for k in self.recordDataInfo! {
                    tmp.append(k.toMap())
                }
                map["RecordDataInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordDataInfo") {
                self.recordDataInfo = dict["RecordDataInfo"] as! [DescribeLiveDomainRecordDataResponseBody.RecordDataInfos.RecordDataInfo]
            }
        }
    }
    public var recordDataInfos: DescribeLiveDomainRecordDataResponseBody.RecordDataInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordDataInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordDataInfos != nil {
            map["RecordDataInfos"] = self.recordDataInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordDataInfos") {
            var model = DescribeLiveDomainRecordDataResponseBody.RecordDataInfos()
            model.fromMap(dict["RecordDataInfos"] as! [String: Any])
            self.recordDataInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainRecordDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRecordDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainRecordDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainRecordUsageDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var splitBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SplitBy") {
            self.splitBy = dict["SplitBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainRecordUsageDataResponseBody : Tea.TeaModel {
    public class RecordUsageData : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var count: Int64?

            public var domain: String?

            public var duration: Int64?

            public var timeStamp: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDomainRecordUsageDataResponseBody.RecordUsageData.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDomainRecordUsageDataResponseBody.RecordUsageData.DataModule]
            }
        }
    }
    public var recordUsageData: DescribeLiveDomainRecordUsageDataResponseBody.RecordUsageData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordUsageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordUsageData != nil {
            map["RecordUsageData"] = self.recordUsageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordUsageData") {
            var model = DescribeLiveDomainRecordUsageDataResponseBody.RecordUsageData()
            model.fromMap(dict["RecordUsageData"] as! [String: Any])
            self.recordUsageData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainRecordUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRecordUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainRecordUsageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainSnapshotDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainSnapshotDataResponseBody : Tea.TeaModel {
    public class SnapshotDataInfos : Tea.TeaModel {
        public class SnapshotDataInfo : Tea.TeaModel {
            public var date: String?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var snapshotDataInfo: [DescribeLiveDomainSnapshotDataResponseBody.SnapshotDataInfos.SnapshotDataInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotDataInfo != nil {
                var tmp : [Any] = []
                for k in self.snapshotDataInfo! {
                    tmp.append(k.toMap())
                }
                map["SnapshotDataInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnapshotDataInfo") {
                self.snapshotDataInfo = dict["SnapshotDataInfo"] as! [DescribeLiveDomainSnapshotDataResponseBody.SnapshotDataInfos.SnapshotDataInfo]
            }
        }
    }
    public var requestId: String?

    public var snapshotDataInfos: DescribeLiveDomainSnapshotDataResponseBody.SnapshotDataInfos?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotDataInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotDataInfos != nil {
            map["SnapshotDataInfos"] = self.snapshotDataInfos?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotDataInfos") {
            var model = DescribeLiveDomainSnapshotDataResponseBody.SnapshotDataInfos()
            model.fromMap(dict["SnapshotDataInfos"] as! [String: Any])
            self.snapshotDataInfos = model
        }
    }
}

public class DescribeLiveDomainSnapshotDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainSnapshotDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainSnapshotDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainStagingConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionNames: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionNames != nil {
            map["FunctionNames"] = self.functionNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FunctionNames") {
            self.functionNames = dict["FunctionNames"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveDomainStagingConfigResponseBody : Tea.TeaModel {
    public class DomainConfigs : Tea.TeaModel {
        public class FunctionArgs : Tea.TeaModel {
            public var argName: String?

            public var argValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.argName != nil {
                    map["ArgName"] = self.argName!
                }
                if self.argValue != nil {
                    map["ArgValue"] = self.argValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ArgName") {
                    self.argName = dict["ArgName"] as! String
                }
                if dict.keys.contains("ArgValue") {
                    self.argValue = dict["ArgValue"] as! String
                }
            }
        }
        public var configId: String?

        public var functionArgs: [DescribeLiveDomainStagingConfigResponseBody.DomainConfigs.FunctionArgs]?

        public var functionName: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configId != nil {
                map["ConfigId"] = self.configId!
            }
            if self.functionArgs != nil {
                var tmp : [Any] = []
                for k in self.functionArgs! {
                    tmp.append(k.toMap())
                }
                map["FunctionArgs"] = tmp
            }
            if self.functionName != nil {
                map["FunctionName"] = self.functionName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigId") {
                self.configId = dict["ConfigId"] as! String
            }
            if dict.keys.contains("FunctionArgs") {
                self.functionArgs = dict["FunctionArgs"] as! [DescribeLiveDomainStagingConfigResponseBody.DomainConfigs.FunctionArgs]
            }
            if dict.keys.contains("FunctionName") {
                self.functionName = dict["FunctionName"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var domainConfigs: [DescribeLiveDomainStagingConfigResponseBody.DomainConfigs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainConfigs != nil {
            var tmp : [Any] = []
            for k in self.domainConfigs! {
                tmp.append(k.toMap())
            }
            map["DomainConfigs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainConfigs") {
            self.domainConfigs = dict["DomainConfigs"] as! [DescribeLiveDomainStagingConfigResponseBody.DomainConfigs]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDomainStagingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainStagingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainStagingConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainStreamTranscodeDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var split: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.split != nil {
            map["Split"] = self.split!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Split") {
            self.split = dict["Split"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainStreamTranscodeDataResponseBody : Tea.TeaModel {
    public class TranscodeDataList : Tea.TeaModel {
        public class TranscodeData : Tea.TeaModel {
            public var domain: String?

            public var duration: Int32?

            public var fps: String?

            public var region: String?

            public var resolution: String?

            public var tanscodeType: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resolution != nil {
                    map["Resolution"] = self.resolution!
                }
                if self.tanscodeType != nil {
                    map["TanscodeType"] = self.tanscodeType!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Resolution") {
                    self.resolution = dict["Resolution"] as! String
                }
                if dict.keys.contains("TanscodeType") {
                    self.tanscodeType = dict["TanscodeType"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var transcodeData: [DescribeLiveDomainStreamTranscodeDataResponseBody.TranscodeDataList.TranscodeData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.transcodeData != nil {
                var tmp : [Any] = []
                for k in self.transcodeData! {
                    tmp.append(k.toMap())
                }
                map["TranscodeData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TranscodeData") {
                self.transcodeData = dict["TranscodeData"] as! [DescribeLiveDomainStreamTranscodeDataResponseBody.TranscodeDataList.TranscodeData]
            }
        }
    }
    public var requestId: String?

    public var transcodeDataList: DescribeLiveDomainStreamTranscodeDataResponseBody.TranscodeDataList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeDataList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeDataList != nil {
            map["TranscodeDataList"] = self.transcodeDataList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeDataList") {
            var model = DescribeLiveDomainStreamTranscodeDataResponseBody.TranscodeDataList()
            model.fromMap(dict["TranscodeDataList"] as! [String: Any])
            self.transcodeDataList = model
        }
    }
}

public class DescribeLiveDomainStreamTranscodeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainStreamTranscodeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainStreamTranscodeDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainTimeShiftDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainTimeShiftDataResponseBody : Tea.TeaModel {
    public class TimeShiftData : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var size: String?

            public var timeStamp: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDomainTimeShiftDataResponseBody.TimeShiftData.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDomainTimeShiftDataResponseBody.TimeShiftData.DataModule]
            }
        }
    }
    public var requestId: String?

    public var timeShiftData: DescribeLiveDomainTimeShiftDataResponseBody.TimeShiftData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.timeShiftData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeShiftData != nil {
            map["TimeShiftData"] = self.timeShiftData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TimeShiftData") {
            var model = DescribeLiveDomainTimeShiftDataResponseBody.TimeShiftData()
            model.fromMap(dict["TimeShiftData"] as! [String: Any])
            self.timeShiftData = model
        }
    }
}

public class DescribeLiveDomainTimeShiftDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainTimeShiftDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainTimeShiftDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("IspNameEn") {
            self.ispNameEn = dict["IspNameEn"] as! String
        }
        if dict.keys.contains("LocationNameEn") {
            self.locationNameEn = dict["LocationNameEn"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainTrafficDataResponseBody : Tea.TeaModel {
    public class TrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var httpTrafficValue: String?

            public var httpsTrafficValue: String?

            public var timeStamp: String?

            public var trafficValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpTrafficValue != nil {
                    map["HttpTrafficValue"] = self.httpTrafficValue!
                }
                if self.httpsTrafficValue != nil {
                    map["HttpsTrafficValue"] = self.httpsTrafficValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.trafficValue != nil {
                    map["TrafficValue"] = self.trafficValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HttpTrafficValue") {
                    self.httpTrafficValue = dict["HttpTrafficValue"] as! String
                }
                if dict.keys.contains("HttpsTrafficValue") {
                    self.httpsTrafficValue = dict["HttpsTrafficValue"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("TrafficValue") {
                    self.trafficValue = dict["TrafficValue"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule]
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var trafficDataPerInterval: DescribeLiveDomainTrafficDataResponseBody.TrafficDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.trafficDataPerInterval != nil {
            map["TrafficDataPerInterval"] = self.trafficDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TrafficDataPerInterval") {
            var model = DescribeLiveDomainTrafficDataResponseBody.TrafficDataPerInterval()
            model.fromMap(dict["TrafficDataPerInterval"] as! [String: Any])
            self.trafficDataPerInterval = model
        }
    }
}

public class DescribeLiveDomainTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainTrafficDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDomainTranscodeDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDomainTranscodeDataResponseBody : Tea.TeaModel {
    public class TranscodeDataInfos : Tea.TeaModel {
        public class TranscodeDataInfo : Tea.TeaModel {
            public var date: String?

            public var detail: String?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.detail != nil {
                    map["Detail"] = self.detail!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Date") {
                    self.date = dict["Date"] as! String
                }
                if dict.keys.contains("Detail") {
                    self.detail = dict["Detail"] as! String
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var transcodeDataInfo: [DescribeLiveDomainTranscodeDataResponseBody.TranscodeDataInfos.TranscodeDataInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.transcodeDataInfo != nil {
                var tmp : [Any] = []
                for k in self.transcodeDataInfo! {
                    tmp.append(k.toMap())
                }
                map["TranscodeDataInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TranscodeDataInfo") {
                self.transcodeDataInfo = dict["TranscodeDataInfo"] as! [DescribeLiveDomainTranscodeDataResponseBody.TranscodeDataInfos.TranscodeDataInfo]
            }
        }
    }
    public var requestId: String?

    public var transcodeDataInfos: DescribeLiveDomainTranscodeDataResponseBody.TranscodeDataInfos?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeDataInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeDataInfos != nil {
            map["TranscodeDataInfos"] = self.transcodeDataInfos?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TranscodeDataInfos") {
            var model = DescribeLiveDomainTranscodeDataResponseBody.TranscodeDataInfos()
            model.fromMap(dict["TranscodeDataInfos"] as! [String: Any])
            self.transcodeDataInfos = model
        }
    }
}

public class DescribeLiveDomainTranscodeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainTranscodeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDomainTranscodeDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveDrmUsageDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var splitBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SplitBy") {
            self.splitBy = dict["SplitBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveDrmUsageDataResponseBody : Tea.TeaModel {
    public class DrmUsageData : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var count: Int64?

            public var domain: String?

            public var drmType: String?

            public var region: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.drmType != nil {
                    map["DrmType"] = self.drmType!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("DrmType") {
                    self.drmType = dict["DrmType"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var dataModule: [DescribeLiveDrmUsageDataResponseBody.DrmUsageData.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataModule") {
                self.dataModule = dict["DataModule"] as! [DescribeLiveDrmUsageDataResponseBody.DrmUsageData.DataModule]
            }
        }
    }
    public var drmUsageData: DescribeLiveDrmUsageDataResponseBody.DrmUsageData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.drmUsageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.drmUsageData != nil {
            map["DrmUsageData"] = self.drmUsageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DrmUsageData") {
            var model = DescribeLiveDrmUsageDataResponseBody.DrmUsageData()
            model.fromMap(dict["DrmUsageData"] as! [String: Any])
            self.drmUsageData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveDrmUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDrmUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveDrmUsageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveEdgeTransferRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveEdgeTransferResponseBody : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var httpDns: String?

    public var requestId: String?

    public var streamName: String?

    public var targetDomainList: String?

    public var transferArgs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.httpDns != nil {
            map["HttpDns"] = self.httpDns!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.targetDomainList != nil {
            map["TargetDomainList"] = self.targetDomainList!
        }
        if self.transferArgs != nil {
            map["TransferArgs"] = self.transferArgs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("HttpDns") {
            self.httpDns = dict["HttpDns"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
        if dict.keys.contains("TargetDomainList") {
            self.targetDomainList = dict["TargetDomainList"] as! String
        }
        if dict.keys.contains("TransferArgs") {
            self.transferArgs = dict["TransferArgs"] as! String
        }
    }
}

public class DescribeLiveEdgeTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveEdgeTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveEdgeTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveLazyPullStreamConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveLazyPullStreamConfigResponseBody : Tea.TeaModel {
    public class LiveLazyPullConfigList : Tea.TeaModel {
        public class LiveLazyPullConfig : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var pullAppName: String?

            public var pullDomainName: String?

            public var pullProtocol: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.pullAppName != nil {
                    map["PullAppName"] = self.pullAppName!
                }
                if self.pullDomainName != nil {
                    map["PullDomainName"] = self.pullDomainName!
                }
                if self.pullProtocol != nil {
                    map["PullProtocol"] = self.pullProtocol!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("PullAppName") {
                    self.pullAppName = dict["PullAppName"] as! String
                }
                if dict.keys.contains("PullDomainName") {
                    self.pullDomainName = dict["PullDomainName"] as! String
                }
                if dict.keys.contains("PullProtocol") {
                    self.pullProtocol = dict["PullProtocol"] as! String
                }
            }
        }
        public var liveLazyPullConfig: [DescribeLiveLazyPullStreamConfigResponseBody.LiveLazyPullConfigList.LiveLazyPullConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveLazyPullConfig != nil {
                var tmp : [Any] = []
                for k in self.liveLazyPullConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveLazyPullConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveLazyPullConfig") {
                self.liveLazyPullConfig = dict["LiveLazyPullConfig"] as! [DescribeLiveLazyPullStreamConfigResponseBody.LiveLazyPullConfigList.LiveLazyPullConfig]
            }
        }
    }
    public var liveLazyPullConfigList: DescribeLiveLazyPullStreamConfigResponseBody.LiveLazyPullConfigList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveLazyPullConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveLazyPullConfigList != nil {
            map["LiveLazyPullConfigList"] = self.liveLazyPullConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveLazyPullConfigList") {
            var model = DescribeLiveLazyPullStreamConfigResponseBody.LiveLazyPullConfigList()
            model.fromMap(dict["LiveLazyPullConfigList"] as! [String: Any])
            self.liveLazyPullConfigList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveLazyPullStreamConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveLazyPullStreamConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveLazyPullStreamConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveProducerUsageDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var instance: String?

    public var interval: String?

    public var ownerId: Int64?

    public var region: String?

    public var splitBy: String?

    public var startTime: String?

    public var type: String?

    public var app: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instance != nil {
            map["Instance"] = self.instance!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.app != nil {
            map["app"] = self.app!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Instance") {
            self.instance = dict["Instance"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("SplitBy") {
            self.splitBy = dict["SplitBy"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("app") {
            self.app = dict["app"] as! String
        }
    }
}

public class DescribeLiveProducerUsageDataResponseBody : Tea.TeaModel {
    public class BillProducerData : Tea.TeaModel {
        public class BillProducerDataItem : Tea.TeaModel {
            public var domainName: String?

            public var instance: String?

            public var outputHdDuration: Int64?

            public var outputLdDuration: Int64?

            public var outputSdDuration: Int64?

            public var region: String?

            public var timeStamp: String?

            public var tranHdDuration: Int64?

            public var tranLdDuration: Int64?

            public var tranSdDuration: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.instance != nil {
                    map["Instance"] = self.instance!
                }
                if self.outputHdDuration != nil {
                    map["OutputHdDuration"] = self.outputHdDuration!
                }
                if self.outputLdDuration != nil {
                    map["OutputLdDuration"] = self.outputLdDuration!
                }
                if self.outputSdDuration != nil {
                    map["OutputSdDuration"] = self.outputSdDuration!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.tranHdDuration != nil {
                    map["TranHdDuration"] = self.tranHdDuration!
                }
                if self.tranLdDuration != nil {
                    map["TranLdDuration"] = self.tranLdDuration!
                }
                if self.tranSdDuration != nil {
                    map["TranSdDuration"] = self.tranSdDuration!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Instance") {
                    self.instance = dict["Instance"] as! String
                }
                if dict.keys.contains("OutputHdDuration") {
                    self.outputHdDuration = dict["OutputHdDuration"] as! Int64
                }
                if dict.keys.contains("OutputLdDuration") {
                    self.outputLdDuration = dict["OutputLdDuration"] as! Int64
                }
                if dict.keys.contains("OutputSdDuration") {
                    self.outputSdDuration = dict["OutputSdDuration"] as! Int64
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("TranHdDuration") {
                    self.tranHdDuration = dict["TranHdDuration"] as! Int64
                }
                if dict.keys.contains("TranLdDuration") {
                    self.tranLdDuration = dict["TranLdDuration"] as! Int64
                }
                if dict.keys.contains("TranSdDuration") {
                    self.tranSdDuration = dict["TranSdDuration"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var billProducerDataItem: [DescribeLiveProducerUsageDataResponseBody.BillProducerData.BillProducerDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.billProducerDataItem != nil {
                var tmp : [Any] = []
                for k in self.billProducerDataItem! {
                    tmp.append(k.toMap())
                }
                map["BillProducerDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BillProducerDataItem") {
                self.billProducerDataItem = dict["BillProducerDataItem"] as! [DescribeLiveProducerUsageDataResponseBody.BillProducerData.BillProducerDataItem]
            }
        }
    }
    public var billProducerData: DescribeLiveProducerUsageDataResponseBody.BillProducerData?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.billProducerData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.billProducerData != nil {
            map["BillProducerData"] = self.billProducerData?.toMap()
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BillProducerData") {
            var model = DescribeLiveProducerUsageDataResponseBody.BillProducerData()
            model.fromMap(dict["BillProducerData"] as! [String: Any])
            self.billProducerData = model
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveProducerUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveProducerUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveProducerUsageDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLivePullStreamConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLivePullStreamConfigResponseBody : Tea.TeaModel {
    public class LiveAppRecordList : Tea.TeaModel {
        public class LiveAppRecord : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var endTime: String?

            public var sourceUrl: String?

            public var sourceUsing: String?

            public var startTime: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.sourceUrl != nil {
                    map["SourceUrl"] = self.sourceUrl!
                }
                if self.sourceUsing != nil {
                    map["SourceUsing"] = self.sourceUsing!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("SourceUrl") {
                    self.sourceUrl = dict["SourceUrl"] as! String
                }
                if dict.keys.contains("SourceUsing") {
                    self.sourceUsing = dict["SourceUsing"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public var liveAppRecord: [DescribeLivePullStreamConfigResponseBody.LiveAppRecordList.LiveAppRecord]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveAppRecord != nil {
                var tmp : [Any] = []
                for k in self.liveAppRecord! {
                    tmp.append(k.toMap())
                }
                map["LiveAppRecord"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveAppRecord") {
                self.liveAppRecord = dict["LiveAppRecord"] as! [DescribeLivePullStreamConfigResponseBody.LiveAppRecordList.LiveAppRecord]
            }
        }
    }
    public var liveAppRecordList: DescribeLivePullStreamConfigResponseBody.LiveAppRecordList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveAppRecordList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveAppRecordList != nil {
            map["LiveAppRecordList"] = self.liveAppRecordList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveAppRecordList") {
            var model = DescribeLivePullStreamConfigResponseBody.LiveAppRecordList()
            model.fromMap(dict["LiveAppRecordList"] as! [String: Any])
            self.liveAppRecordList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLivePullStreamConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLivePullStreamConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLivePullStreamConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveRealtimeDeliveryAccRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var logStore: String?

    public var ownerId: Int64?

    public var project: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.logStore != nil {
            map["LogStore"] = self.logStore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("LogStore") {
            self.logStore = dict["LogStore"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Project") {
            self.project = dict["Project"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveRealtimeDeliveryAccResponseBody : Tea.TeaModel {
    public class RealTimeDeliveryAccData : Tea.TeaModel {
        public class AccData : Tea.TeaModel {
            public var failedNum: Int32?

            public var successNum: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedNum != nil {
                    map["FailedNum"] = self.failedNum!
                }
                if self.successNum != nil {
                    map["SuccessNum"] = self.successNum!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FailedNum") {
                    self.failedNum = dict["FailedNum"] as! Int32
                }
                if dict.keys.contains("SuccessNum") {
                    self.successNum = dict["SuccessNum"] as! Int32
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var accData: [DescribeLiveRealtimeDeliveryAccResponseBody.RealTimeDeliveryAccData.AccData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accData != nil {
                var tmp : [Any] = []
                for k in self.accData! {
                    tmp.append(k.toMap())
                }
                map["AccData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccData") {
                self.accData = dict["AccData"] as! [DescribeLiveRealtimeDeliveryAccResponseBody.RealTimeDeliveryAccData.AccData]
            }
        }
    }
    public var realTimeDeliveryAccData: DescribeLiveRealtimeDeliveryAccResponseBody.RealTimeDeliveryAccData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeDeliveryAccData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.realTimeDeliveryAccData != nil {
            map["RealTimeDeliveryAccData"] = self.realTimeDeliveryAccData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RealTimeDeliveryAccData") {
            var model = DescribeLiveRealtimeDeliveryAccResponseBody.RealTimeDeliveryAccData()
            model.fromMap(dict["RealTimeDeliveryAccData"] as! [String: Any])
            self.realTimeDeliveryAccData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveRealtimeDeliveryAccResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRealtimeDeliveryAccResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveRealtimeDeliveryAccResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveRealtimeLogAuthorizedRequest : Tea.TeaModel {
    public var liveOpenapiReserve: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveOpenapiReserve != nil {
            map["LiveOpenapiReserve"] = self.liveOpenapiReserve!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveOpenapiReserve") {
            self.liveOpenapiReserve = dict["LiveOpenapiReserve"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveRealtimeLogAuthorizedResponseBody : Tea.TeaModel {
    public var authorizedStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizedStatus != nil {
            map["AuthorizedStatus"] = self.authorizedStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizedStatus") {
            self.authorizedStatus = dict["AuthorizedStatus"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveRealtimeLogAuthorizedResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRealtimeLogAuthorizedResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveRealtimeLogAuthorizedResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveRecordConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveRecordConfigResponseBody : Tea.TeaModel {
    public class LiveAppRecordList : Tea.TeaModel {
        public class LiveAppRecord : Tea.TeaModel {
            public class RecordFormatList : Tea.TeaModel {
                public class RecordFormat : Tea.TeaModel {
                    public var cycleDuration: Int32?

                    public var format: String?

                    public var ossObjectPrefix: String?

                    public var sliceDuration: Int32?

                    public var sliceOssObjectPrefix: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleDuration != nil {
                            map["CycleDuration"] = self.cycleDuration!
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.ossObjectPrefix != nil {
                            map["OssObjectPrefix"] = self.ossObjectPrefix!
                        }
                        if self.sliceDuration != nil {
                            map["SliceDuration"] = self.sliceDuration!
                        }
                        if self.sliceOssObjectPrefix != nil {
                            map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CycleDuration") {
                            self.cycleDuration = dict["CycleDuration"] as! Int32
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("OssObjectPrefix") {
                            self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                        }
                        if dict.keys.contains("SliceDuration") {
                            self.sliceDuration = dict["SliceDuration"] as! Int32
                        }
                        if dict.keys.contains("SliceOssObjectPrefix") {
                            self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                        }
                    }
                }
                public var recordFormat: [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.RecordFormatList.RecordFormat]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recordFormat != nil {
                        var tmp : [Any] = []
                        for k in self.recordFormat! {
                            tmp.append(k.toMap())
                        }
                        map["RecordFormat"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RecordFormat") {
                        self.recordFormat = dict["RecordFormat"] as! [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.RecordFormatList.RecordFormat]
                    }
                }
            }
            public class TranscodeRecordFormatList : Tea.TeaModel {
                public class RecordFormat : Tea.TeaModel {
                    public var cycleDuration: Int32?

                    public var format: String?

                    public var ossObjectPrefix: String?

                    public var sliceDuration: Int32?

                    public var sliceOssObjectPrefix: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleDuration != nil {
                            map["CycleDuration"] = self.cycleDuration!
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.ossObjectPrefix != nil {
                            map["OssObjectPrefix"] = self.ossObjectPrefix!
                        }
                        if self.sliceDuration != nil {
                            map["SliceDuration"] = self.sliceDuration!
                        }
                        if self.sliceOssObjectPrefix != nil {
                            map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CycleDuration") {
                            self.cycleDuration = dict["CycleDuration"] as! Int32
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("OssObjectPrefix") {
                            self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                        }
                        if dict.keys.contains("SliceDuration") {
                            self.sliceDuration = dict["SliceDuration"] as! Int32
                        }
                        if dict.keys.contains("SliceOssObjectPrefix") {
                            self.sliceOssObjectPrefix = dict["SliceOssObjectPrefix"] as! String
                        }
                    }
                }
                public var recordFormat: [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeRecordFormatList.RecordFormat]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recordFormat != nil {
                        var tmp : [Any] = []
                        for k in self.recordFormat! {
                            tmp.append(k.toMap())
                        }
                        map["RecordFormat"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RecordFormat") {
                        self.recordFormat = dict["RecordFormat"] as! [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeRecordFormatList.RecordFormat]
                    }
                }
            }
            public class TranscodeTemplates : Tea.TeaModel {
                public var templates: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.templates != nil {
                        map["Templates"] = self.templates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Templates") {
                        self.templates = dict["Templates"] as! [String]
                    }
                }
            }
            public var appName: String?

            public var createTime: String?

            public var domainName: String?

            public var endTime: String?

            public var onDemond: Int32?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var recordFormatList: DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.RecordFormatList?

            public var startTime: String?

            public var streamName: String?

            public var transcodeRecordFormatList: DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeRecordFormatList?

            public var transcodeTemplates: DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeTemplates?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.recordFormatList?.validate()
                try self.transcodeRecordFormatList?.validate()
                try self.transcodeTemplates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.onDemond != nil {
                    map["OnDemond"] = self.onDemond!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.recordFormatList != nil {
                    map["RecordFormatList"] = self.recordFormatList?.toMap()
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.transcodeRecordFormatList != nil {
                    map["TranscodeRecordFormatList"] = self.transcodeRecordFormatList?.toMap()
                }
                if self.transcodeTemplates != nil {
                    map["TranscodeTemplates"] = self.transcodeTemplates?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("OnDemond") {
                    self.onDemond = dict["OnDemond"] as! Int32
                }
                if dict.keys.contains("OssBucket") {
                    self.ossBucket = dict["OssBucket"] as! String
                }
                if dict.keys.contains("OssEndpoint") {
                    self.ossEndpoint = dict["OssEndpoint"] as! String
                }
                if dict.keys.contains("RecordFormatList") {
                    var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.RecordFormatList()
                    model.fromMap(dict["RecordFormatList"] as! [String: Any])
                    self.recordFormatList = model
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("TranscodeRecordFormatList") {
                    var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeRecordFormatList()
                    model.fromMap(dict["TranscodeRecordFormatList"] as! [String: Any])
                    self.transcodeRecordFormatList = model
                }
                if dict.keys.contains("TranscodeTemplates") {
                    var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeTemplates()
                    model.fromMap(dict["TranscodeTemplates"] as! [String: Any])
                    self.transcodeTemplates = model
                }
            }
        }
        public var liveAppRecord: [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveAppRecord != nil {
                var tmp : [Any] = []
                for k in self.liveAppRecord! {
                    tmp.append(k.toMap())
                }
                map["LiveAppRecord"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveAppRecord") {
                self.liveAppRecord = dict["LiveAppRecord"] as! [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord]
            }
        }
    }
    public var liveAppRecordList: DescribeLiveRecordConfigResponseBody.LiveAppRecordList?

    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveAppRecordList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveAppRecordList != nil {
            map["LiveAppRecordList"] = self.liveAppRecordList?.toMap()
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveAppRecordList") {
            var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList()
            model.fromMap(dict["LiveAppRecordList"] as! [String: Any])
            self.liveAppRecordList = model
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeLiveRecordConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRecordConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveRecordConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveRecordNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLiveRecordNotifyConfigResponseBody : Tea.TeaModel {
    public class LiveRecordNotifyConfig : Tea.TeaModel {
        public var domainName: String?

        public var needStatusNotify: Bool?

        public var notifyUrl: String?

        public var onDemandUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.needStatusNotify != nil {
                map["NeedStatusNotify"] = self.needStatusNotify!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.onDemandUrl != nil {
                map["OnDemandUrl"] = self.onDemandUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("NeedStatusNotify") {
                self.needStatusNotify = dict["NeedStatusNotify"] as! Bool
            }
            if dict.keys.contains("NotifyUrl") {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
            if dict.keys.contains("OnDemandUrl") {
                self.onDemandUrl = dict["OnDemandUrl"] as! String
            }
        }
    }
    public var liveRecordNotifyConfig: DescribeLiveRecordNotifyConfigResponseBody.LiveRecordNotifyConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveRecordNotifyConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordNotifyConfig != nil {
            map["LiveRecordNotifyConfig"] = self.liveRecordNotifyConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveRecordNotifyConfig") {
            var model = DescribeLiveRecordNotifyConfigResponseBody.LiveRecordNotifyConfig()
            model.fromMap(dict["LiveRecordNotifyConfig"] as! [String: Any])
            self.liveRecordNotifyConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveRecordNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRecordNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveRecordNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveRecordVodConfigsRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveRecordVodConfigsResponseBody : Tea.TeaModel {
    public class LiveRecordVodConfigs : Tea.TeaModel {
        public class LiveRecordVodConfig : Tea.TeaModel {
            public var appName: String?

            public var autoCompose: String?

            public var composeVodTranscodeGroupId: String?

            public var createTime: String?

            public var cycleDuration: Int32?

            public var domainName: String?

            public var streamName: String?

            public var vodTranscodeGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.autoCompose != nil {
                    map["AutoCompose"] = self.autoCompose!
                }
                if self.composeVodTranscodeGroupId != nil {
                    map["ComposeVodTranscodeGroupId"] = self.composeVodTranscodeGroupId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.vodTranscodeGroupId != nil {
                    map["VodTranscodeGroupId"] = self.vodTranscodeGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("AutoCompose") {
                    self.autoCompose = dict["AutoCompose"] as! String
                }
                if dict.keys.contains("ComposeVodTranscodeGroupId") {
                    self.composeVodTranscodeGroupId = dict["ComposeVodTranscodeGroupId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CycleDuration") {
                    self.cycleDuration = dict["CycleDuration"] as! Int32
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("VodTranscodeGroupId") {
                    self.vodTranscodeGroupId = dict["VodTranscodeGroupId"] as! String
                }
            }
        }
        public var liveRecordVodConfig: [DescribeLiveRecordVodConfigsResponseBody.LiveRecordVodConfigs.LiveRecordVodConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveRecordVodConfig != nil {
                var tmp : [Any] = []
                for k in self.liveRecordVodConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveRecordVodConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveRecordVodConfig") {
                self.liveRecordVodConfig = dict["LiveRecordVodConfig"] as! [DescribeLiveRecordVodConfigsResponseBody.LiveRecordVodConfigs.LiveRecordVodConfig]
            }
        }
    }
    public var liveRecordVodConfigs: DescribeLiveRecordVodConfigsResponseBody.LiveRecordVodConfigs?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveRecordVodConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordVodConfigs != nil {
            map["LiveRecordVodConfigs"] = self.liveRecordVodConfigs?.toMap()
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveRecordVodConfigs") {
            var model = DescribeLiveRecordVodConfigsResponseBody.LiveRecordVodConfigs()
            model.fromMap(dict["LiveRecordVodConfigs"] as! [String: Any])
            self.liveRecordVodConfigs = model
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! String
        }
    }
}

public class DescribeLiveRecordVodConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRecordVodConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveRecordVodConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveShiftConfigsRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveShiftConfigsResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class Config : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var ignoreTranscode: Bool?

            public var streamName: String?

            public var vision: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.ignoreTranscode != nil {
                    map["IgnoreTranscode"] = self.ignoreTranscode!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.vision != nil {
                    map["Vision"] = self.vision!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("IgnoreTranscode") {
                    self.ignoreTranscode = dict["IgnoreTranscode"] as! Bool
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("Vision") {
                    self.vision = dict["Vision"] as! Int32
                }
            }
        }
        public var config: [DescribeLiveShiftConfigsResponseBody.Content.Config]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                var tmp : [Any] = []
                for k in self.config! {
                    tmp.append(k.toMap())
                }
                map["Config"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! [DescribeLiveShiftConfigsResponseBody.Content.Config]
            }
        }
    }
    public var content: DescribeLiveShiftConfigsResponseBody.Content?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = DescribeLiveShiftConfigsResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveShiftConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveShiftConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveShiftConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveSnapshotConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLiveSnapshotConfigResponseBody : Tea.TeaModel {
    public class LiveStreamSnapshotConfigList : Tea.TeaModel {
        public class LiveStreamSnapshotConfig : Tea.TeaModel {
            public var appName: String?

            public var callback: String?

            public var createTime: String?

            public var domainName: String?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var overwriteOssObject: String?

            public var sequenceOssObject: String?

            public var timeInterval: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.callback != nil {
                    map["Callback"] = self.callback!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.overwriteOssObject != nil {
                    map["OverwriteOssObject"] = self.overwriteOssObject!
                }
                if self.sequenceOssObject != nil {
                    map["SequenceOssObject"] = self.sequenceOssObject!
                }
                if self.timeInterval != nil {
                    map["TimeInterval"] = self.timeInterval!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Callback") {
                    self.callback = dict["Callback"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("OssBucket") {
                    self.ossBucket = dict["OssBucket"] as! String
                }
                if dict.keys.contains("OssEndpoint") {
                    self.ossEndpoint = dict["OssEndpoint"] as! String
                }
                if dict.keys.contains("OverwriteOssObject") {
                    self.overwriteOssObject = dict["OverwriteOssObject"] as! String
                }
                if dict.keys.contains("SequenceOssObject") {
                    self.sequenceOssObject = dict["SequenceOssObject"] as! String
                }
                if dict.keys.contains("TimeInterval") {
                    self.timeInterval = dict["TimeInterval"] as! Int32
                }
            }
        }
        public var liveStreamSnapshotConfig: [DescribeLiveSnapshotConfigResponseBody.LiveStreamSnapshotConfigList.LiveStreamSnapshotConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamSnapshotConfig != nil {
                var tmp : [Any] = []
                for k in self.liveStreamSnapshotConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamSnapshotConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveStreamSnapshotConfig") {
                self.liveStreamSnapshotConfig = dict["LiveStreamSnapshotConfig"] as! [DescribeLiveSnapshotConfigResponseBody.LiveStreamSnapshotConfigList.LiveStreamSnapshotConfig]
            }
        }
    }
    public var liveStreamSnapshotConfigList: DescribeLiveSnapshotConfigResponseBody.LiveStreamSnapshotConfigList?

    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamSnapshotConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamSnapshotConfigList != nil {
            map["LiveStreamSnapshotConfigList"] = self.liveStreamSnapshotConfigList?.toMap()
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveStreamSnapshotConfigList") {
            var model = DescribeLiveSnapshotConfigResponseBody.LiveStreamSnapshotConfigList()
            model.fromMap(dict["LiveStreamSnapshotConfigList"] as! [String: Any])
            self.liveStreamSnapshotConfigList = model
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeLiveSnapshotConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveSnapshotConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveSnapshotConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveSnapshotDetectPornConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLiveSnapshotDetectPornConfigResponseBody : Tea.TeaModel {
    public class LiveSnapshotDetectPornConfigList : Tea.TeaModel {
        public class LiveSnapshotDetectPornConfig : Tea.TeaModel {
            public class Scenes : Tea.TeaModel {
                public var scene: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.scene != nil {
                        map["scene"] = self.scene!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("scene") {
                        self.scene = dict["scene"] as! [String]
                    }
                }
            }
            public var appName: String?

            public var domainName: String?

            public var interval: Int32?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var ossObject: String?

            public var scenes: DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList.LiveSnapshotDetectPornConfig.Scenes?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scenes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.ossObject != nil {
                    map["OssObject"] = self.ossObject!
                }
                if self.scenes != nil {
                    map["Scenes"] = self.scenes?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! Int32
                }
                if dict.keys.contains("OssBucket") {
                    self.ossBucket = dict["OssBucket"] as! String
                }
                if dict.keys.contains("OssEndpoint") {
                    self.ossEndpoint = dict["OssEndpoint"] as! String
                }
                if dict.keys.contains("OssObject") {
                    self.ossObject = dict["OssObject"] as! String
                }
                if dict.keys.contains("Scenes") {
                    var model = DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList.LiveSnapshotDetectPornConfig.Scenes()
                    model.fromMap(dict["Scenes"] as! [String: Any])
                    self.scenes = model
                }
            }
        }
        public var liveSnapshotDetectPornConfig: [DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList.LiveSnapshotDetectPornConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveSnapshotDetectPornConfig != nil {
                var tmp : [Any] = []
                for k in self.liveSnapshotDetectPornConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveSnapshotDetectPornConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveSnapshotDetectPornConfig") {
                self.liveSnapshotDetectPornConfig = dict["LiveSnapshotDetectPornConfig"] as! [DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList.LiveSnapshotDetectPornConfig]
            }
        }
    }
    public var liveSnapshotDetectPornConfigList: DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList?

    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveSnapshotDetectPornConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveSnapshotDetectPornConfigList != nil {
            map["LiveSnapshotDetectPornConfigList"] = self.liveSnapshotDetectPornConfigList?.toMap()
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveSnapshotDetectPornConfigList") {
            var model = DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList()
            model.fromMap(dict["LiveSnapshotDetectPornConfigList"] as! [String: Any])
            self.liveSnapshotDetectPornConfigList = model
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeLiveSnapshotDetectPornConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveSnapshotDetectPornConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveSnapshotDetectPornConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveSnapshotNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveSnapshotNotifyConfigResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var notifyAuthKey: String?

    public var notifyReqAuth: String?

    public var notifyUrl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("NotifyAuthKey") {
            self.notifyAuthKey = dict["NotifyAuthKey"] as! String
        }
        if dict.keys.contains("NotifyReqAuth") {
            self.notifyReqAuth = dict["NotifyReqAuth"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveSnapshotNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveSnapshotNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveSnapshotNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamAuthCheckingRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
    }
}

public class DescribeLiveStreamAuthCheckingResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeLiveStreamAuthCheckingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamAuthCheckingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamAuthCheckingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamBitRateDataRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveStreamBitRateDataResponseBody : Tea.TeaModel {
    public class FrameRateAndBitRateInfos : Tea.TeaModel {
        public class FrameRateAndBitRateInfo : Tea.TeaModel {
            public var audioFrameRate: Double?

            public var bitRate: Double?

            public var streamUrl: String?

            public var time: String?

            public var videoFrameRate: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioFrameRate != nil {
                    map["AudioFrameRate"] = self.audioFrameRate!
                }
                if self.bitRate != nil {
                    map["BitRate"] = self.bitRate!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.videoFrameRate != nil {
                    map["VideoFrameRate"] = self.videoFrameRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioFrameRate") {
                    self.audioFrameRate = dict["AudioFrameRate"] as! Double
                }
                if dict.keys.contains("BitRate") {
                    self.bitRate = dict["BitRate"] as! Double
                }
                if dict.keys.contains("StreamUrl") {
                    self.streamUrl = dict["StreamUrl"] as! String
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! String
                }
                if dict.keys.contains("VideoFrameRate") {
                    self.videoFrameRate = dict["VideoFrameRate"] as! Double
                }
            }
        }
        public var frameRateAndBitRateInfo: [DescribeLiveStreamBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.frameRateAndBitRateInfo != nil {
                var tmp : [Any] = []
                for k in self.frameRateAndBitRateInfo! {
                    tmp.append(k.toMap())
                }
                map["FrameRateAndBitRateInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FrameRateAndBitRateInfo") {
                self.frameRateAndBitRateInfo = dict["FrameRateAndBitRateInfo"] as! [DescribeLiveStreamBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo]
            }
        }
    }
    public var frameRateAndBitRateInfos: DescribeLiveStreamBitRateDataResponseBody.FrameRateAndBitRateInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.frameRateAndBitRateInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.frameRateAndBitRateInfos != nil {
            map["FrameRateAndBitRateInfos"] = self.frameRateAndBitRateInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FrameRateAndBitRateInfos") {
            var model = DescribeLiveStreamBitRateDataResponseBody.FrameRateAndBitRateInfos()
            model.fromMap(dict["FrameRateAndBitRateInfos"] as! [String: Any])
            self.frameRateAndBitRateInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamBitRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamBitRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamBitRateDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamCountRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveStreamCountResponseBody : Tea.TeaModel {
    public class StreamCountInfos : Tea.TeaModel {
        public class StreamCountInfo : Tea.TeaModel {
            public class StreamCountDetails : Tea.TeaModel {
                public class StreamCountDetail : Tea.TeaModel {
                    public var count: Int64?

                    public var format: String?

                    public var videoDataRate: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.videoDataRate != nil {
                            map["VideoDataRate"] = self.videoDataRate!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int64
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("VideoDataRate") {
                            self.videoDataRate = dict["VideoDataRate"] as! Int64
                        }
                    }
                }
                public var streamCountDetail: [DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo.StreamCountDetails.StreamCountDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.streamCountDetail != nil {
                        var tmp : [Any] = []
                        for k in self.streamCountDetail! {
                            tmp.append(k.toMap())
                        }
                        map["StreamCountDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StreamCountDetail") {
                        self.streamCountDetail = dict["StreamCountDetail"] as! [DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo.StreamCountDetails.StreamCountDetail]
                    }
                }
            }
            public var count: Int64?

            public var limit: Int64?

            public var streamCountDetails: DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo.StreamCountDetails?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.streamCountDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.limit != nil {
                    map["Limit"] = self.limit!
                }
                if self.streamCountDetails != nil {
                    map["StreamCountDetails"] = self.streamCountDetails?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("Limit") {
                    self.limit = dict["Limit"] as! Int64
                }
                if dict.keys.contains("StreamCountDetails") {
                    var model = DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo.StreamCountDetails()
                    model.fromMap(dict["StreamCountDetails"] as! [String: Any])
                    self.streamCountDetails = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var streamCountInfo: [DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamCountInfo != nil {
                var tmp : [Any] = []
                for k in self.streamCountInfo! {
                    tmp.append(k.toMap())
                }
                map["StreamCountInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StreamCountInfo") {
                self.streamCountInfo = dict["StreamCountInfo"] as! [DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo]
            }
        }
    }
    public var requestId: String?

    public var streamCountInfos: DescribeLiveStreamCountResponseBody.StreamCountInfos?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamCountInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamCountInfos != nil {
            map["StreamCountInfos"] = self.streamCountInfos?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StreamCountInfos") {
            var model = DescribeLiveStreamCountResponseBody.StreamCountInfos()
            model.fromMap(dict["StreamCountInfos"] as! [String: Any])
            self.streamCountInfos = model
        }
    }
}

public class DescribeLiveStreamCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamDelayConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveStreamDelayConfigResponseBody : Tea.TeaModel {
    public class LiveStreamFlvDelayConfig : Tea.TeaModel {
        public var delay: Int32?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! Int32
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
        }
    }
    public class LiveStreamHlsDelayConfig : Tea.TeaModel {
        public var delay: Int32?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! Int32
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
        }
    }
    public class LiveStreamRtmpDelayConfig : Tea.TeaModel {
        public var delay: Int32?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Delay") {
                self.delay = dict["Delay"] as! Int32
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
        }
    }
    public var liveStreamFlvDelayConfig: DescribeLiveStreamDelayConfigResponseBody.LiveStreamFlvDelayConfig?

    public var liveStreamHlsDelayConfig: DescribeLiveStreamDelayConfigResponseBody.LiveStreamHlsDelayConfig?

    public var liveStreamRtmpDelayConfig: DescribeLiveStreamDelayConfigResponseBody.LiveStreamRtmpDelayConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamFlvDelayConfig?.validate()
        try self.liveStreamHlsDelayConfig?.validate()
        try self.liveStreamRtmpDelayConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamFlvDelayConfig != nil {
            map["LiveStreamFlvDelayConfig"] = self.liveStreamFlvDelayConfig?.toMap()
        }
        if self.liveStreamHlsDelayConfig != nil {
            map["LiveStreamHlsDelayConfig"] = self.liveStreamHlsDelayConfig?.toMap()
        }
        if self.liveStreamRtmpDelayConfig != nil {
            map["LiveStreamRtmpDelayConfig"] = self.liveStreamRtmpDelayConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveStreamFlvDelayConfig") {
            var model = DescribeLiveStreamDelayConfigResponseBody.LiveStreamFlvDelayConfig()
            model.fromMap(dict["LiveStreamFlvDelayConfig"] as! [String: Any])
            self.liveStreamFlvDelayConfig = model
        }
        if dict.keys.contains("LiveStreamHlsDelayConfig") {
            var model = DescribeLiveStreamDelayConfigResponseBody.LiveStreamHlsDelayConfig()
            model.fromMap(dict["LiveStreamHlsDelayConfig"] as! [String: Any])
            self.liveStreamHlsDelayConfig = model
        }
        if dict.keys.contains("LiveStreamRtmpDelayConfig") {
            var model = DescribeLiveStreamDelayConfigResponseBody.LiveStreamRtmpDelayConfig()
            model.fromMap(dict["LiveStreamRtmpDelayConfig"] as! [String: Any])
            self.liveStreamRtmpDelayConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamDelayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamDelayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamDelayConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamHistoryUserNumRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveStreamHistoryUserNumResponseBody : Tea.TeaModel {
    public class LiveStreamUserNumInfos : Tea.TeaModel {
        public class LiveStreamUserNumInfo : Tea.TeaModel {
            public var streamTime: String?

            public var userNum: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamTime != nil {
                    map["StreamTime"] = self.streamTime!
                }
                if self.userNum != nil {
                    map["UserNum"] = self.userNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("StreamTime") {
                    self.streamTime = dict["StreamTime"] as! String
                }
                if dict.keys.contains("UserNum") {
                    self.userNum = dict["UserNum"] as! String
                }
            }
        }
        public var liveStreamUserNumInfo: [DescribeLiveStreamHistoryUserNumResponseBody.LiveStreamUserNumInfos.LiveStreamUserNumInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamUserNumInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamUserNumInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamUserNumInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveStreamUserNumInfo") {
                self.liveStreamUserNumInfo = dict["LiveStreamUserNumInfo"] as! [DescribeLiveStreamHistoryUserNumResponseBody.LiveStreamUserNumInfos.LiveStreamUserNumInfo]
            }
        }
    }
    public var liveStreamUserNumInfos: DescribeLiveStreamHistoryUserNumResponseBody.LiveStreamUserNumInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamUserNumInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamUserNumInfos != nil {
            map["LiveStreamUserNumInfos"] = self.liveStreamUserNumInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveStreamUserNumInfos") {
            var model = DescribeLiveStreamHistoryUserNumResponseBody.LiveStreamUserNumInfos()
            model.fromMap(dict["LiveStreamUserNumInfos"] as! [String: Any])
            self.liveStreamUserNumInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamHistoryUserNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamHistoryUserNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamHistoryUserNumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamMetricDetailDataRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var nextPageToken: String?

    public var ownerId: Int64?

    public var protocol_: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Protocol") {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveStreamMetricDetailDataResponseBody : Tea.TeaModel {
    public class StreamDetailData : Tea.TeaModel {
        public class StreamData : Tea.TeaModel {
            public var appName: String?

            public var bps: Double?

            public var count: Int64?

            public var flvBps: Double?

            public var flvCount: Int64?

            public var flvTraffic: Int64?

            public var hlsBps: Double?

            public var hlsCount: Int64?

            public var hlsTraffic: Int64?

            public var p2pBps: Double?

            public var p2pCount: Int64?

            public var p2pTraffic: Int64?

            public var rtmpBps: Double?

            public var rtmpCount: Int64?

            public var rtmpTraffic: Int64?

            public var rtsBps: Double?

            public var rtsCount: Int64?

            public var rtsTraffic: Int64?

            public var streamName: String?

            public var timeStamp: String?

            public var traffic: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.bps != nil {
                    map["Bps"] = self.bps!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.flvBps != nil {
                    map["FlvBps"] = self.flvBps!
                }
                if self.flvCount != nil {
                    map["FlvCount"] = self.flvCount!
                }
                if self.flvTraffic != nil {
                    map["FlvTraffic"] = self.flvTraffic!
                }
                if self.hlsBps != nil {
                    map["HlsBps"] = self.hlsBps!
                }
                if self.hlsCount != nil {
                    map["HlsCount"] = self.hlsCount!
                }
                if self.hlsTraffic != nil {
                    map["HlsTraffic"] = self.hlsTraffic!
                }
                if self.p2pBps != nil {
                    map["P2pBps"] = self.p2pBps!
                }
                if self.p2pCount != nil {
                    map["P2pCount"] = self.p2pCount!
                }
                if self.p2pTraffic != nil {
                    map["P2pTraffic"] = self.p2pTraffic!
                }
                if self.rtmpBps != nil {
                    map["RtmpBps"] = self.rtmpBps!
                }
                if self.rtmpCount != nil {
                    map["RtmpCount"] = self.rtmpCount!
                }
                if self.rtmpTraffic != nil {
                    map["RtmpTraffic"] = self.rtmpTraffic!
                }
                if self.rtsBps != nil {
                    map["RtsBps"] = self.rtsBps!
                }
                if self.rtsCount != nil {
                    map["RtsCount"] = self.rtsCount!
                }
                if self.rtsTraffic != nil {
                    map["RtsTraffic"] = self.rtsTraffic!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.traffic != nil {
                    map["Traffic"] = self.traffic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Bps") {
                    self.bps = dict["Bps"] as! Double
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("FlvBps") {
                    self.flvBps = dict["FlvBps"] as! Double
                }
                if dict.keys.contains("FlvCount") {
                    self.flvCount = dict["FlvCount"] as! Int64
                }
                if dict.keys.contains("FlvTraffic") {
                    self.flvTraffic = dict["FlvTraffic"] as! Int64
                }
                if dict.keys.contains("HlsBps") {
                    self.hlsBps = dict["HlsBps"] as! Double
                }
                if dict.keys.contains("HlsCount") {
                    self.hlsCount = dict["HlsCount"] as! Int64
                }
                if dict.keys.contains("HlsTraffic") {
                    self.hlsTraffic = dict["HlsTraffic"] as! Int64
                }
                if dict.keys.contains("P2pBps") {
                    self.p2pBps = dict["P2pBps"] as! Double
                }
                if dict.keys.contains("P2pCount") {
                    self.p2pCount = dict["P2pCount"] as! Int64
                }
                if dict.keys.contains("P2pTraffic") {
                    self.p2pTraffic = dict["P2pTraffic"] as! Int64
                }
                if dict.keys.contains("RtmpBps") {
                    self.rtmpBps = dict["RtmpBps"] as! Double
                }
                if dict.keys.contains("RtmpCount") {
                    self.rtmpCount = dict["RtmpCount"] as! Int64
                }
                if dict.keys.contains("RtmpTraffic") {
                    self.rtmpTraffic = dict["RtmpTraffic"] as! Int64
                }
                if dict.keys.contains("RtsBps") {
                    self.rtsBps = dict["RtsBps"] as! Double
                }
                if dict.keys.contains("RtsCount") {
                    self.rtsCount = dict["RtsCount"] as! Int64
                }
                if dict.keys.contains("RtsTraffic") {
                    self.rtsTraffic = dict["RtsTraffic"] as! Int64
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
                if dict.keys.contains("Traffic") {
                    self.traffic = dict["Traffic"] as! Int64
                }
            }
        }
        public var streamData: [DescribeLiveStreamMetricDetailDataResponseBody.StreamDetailData.StreamData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamData != nil {
                var tmp : [Any] = []
                for k in self.streamData! {
                    tmp.append(k.toMap())
                }
                map["StreamData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StreamData") {
                self.streamData = dict["StreamData"] as! [DescribeLiveStreamMetricDetailDataResponseBody.StreamDetailData.StreamData]
            }
        }
    }
    public var domainName: String?

    public var endTime: String?

    public var nextPageToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var startTime: String?

    public var streamDetailData: DescribeLiveStreamMetricDetailDataResponseBody.StreamDetailData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamDetailData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamDetailData != nil {
            map["StreamDetailData"] = self.streamDetailData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamDetailData") {
            var model = DescribeLiveStreamMetricDetailDataResponseBody.StreamDetailData()
            model.fromMap(dict["StreamDetailData"] as! [String: Any])
            self.streamDetailData = model
        }
    }
}

public class DescribeLiveStreamMetricDetailDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamMetricDetailDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamMetricDetailDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamMonitorListRequest : Tea.TeaModel {
    public var monitorId: String?

    public var orderRule: Int32?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.orderRule != nil {
            map["OrderRule"] = self.orderRule!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorId") {
            self.monitorId = dict["MonitorId"] as! String
        }
        if dict.keys.contains("OrderRule") {
            self.orderRule = dict["OrderRule"] as! Int32
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class DescribeLiveStreamMonitorListResponseBody : Tea.TeaModel {
    public class LiveStreamMonitorList : Tea.TeaModel {
        public class InputList : Tea.TeaModel {
            public class LayoutConfig : Tea.TeaModel {
                public var fillMode: String?

                public var positionNormalized: [Double]?

                public var positionRefer: String?

                public var sizeNormalized: [Double]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fillMode != nil {
                        map["FillMode"] = self.fillMode!
                    }
                    if self.positionNormalized != nil {
                        map["PositionNormalized"] = self.positionNormalized!
                    }
                    if self.positionRefer != nil {
                        map["PositionRefer"] = self.positionRefer!
                    }
                    if self.sizeNormalized != nil {
                        map["SizeNormalized"] = self.sizeNormalized!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FillMode") {
                        self.fillMode = dict["FillMode"] as! String
                    }
                    if dict.keys.contains("PositionNormalized") {
                        self.positionNormalized = dict["PositionNormalized"] as! [Double]
                    }
                    if dict.keys.contains("PositionRefer") {
                        self.positionRefer = dict["PositionRefer"] as! String
                    }
                    if dict.keys.contains("SizeNormalized") {
                        self.sizeNormalized = dict["SizeNormalized"] as! [Double]
                    }
                }
            }
            public class PlayConfig : Tea.TeaModel {
                public var volumeRate: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.volumeRate != nil {
                        map["VolumeRate"] = self.volumeRate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VolumeRate") {
                        self.volumeRate = dict["VolumeRate"] as! Double
                    }
                }
            }
            public var index: Int32?

            public var inputUrl: String?

            public var layoutConfig: DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList.LayoutConfig?

            public var layoutId: Int32?

            public var playConfig: DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList.PlayConfig?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.layoutConfig?.validate()
                try self.playConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.layoutConfig != nil {
                    map["LayoutConfig"] = self.layoutConfig?.toMap()
                }
                if self.layoutId != nil {
                    map["LayoutId"] = self.layoutId!
                }
                if self.playConfig != nil {
                    map["PlayConfig"] = self.playConfig?.toMap()
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! Int32
                }
                if dict.keys.contains("InputUrl") {
                    self.inputUrl = dict["InputUrl"] as! String
                }
                if dict.keys.contains("LayoutConfig") {
                    var model = DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList.LayoutConfig()
                    model.fromMap(dict["LayoutConfig"] as! [String: Any])
                    self.layoutConfig = model
                }
                if dict.keys.contains("LayoutId") {
                    self.layoutId = dict["LayoutId"] as! Int32
                }
                if dict.keys.contains("PlayConfig") {
                    var model = DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList.PlayConfig()
                    model.fromMap(dict["PlayConfig"] as! [String: Any])
                    self.playConfig = model
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public class OutputUrls : Tea.TeaModel {
            public var flvUrl: String?

            public var rtmpUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flvUrl != nil {
                    map["FlvUrl"] = self.flvUrl!
                }
                if self.rtmpUrl != nil {
                    map["RtmpUrl"] = self.rtmpUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FlvUrl") {
                    self.flvUrl = dict["FlvUrl"] as! String
                }
                if dict.keys.contains("RtmpUrl") {
                    self.rtmpUrl = dict["RtmpUrl"] as! String
                }
            }
        }
        public var audioFrom: Int32?

        public var domain: String?

        public var inputList: [DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList]?

        public var monitorId: String?

        public var monitorName: String?

        public var outputTemplate: String?

        public var outputUrls: DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.OutputUrls?

        public var region: String?

        public var startTime: String?

        public var status: Int32?

        public var stopTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputUrls?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioFrom != nil {
                map["AudioFrom"] = self.audioFrom!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.inputList != nil {
                var tmp : [Any] = []
                for k in self.inputList! {
                    tmp.append(k.toMap())
                }
                map["InputList"] = tmp
            }
            if self.monitorId != nil {
                map["MonitorId"] = self.monitorId!
            }
            if self.monitorName != nil {
                map["MonitorName"] = self.monitorName!
            }
            if self.outputTemplate != nil {
                map["OutputTemplate"] = self.outputTemplate!
            }
            if self.outputUrls != nil {
                map["OutputUrls"] = self.outputUrls?.toMap()
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopTime != nil {
                map["StopTime"] = self.stopTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioFrom") {
                self.audioFrom = dict["AudioFrom"] as! Int32
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("InputList") {
                self.inputList = dict["InputList"] as! [DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList]
            }
            if dict.keys.contains("MonitorId") {
                self.monitorId = dict["MonitorId"] as! String
            }
            if dict.keys.contains("MonitorName") {
                self.monitorName = dict["MonitorName"] as! String
            }
            if dict.keys.contains("OutputTemplate") {
                self.outputTemplate = dict["OutputTemplate"] as! String
            }
            if dict.keys.contains("OutputUrls") {
                var model = DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.OutputUrls()
                model.fromMap(dict["OutputUrls"] as! [String: Any])
                self.outputUrls = model
            }
            if dict.keys.contains("Region") {
                self.region = dict["Region"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("StopTime") {
                self.stopTime = dict["StopTime"] as! String
            }
        }
    }
    public var liveStreamMonitorList: [DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamMonitorList != nil {
            var tmp : [Any] = []
            for k in self.liveStreamMonitorList! {
                tmp.append(k.toMap())
            }
            map["LiveStreamMonitorList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveStreamMonitorList") {
            self.liveStreamMonitorList = dict["LiveStreamMonitorList"] as! [DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeLiveStreamMonitorListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamMonitorListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamMonitorListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamOptimizedFeatureConfigRequest : Tea.TeaModel {
    public var configName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configName != nil {
            map["ConfigName"] = self.configName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigName") {
            self.configName = dict["ConfigName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveStreamOptimizedFeatureConfigResponseBody : Tea.TeaModel {
    public class LiveStreamOptimizedFeatureConfigList : Tea.TeaModel {
        public class LiveStreamOptimizedFeatureConfig : Tea.TeaModel {
            public var configName: String?

            public var configStatus: String?

            public var configValue: String?

            public var domainName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configName != nil {
                    map["ConfigName"] = self.configName!
                }
                if self.configStatus != nil {
                    map["ConfigStatus"] = self.configStatus!
                }
                if self.configValue != nil {
                    map["ConfigValue"] = self.configValue!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigName") {
                    self.configName = dict["ConfigName"] as! String
                }
                if dict.keys.contains("ConfigStatus") {
                    self.configStatus = dict["ConfigStatus"] as! String
                }
                if dict.keys.contains("ConfigValue") {
                    self.configValue = dict["ConfigValue"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
            }
        }
        public var liveStreamOptimizedFeatureConfig: [DescribeLiveStreamOptimizedFeatureConfigResponseBody.LiveStreamOptimizedFeatureConfigList.LiveStreamOptimizedFeatureConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamOptimizedFeatureConfig != nil {
                var tmp : [Any] = []
                for k in self.liveStreamOptimizedFeatureConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamOptimizedFeatureConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveStreamOptimizedFeatureConfig") {
                self.liveStreamOptimizedFeatureConfig = dict["LiveStreamOptimizedFeatureConfig"] as! [DescribeLiveStreamOptimizedFeatureConfigResponseBody.LiveStreamOptimizedFeatureConfigList.LiveStreamOptimizedFeatureConfig]
            }
        }
    }
    public var liveStreamOptimizedFeatureConfigList: DescribeLiveStreamOptimizedFeatureConfigResponseBody.LiveStreamOptimizedFeatureConfigList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamOptimizedFeatureConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamOptimizedFeatureConfigList != nil {
            map["LiveStreamOptimizedFeatureConfigList"] = self.liveStreamOptimizedFeatureConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveStreamOptimizedFeatureConfigList") {
            var model = DescribeLiveStreamOptimizedFeatureConfigResponseBody.LiveStreamOptimizedFeatureConfigList()
            model.fromMap(dict["LiveStreamOptimizedFeatureConfigList"] as! [String: Any])
            self.liveStreamOptimizedFeatureConfigList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamOptimizedFeatureConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamOptimizedFeatureConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamOptimizedFeatureConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamRecordContentRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveStreamRecordContentResponseBody : Tea.TeaModel {
    public class RecordContentInfoList : Tea.TeaModel {
        public class RecordContentInfo : Tea.TeaModel {
            public var duration: Double?

            public var endTime: String?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var ossObjectPrefix: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("OssBucket") {
                    self.ossBucket = dict["OssBucket"] as! String
                }
                if dict.keys.contains("OssEndpoint") {
                    self.ossEndpoint = dict["OssEndpoint"] as! String
                }
                if dict.keys.contains("OssObjectPrefix") {
                    self.ossObjectPrefix = dict["OssObjectPrefix"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var recordContentInfo: [DescribeLiveStreamRecordContentResponseBody.RecordContentInfoList.RecordContentInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordContentInfo != nil {
                var tmp : [Any] = []
                for k in self.recordContentInfo! {
                    tmp.append(k.toMap())
                }
                map["RecordContentInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordContentInfo") {
                self.recordContentInfo = dict["RecordContentInfo"] as! [DescribeLiveStreamRecordContentResponseBody.RecordContentInfoList.RecordContentInfo]
            }
        }
    }
    public var recordContentInfoList: DescribeLiveStreamRecordContentResponseBody.RecordContentInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordContentInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordContentInfoList != nil {
            map["RecordContentInfoList"] = self.recordContentInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordContentInfoList") {
            var model = DescribeLiveStreamRecordContentResponseBody.RecordContentInfoList()
            model.fromMap(dict["RecordContentInfoList"] as! [String: Any])
            self.recordContentInfoList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamRecordContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamRecordContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamRecordContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamRecordIndexFileRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var recordId: String?

    public var securityToken: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RecordId") {
            self.recordId = dict["RecordId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveStreamRecordIndexFileResponseBody : Tea.TeaModel {
    public class RecordIndexInfo : Tea.TeaModel {
        public var appName: String?

        public var createTime: String?

        public var domainName: String?

        public var duration: Double?

        public var endTime: String?

        public var height: Int32?

        public var ossBucket: String?

        public var ossEndpoint: String?

        public var ossObject: String?

        public var recordId: String?

        public var recordUrl: String?

        public var startTime: String?

        public var streamName: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.ossObject != nil {
                map["OssObject"] = self.ossObject!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordUrl != nil {
                map["RecordUrl"] = self.recordUrl!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Double
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("OssBucket") {
                self.ossBucket = dict["OssBucket"] as! String
            }
            if dict.keys.contains("OssEndpoint") {
                self.ossEndpoint = dict["OssEndpoint"] as! String
            }
            if dict.keys.contains("OssObject") {
                self.ossObject = dict["OssObject"] as! String
            }
            if dict.keys.contains("RecordId") {
                self.recordId = dict["RecordId"] as! String
            }
            if dict.keys.contains("RecordUrl") {
                self.recordUrl = dict["RecordUrl"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! Int32
            }
        }
    }
    public var recordIndexInfo: DescribeLiveStreamRecordIndexFileResponseBody.RecordIndexInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordIndexInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordIndexInfo != nil {
            map["RecordIndexInfo"] = self.recordIndexInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordIndexInfo") {
            var model = DescribeLiveStreamRecordIndexFileResponseBody.RecordIndexInfo()
            model.fromMap(dict["RecordIndexInfo"] as! [String: Any])
            self.recordIndexInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamRecordIndexFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamRecordIndexFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamRecordIndexFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamRecordIndexFilesRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveStreamRecordIndexFilesResponseBody : Tea.TeaModel {
    public class RecordIndexInfoList : Tea.TeaModel {
        public class RecordIndexInfo : Tea.TeaModel {
            public var appName: String?

            public var createTime: String?

            public var domainName: String?

            public var duration: Double?

            public var endTime: String?

            public var height: Int32?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var ossObject: String?

            public var recordId: String?

            public var recordUrl: String?

            public var startTime: String?

            public var streamName: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.ossObject != nil {
                    map["OssObject"] = self.ossObject!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.recordUrl != nil {
                    map["RecordUrl"] = self.recordUrl!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Double
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("OssBucket") {
                    self.ossBucket = dict["OssBucket"] as! String
                }
                if dict.keys.contains("OssEndpoint") {
                    self.ossEndpoint = dict["OssEndpoint"] as! String
                }
                if dict.keys.contains("OssObject") {
                    self.ossObject = dict["OssObject"] as! String
                }
                if dict.keys.contains("RecordId") {
                    self.recordId = dict["RecordId"] as! String
                }
                if dict.keys.contains("RecordUrl") {
                    self.recordUrl = dict["RecordUrl"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var recordIndexInfo: [DescribeLiveStreamRecordIndexFilesResponseBody.RecordIndexInfoList.RecordIndexInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordIndexInfo != nil {
                var tmp : [Any] = []
                for k in self.recordIndexInfo! {
                    tmp.append(k.toMap())
                }
                map["RecordIndexInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecordIndexInfo") {
                self.recordIndexInfo = dict["RecordIndexInfo"] as! [DescribeLiveStreamRecordIndexFilesResponseBody.RecordIndexInfoList.RecordIndexInfo]
            }
        }
    }
    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var recordIndexInfoList: DescribeLiveStreamRecordIndexFilesResponseBody.RecordIndexInfoList?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordIndexInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordIndexInfoList != nil {
            map["RecordIndexInfoList"] = self.recordIndexInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RecordIndexInfoList") {
            var model = DescribeLiveStreamRecordIndexFilesResponseBody.RecordIndexInfoList()
            model.fromMap(dict["RecordIndexInfoList"] as! [String: Any])
            self.recordIndexInfoList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeLiveStreamRecordIndexFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamRecordIndexFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamRecordIndexFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamSnapshotInfoRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var limit: Int32?

    public var order: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveStreamSnapshotInfoResponseBody : Tea.TeaModel {
    public class LiveStreamSnapshotInfoList : Tea.TeaModel {
        public class LiveStreamSnapshotInfo : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var isOverlay: Bool?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var ossObject: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.isOverlay != nil {
                    map["IsOverlay"] = self.isOverlay!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.ossObject != nil {
                    map["OssObject"] = self.ossObject!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateTimestamp") {
                    self.createTimestamp = dict["CreateTimestamp"] as! Int64
                }
                if dict.keys.contains("IsOverlay") {
                    self.isOverlay = dict["IsOverlay"] as! Bool
                }
                if dict.keys.contains("OssBucket") {
                    self.ossBucket = dict["OssBucket"] as! String
                }
                if dict.keys.contains("OssEndpoint") {
                    self.ossEndpoint = dict["OssEndpoint"] as! String
                }
                if dict.keys.contains("OssObject") {
                    self.ossObject = dict["OssObject"] as! String
                }
            }
        }
        public var liveStreamSnapshotInfo: [DescribeLiveStreamSnapshotInfoResponseBody.LiveStreamSnapshotInfoList.LiveStreamSnapshotInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamSnapshotInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamSnapshotInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamSnapshotInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveStreamSnapshotInfo") {
                self.liveStreamSnapshotInfo = dict["LiveStreamSnapshotInfo"] as! [DescribeLiveStreamSnapshotInfoResponseBody.LiveStreamSnapshotInfoList.LiveStreamSnapshotInfo]
            }
        }
    }
    public var liveStreamSnapshotInfoList: DescribeLiveStreamSnapshotInfoResponseBody.LiveStreamSnapshotInfoList?

    public var nextStartTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamSnapshotInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamSnapshotInfoList != nil {
            map["LiveStreamSnapshotInfoList"] = self.liveStreamSnapshotInfoList?.toMap()
        }
        if self.nextStartTime != nil {
            map["NextStartTime"] = self.nextStartTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveStreamSnapshotInfoList") {
            var model = DescribeLiveStreamSnapshotInfoResponseBody.LiveStreamSnapshotInfoList()
            model.fromMap(dict["LiveStreamSnapshotInfoList"] as! [String: Any])
            self.liveStreamSnapshotInfoList = model
        }
        if dict.keys.contains("NextStartTime") {
            self.nextStartTime = dict["NextStartTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamSnapshotInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamSnapshotInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamSnapshotInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamStateRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveStreamStateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var streamState: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamState != nil {
            map["StreamState"] = self.streamState!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StreamState") {
            self.streamState = dict["StreamState"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeLiveStreamStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamTranscodeInfoRequest : Tea.TeaModel {
    public var domainTranscodeName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainTranscodeName != nil {
            map["DomainTranscodeName"] = self.domainTranscodeName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainTranscodeName") {
            self.domainTranscodeName = dict["DomainTranscodeName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveStreamTranscodeInfoResponseBody : Tea.TeaModel {
    public class DomainTranscodeList : Tea.TeaModel {
        public class DomainTranscodeInfo : Tea.TeaModel {
            public class CustomTranscodeParameters : Tea.TeaModel {
                public var audioBitrate: Int32?

                public var audioChannelNum: Int32?

                public var audioCodec: String?

                public var audioProfile: String?

                public var audioRate: Int32?

                public var bframes: String?

                public var FPS: Int32?

                public var gop: String?

                public var height: Int32?

                public var rtsFlag: String?

                public var templateType: String?

                public var videoBitrate: Int32?

                public var videoProfile: String?

                public var width: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioBitrate != nil {
                        map["AudioBitrate"] = self.audioBitrate!
                    }
                    if self.audioChannelNum != nil {
                        map["AudioChannelNum"] = self.audioChannelNum!
                    }
                    if self.audioCodec != nil {
                        map["AudioCodec"] = self.audioCodec!
                    }
                    if self.audioProfile != nil {
                        map["AudioProfile"] = self.audioProfile!
                    }
                    if self.audioRate != nil {
                        map["AudioRate"] = self.audioRate!
                    }
                    if self.bframes != nil {
                        map["Bframes"] = self.bframes!
                    }
                    if self.FPS != nil {
                        map["FPS"] = self.FPS!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.rtsFlag != nil {
                        map["RtsFlag"] = self.rtsFlag!
                    }
                    if self.templateType != nil {
                        map["TemplateType"] = self.templateType!
                    }
                    if self.videoBitrate != nil {
                        map["VideoBitrate"] = self.videoBitrate!
                    }
                    if self.videoProfile != nil {
                        map["VideoProfile"] = self.videoProfile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioBitrate") {
                        self.audioBitrate = dict["AudioBitrate"] as! Int32
                    }
                    if dict.keys.contains("AudioChannelNum") {
                        self.audioChannelNum = dict["AudioChannelNum"] as! Int32
                    }
                    if dict.keys.contains("AudioCodec") {
                        self.audioCodec = dict["AudioCodec"] as! String
                    }
                    if dict.keys.contains("AudioProfile") {
                        self.audioProfile = dict["AudioProfile"] as! String
                    }
                    if dict.keys.contains("AudioRate") {
                        self.audioRate = dict["AudioRate"] as! Int32
                    }
                    if dict.keys.contains("Bframes") {
                        self.bframes = dict["Bframes"] as! String
                    }
                    if dict.keys.contains("FPS") {
                        self.FPS = dict["FPS"] as! Int32
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! Int32
                    }
                    if dict.keys.contains("RtsFlag") {
                        self.rtsFlag = dict["RtsFlag"] as! String
                    }
                    if dict.keys.contains("TemplateType") {
                        self.templateType = dict["TemplateType"] as! String
                    }
                    if dict.keys.contains("VideoBitrate") {
                        self.videoBitrate = dict["VideoBitrate"] as! Int32
                    }
                    if dict.keys.contains("VideoProfile") {
                        self.videoProfile = dict["VideoProfile"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! Int32
                    }
                }
            }
            public class EncryptParameters : Tea.TeaModel {
                public var encryptType: String?

                public var kmsKeyExpireInterval: String?

                public var kmsKeyID: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.encryptType != nil {
                        map["EncryptType"] = self.encryptType!
                    }
                    if self.kmsKeyExpireInterval != nil {
                        map["KmsKeyExpireInterval"] = self.kmsKeyExpireInterval!
                    }
                    if self.kmsKeyID != nil {
                        map["KmsKeyID"] = self.kmsKeyID!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EncryptType") {
                        self.encryptType = dict["EncryptType"] as! String
                    }
                    if dict.keys.contains("KmsKeyExpireInterval") {
                        self.kmsKeyExpireInterval = dict["KmsKeyExpireInterval"] as! String
                    }
                    if dict.keys.contains("KmsKeyID") {
                        self.kmsKeyID = dict["KmsKeyID"] as! String
                    }
                }
            }
            public var customTranscodeParameters: DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo.CustomTranscodeParameters?

            public var encryptParameters: DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo.EncryptParameters?

            public var isLazy: Bool?

            public var transcodeApp: String?

            public var transcodeName: String?

            public var transcodeTemplate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.customTranscodeParameters?.validate()
                try self.encryptParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customTranscodeParameters != nil {
                    map["CustomTranscodeParameters"] = self.customTranscodeParameters?.toMap()
                }
                if self.encryptParameters != nil {
                    map["EncryptParameters"] = self.encryptParameters?.toMap()
                }
                if self.isLazy != nil {
                    map["IsLazy"] = self.isLazy!
                }
                if self.transcodeApp != nil {
                    map["TranscodeApp"] = self.transcodeApp!
                }
                if self.transcodeName != nil {
                    map["TranscodeName"] = self.transcodeName!
                }
                if self.transcodeTemplate != nil {
                    map["TranscodeTemplate"] = self.transcodeTemplate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomTranscodeParameters") {
                    var model = DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo.CustomTranscodeParameters()
                    model.fromMap(dict["CustomTranscodeParameters"] as! [String: Any])
                    self.customTranscodeParameters = model
                }
                if dict.keys.contains("EncryptParameters") {
                    var model = DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo.EncryptParameters()
                    model.fromMap(dict["EncryptParameters"] as! [String: Any])
                    self.encryptParameters = model
                }
                if dict.keys.contains("IsLazy") {
                    self.isLazy = dict["IsLazy"] as! Bool
                }
                if dict.keys.contains("TranscodeApp") {
                    self.transcodeApp = dict["TranscodeApp"] as! String
                }
                if dict.keys.contains("TranscodeName") {
                    self.transcodeName = dict["TranscodeName"] as! String
                }
                if dict.keys.contains("TranscodeTemplate") {
                    self.transcodeTemplate = dict["TranscodeTemplate"] as! String
                }
            }
        }
        public var domainTranscodeInfo: [DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainTranscodeInfo != nil {
                var tmp : [Any] = []
                for k in self.domainTranscodeInfo! {
                    tmp.append(k.toMap())
                }
                map["DomainTranscodeInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainTranscodeInfo") {
                self.domainTranscodeInfo = dict["DomainTranscodeInfo"] as! [DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo]
            }
        }
    }
    public var domainTranscodeList: DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainTranscodeList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainTranscodeList != nil {
            map["DomainTranscodeList"] = self.domainTranscodeList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainTranscodeList") {
            var model = DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList()
            model.fromMap(dict["DomainTranscodeList"] as! [String: Any])
            self.domainTranscodeList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamTranscodeInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamTranscodeInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamTranscodeInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamTranscodeStreamNumRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveStreamTranscodeStreamNumResponseBody : Tea.TeaModel {
    public var lazyTranscodedNumber: Int64?

    public var requestId: String?

    public var total: Int64?

    public var transcodedNumber: Int64?

    public var untranscodeNumber: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lazyTranscodedNumber != nil {
            map["LazyTranscodedNumber"] = self.lazyTranscodedNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.transcodedNumber != nil {
            map["TranscodedNumber"] = self.transcodedNumber!
        }
        if self.untranscodeNumber != nil {
            map["UntranscodeNumber"] = self.untranscodeNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LazyTranscodedNumber") {
            self.lazyTranscodedNumber = dict["LazyTranscodedNumber"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int64
        }
        if dict.keys.contains("TranscodedNumber") {
            self.transcodedNumber = dict["TranscodedNumber"] as! Int64
        }
        if dict.keys.contains("UntranscodeNumber") {
            self.untranscodeNumber = dict["UntranscodeNumber"] as! Int64
        }
    }
}

public class DescribeLiveStreamTranscodeStreamNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamTranscodeStreamNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamTranscodeStreamNumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamWatermarkRulesRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeLiveStreamWatermarkRulesResponseBody : Tea.TeaModel {
    public class RuleInfoList : Tea.TeaModel {
        public class RuleInfo : Tea.TeaModel {
            public var app: String?

            public var description_: String?

            public var domain: String?

            public var name: String?

            public var ruleId: String?

            public var stream: String?

            public var templateId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.app != nil {
                    map["App"] = self.app!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.stream != nil {
                    map["Stream"] = self.stream!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("App") {
                    self.app = dict["App"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("Stream") {
                    self.stream = dict["Stream"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! String
                }
            }
        }
        public var ruleInfo: [DescribeLiveStreamWatermarkRulesResponseBody.RuleInfoList.RuleInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleInfo != nil {
                var tmp : [Any] = []
                for k in self.ruleInfo! {
                    tmp.append(k.toMap())
                }
                map["RuleInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleInfo") {
                self.ruleInfo = dict["RuleInfo"] as! [DescribeLiveStreamWatermarkRulesResponseBody.RuleInfoList.RuleInfo]
            }
        }
    }
    public var requestId: String?

    public var ruleInfoList: DescribeLiveStreamWatermarkRulesResponseBody.RuleInfoList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ruleInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleInfoList != nil {
            map["RuleInfoList"] = self.ruleInfoList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleInfoList") {
            var model = DescribeLiveStreamWatermarkRulesResponseBody.RuleInfoList()
            model.fromMap(dict["RuleInfoList"] as! [String: Any])
            self.ruleInfoList = model
        }
    }
}

public class DescribeLiveStreamWatermarkRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamWatermarkRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamWatermarkRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamWatermarksRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeLiveStreamWatermarksResponseBody : Tea.TeaModel {
    public class WatermarkList : Tea.TeaModel {
        public class Watermark : Tea.TeaModel {
            public var description_: String?

            public var height: Int32?

            public var name: String?

            public var offsetCorner: String?

            public var pictureUrl: String?

            public var refHeight: Int32?

            public var refWidth: Int32?

            public var templateId: String?

            public var transparency: Int32?

            public var type: Int32?

            public var XOffset: Double?

            public var YOffset: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.offsetCorner != nil {
                    map["OffsetCorner"] = self.offsetCorner!
                }
                if self.pictureUrl != nil {
                    map["PictureUrl"] = self.pictureUrl!
                }
                if self.refHeight != nil {
                    map["RefHeight"] = self.refHeight!
                }
                if self.refWidth != nil {
                    map["RefWidth"] = self.refWidth!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.transparency != nil {
                    map["Transparency"] = self.transparency!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.XOffset != nil {
                    map["XOffset"] = self.XOffset!
                }
                if self.YOffset != nil {
                    map["YOffset"] = self.YOffset!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OffsetCorner") {
                    self.offsetCorner = dict["OffsetCorner"] as! String
                }
                if dict.keys.contains("PictureUrl") {
                    self.pictureUrl = dict["PictureUrl"] as! String
                }
                if dict.keys.contains("RefHeight") {
                    self.refHeight = dict["RefHeight"] as! Int32
                }
                if dict.keys.contains("RefWidth") {
                    self.refWidth = dict["RefWidth"] as! Int32
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! String
                }
                if dict.keys.contains("Transparency") {
                    self.transparency = dict["Transparency"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int32
                }
                if dict.keys.contains("XOffset") {
                    self.XOffset = dict["XOffset"] as! Double
                }
                if dict.keys.contains("YOffset") {
                    self.YOffset = dict["YOffset"] as! Double
                }
            }
        }
        public var watermark: [DescribeLiveStreamWatermarksResponseBody.WatermarkList.Watermark]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.watermark != nil {
                var tmp : [Any] = []
                for k in self.watermark! {
                    tmp.append(k.toMap())
                }
                map["Watermark"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Watermark") {
                self.watermark = dict["Watermark"] as! [DescribeLiveStreamWatermarksResponseBody.WatermarkList.Watermark]
            }
        }
    }
    public var requestId: String?

    public var watermarkList: DescribeLiveStreamWatermarksResponseBody.WatermarkList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.watermarkList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.watermarkList != nil {
            map["WatermarkList"] = self.watermarkList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WatermarkList") {
            var model = DescribeLiveStreamWatermarksResponseBody.WatermarkList()
            model.fromMap(dict["WatermarkList"] as! [String: Any])
            self.watermarkList = model
        }
    }
}

public class DescribeLiveStreamWatermarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamWatermarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamWatermarksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamsBlockListRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeLiveStreamsBlockListResponseBody : Tea.TeaModel {
    public class StreamUrls : Tea.TeaModel {
        public var streamUrl: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamUrl != nil {
                map["StreamUrl"] = self.streamUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StreamUrl") {
                self.streamUrl = dict["StreamUrl"] as! [String]
            }
        }
    }
    public var domainName: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var streamUrls: DescribeLiveStreamsBlockListResponseBody.StreamUrls?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamUrls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamUrls != nil {
            map["StreamUrls"] = self.streamUrls?.toMap()
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StreamUrls") {
            var model = DescribeLiveStreamsBlockListResponseBody.StreamUrls()
            model.fromMap(dict["StreamUrls"] as! [String: Any])
            self.streamUrls = model
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeLiveStreamsBlockListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsBlockListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamsBlockListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamsControlHistoryRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveStreamsControlHistoryResponseBody : Tea.TeaModel {
    public class ControlInfo : Tea.TeaModel {
        public class LiveStreamControlInfo : Tea.TeaModel {
            public var action: String?

            public var clientIP: String?

            public var streamName: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.clientIP != nil {
                    map["ClientIP"] = self.clientIP!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ClientIP") {
                    self.clientIP = dict["ClientIP"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var liveStreamControlInfo: [DescribeLiveStreamsControlHistoryResponseBody.ControlInfo.LiveStreamControlInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamControlInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamControlInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamControlInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveStreamControlInfo") {
                self.liveStreamControlInfo = dict["LiveStreamControlInfo"] as! [DescribeLiveStreamsControlHistoryResponseBody.ControlInfo.LiveStreamControlInfo]
            }
        }
    }
    public var controlInfo: DescribeLiveStreamsControlHistoryResponseBody.ControlInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.controlInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.controlInfo != nil {
            map["ControlInfo"] = self.controlInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ControlInfo") {
            var model = DescribeLiveStreamsControlHistoryResponseBody.ControlInfo()
            model.fromMap(dict["ControlInfo"] as! [String: Any])
            self.controlInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamsControlHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsControlHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamsControlHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamsNotifyRecordsRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var status: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeLiveStreamsNotifyRecordsResponseBody : Tea.TeaModel {
    public class NotifyRecordsInfo : Tea.TeaModel {
        public class LiveStreamNotifyRecordsInfo : Tea.TeaModel {
            public var appName: String?

            public var description_: String?

            public var domainName: String?

            public var notifyContent: String?

            public var notifyResult: String?

            public var notifyTime: String?

            public var notifyType: String?

            public var notifyUrl: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.notifyContent != nil {
                    map["NotifyContent"] = self.notifyContent!
                }
                if self.notifyResult != nil {
                    map["NotifyResult"] = self.notifyResult!
                }
                if self.notifyTime != nil {
                    map["NotifyTime"] = self.notifyTime!
                }
                if self.notifyType != nil {
                    map["NotifyType"] = self.notifyType!
                }
                if self.notifyUrl != nil {
                    map["NotifyUrl"] = self.notifyUrl!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("NotifyContent") {
                    self.notifyContent = dict["NotifyContent"] as! String
                }
                if dict.keys.contains("NotifyResult") {
                    self.notifyResult = dict["NotifyResult"] as! String
                }
                if dict.keys.contains("NotifyTime") {
                    self.notifyTime = dict["NotifyTime"] as! String
                }
                if dict.keys.contains("NotifyType") {
                    self.notifyType = dict["NotifyType"] as! String
                }
                if dict.keys.contains("NotifyUrl") {
                    self.notifyUrl = dict["NotifyUrl"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
            }
        }
        public var liveStreamNotifyRecordsInfo: [DescribeLiveStreamsNotifyRecordsResponseBody.NotifyRecordsInfo.LiveStreamNotifyRecordsInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamNotifyRecordsInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamNotifyRecordsInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamNotifyRecordsInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveStreamNotifyRecordsInfo") {
                self.liveStreamNotifyRecordsInfo = dict["LiveStreamNotifyRecordsInfo"] as! [DescribeLiveStreamsNotifyRecordsResponseBody.NotifyRecordsInfo.LiveStreamNotifyRecordsInfo]
            }
        }
    }
    public var notifyRecordsInfo: DescribeLiveStreamsNotifyRecordsResponseBody.NotifyRecordsInfo?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifyRecordsInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notifyRecordsInfo != nil {
            map["NotifyRecordsInfo"] = self.notifyRecordsInfo?.toMap()
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NotifyRecordsInfo") {
            var model = DescribeLiveStreamsNotifyRecordsResponseBody.NotifyRecordsInfo()
            model.fromMap(dict["NotifyRecordsInfo"] as! [String: Any])
            self.notifyRecordsInfo = model
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeLiveStreamsNotifyRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsNotifyRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamsNotifyRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamsNotifyUrlConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveStreamsNotifyUrlConfigResponseBody : Tea.TeaModel {
    public class LiveStreamsNotifyConfig : Tea.TeaModel {
        public var domainName: String?

        public var notifyAuthKey: String?

        public var notifyReqAuth: String?

        public var notifyUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.notifyAuthKey != nil {
                map["NotifyAuthKey"] = self.notifyAuthKey!
            }
            if self.notifyReqAuth != nil {
                map["NotifyReqAuth"] = self.notifyReqAuth!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("NotifyAuthKey") {
                self.notifyAuthKey = dict["NotifyAuthKey"] as! String
            }
            if dict.keys.contains("NotifyReqAuth") {
                self.notifyReqAuth = dict["NotifyReqAuth"] as! String
            }
            if dict.keys.contains("NotifyUrl") {
                self.notifyUrl = dict["NotifyUrl"] as! String
            }
        }
    }
    public var liveStreamsNotifyConfig: DescribeLiveStreamsNotifyUrlConfigResponseBody.LiveStreamsNotifyConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamsNotifyConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamsNotifyConfig != nil {
            map["LiveStreamsNotifyConfig"] = self.liveStreamsNotifyConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveStreamsNotifyConfig") {
            var model = DescribeLiveStreamsNotifyUrlConfigResponseBody.LiveStreamsNotifyConfig()
            model.fromMap(dict["LiveStreamsNotifyConfig"] as! [String: Any])
            self.liveStreamsNotifyConfig = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeLiveStreamsNotifyUrlConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsNotifyUrlConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamsNotifyUrlConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamsOnlineListRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var onlyStream: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var queryType: String?

    public var streamName: String?

    public var streamType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.onlyStream != nil {
            map["OnlyStream"] = self.onlyStream!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryType != nil {
            map["QueryType"] = self.queryType!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OnlyStream") {
            self.onlyStream = dict["OnlyStream"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueryType") {
            self.queryType = dict["QueryType"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
        if dict.keys.contains("StreamType") {
            self.streamType = dict["StreamType"] as! String
        }
    }
}

public class DescribeLiveStreamsOnlineListResponseBody : Tea.TeaModel {
    public class OnlineInfo : Tea.TeaModel {
        public class LiveStreamOnlineInfo : Tea.TeaModel {
            public var appName: String?

            public var audioCodecId: Int32?

            public var clientIp: String?

            public var domainName: String?

            public var frameRate: Int32?

            public var height: Int32?

            public var publishDomain: String?

            public var publishTime: String?

            public var publishType: String?

            public var publishUrl: String?

            public var serverIp: String?

            public var streamName: String?

            public var transcoded: String?

            public var videoCodecId: Int32?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.audioCodecId != nil {
                    map["AudioCodecId"] = self.audioCodecId!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.frameRate != nil {
                    map["FrameRate"] = self.frameRate!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.publishDomain != nil {
                    map["PublishDomain"] = self.publishDomain!
                }
                if self.publishTime != nil {
                    map["PublishTime"] = self.publishTime!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.publishUrl != nil {
                    map["PublishUrl"] = self.publishUrl!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.transcoded != nil {
                    map["Transcoded"] = self.transcoded!
                }
                if self.videoCodecId != nil {
                    map["VideoCodecId"] = self.videoCodecId!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("AudioCodecId") {
                    self.audioCodecId = dict["AudioCodecId"] as! Int32
                }
                if dict.keys.contains("ClientIp") {
                    self.clientIp = dict["ClientIp"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("FrameRate") {
                    self.frameRate = dict["FrameRate"] as! Int32
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("PublishDomain") {
                    self.publishDomain = dict["PublishDomain"] as! String
                }
                if dict.keys.contains("PublishTime") {
                    self.publishTime = dict["PublishTime"] as! String
                }
                if dict.keys.contains("PublishType") {
                    self.publishType = dict["PublishType"] as! String
                }
                if dict.keys.contains("PublishUrl") {
                    self.publishUrl = dict["PublishUrl"] as! String
                }
                if dict.keys.contains("ServerIp") {
                    self.serverIp = dict["ServerIp"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("Transcoded") {
                    self.transcoded = dict["Transcoded"] as! String
                }
                if dict.keys.contains("VideoCodecId") {
                    self.videoCodecId = dict["VideoCodecId"] as! Int32
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var liveStreamOnlineInfo: [DescribeLiveStreamsOnlineListResponseBody.OnlineInfo.LiveStreamOnlineInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamOnlineInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamOnlineInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamOnlineInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveStreamOnlineInfo") {
                self.liveStreamOnlineInfo = dict["LiveStreamOnlineInfo"] as! [DescribeLiveStreamsOnlineListResponseBody.OnlineInfo.LiveStreamOnlineInfo]
            }
        }
    }
    public var onlineInfo: DescribeLiveStreamsOnlineListResponseBody.OnlineInfo?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.onlineInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onlineInfo != nil {
            map["OnlineInfo"] = self.onlineInfo?.toMap()
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OnlineInfo") {
            var model = DescribeLiveStreamsOnlineListResponseBody.OnlineInfo()
            model.fromMap(dict["OnlineInfo"] as! [String: Any])
            self.onlineInfo = model
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeLiveStreamsOnlineListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsOnlineListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamsOnlineListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveStreamsPublishListRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var orderBy: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var queryType: String?

    public var startTime: String?

    public var streamName: String?

    public var streamType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryType != nil {
            map["QueryType"] = self.queryType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueryType") {
            self.queryType = dict["QueryType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
        if dict.keys.contains("StreamType") {
            self.streamType = dict["StreamType"] as! String
        }
    }
}

public class DescribeLiveStreamsPublishListResponseBody : Tea.TeaModel {
    public class PublishInfo : Tea.TeaModel {
        public class LiveStreamPublishInfo : Tea.TeaModel {
            public var appName: String?

            public var clientAddr: String?

            public var domainName: String?

            public var edgeNodeAddr: String?

            public var publishDomain: String?

            public var publishTime: String?

            public var publishType: String?

            public var publishUrl: String?

            public var stopTime: String?

            public var streamName: String?

            public var streamUrl: String?

            public var transcodeId: String?

            public var transcoded: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.clientAddr != nil {
                    map["ClientAddr"] = self.clientAddr!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.edgeNodeAddr != nil {
                    map["EdgeNodeAddr"] = self.edgeNodeAddr!
                }
                if self.publishDomain != nil {
                    map["PublishDomain"] = self.publishDomain!
                }
                if self.publishTime != nil {
                    map["PublishTime"] = self.publishTime!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.publishUrl != nil {
                    map["PublishUrl"] = self.publishUrl!
                }
                if self.stopTime != nil {
                    map["StopTime"] = self.stopTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                if self.transcodeId != nil {
                    map["TranscodeId"] = self.transcodeId!
                }
                if self.transcoded != nil {
                    map["Transcoded"] = self.transcoded!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("ClientAddr") {
                    self.clientAddr = dict["ClientAddr"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("EdgeNodeAddr") {
                    self.edgeNodeAddr = dict["EdgeNodeAddr"] as! String
                }
                if dict.keys.contains("PublishDomain") {
                    self.publishDomain = dict["PublishDomain"] as! String
                }
                if dict.keys.contains("PublishTime") {
                    self.publishTime = dict["PublishTime"] as! String
                }
                if dict.keys.contains("PublishType") {
                    self.publishType = dict["PublishType"] as! String
                }
                if dict.keys.contains("PublishUrl") {
                    self.publishUrl = dict["PublishUrl"] as! String
                }
                if dict.keys.contains("StopTime") {
                    self.stopTime = dict["StopTime"] as! String
                }
                if dict.keys.contains("StreamName") {
                    self.streamName = dict["StreamName"] as! String
                }
                if dict.keys.contains("StreamUrl") {
                    self.streamUrl = dict["StreamUrl"] as! String
                }
                if dict.keys.contains("TranscodeId") {
                    self.transcodeId = dict["TranscodeId"] as! String
                }
                if dict.keys.contains("Transcoded") {
                    self.transcoded = dict["Transcoded"] as! String
                }
            }
        }
        public var liveStreamPublishInfo: [DescribeLiveStreamsPublishListResponseBody.PublishInfo.LiveStreamPublishInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamPublishInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamPublishInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamPublishInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LiveStreamPublishInfo") {
                self.liveStreamPublishInfo = dict["LiveStreamPublishInfo"] as! [DescribeLiveStreamsPublishListResponseBody.PublishInfo.LiveStreamPublishInfo]
            }
        }
    }
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var publishInfo: DescribeLiveStreamsPublishListResponseBody.PublishInfo?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.publishInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.publishInfo != nil {
            map["PublishInfo"] = self.publishInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PublishInfo") {
            var model = DescribeLiveStreamsPublishListResponseBody.PublishInfo()
            model.fromMap(dict["PublishInfo"] as! [String: Any])
            self.publishInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeLiveStreamsPublishListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsPublishListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveStreamsPublishListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerId: Int64?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [DescribeLiveTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeLiveTagResourcesRequest.Tag]
        }
    }
}

public class DescribeLiveTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var resourceId: String?

        public var tag: [DescribeLiveTagResourcesResponseBody.TagResources.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("Tag") {
                self.tag = dict["Tag"] as! [DescribeLiveTagResourcesResponseBody.TagResources.Tag]
            }
        }
    }
    public var requestId: String?

    public var tagResources: [DescribeLiveTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            self.tagResources = dict["TagResources"] as! [DescribeLiveTagResourcesResponseBody.TagResources]
        }
    }
}

public class DescribeLiveTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveTopDomainsByFlowRequest : Tea.TeaModel {
    public var endTime: String?

    public var limit: Int64?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int64
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveTopDomainsByFlowResponseBody : Tea.TeaModel {
    public class TopDomains : Tea.TeaModel {
        public class TopDomain : Tea.TeaModel {
            public var domainName: String?

            public var maxBps: Int64?

            public var maxBpsTime: String?

            public var rank: Int64?

            public var totalAccess: Int64?

            public var totalTraffic: String?

            public var trafficPercent: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.maxBps != nil {
                    map["MaxBps"] = self.maxBps!
                }
                if self.maxBpsTime != nil {
                    map["MaxBpsTime"] = self.maxBpsTime!
                }
                if self.rank != nil {
                    map["Rank"] = self.rank!
                }
                if self.totalAccess != nil {
                    map["TotalAccess"] = self.totalAccess!
                }
                if self.totalTraffic != nil {
                    map["TotalTraffic"] = self.totalTraffic!
                }
                if self.trafficPercent != nil {
                    map["TrafficPercent"] = self.trafficPercent!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("MaxBps") {
                    self.maxBps = dict["MaxBps"] as! Int64
                }
                if dict.keys.contains("MaxBpsTime") {
                    self.maxBpsTime = dict["MaxBpsTime"] as! String
                }
                if dict.keys.contains("Rank") {
                    self.rank = dict["Rank"] as! Int64
                }
                if dict.keys.contains("TotalAccess") {
                    self.totalAccess = dict["TotalAccess"] as! Int64
                }
                if dict.keys.contains("TotalTraffic") {
                    self.totalTraffic = dict["TotalTraffic"] as! String
                }
                if dict.keys.contains("TrafficPercent") {
                    self.trafficPercent = dict["TrafficPercent"] as! String
                }
            }
        }
        public var topDomain: [DescribeLiveTopDomainsByFlowResponseBody.TopDomains.TopDomain]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.topDomain != nil {
                var tmp : [Any] = []
                for k in self.topDomain! {
                    tmp.append(k.toMap())
                }
                map["TopDomain"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TopDomain") {
                self.topDomain = dict["TopDomain"] as! [DescribeLiveTopDomainsByFlowResponseBody.TopDomains.TopDomain]
            }
        }
    }
    public var domainCount: Int64?

    public var domainOnlineCount: Int64?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var topDomains: DescribeLiveTopDomainsByFlowResponseBody.TopDomains?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.topDomains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainCount != nil {
            map["DomainCount"] = self.domainCount!
        }
        if self.domainOnlineCount != nil {
            map["DomainOnlineCount"] = self.domainOnlineCount!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.topDomains != nil {
            map["TopDomains"] = self.topDomains?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainCount") {
            self.domainCount = dict["DomainCount"] as! Int64
        }
        if dict.keys.contains("DomainOnlineCount") {
            self.domainOnlineCount = dict["DomainOnlineCount"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TopDomains") {
            var model = DescribeLiveTopDomainsByFlowResponseBody.TopDomains()
            model.fromMap(dict["TopDomains"] as! [String: Any])
            self.topDomains = model
        }
    }
}

public class DescribeLiveTopDomainsByFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveTopDomainsByFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveTopDomainsByFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveUserBillPredictionRequest : Tea.TeaModel {
    public var area: String?

    public var dimension: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.dimension != nil {
            map["Dimension"] = self.dimension!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Area") {
            self.area = dict["Area"] as! String
        }
        if dict.keys.contains("Dimension") {
            self.dimension = dict["Dimension"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveUserBillPredictionResponseBody : Tea.TeaModel {
    public class BillPredictionData : Tea.TeaModel {
        public class BillPredictionDataItem : Tea.TeaModel {
            public var area: String?

            public var timeStp: String?

            public var value: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area != nil {
                    map["Area"] = self.area!
                }
                if self.timeStp != nil {
                    map["TimeStp"] = self.timeStp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Area") {
                    self.area = dict["Area"] as! String
                }
                if dict.keys.contains("TimeStp") {
                    self.timeStp = dict["TimeStp"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! Double
                }
            }
        }
        public var billPredictionDataItem: [DescribeLiveUserBillPredictionResponseBody.BillPredictionData.BillPredictionDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.billPredictionDataItem != nil {
                var tmp : [Any] = []
                for k in self.billPredictionDataItem! {
                    tmp.append(k.toMap())
                }
                map["BillPredictionDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BillPredictionDataItem") {
                self.billPredictionDataItem = dict["BillPredictionDataItem"] as! [DescribeLiveUserBillPredictionResponseBody.BillPredictionData.BillPredictionDataItem]
            }
        }
    }
    public var billPredictionData: DescribeLiveUserBillPredictionResponseBody.BillPredictionData?

    public var billType: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.billPredictionData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.billPredictionData != nil {
            map["BillPredictionData"] = self.billPredictionData?.toMap()
        }
        if self.billType != nil {
            map["BillType"] = self.billType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BillPredictionData") {
            var model = DescribeLiveUserBillPredictionResponseBody.BillPredictionData()
            model.fromMap(dict["BillPredictionData"] as! [String: Any])
            self.billPredictionData = model
        }
        if dict.keys.contains("BillType") {
            self.billType = dict["BillType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeLiveUserBillPredictionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveUserBillPredictionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveUserBillPredictionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveUserDomainsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var domainName: String?

    public var domainSearchType: String?

    public var domainStatus: String?

    public var liveDomainType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionName: String?

    public var securityToken: String?

    public var tag: [DescribeLiveUserDomainsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSearchType != nil {
            map["DomainSearchType"] = self.domainSearchType!
        }
        if self.domainStatus != nil {
            map["DomainStatus"] = self.domainStatus!
        }
        if self.liveDomainType != nil {
            map["LiveDomainType"] = self.liveDomainType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionName != nil {
            map["RegionName"] = self.regionName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainSearchType") {
            self.domainSearchType = dict["DomainSearchType"] as! String
        }
        if dict.keys.contains("DomainStatus") {
            self.domainStatus = dict["DomainStatus"] as! String
        }
        if dict.keys.contains("LiveDomainType") {
            self.liveDomainType = dict["LiveDomainType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionName") {
            self.regionName = dict["RegionName"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [DescribeLiveUserDomainsRequest.Tag]
        }
    }
}

public class DescribeLiveUserDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class PageData : Tea.TeaModel {
            public var cname: String?

            public var description_: String?

            public var domainName: String?

            public var gmtCreated: String?

            public var gmtModified: String?

            public var liveDomainStatus: String?

            public var liveDomainType: String?

            public var regionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cname != nil {
                    map["Cname"] = self.cname!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.gmtCreated != nil {
                    map["GmtCreated"] = self.gmtCreated!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.liveDomainStatus != nil {
                    map["LiveDomainStatus"] = self.liveDomainStatus!
                }
                if self.liveDomainType != nil {
                    map["LiveDomainType"] = self.liveDomainType!
                }
                if self.regionName != nil {
                    map["RegionName"] = self.regionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cname") {
                    self.cname = dict["Cname"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("GmtCreated") {
                    self.gmtCreated = dict["GmtCreated"] as! String
                }
                if dict.keys.contains("GmtModified") {
                    self.gmtModified = dict["GmtModified"] as! String
                }
                if dict.keys.contains("LiveDomainStatus") {
                    self.liveDomainStatus = dict["LiveDomainStatus"] as! String
                }
                if dict.keys.contains("LiveDomainType") {
                    self.liveDomainType = dict["LiveDomainType"] as! String
                }
                if dict.keys.contains("RegionName") {
                    self.regionName = dict["RegionName"] as! String
                }
            }
        }
        public var pageData: [DescribeLiveUserDomainsResponseBody.Domains.PageData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageData != nil {
                var tmp : [Any] = []
                for k in self.pageData! {
                    tmp.append(k.toMap())
                }
                map["PageData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PageData") {
                self.pageData = dict["PageData"] as! [DescribeLiveUserDomainsResponseBody.Domains.PageData]
            }
        }
    }
    public var domains: DescribeLiveUserDomainsResponseBody.Domains?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            map["Domains"] = self.domains?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domains") {
            var model = DescribeLiveUserDomainsResponseBody.Domains()
            model.fromMap(dict["Domains"] as! [String: Any])
            self.domains = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeLiveUserDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveUserDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveUserDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLiveUserTagsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeLiveUserTagsResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var tags: [DescribeLiveUserTagsResponseBody.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! [DescribeLiveUserTagsResponseBody.Tags]
        }
    }
}

public class DescribeLiveUserTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveUserTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLiveUserTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMeterLiveRtcDurationRequest : Tea.TeaModel {
    public var endTime: String?

    public var interval: String?

    public var serviceArea: String?

    public var startTime: String?

    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.serviceArea != nil {
            map["ServiceArea"] = self.serviceArea!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("ServiceArea") {
            self.serviceArea = dict["ServiceArea"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("appId") {
            self.appId = dict["appId"] as! String
        }
    }
}

public class DescribeMeterLiveRtcDurationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var audioDuration: Int64?

        public var timestamp: String?

        public var totalDuration: Int64?

        public var v1080Duration: Int64?

        public var v480Duration: Int64?

        public var v720Duration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioDuration != nil {
                map["AudioDuration"] = self.audioDuration!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalDuration != nil {
                map["TotalDuration"] = self.totalDuration!
            }
            if self.v1080Duration != nil {
                map["V1080Duration"] = self.v1080Duration!
            }
            if self.v480Duration != nil {
                map["V480Duration"] = self.v480Duration!
            }
            if self.v720Duration != nil {
                map["V720Duration"] = self.v720Duration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioDuration") {
                self.audioDuration = dict["AudioDuration"] as! Int64
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! String
            }
            if dict.keys.contains("TotalDuration") {
                self.totalDuration = dict["TotalDuration"] as! Int64
            }
            if dict.keys.contains("V1080Duration") {
                self.v1080Duration = dict["V1080Duration"] as! Int64
            }
            if dict.keys.contains("V480Duration") {
                self.v480Duration = dict["V480Duration"] as! Int64
            }
            if dict.keys.contains("V720Duration") {
                self.v720Duration = dict["V720Duration"] as! Int64
            }
        }
    }
    public var audioSummaryDuration: Int64?

    public var data: [DescribeMeterLiveRtcDurationResponseBody.Data]?

    public var requestId: String?

    public var totalSummaryDuration: Int64?

    public var v1080SummaryDuration: Int64?

    public var v480SummaryDuration: Int64?

    public var v720SummaryDuration: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioSummaryDuration != nil {
            map["AudioSummaryDuration"] = self.audioSummaryDuration!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalSummaryDuration != nil {
            map["TotalSummaryDuration"] = self.totalSummaryDuration!
        }
        if self.v1080SummaryDuration != nil {
            map["V1080SummaryDuration"] = self.v1080SummaryDuration!
        }
        if self.v480SummaryDuration != nil {
            map["V480SummaryDuration"] = self.v480SummaryDuration!
        }
        if self.v720SummaryDuration != nil {
            map["V720SummaryDuration"] = self.v720SummaryDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioSummaryDuration") {
            self.audioSummaryDuration = dict["AudioSummaryDuration"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [DescribeMeterLiveRtcDurationResponseBody.Data]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalSummaryDuration") {
            self.totalSummaryDuration = dict["TotalSummaryDuration"] as! Int64
        }
        if dict.keys.contains("V1080SummaryDuration") {
            self.v1080SummaryDuration = dict["V1080SummaryDuration"] as! Int64
        }
        if dict.keys.contains("V480SummaryDuration") {
            self.v480SummaryDuration = dict["V480SummaryDuration"] as! Int64
        }
        if dict.keys.contains("V720SummaryDuration") {
            self.v720SummaryDuration = dict["V720SummaryDuration"] as! Int64
        }
    }
}

public class DescribeMeterLiveRtcDurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterLiveRtcDurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMeterLiveRtcDurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMixStreamListRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var mixStreamId: String?

    public var ownerId: Int64?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("MixStreamId") {
            self.mixStreamId = dict["MixStreamId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class DescribeMixStreamListResponseBody : Tea.TeaModel {
    public class MixStreamList : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var inputStreamNumber: Int32?

        public var layoutId: String?

        public var mixStreamTemplate: String?

        public var mixstreamId: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.inputStreamNumber != nil {
                map["InputStreamNumber"] = self.inputStreamNumber!
            }
            if self.layoutId != nil {
                map["LayoutId"] = self.layoutId!
            }
            if self.mixStreamTemplate != nil {
                map["MixStreamTemplate"] = self.mixStreamTemplate!
            }
            if self.mixstreamId != nil {
                map["MixstreamId"] = self.mixstreamId!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! String
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! String
            }
            if dict.keys.contains("InputStreamNumber") {
                self.inputStreamNumber = dict["InputStreamNumber"] as! Int32
            }
            if dict.keys.contains("LayoutId") {
                self.layoutId = dict["LayoutId"] as! String
            }
            if dict.keys.contains("MixStreamTemplate") {
                self.mixStreamTemplate = dict["MixStreamTemplate"] as! String
            }
            if dict.keys.contains("MixstreamId") {
                self.mixstreamId = dict["MixstreamId"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
        }
    }
    public var mixStreamList: [DescribeMixStreamListResponseBody.MixStreamList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixStreamList != nil {
            var tmp : [Any] = []
            for k in self.mixStreamList! {
                tmp.append(k.toMap())
            }
            map["MixStreamList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MixStreamList") {
            self.mixStreamList = dict["MixStreamList"] as! [DescribeMixStreamListResponseBody.MixStreamList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeMixStreamListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMixStreamListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMixStreamListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameCostRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameList = dict["DomainNameList"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameCostShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameListShrink = dict["DomainNameList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameCostResponseBody : Tea.TeaModel {
    public class FirstFrameCostData : Tea.TeaModel {
        public var connected: String?

        public var finishGetStreamInfo: String?

        public var firstFrameComplete: String?

        public var firstPacket: String?

        public var initialized: String?

        public var timeStamp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connected != nil {
                map["Connected"] = self.connected!
            }
            if self.finishGetStreamInfo != nil {
                map["FinishGetStreamInfo"] = self.finishGetStreamInfo!
            }
            if self.firstFrameComplete != nil {
                map["FirstFrameComplete"] = self.firstFrameComplete!
            }
            if self.firstPacket != nil {
                map["FirstPacket"] = self.firstPacket!
            }
            if self.initialized != nil {
                map["Initialized"] = self.initialized!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Connected") {
                self.connected = dict["Connected"] as! String
            }
            if dict.keys.contains("FinishGetStreamInfo") {
                self.finishGetStreamInfo = dict["FinishGetStreamInfo"] as! String
            }
            if dict.keys.contains("FirstFrameComplete") {
                self.firstFrameComplete = dict["FirstFrameComplete"] as! String
            }
            if dict.keys.contains("FirstPacket") {
                self.firstPacket = dict["FirstPacket"] as! String
            }
            if dict.keys.contains("Initialized") {
                self.initialized = dict["Initialized"] as! String
            }
            if dict.keys.contains("TimeStamp") {
                self.timeStamp = dict["TimeStamp"] as! String
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var firstFrameCostData: [DescribeRTSNativeSDKFirstFrameCostResponseBody.FirstFrameCostData]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.firstFrameCostData != nil {
            var tmp : [Any] = []
            for k in self.firstFrameCostData! {
                tmp.append(k.toMap())
            }
            map["FirstFrameCostData"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FirstFrameCostData") {
            self.firstFrameCostData = dict["FirstFrameCostData"] as! [DescribeRTSNativeSDKFirstFrameCostResponseBody.FirstFrameCostData]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameCostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKFirstFrameCostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRTSNativeSDKFirstFrameCostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameDelayRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameList = dict["DomainNameList"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameDelayShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameListShrink = dict["DomainNameList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameDelayResponseBody : Tea.TeaModel {
    public class FrameDelayData : Tea.TeaModel {
        public var frameDelay: String?

        public var timeStamp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.frameDelay != nil {
                map["FrameDelay"] = self.frameDelay!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FrameDelay") {
                self.frameDelay = dict["FrameDelay"] as! String
            }
            if dict.keys.contains("TimeStamp") {
                self.timeStamp = dict["TimeStamp"] as! String
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var frameDelayData: [DescribeRTSNativeSDKFirstFrameDelayResponseBody.FrameDelayData]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.frameDelayData != nil {
            var tmp : [Any] = []
            for k in self.frameDelayData! {
                tmp.append(k.toMap())
            }
            map["FrameDelayData"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FrameDelayData") {
            self.frameDelayData = dict["FrameDelayData"] as! [DescribeRTSNativeSDKFirstFrameDelayResponseBody.FrameDelayData]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameDelayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKFirstFrameDelayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRTSNativeSDKFirstFrameDelayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKPlayFailStatusRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameList = dict["DomainNameList"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKPlayFailStatusShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameListShrink = dict["DomainNameList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKPlayFailStatusResponseBody : Tea.TeaModel {
    public class PlayFailStatus : Tea.TeaModel {
        public var timeStamp: String?

        public var v20001: String?

        public var v20002: String?

        public var v20011: String?

        public var v20012: String?

        public var v20013: String?

        public var v20052: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            if self.v20001 != nil {
                map["V20001"] = self.v20001!
            }
            if self.v20002 != nil {
                map["V20002"] = self.v20002!
            }
            if self.v20011 != nil {
                map["V20011"] = self.v20011!
            }
            if self.v20012 != nil {
                map["V20012"] = self.v20012!
            }
            if self.v20013 != nil {
                map["V20013"] = self.v20013!
            }
            if self.v20052 != nil {
                map["V20052"] = self.v20052!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TimeStamp") {
                self.timeStamp = dict["TimeStamp"] as! String
            }
            if dict.keys.contains("V20001") {
                self.v20001 = dict["V20001"] as! String
            }
            if dict.keys.contains("V20002") {
                self.v20002 = dict["V20002"] as! String
            }
            if dict.keys.contains("V20011") {
                self.v20011 = dict["V20011"] as! String
            }
            if dict.keys.contains("V20012") {
                self.v20012 = dict["V20012"] as! String
            }
            if dict.keys.contains("V20013") {
                self.v20013 = dict["V20013"] as! String
            }
            if dict.keys.contains("V20052") {
                self.v20052 = dict["V20052"] as! String
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var playFailStatus: [DescribeRTSNativeSDKPlayFailStatusResponseBody.PlayFailStatus]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.playFailStatus != nil {
            var tmp : [Any] = []
            for k in self.playFailStatus! {
                tmp.append(k.toMap())
            }
            map["PlayFailStatus"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PlayFailStatus") {
            self.playFailStatus = dict["PlayFailStatus"] as! [DescribeRTSNativeSDKPlayFailStatusResponseBody.PlayFailStatus]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKPlayFailStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKPlayFailStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRTSNativeSDKPlayFailStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKPlayTimeRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameList = dict["DomainNameList"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKPlayTimeShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameListShrink = dict["DomainNameList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKPlayTimeResponseBody : Tea.TeaModel {
    public class PlayTimeData : Tea.TeaModel {
        public var playTime: String?

        public var stallTime: String?

        public var timeStamp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.playTime != nil {
                map["PlayTime"] = self.playTime!
            }
            if self.stallTime != nil {
                map["StallTime"] = self.stallTime!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PlayTime") {
                self.playTime = dict["PlayTime"] as! String
            }
            if dict.keys.contains("StallTime") {
                self.stallTime = dict["StallTime"] as! String
            }
            if dict.keys.contains("TimeStamp") {
                self.timeStamp = dict["TimeStamp"] as! String
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var playTimeData: [DescribeRTSNativeSDKPlayTimeResponseBody.PlayTimeData]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.playTimeData != nil {
            var tmp : [Any] = []
            for k in self.playTimeData! {
                tmp.append(k.toMap())
            }
            map["PlayTimeData"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PlayTimeData") {
            self.playTimeData = dict["PlayTimeData"] as! [DescribeRTSNativeSDKPlayTimeResponseBody.PlayTimeData]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKPlayTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKPlayTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRTSNativeSDKPlayTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKVvDataRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameList = dict["DomainNameList"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKVvDataShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("DomainNameList") {
            self.domainNameListShrink = dict["DomainNameList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRTSNativeSDKVvDataResponseBody : Tea.TeaModel {
    public class VvData : Tea.TeaModel {
        public var timeStamp: String?

        public var vvSuccess: String?

        public var vvTotal: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            if self.vvSuccess != nil {
                map["VvSuccess"] = self.vvSuccess!
            }
            if self.vvTotal != nil {
                map["VvTotal"] = self.vvTotal!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TimeStamp") {
                self.timeStamp = dict["TimeStamp"] as! String
            }
            if dict.keys.contains("VvSuccess") {
                self.vvSuccess = dict["VvSuccess"] as! String
            }
            if dict.keys.contains("VvTotal") {
                self.vvTotal = dict["VvTotal"] as! String
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var vvData: [DescribeRTSNativeSDKVvDataResponseBody.VvData]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.vvData != nil {
            var tmp : [Any] = []
            for k in self.vvData! {
                tmp.append(k.toMap())
            }
            map["VvData"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataInterval") {
            self.dataInterval = dict["DataInterval"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("VvData") {
            self.vvData = dict["VvData"] as! [DescribeRTSNativeSDKVvDataResponseBody.VvData]
        }
    }
}

public class DescribeRTSNativeSDKVvDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKVvDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRTSNativeSDKVvDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRoomKickoutUserListRequest : Tea.TeaModel {
    public var appId: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var roomId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
    }
}

public class DescribeRoomKickoutUserListResponseBody : Tea.TeaModel {
    public class UserList : Tea.TeaModel {
        public var appUid: String?

        public var opEndTime: String?

        public var opStartTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appUid != nil {
                map["AppUid"] = self.appUid!
            }
            if self.opEndTime != nil {
                map["OpEndTime"] = self.opEndTime!
            }
            if self.opStartTime != nil {
                map["OpStartTime"] = self.opStartTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppUid") {
                self.appUid = dict["AppUid"] as! String
            }
            if dict.keys.contains("OpEndTime") {
                self.opEndTime = dict["OpEndTime"] as! String
            }
            if dict.keys.contains("OpStartTime") {
                self.opStartTime = dict["OpStartTime"] as! String
            }
        }
    }
    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public var userList: [DescribeRoomKickoutUserListResponseBody.UserList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        if self.userList != nil {
            var tmp : [Any] = []
            for k in self.userList! {
                tmp.append(k.toMap())
            }
            map["UserList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
        if dict.keys.contains("UserList") {
            self.userList = dict["UserList"] as! [DescribeRoomKickoutUserListResponseBody.UserList]
        }
    }
}

public class DescribeRoomKickoutUserListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRoomKickoutUserListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRoomKickoutUserListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRoomListRequest : Tea.TeaModel {
    public var anchorId: String?

    public var appId: String?

    public var endTime: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var roomId: String?

    public var roomStatus: Int32?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.anchorId != nil {
            map["AnchorId"] = self.anchorId!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnchorId") {
            self.anchorId = dict["AnchorId"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Order") {
            self.order = dict["Order"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("RoomStatus") {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeRoomListResponseBody : Tea.TeaModel {
    public class RoomList : Tea.TeaModel {
        public var anchorId: String?

        public var createTime: String?

        public var forbidStream: String?

        public var roomId: String?

        public var roomStatus: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.anchorId != nil {
                map["AnchorId"] = self.anchorId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.forbidStream != nil {
                map["ForbidStream"] = self.forbidStream!
            }
            if self.roomId != nil {
                map["RoomId"] = self.roomId!
            }
            if self.roomStatus != nil {
                map["RoomStatus"] = self.roomStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AnchorId") {
                self.anchorId = dict["AnchorId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ForbidStream") {
                self.forbidStream = dict["ForbidStream"] as! String
            }
            if dict.keys.contains("RoomId") {
                self.roomId = dict["RoomId"] as! String
            }
            if dict.keys.contains("RoomStatus") {
                self.roomStatus = dict["RoomStatus"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var roomList: [DescribeRoomListResponseBody.RoomList]?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.roomList != nil {
            var tmp : [Any] = []
            for k in self.roomList! {
                tmp.append(k.toMap())
            }
            map["RoomList"] = tmp
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RoomList") {
            self.roomList = dict["RoomList"] as! [DescribeRoomListResponseBody.RoomList]
        }
        if dict.keys.contains("TotalNum") {
            self.totalNum = dict["TotalNum"] as! Int32
        }
        if dict.keys.contains("TotalPage") {
            self.totalPage = dict["TotalPage"] as! Int32
        }
    }
}

public class DescribeRoomListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRoomListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRoomListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRoomStatusRequest : Tea.TeaModel {
    public var appId: String?

    public var ownerId: Int64?

    public var roomId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
    }
}

public class DescribeRoomStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var roomStatus: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.roomStatus != nil {
            map["RoomStatus"] = self.roomStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RoomStatus") {
            self.roomStatus = dict["RoomStatus"] as! Int32
        }
    }
}

public class DescribeRoomStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRoomStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRoomStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeShowListRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeShowListResponseBody : Tea.TeaModel {
    public class ShowListInfo : Tea.TeaModel {
        public class ShowList : Tea.TeaModel {
            public class Show : Tea.TeaModel {
                public class ResourceInfo : Tea.TeaModel {
                    public var liveInputType: Int32?

                    public var resourceId: String?

                    public var resourceType: String?

                    public var resourceUrl: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.liveInputType != nil {
                            map["LiveInputType"] = self.liveInputType!
                        }
                        if self.resourceId != nil {
                            map["ResourceId"] = self.resourceId!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        if self.resourceUrl != nil {
                            map["ResourceUrl"] = self.resourceUrl!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LiveInputType") {
                            self.liveInputType = dict["LiveInputType"] as! Int32
                        }
                        if dict.keys.contains("ResourceId") {
                            self.resourceId = dict["ResourceId"] as! String
                        }
                        if dict.keys.contains("ResourceType") {
                            self.resourceType = dict["ResourceType"] as! String
                        }
                        if dict.keys.contains("ResourceUrl") {
                            self.resourceUrl = dict["ResourceUrl"] as! String
                        }
                    }
                }
                public var duration: Int64?

                public var repeatTimes: Int32?

                public var resourceInfo: DescribeShowListResponseBody.ShowListInfo.ShowList.Show.ResourceInfo?

                public var showId: String?

                public var showName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.resourceInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.repeatTimes != nil {
                        map["RepeatTimes"] = self.repeatTimes!
                    }
                    if self.resourceInfo != nil {
                        map["ResourceInfo"] = self.resourceInfo?.toMap()
                    }
                    if self.showId != nil {
                        map["ShowId"] = self.showId!
                    }
                    if self.showName != nil {
                        map["ShowName"] = self.showName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int64
                    }
                    if dict.keys.contains("RepeatTimes") {
                        self.repeatTimes = dict["RepeatTimes"] as! Int32
                    }
                    if dict.keys.contains("ResourceInfo") {
                        var model = DescribeShowListResponseBody.ShowListInfo.ShowList.Show.ResourceInfo()
                        model.fromMap(dict["ResourceInfo"] as! [String: Any])
                        self.resourceInfo = model
                    }
                    if dict.keys.contains("ShowId") {
                        self.showId = dict["ShowId"] as! String
                    }
                    if dict.keys.contains("ShowName") {
                        self.showName = dict["ShowName"] as! String
                    }
                }
            }
            public var show: [DescribeShowListResponseBody.ShowListInfo.ShowList.Show]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.show != nil {
                    var tmp : [Any] = []
                    for k in self.show! {
                        tmp.append(k.toMap())
                    }
                    map["Show"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Show") {
                    self.show = dict["Show"] as! [DescribeShowListResponseBody.ShowListInfo.ShowList.Show]
                }
            }
        }
        public var currentShowId: String?

        public var highPriorityShowId: String?

        public var highPriorityShowStartTime: String?

        public var showList: DescribeShowListResponseBody.ShowListInfo.ShowList?

        public var showListRepeatTimes: Int32?

        public var totalShowListRepeatTimes: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.showList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentShowId != nil {
                map["CurrentShowId"] = self.currentShowId!
            }
            if self.highPriorityShowId != nil {
                map["HighPriorityShowId"] = self.highPriorityShowId!
            }
            if self.highPriorityShowStartTime != nil {
                map["HighPriorityShowStartTime"] = self.highPriorityShowStartTime!
            }
            if self.showList != nil {
                map["ShowList"] = self.showList?.toMap()
            }
            if self.showListRepeatTimes != nil {
                map["ShowListRepeatTimes"] = self.showListRepeatTimes!
            }
            if self.totalShowListRepeatTimes != nil {
                map["TotalShowListRepeatTimes"] = self.totalShowListRepeatTimes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentShowId") {
                self.currentShowId = dict["CurrentShowId"] as! String
            }
            if dict.keys.contains("HighPriorityShowId") {
                self.highPriorityShowId = dict["HighPriorityShowId"] as! String
            }
            if dict.keys.contains("HighPriorityShowStartTime") {
                self.highPriorityShowStartTime = dict["HighPriorityShowStartTime"] as! String
            }
            if dict.keys.contains("ShowList") {
                var model = DescribeShowListResponseBody.ShowListInfo.ShowList()
                model.fromMap(dict["ShowList"] as! [String: Any])
                self.showList = model
            }
            if dict.keys.contains("ShowListRepeatTimes") {
                self.showListRepeatTimes = dict["ShowListRepeatTimes"] as! Int32
            }
            if dict.keys.contains("TotalShowListRepeatTimes") {
                self.totalShowListRepeatTimes = dict["TotalShowListRepeatTimes"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var showList: String?

    public var showListInfo: DescribeShowListResponseBody.ShowListInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.showListInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.showList != nil {
            map["ShowList"] = self.showList!
        }
        if self.showListInfo != nil {
            map["ShowListInfo"] = self.showListInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ShowList") {
            self.showList = dict["ShowList"] as! String
        }
        if dict.keys.contains("ShowListInfo") {
            var model = DescribeShowListResponseBody.ShowListInfo()
            model.fromMap(dict["ShowListInfo"] as! [String: Any])
            self.showListInfo = model
        }
    }
}

public class DescribeShowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeShowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeShowListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStudioLayoutsRequest : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DescribeStudioLayoutsResponseBody : Tea.TeaModel {
    public class StudioLayouts : Tea.TeaModel {
        public class BgImageConfig : Tea.TeaModel {
            public var id: String?

            public var imageUrl: String?

            public var locationId: String?

            public var materialId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.locationId != nil {
                    map["LocationId"] = self.locationId!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ImageUrl") {
                    self.imageUrl = dict["ImageUrl"] as! String
                }
                if dict.keys.contains("LocationId") {
                    self.locationId = dict["LocationId"] as! String
                }
                if dict.keys.contains("MaterialId") {
                    self.materialId = dict["MaterialId"] as! String
                }
            }
        }
        public class CommonConfig : Tea.TeaModel {
            public var channelId: String?

            public var videoResourceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.videoResourceId != nil {
                    map["VideoResourceId"] = self.videoResourceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelId") {
                    self.channelId = dict["ChannelId"] as! String
                }
                if dict.keys.contains("VideoResourceId") {
                    self.videoResourceId = dict["VideoResourceId"] as! String
                }
            }
        }
        public class LayerOrderConfigList : Tea.TeaModel {
            public var id: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class MediaInputConfigList : Tea.TeaModel {
            public var channelId: String?

            public var fillMode: String?

            public var heightNormalized: Double?

            public var id: String?

            public var imageMaterialId: String?

            public var index: Int32?

            public var positionNormalized: [Double]?

            public var positionRefer: String?

            public var videoResourceId: String?

            public var widthNormalized: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.fillMode != nil {
                    map["FillMode"] = self.fillMode!
                }
                if self.heightNormalized != nil {
                    map["HeightNormalized"] = self.heightNormalized!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.imageMaterialId != nil {
                    map["ImageMaterialId"] = self.imageMaterialId!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.positionNormalized != nil {
                    map["PositionNormalized"] = self.positionNormalized!
                }
                if self.positionRefer != nil {
                    map["PositionRefer"] = self.positionRefer!
                }
                if self.videoResourceId != nil {
                    map["VideoResourceId"] = self.videoResourceId!
                }
                if self.widthNormalized != nil {
                    map["WidthNormalized"] = self.widthNormalized!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelId") {
                    self.channelId = dict["ChannelId"] as! String
                }
                if dict.keys.contains("FillMode") {
                    self.fillMode = dict["FillMode"] as! String
                }
                if dict.keys.contains("HeightNormalized") {
                    self.heightNormalized = dict["HeightNormalized"] as! Double
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("ImageMaterialId") {
                    self.imageMaterialId = dict["ImageMaterialId"] as! String
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! Int32
                }
                if dict.keys.contains("PositionNormalized") {
                    self.positionNormalized = dict["PositionNormalized"] as! [Double]
                }
                if dict.keys.contains("PositionRefer") {
                    self.positionRefer = dict["PositionRefer"] as! String
                }
                if dict.keys.contains("VideoResourceId") {
                    self.videoResourceId = dict["VideoResourceId"] as! String
                }
                if dict.keys.contains("WidthNormalized") {
                    self.widthNormalized = dict["WidthNormalized"] as! Double
                }
            }
        }
        public class ScreenInputConfigList : Tea.TeaModel {
            public class AudioConfig : Tea.TeaModel {
                public var validChannel: String?

                public var volumeRate: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.validChannel != nil {
                        map["ValidChannel"] = self.validChannel!
                    }
                    if self.volumeRate != nil {
                        map["VolumeRate"] = self.volumeRate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ValidChannel") {
                        self.validChannel = dict["ValidChannel"] as! String
                    }
                    if dict.keys.contains("VolumeRate") {
                        self.volumeRate = dict["VolumeRate"] as! Double
                    }
                }
            }
            public var audioConfig: DescribeStudioLayoutsResponseBody.StudioLayouts.ScreenInputConfigList.AudioConfig?

            public var channelId: String?

            public var color: String?

            public var heightNormalized: Double?

            public var id: String?

            public var index: Int32?

            public var onlyAudio: Bool?

            public var portraitType: Int32?

            public var positionX: String?

            public var positionY: String?

            public var videoResourceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioConfig != nil {
                    map["AudioConfig"] = self.audioConfig?.toMap()
                }
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.color != nil {
                    map["Color"] = self.color!
                }
                if self.heightNormalized != nil {
                    map["HeightNormalized"] = self.heightNormalized!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.onlyAudio != nil {
                    map["OnlyAudio"] = self.onlyAudio!
                }
                if self.portraitType != nil {
                    map["PortraitType"] = self.portraitType!
                }
                if self.positionX != nil {
                    map["PositionX"] = self.positionX!
                }
                if self.positionY != nil {
                    map["PositionY"] = self.positionY!
                }
                if self.videoResourceId != nil {
                    map["VideoResourceId"] = self.videoResourceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioConfig") {
                    var model = DescribeStudioLayoutsResponseBody.StudioLayouts.ScreenInputConfigList.AudioConfig()
                    model.fromMap(dict["AudioConfig"] as! [String: Any])
                    self.audioConfig = model
                }
                if dict.keys.contains("ChannelId") {
                    self.channelId = dict["ChannelId"] as! String
                }
                if dict.keys.contains("Color") {
                    self.color = dict["Color"] as! String
                }
                if dict.keys.contains("HeightNormalized") {
                    self.heightNormalized = dict["HeightNormalized"] as! Double
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! Int32
                }
                if dict.keys.contains("OnlyAudio") {
                    self.onlyAudio = dict["OnlyAudio"] as! Bool
                }
                if dict.keys.contains("PortraitType") {
                    self.portraitType = dict["PortraitType"] as! Int32
                }
                if dict.keys.contains("PositionX") {
                    self.positionX = dict["PositionX"] as! String
                }
                if dict.keys.contains("PositionY") {
                    self.positionY = dict["PositionY"] as! String
                }
                if dict.keys.contains("VideoResourceId") {
                    self.videoResourceId = dict["VideoResourceId"] as! String
                }
            }
        }
        public var bgImageConfig: DescribeStudioLayoutsResponseBody.StudioLayouts.BgImageConfig?

        public var commonConfig: DescribeStudioLayoutsResponseBody.StudioLayouts.CommonConfig?

        public var layerOrderConfigList: [DescribeStudioLayoutsResponseBody.StudioLayouts.LayerOrderConfigList]?

        public var layoutId: String?

        public var layoutName: String?

        public var layoutType: String?

        public var mediaInputConfigList: [DescribeStudioLayoutsResponseBody.StudioLayouts.MediaInputConfigList]?

        public var screenInputConfigList: [DescribeStudioLayoutsResponseBody.StudioLayouts.ScreenInputConfigList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bgImageConfig?.validate()
            try self.commonConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bgImageConfig != nil {
                map["BgImageConfig"] = self.bgImageConfig?.toMap()
            }
            if self.commonConfig != nil {
                map["CommonConfig"] = self.commonConfig?.toMap()
            }
            if self.layerOrderConfigList != nil {
                var tmp : [Any] = []
                for k in self.layerOrderConfigList! {
                    tmp.append(k.toMap())
                }
                map["LayerOrderConfigList"] = tmp
            }
            if self.layoutId != nil {
                map["LayoutId"] = self.layoutId!
            }
            if self.layoutName != nil {
                map["LayoutName"] = self.layoutName!
            }
            if self.layoutType != nil {
                map["LayoutType"] = self.layoutType!
            }
            if self.mediaInputConfigList != nil {
                var tmp : [Any] = []
                for k in self.mediaInputConfigList! {
                    tmp.append(k.toMap())
                }
                map["MediaInputConfigList"] = tmp
            }
            if self.screenInputConfigList != nil {
                var tmp : [Any] = []
                for k in self.screenInputConfigList! {
                    tmp.append(k.toMap())
                }
                map["ScreenInputConfigList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BgImageConfig") {
                var model = DescribeStudioLayoutsResponseBody.StudioLayouts.BgImageConfig()
                model.fromMap(dict["BgImageConfig"] as! [String: Any])
                self.bgImageConfig = model
            }
            if dict.keys.contains("CommonConfig") {
                var model = DescribeStudioLayoutsResponseBody.StudioLayouts.CommonConfig()
                model.fromMap(dict["CommonConfig"] as! [String: Any])
                self.commonConfig = model
            }
            if dict.keys.contains("LayerOrderConfigList") {
                self.layerOrderConfigList = dict["LayerOrderConfigList"] as! [DescribeStudioLayoutsResponseBody.StudioLayouts.LayerOrderConfigList]
            }
            if dict.keys.contains("LayoutId") {
                self.layoutId = dict["LayoutId"] as! String
            }
            if dict.keys.contains("LayoutName") {
                self.layoutName = dict["LayoutName"] as! String
            }
            if dict.keys.contains("LayoutType") {
                self.layoutType = dict["LayoutType"] as! String
            }
            if dict.keys.contains("MediaInputConfigList") {
                self.mediaInputConfigList = dict["MediaInputConfigList"] as! [DescribeStudioLayoutsResponseBody.StudioLayouts.MediaInputConfigList]
            }
            if dict.keys.contains("ScreenInputConfigList") {
                self.screenInputConfigList = dict["ScreenInputConfigList"] as! [DescribeStudioLayoutsResponseBody.StudioLayouts.ScreenInputConfigList]
            }
        }
    }
    public var requestId: String?

    public var studioLayouts: [DescribeStudioLayoutsResponseBody.StudioLayouts]?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.studioLayouts != nil {
            var tmp : [Any] = []
            for k in self.studioLayouts! {
                tmp.append(k.toMap())
            }
            map["StudioLayouts"] = tmp
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StudioLayouts") {
            self.studioLayouts = dict["StudioLayouts"] as! [DescribeStudioLayoutsResponseBody.StudioLayouts]
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class DescribeStudioLayoutsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStudioLayoutsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStudioLayoutsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeToutiaoLivePlayRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Stream") {
            self.stream = dict["Stream"] as! String
        }
    }
}

public class DescribeToutiaoLivePlayResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var app: String?

        public var bandwidth: Double?

        public var cdnName: String?

        public var domain: String?

        public var playNum: Int64?

        public var streamName: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.cdnName != nil {
                map["CdnName"] = self.cdnName!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.playNum != nil {
                map["PlayNum"] = self.playNum!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("Bandwidth") {
                self.bandwidth = dict["Bandwidth"] as! Double
            }
            if dict.keys.contains("CdnName") {
                self.cdnName = dict["CdnName"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("PlayNum") {
                self.playNum = dict["PlayNum"] as! Int64
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var content: [DescribeToutiaoLivePlayResponseBody.Content]?

    public var description_: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["Content"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! [DescribeToutiaoLivePlayResponseBody.Content]
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeToutiaoLivePlayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeToutiaoLivePlayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeToutiaoLivePlayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeToutiaoLivePublishRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Stream") {
            self.stream = dict["Stream"] as! String
        }
    }
}

public class DescribeToutiaoLivePublishResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var app: String?

        public var bitrate: Double?

        public var bwDiff: Double?

        public var cdnName: String?

        public var domain: String?

        public var flr: Double?

        public var fps: Double?

        public var streamName: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.bwDiff != nil {
                map["BwDiff"] = self.bwDiff!
            }
            if self.cdnName != nil {
                map["CdnName"] = self.cdnName!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.flr != nil {
                map["Flr"] = self.flr!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("App") {
                self.app = dict["App"] as! String
            }
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! Double
            }
            if dict.keys.contains("BwDiff") {
                self.bwDiff = dict["BwDiff"] as! Double
            }
            if dict.keys.contains("CdnName") {
                self.cdnName = dict["CdnName"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Flr") {
                self.flr = dict["Flr"] as! Double
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! Double
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var content: [DescribeToutiaoLivePublishResponseBody.Content]?

    public var description_: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["Content"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! [DescribeToutiaoLivePublishResponseBody.Content]
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeToutiaoLivePublishResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeToutiaoLivePublishResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeToutiaoLivePublishResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUpBpsPeakDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainSwitch: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSwitch != nil {
            map["DomainSwitch"] = self.domainSwitch!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainSwitch") {
            self.domainSwitch = dict["DomainSwitch"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeUpBpsPeakDataResponseBody : Tea.TeaModel {
    public class DescribeUpPeakTraffics : Tea.TeaModel {
        public class DescribeUpPeakTraffic : Tea.TeaModel {
            public var bandWidth: String?

            public var peakTime: String?

            public var queryTime: String?

            public var statName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidth != nil {
                    map["BandWidth"] = self.bandWidth!
                }
                if self.peakTime != nil {
                    map["PeakTime"] = self.peakTime!
                }
                if self.queryTime != nil {
                    map["QueryTime"] = self.queryTime!
                }
                if self.statName != nil {
                    map["StatName"] = self.statName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandWidth") {
                    self.bandWidth = dict["BandWidth"] as! String
                }
                if dict.keys.contains("PeakTime") {
                    self.peakTime = dict["PeakTime"] as! String
                }
                if dict.keys.contains("QueryTime") {
                    self.queryTime = dict["QueryTime"] as! String
                }
                if dict.keys.contains("StatName") {
                    self.statName = dict["StatName"] as! String
                }
            }
        }
        public var describeUpPeakTraffic: [DescribeUpBpsPeakDataResponseBody.DescribeUpPeakTraffics.DescribeUpPeakTraffic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.describeUpPeakTraffic != nil {
                var tmp : [Any] = []
                for k in self.describeUpPeakTraffic! {
                    tmp.append(k.toMap())
                }
                map["DescribeUpPeakTraffic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DescribeUpPeakTraffic") {
                self.describeUpPeakTraffic = dict["DescribeUpPeakTraffic"] as! [DescribeUpBpsPeakDataResponseBody.DescribeUpPeakTraffics.DescribeUpPeakTraffic]
            }
        }
    }
    public var describeUpPeakTraffics: DescribeUpBpsPeakDataResponseBody.DescribeUpPeakTraffics?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.describeUpPeakTraffics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describeUpPeakTraffics != nil {
            map["DescribeUpPeakTraffics"] = self.describeUpPeakTraffics?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DescribeUpPeakTraffics") {
            var model = DescribeUpBpsPeakDataResponseBody.DescribeUpPeakTraffics()
            model.fromMap(dict["DescribeUpPeakTraffics"] as! [String: Any])
            self.describeUpPeakTraffics = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUpBpsPeakDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpBpsPeakDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUpBpsPeakDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUpBpsPeakOfLineRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainSwitch: String?

    public var endTime: String?

    public var line: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSwitch != nil {
            map["DomainSwitch"] = self.domainSwitch!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainSwitch") {
            self.domainSwitch = dict["DomainSwitch"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Line") {
            self.line = dict["Line"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeUpBpsPeakOfLineResponseBody : Tea.TeaModel {
    public class DescribeUpBpsPeakOfLines : Tea.TeaModel {
        public class DescribeUpBpsPeakOfLine : Tea.TeaModel {
            public var bandWidth: Double?

            public var peakTime: String?

            public var queryTime: String?

            public var statName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidth != nil {
                    map["BandWidth"] = self.bandWidth!
                }
                if self.peakTime != nil {
                    map["PeakTime"] = self.peakTime!
                }
                if self.queryTime != nil {
                    map["QueryTime"] = self.queryTime!
                }
                if self.statName != nil {
                    map["StatName"] = self.statName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandWidth") {
                    self.bandWidth = dict["BandWidth"] as! Double
                }
                if dict.keys.contains("PeakTime") {
                    self.peakTime = dict["PeakTime"] as! String
                }
                if dict.keys.contains("QueryTime") {
                    self.queryTime = dict["QueryTime"] as! String
                }
                if dict.keys.contains("StatName") {
                    self.statName = dict["StatName"] as! String
                }
            }
        }
        public var describeUpBpsPeakOfLine: [DescribeUpBpsPeakOfLineResponseBody.DescribeUpBpsPeakOfLines.DescribeUpBpsPeakOfLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.describeUpBpsPeakOfLine != nil {
                var tmp : [Any] = []
                for k in self.describeUpBpsPeakOfLine! {
                    tmp.append(k.toMap())
                }
                map["DescribeUpBpsPeakOfLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DescribeUpBpsPeakOfLine") {
                self.describeUpBpsPeakOfLine = dict["DescribeUpBpsPeakOfLine"] as! [DescribeUpBpsPeakOfLineResponseBody.DescribeUpBpsPeakOfLines.DescribeUpBpsPeakOfLine]
            }
        }
    }
    public var describeUpBpsPeakOfLines: DescribeUpBpsPeakOfLineResponseBody.DescribeUpBpsPeakOfLines?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.describeUpBpsPeakOfLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describeUpBpsPeakOfLines != nil {
            map["DescribeUpBpsPeakOfLines"] = self.describeUpBpsPeakOfLines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DescribeUpBpsPeakOfLines") {
            var model = DescribeUpBpsPeakOfLineResponseBody.DescribeUpBpsPeakOfLines()
            model.fromMap(dict["DescribeUpBpsPeakOfLines"] as! [String: Any])
            self.describeUpBpsPeakOfLines = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUpBpsPeakOfLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpBpsPeakOfLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUpBpsPeakOfLineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUpPeakPublishStreamDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainSwitch: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSwitch != nil {
            map["DomainSwitch"] = self.domainSwitch!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("DomainSwitch") {
            self.domainSwitch = dict["DomainSwitch"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeUpPeakPublishStreamDataResponseBody : Tea.TeaModel {
    public class DescribeUpPeakPublishStreamDatas : Tea.TeaModel {
        public class DescribeUpPeakPublishStreamData : Tea.TeaModel {
            public var bandWidth: String?

            public var peakTime: String?

            public var publishStreamNum: Int32?

            public var queryTime: String?

            public var statName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidth != nil {
                    map["BandWidth"] = self.bandWidth!
                }
                if self.peakTime != nil {
                    map["PeakTime"] = self.peakTime!
                }
                if self.publishStreamNum != nil {
                    map["PublishStreamNum"] = self.publishStreamNum!
                }
                if self.queryTime != nil {
                    map["QueryTime"] = self.queryTime!
                }
                if self.statName != nil {
                    map["StatName"] = self.statName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandWidth") {
                    self.bandWidth = dict["BandWidth"] as! String
                }
                if dict.keys.contains("PeakTime") {
                    self.peakTime = dict["PeakTime"] as! String
                }
                if dict.keys.contains("PublishStreamNum") {
                    self.publishStreamNum = dict["PublishStreamNum"] as! Int32
                }
                if dict.keys.contains("QueryTime") {
                    self.queryTime = dict["QueryTime"] as! String
                }
                if dict.keys.contains("StatName") {
                    self.statName = dict["StatName"] as! String
                }
            }
        }
        public var describeUpPeakPublishStreamData: [DescribeUpPeakPublishStreamDataResponseBody.DescribeUpPeakPublishStreamDatas.DescribeUpPeakPublishStreamData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.describeUpPeakPublishStreamData != nil {
                var tmp : [Any] = []
                for k in self.describeUpPeakPublishStreamData! {
                    tmp.append(k.toMap())
                }
                map["DescribeUpPeakPublishStreamData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DescribeUpPeakPublishStreamData") {
                self.describeUpPeakPublishStreamData = dict["DescribeUpPeakPublishStreamData"] as! [DescribeUpPeakPublishStreamDataResponseBody.DescribeUpPeakPublishStreamDatas.DescribeUpPeakPublishStreamData]
            }
        }
    }
    public var describeUpPeakPublishStreamDatas: DescribeUpPeakPublishStreamDataResponseBody.DescribeUpPeakPublishStreamDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.describeUpPeakPublishStreamDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describeUpPeakPublishStreamDatas != nil {
            map["DescribeUpPeakPublishStreamDatas"] = self.describeUpPeakPublishStreamDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DescribeUpPeakPublishStreamDatas") {
            var model = DescribeUpPeakPublishStreamDataResponseBody.DescribeUpPeakPublishStreamDatas()
            model.fromMap(dict["DescribeUpPeakPublishStreamDatas"] as! [String: Any])
            self.describeUpPeakPublishStreamDatas = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeUpPeakPublishStreamDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpPeakPublishStreamDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUpPeakPublishStreamDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class DisableLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DynamicUpdateWaterMarkStreamRuleRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var stream: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Stream") {
            self.stream = dict["Stream"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DynamicUpdateWaterMarkStreamRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DynamicUpdateWaterMarkStreamRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DynamicUpdateWaterMarkStreamRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DynamicUpdateWaterMarkStreamRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EditPlaylistRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programConfig: String?

    public var programId: String?

    public var programItems: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programConfig != nil {
            map["ProgramConfig"] = self.programConfig!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.programItems != nil {
            map["ProgramItems"] = self.programItems!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProgramConfig") {
            self.programConfig = dict["ProgramConfig"] as! String
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("ProgramItems") {
            self.programItems = dict["ProgramItems"] as! String
        }
    }
}

public class EditPlaylistResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class FailedItems : Tea.TeaModel {
            public var itemId: String?

            public var itemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") {
                    self.itemId = dict["ItemId"] as! String
                }
                if dict.keys.contains("ItemName") {
                    self.itemName = dict["ItemName"] as! String
                }
            }
        }
        public class SuccessItems : Tea.TeaModel {
            public var itemId: String?

            public var itemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ItemId") {
                    self.itemId = dict["ItemId"] as! String
                }
                if dict.keys.contains("ItemName") {
                    self.itemName = dict["ItemName"] as! String
                }
            }
        }
        public var failedItems: [EditPlaylistResponseBody.Items.FailedItems]?

        public var successItems: [EditPlaylistResponseBody.Items.SuccessItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedItems != nil {
                var tmp : [Any] = []
                for k in self.failedItems! {
                    tmp.append(k.toMap())
                }
                map["FailedItems"] = tmp
            }
            if self.successItems != nil {
                var tmp : [Any] = []
                for k in self.successItems! {
                    tmp.append(k.toMap())
                }
                map["SuccessItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FailedItems") {
                self.failedItems = dict["FailedItems"] as! [EditPlaylistResponseBody.Items.FailedItems]
            }
            if dict.keys.contains("SuccessItems") {
                self.successItems = dict["SuccessItems"] as! [EditPlaylistResponseBody.Items.SuccessItems]
            }
        }
    }
    public var casterId: String?

    public var items: EditPlaylistResponseBody.Items?

    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("Items") {
            var model = EditPlaylistResponseBody.Items()
            model.fromMap(dict["Items"] as! [String: Any])
            self.items = model
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EditPlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EditPlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EditPlaylistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EditShowAndReplaceRequest : Tea.TeaModel {
    public var casterId: String?

    public var endTime: Double?

    public var ownerId: Int64?

    public var showId: String?

    public var startTime: Double?

    public var storageInfo: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.storageInfo != nil {
            map["StorageInfo"] = self.storageInfo!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Double
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ShowId") {
            self.showId = dict["ShowId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Double
        }
        if dict.keys.contains("StorageInfo") {
            self.storageInfo = dict["StorageInfo"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class EditShowAndReplaceResponseBody : Tea.TeaModel {
    public var jobInfo: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobInfo != nil {
            map["JobInfo"] = self.jobInfo!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobInfo") {
            self.jobInfo = dict["JobInfo"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EditShowAndReplaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EditShowAndReplaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EditShowAndReplaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EffectCasterUrgentRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
    }
}

public class EffectCasterUrgentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EffectCasterUrgentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EffectCasterUrgentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EffectCasterUrgentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EffectCasterVideoResourceRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var resourceId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
    }
}

public class EffectCasterVideoResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EffectCasterVideoResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EffectCasterVideoResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EffectCasterVideoResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class EnableLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ForbidLiveStreamRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var liveStreamType: String?

    public var oneshot: String?

    public var ownerId: Int64?

    public var resumeTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.liveStreamType != nil {
            map["LiveStreamType"] = self.liveStreamType!
        }
        if self.oneshot != nil {
            map["Oneshot"] = self.oneshot!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resumeTime != nil {
            map["ResumeTime"] = self.resumeTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("LiveStreamType") {
            self.liveStreamType = dict["LiveStreamType"] as! String
        }
        if dict.keys.contains("Oneshot") {
            self.oneshot = dict["Oneshot"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResumeTime") {
            self.resumeTime = dict["ResumeTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class ForbidLiveStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ForbidLiveStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ForbidLiveStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ForbidLiveStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ForbidPushStreamRequest : Tea.TeaModel {
    public var appId: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var roomId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class ForbidPushStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ForbidPushStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ForbidPushStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ForbidPushStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAllCustomTemplatesRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetAllCustomTemplatesResponseBody : Tea.TeaModel {
    public var customTemplates: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplates != nil {
            map["CustomTemplates"] = self.customTemplates!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplates") {
            self.customTemplates = dict["CustomTemplates"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAllCustomTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAllCustomTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAllCustomTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCustomTemplateRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
    }
}

public class GetCustomTemplateResponseBody : Tea.TeaModel {
    public var customTemplate: String?

    public var requestId: String?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomTemplate") {
            self.customTemplate = dict["CustomTemplate"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            self.template = dict["Template"] as! String
        }
    }
}

public class GetCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCustomTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEditingJobInfoRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var showId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ShowId") {
            self.showId = dict["ShowId"] as! String
        }
    }
}

public class GetEditingJobInfoResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var editingTasksInfo: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.editingTasksInfo != nil {
            map["EditingTasksInfo"] = self.editingTasksInfo!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("EditingTasksInfo") {
            self.editingTasksInfo = dict["EditingTasksInfo"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEditingJobInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingJobInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEditingJobInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMessageAppRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class GetMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var appConfig: [String: String]?

        public var appId: String?

        public var appName: String?

        public var createTime: Int64?

        public var extension_: [String: String]?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appConfig != nil {
                map["AppConfig"] = self.appConfig!
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppConfig") {
                self.appConfig = dict["AppConfig"] as! [String: String]
            }
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! [String: String]
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: GetMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetMessageAppResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMessageAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
    }
}

public class GetMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: Int64?

        public var creatorId: String?

        public var extension_: [String: Any]?

        public var groupId: String?

        public var isMuteAll: Bool?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.isMuteAll != nil {
                map["IsMuteAll"] = self.isMuteAll!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CreatorId") {
                self.creatorId = dict["CreatorId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! [String: Any]
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("IsMuteAll") {
                self.isMuteAll = dict["IsMuteAll"] as! Bool
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: GetMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetMessageGroupResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMessageGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMessageTokenRequest : Tea.TeaModel {
    public var appId: String?

    public var deviceId: String?

    public var deviceType: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("DeviceType") {
            self.deviceType = dict["DeviceType"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetMessageTokenResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessToken: String?

        public var accessTokenExpiredTime: Int64?

        public var refreshToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessToken != nil {
                map["AccessToken"] = self.accessToken!
            }
            if self.accessTokenExpiredTime != nil {
                map["AccessTokenExpiredTime"] = self.accessTokenExpiredTime!
            }
            if self.refreshToken != nil {
                map["RefreshToken"] = self.refreshToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessToken") {
                self.accessToken = dict["AccessToken"] as! String
            }
            if dict.keys.contains("AccessTokenExpiredTime") {
                self.accessTokenExpiredTime = dict["AccessTokenExpiredTime"] as! Int64
            }
            if dict.keys.contains("RefreshToken") {
                self.refreshToken = dict["RefreshToken"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: GetMessageTokenResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetMessageTokenResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetMessageTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMessageTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMessageTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultiRateConfigRequest : Tea.TeaModel {
    public var app: String?

    public var domainName: String?

    public var groupId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class GetMultiRateConfigResponseBody : Tea.TeaModel {
    public class TemplatesInfo : Tea.TeaModel {
        public class Detail : Tea.TeaModel {
            public var audioBitrate: Int32?

            public var audioChannelNum: Int32?

            public var audioCodec: String?

            public var audioProfile: String?

            public var audioRate: Int32?

            public var bandWidth: Int32?

            public var fps: Int32?

            public var gop: String?

            public var height: Int32?

            public var profile: Int32?

            public var template: String?

            public var templateType: String?

            public var videoBitrate: Int32?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioBitrate != nil {
                    map["AudioBitrate"] = self.audioBitrate!
                }
                if self.audioChannelNum != nil {
                    map["AudioChannelNum"] = self.audioChannelNum!
                }
                if self.audioCodec != nil {
                    map["AudioCodec"] = self.audioCodec!
                }
                if self.audioProfile != nil {
                    map["AudioProfile"] = self.audioProfile!
                }
                if self.audioRate != nil {
                    map["AudioRate"] = self.audioRate!
                }
                if self.bandWidth != nil {
                    map["BandWidth"] = self.bandWidth!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.template != nil {
                    map["Template"] = self.template!
                }
                if self.templateType != nil {
                    map["TemplateType"] = self.templateType!
                }
                if self.videoBitrate != nil {
                    map["VideoBitrate"] = self.videoBitrate!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioBitrate") {
                    self.audioBitrate = dict["AudioBitrate"] as! Int32
                }
                if dict.keys.contains("AudioChannelNum") {
                    self.audioChannelNum = dict["AudioChannelNum"] as! Int32
                }
                if dict.keys.contains("AudioCodec") {
                    self.audioCodec = dict["AudioCodec"] as! String
                }
                if dict.keys.contains("AudioProfile") {
                    self.audioProfile = dict["AudioProfile"] as! String
                }
                if dict.keys.contains("AudioRate") {
                    self.audioRate = dict["AudioRate"] as! Int32
                }
                if dict.keys.contains("BandWidth") {
                    self.bandWidth = dict["BandWidth"] as! Int32
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! Int32
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int32
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! Int32
                }
                if dict.keys.contains("Template") {
                    self.template = dict["Template"] as! String
                }
                if dict.keys.contains("TemplateType") {
                    self.templateType = dict["TemplateType"] as! String
                }
                if dict.keys.contains("VideoBitrate") {
                    self.videoBitrate = dict["VideoBitrate"] as! Int32
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! Int32
                }
            }
        }
        public var detail: [GetMultiRateConfigResponseBody.TemplatesInfo.Detail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detail != nil {
                var tmp : [Any] = []
                for k in self.detail! {
                    tmp.append(k.toMap())
                }
                map["Detail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Detail") {
                self.detail = dict["Detail"] as! [GetMultiRateConfigResponseBody.TemplatesInfo.Detail]
            }
        }
    }
    public var app: String?

    public var avFormat: String?

    public var code: Int32?

    public var domain: String?

    public var groupId: String?

    public var isLazy: String?

    public var isTimeAlign: String?

    public var message: String?

    public var requestId: String?

    public var stream: String?

    public var templatesInfo: GetMultiRateConfigResponseBody.TemplatesInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templatesInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.avFormat != nil {
            map["AvFormat"] = self.avFormat!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isLazy != nil {
            map["IsLazy"] = self.isLazy!
        }
        if self.isTimeAlign != nil {
            map["IsTimeAlign"] = self.isTimeAlign!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        if self.templatesInfo != nil {
            map["TemplatesInfo"] = self.templatesInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("AvFormat") {
            self.avFormat = dict["AvFormat"] as! String
        }
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("IsLazy") {
            self.isLazy = dict["IsLazy"] as! String
        }
        if dict.keys.contains("IsTimeAlign") {
            self.isTimeAlign = dict["IsTimeAlign"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Stream") {
            self.stream = dict["Stream"] as! String
        }
        if dict.keys.contains("TemplatesInfo") {
            var model = GetMultiRateConfigResponseBody.TemplatesInfo()
            model.fromMap(dict["TemplatesInfo"] as! [String: Any])
            self.templatesInfo = model
        }
    }
}

public class GetMultiRateConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultiRateConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMultiRateConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultiRateConfigListRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class GetMultiRateConfigListResponseBody : Tea.TeaModel {
    public class GroupInfo : Tea.TeaModel {
        public class Info : Tea.TeaModel {
            public var app: String?

            public var avFormat: String?

            public var count: Int32?

            public var groupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.app != nil {
                    map["App"] = self.app!
                }
                if self.avFormat != nil {
                    map["AvFormat"] = self.avFormat!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("App") {
                    self.app = dict["App"] as! String
                }
                if dict.keys.contains("AvFormat") {
                    self.avFormat = dict["AvFormat"] as! String
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
            }
        }
        public var info: [GetMultiRateConfigListResponseBody.GroupInfo.Info]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.info != nil {
                var tmp : [Any] = []
                for k in self.info! {
                    tmp.append(k.toMap())
                }
                map["Info"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Info") {
                self.info = dict["Info"] as! [GetMultiRateConfigListResponseBody.GroupInfo.Info]
            }
        }
    }
    public var code: Int32?

    public var groupInfo: GetMultiRateConfigListResponseBody.GroupInfo?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.groupInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.groupInfo != nil {
            map["GroupInfo"] = self.groupInfo?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("GroupInfo") {
            var model = GetMultiRateConfigListResponseBody.GroupInfo()
            model.fromMap(dict["GroupInfo"] as! [String: Any])
            self.groupInfo = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMultiRateConfigListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultiRateConfigListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMultiRateConfigListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class HotLiveRtcStreamRequest : Tea.TeaModel {
    public var appName: String?

    public var audioMsid: String?

    public var connectionTimeout: String?

    public var domainName: String?

    public var mediaTimeout: String?

    public var ownerId: Int64?

    public var regionCode: String?

    public var streamName: String?

    public var videoMsid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.audioMsid != nil {
            map["AudioMsid"] = self.audioMsid!
        }
        if self.connectionTimeout != nil {
            map["ConnectionTimeout"] = self.connectionTimeout!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.mediaTimeout != nil {
            map["MediaTimeout"] = self.mediaTimeout!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionCode != nil {
            map["RegionCode"] = self.regionCode!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.videoMsid != nil {
            map["VideoMsid"] = self.videoMsid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AudioMsid") {
            self.audioMsid = dict["AudioMsid"] as! String
        }
        if dict.keys.contains("ConnectionTimeout") {
            self.connectionTimeout = dict["ConnectionTimeout"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("MediaTimeout") {
            self.mediaTimeout = dict["MediaTimeout"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionCode") {
            self.regionCode = dict["RegionCode"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
        if dict.keys.contains("VideoMsid") {
            self.videoMsid = dict["VideoMsid"] as! String
        }
    }
}

public class HotLiveRtcStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class HotLiveRtcStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: HotLiveRtcStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = HotLiveRtcStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitializeAutoShowListTaskRequest : Tea.TeaModel {
    public var callBackUrl: String?

    public var casterConfig: String?

    public var domainName: String?

    public var endTime: Int64?

    public var ownerId: Int64?

    public var resourceIds: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callBackUrl != nil {
            map["CallBackUrl"] = self.callBackUrl!
        }
        if self.casterConfig != nil {
            map["CasterConfig"] = self.casterConfig!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallBackUrl") {
            self.callBackUrl = dict["CallBackUrl"] as! String
        }
        if dict.keys.contains("CasterConfig") {
            self.casterConfig = dict["CasterConfig"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class InitializeAutoShowListTaskResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public var streamList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamList != nil {
            map["StreamList"] = self.streamList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StreamList") {
            self.streamList = dict["StreamList"] as! String
        }
    }
}

public class InitializeAutoShowListTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitializeAutoShowListTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InitializeAutoShowListTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastStatistics: Bool?

    public var broadCastType: Int32?

    public var groupId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastStatistics != nil {
            map["BroadCastStatistics"] = self.broadCastStatistics!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BroadCastStatistics") {
            self.broadCastStatistics = dict["BroadCastStatistics"] as! Bool
        }
        if dict.keys.contains("BroadCastType") {
            self.broadCastType = dict["BroadCastType"] as! Int32
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class JoinMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: JoinMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = JoinMessageGroupResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class JoinMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinMessageGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LeaveMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastStatistics: Bool?

    public var broadCastType: Int32?

    public var groupId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastStatistics != nil {
            map["BroadCastStatistics"] = self.broadCastStatistics!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BroadCastStatistics") {
            self.broadCastStatistics = dict["BroadCastStatistics"] as! Bool
        }
        if dict.keys.contains("BroadCastType") {
            self.broadCastType = dict["BroadCastType"] as! Int32
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class LeaveMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: LeaveMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = LeaveMessageGroupResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class LeaveMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LeaveMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LeaveMessageGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var liveOpenapiReserve: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveOpenapiReserve != nil {
            map["LiveOpenapiReserve"] = self.liveOpenapiReserve!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveOpenapiReserve") {
            self.liveOpenapiReserve = dict["LiveOpenapiReserve"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class ListLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class RealtimeLogDeliveryInfo : Tea.TeaModel {
            public var dmId: Int32?

            public var domainName: String?

            public var logstore: String?

            public var project: String?

            public var region: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dmId != nil {
                    map["DmId"] = self.dmId!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.logstore != nil {
                    map["Logstore"] = self.logstore!
                }
                if self.project != nil {
                    map["Project"] = self.project!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DmId") {
                    self.dmId = dict["DmId"] as! Int32
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Logstore") {
                    self.logstore = dict["Logstore"] as! String
                }
                if dict.keys.contains("Project") {
                    self.project = dict["Project"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var realtimeLogDeliveryInfo: [ListLiveRealtimeLogDeliveryResponseBody.Content.RealtimeLogDeliveryInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.realtimeLogDeliveryInfo != nil {
                var tmp : [Any] = []
                for k in self.realtimeLogDeliveryInfo! {
                    tmp.append(k.toMap())
                }
                map["RealtimeLogDeliveryInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RealtimeLogDeliveryInfo") {
                self.realtimeLogDeliveryInfo = dict["RealtimeLogDeliveryInfo"] as! [ListLiveRealtimeLogDeliveryResponseBody.Content.RealtimeLogDeliveryInfo]
            }
        }
    }
    public var content: ListLiveRealtimeLogDeliveryResponseBody.Content?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = ListLiveRealtimeLogDeliveryResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRealtimeLogDeliveryDomainsRequest : Tea.TeaModel {
    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Logstore") {
            self.logstore = dict["Logstore"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Project") {
            self.project = dict["Project"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class ListLiveRealtimeLogDeliveryDomainsResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class Domains : Tea.TeaModel {
            public var domainName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var domains: [ListLiveRealtimeLogDeliveryDomainsResponseBody.Content.Domains]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domains != nil {
                var tmp : [Any] = []
                for k in self.domains! {
                    tmp.append(k.toMap())
                }
                map["Domains"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domains") {
                self.domains = dict["Domains"] as! [ListLiveRealtimeLogDeliveryDomainsResponseBody.Content.Domains]
            }
        }
    }
    public var content: ListLiveRealtimeLogDeliveryDomainsResponseBody.Content?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = ListLiveRealtimeLogDeliveryDomainsResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListLiveRealtimeLogDeliveryDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRealtimeLogDeliveryDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRealtimeLogDeliveryDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLiveRealtimeLogDeliveryInfosRequest : Tea.TeaModel {
    public var liveOpenapiReserve: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveOpenapiReserve != nil {
            map["LiveOpenapiReserve"] = self.liveOpenapiReserve!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LiveOpenapiReserve") {
            self.liveOpenapiReserve = dict["LiveOpenapiReserve"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class ListLiveRealtimeLogDeliveryInfosResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class RealtimeLogDeliveryInfos : Tea.TeaModel {
            public var logstore: String?

            public var project: String?

            public var region: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logstore != nil {
                    map["Logstore"] = self.logstore!
                }
                if self.project != nil {
                    map["Project"] = self.project!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Logstore") {
                    self.logstore = dict["Logstore"] as! String
                }
                if dict.keys.contains("Project") {
                    self.project = dict["Project"] as! String
                }
                if dict.keys.contains("Region") {
                    self.region = dict["Region"] as! String
                }
            }
        }
        public var realtimeLogDeliveryInfos: [ListLiveRealtimeLogDeliveryInfosResponseBody.Content.RealtimeLogDeliveryInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.realtimeLogDeliveryInfos != nil {
                var tmp : [Any] = []
                for k in self.realtimeLogDeliveryInfos! {
                    tmp.append(k.toMap())
                }
                map["RealtimeLogDeliveryInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RealtimeLogDeliveryInfos") {
                self.realtimeLogDeliveryInfos = dict["RealtimeLogDeliveryInfos"] as! [ListLiveRealtimeLogDeliveryInfosResponseBody.Content.RealtimeLogDeliveryInfos]
            }
        }
    }
    public var content: ListLiveRealtimeLogDeliveryInfosResponseBody.Content?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            var model = ListLiveRealtimeLogDeliveryInfosResponseBody.Content()
            model.fromMap(dict["Content"] as! [String: Any])
            self.content = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListLiveRealtimeLogDeliveryInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRealtimeLogDeliveryInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLiveRealtimeLogDeliveryInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMessageRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! Int32
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class ListMessageResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class MessageList : Tea.TeaModel {
            public var data: String?

            public var groupId: String?

            public var messageId: String?

            public var senderId: String?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                if self.senderId != nil {
                    map["SenderId"] = self.senderId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("MessageId") {
                    self.messageId = dict["MessageId"] as! String
                }
                if dict.keys.contains("SenderId") {
                    self.senderId = dict["SenderId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int32
                }
            }
        }
        public var hasMore: Bool?

        public var messageList: [ListMessageResponseBody.Result.MessageList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.messageList != nil {
                var tmp : [Any] = []
                for k in self.messageList! {
                    tmp.append(k.toMap())
                }
                map["MessageList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HasMore") {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("MessageList") {
                self.messageList = dict["MessageList"] as! [ListMessageResponseBody.Result.MessageList]
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ListMessageResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ListMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMessageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMessageAppRequest : Tea.TeaModel {
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! Int32
        }
    }
}

public class ListMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AppList : Tea.TeaModel {
            public var appConfig: [String: String]?

            public var appId: String?

            public var appName: String?

            public var createTime: Int64?

            public var extension_: [String: String]?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appConfig != nil {
                    map["AppConfig"] = self.appConfig!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppConfig") {
                    self.appConfig = dict["AppConfig"] as! [String: String]
                }
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! [String: String]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var appList: [ListMessageAppResponseBody.Result.AppList]?

        public var hasMore: Bool?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appList != nil {
                var tmp : [Any] = []
                for k in self.appList! {
                    tmp.append(k.toMap())
                }
                map["AppList"] = tmp
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppList") {
                self.appList = dict["AppList"] as! [ListMessageAppResponseBody.Result.AppList]
            }
            if dict.keys.contains("HasMore") {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ListMessageAppResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ListMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMessageAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class GroupList : Tea.TeaModel {
            public var appId: String?

            public var createTime: Int64?

            public var creatorId: String?

            public var extension_: [String: String]?

            public var groupId: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreatorId") {
                    self.creatorId = dict["CreatorId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! [String: String]
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var groupList: [ListMessageGroupResponseBody.Result.GroupList]?

        public var hasMore: Bool?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupList != nil {
                var tmp : [Any] = []
                for k in self.groupList! {
                    tmp.append(k.toMap())
                }
                map["GroupList"] = tmp
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GroupList") {
                self.groupList = dict["GroupList"] as! [ListMessageGroupResponseBody.Result.GroupList]
            }
            if dict.keys.contains("HasMore") {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ListMessageGroupResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ListMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMessageGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMessageGroupUserRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! Int32
        }
    }
}

public class ListMessageGroupUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class UserList : Tea.TeaModel {
            public var joinTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.joinTime != nil {
                    map["JoinTime"] = self.joinTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JoinTime") {
                    self.joinTime = dict["JoinTime"] as! Int64
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var hasMore: Bool?

        public var total: Int32?

        public var userList: [ListMessageGroupUserResponseBody.Result.UserList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            if self.userList != nil {
                var tmp : [Any] = []
                for k in self.userList! {
                    tmp.append(k.toMap())
                }
                map["UserList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HasMore") {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
            if dict.keys.contains("UserList") {
                self.userList = dict["UserList"] as! [ListMessageGroupUserResponseBody.Result.UserList]
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageGroupUserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ListMessageGroupUserResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ListMessageGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMessageGroupUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMessageGroupUserByIdRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var userIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("UserIdList") {
            self.userIdList = dict["UserIdList"] as! [String]
        }
    }
}

public class ListMessageGroupUserByIdShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var userIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userIdListShrink != nil {
            map["UserIdList"] = self.userIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("UserIdList") {
            self.userIdListShrink = dict["UserIdList"] as! String
        }
    }
}

public class ListMessageGroupUserByIdResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class UserList : Tea.TeaModel {
            public var isMute: Bool?

            public var muteBy: [String]?

            public var userAvatar: String?

            public var userExtension: String?

            public var userId: String?

            public var userNick: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isMute != nil {
                    map["IsMute"] = self.isMute!
                }
                if self.muteBy != nil {
                    map["MuteBy"] = self.muteBy!
                }
                if self.userAvatar != nil {
                    map["UserAvatar"] = self.userAvatar!
                }
                if self.userExtension != nil {
                    map["UserExtension"] = self.userExtension!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNick != nil {
                    map["UserNick"] = self.userNick!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IsMute") {
                    self.isMute = dict["IsMute"] as! Bool
                }
                if dict.keys.contains("MuteBy") {
                    self.muteBy = dict["MuteBy"] as! [String]
                }
                if dict.keys.contains("UserAvatar") {
                    self.userAvatar = dict["UserAvatar"] as! String
                }
                if dict.keys.contains("UserExtension") {
                    self.userExtension = dict["UserExtension"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserNick") {
                    self.userNick = dict["UserNick"] as! String
                }
            }
        }
        public var hasMore: Bool?

        public var total: Int32?

        public var userList: [ListMessageGroupUserByIdResponseBody.Result.UserList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            if self.userList != nil {
                var tmp : [Any] = []
                for k in self.userList! {
                    tmp.append(k.toMap())
                }
                map["UserList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HasMore") {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int32
            }
            if dict.keys.contains("UserList") {
                self.userList = dict["UserList"] as! [ListMessageGroupUserByIdResponseBody.Result.UserList]
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageGroupUserByIdResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ListMessageGroupUserByIdResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ListMessageGroupUserByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageGroupUserByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMessageGroupUserByIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPlaylistRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var page: Int32?

    public var pageSize: Int32?

    public var programId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
    }
}

public class ListPlaylistResponseBody : Tea.TeaModel {
    public class ProgramList : Tea.TeaModel {
        public var casterId: String?

        public var domainName: String?

        public var programId: String?

        public var programName: String?

        public var repeatNumber: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.casterId != nil {
                map["CasterId"] = self.casterId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.programId != nil {
                map["ProgramId"] = self.programId!
            }
            if self.programName != nil {
                map["ProgramName"] = self.programName!
            }
            if self.repeatNumber != nil {
                map["RepeatNumber"] = self.repeatNumber!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CasterId") {
                self.casterId = dict["CasterId"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("ProgramId") {
                self.programId = dict["ProgramId"] as! String
            }
            if dict.keys.contains("ProgramName") {
                self.programName = dict["ProgramName"] as! String
            }
            if dict.keys.contains("RepeatNumber") {
                self.repeatNumber = dict["RepeatNumber"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
        }
    }
    public var programList: [ListPlaylistResponseBody.ProgramList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programList != nil {
            var tmp : [Any] = []
            for k in self.programList! {
                tmp.append(k.toMap())
            }
            map["ProgramList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProgramList") {
            self.programList = dict["ProgramList"] as! [ListPlaylistResponseBody.ProgramList]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListPlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPlaylistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPlaylistItemsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public var programItemIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.programItemIds != nil {
            map["ProgramItemIds"] = self.programItemIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("ProgramItemIds") {
            self.programItemIds = dict["ProgramItemIds"] as! String
        }
    }
}

public class ListPlaylistItemsResponseBody : Tea.TeaModel {
    public class ProgramItems : Tea.TeaModel {
        public var index: Int32?

        public var programId: String?

        public var programItemId: String?

        public var programItemName: String?

        public var resourceType: String?

        public var resourceValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.index != nil {
                map["Index"] = self.index!
            }
            if self.programId != nil {
                map["ProgramId"] = self.programId!
            }
            if self.programItemId != nil {
                map["ProgramItemId"] = self.programItemId!
            }
            if self.programItemName != nil {
                map["ProgramItemName"] = self.programItemName!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.resourceValue != nil {
                map["ResourceValue"] = self.resourceValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Index") {
                self.index = dict["Index"] as! Int32
            }
            if dict.keys.contains("ProgramId") {
                self.programId = dict["ProgramId"] as! String
            }
            if dict.keys.contains("ProgramItemId") {
                self.programItemId = dict["ProgramItemId"] as! String
            }
            if dict.keys.contains("ProgramItemName") {
                self.programItemName = dict["ProgramItemName"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("ResourceValue") {
                self.resourceValue = dict["ResourceValue"] as! String
            }
        }
    }
    public var programItems: [ListPlaylistItemsResponseBody.ProgramItems]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programItems != nil {
            var tmp : [Any] = []
            for k in self.programItems! {
                tmp.append(k.toMap())
            }
            map["ProgramItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProgramItems") {
            self.programItems = dict["ProgramItems"] as! [ListPlaylistItemsResponseBody.ProgramItems]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListPlaylistItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPlaylistItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPlaylistItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCasterComponentRequest : Tea.TeaModel {
    public var captionLayerContent: String?

    public var casterId: String?

    public var componentId: String?

    public var componentLayer: String?

    public var componentName: String?

    public var componentType: String?

    public var effect: String?

    public var imageLayerContent: String?

    public var ownerId: Int64?

    public var textLayerContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.captionLayerContent != nil {
            map["CaptionLayerContent"] = self.captionLayerContent!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.componentLayer != nil {
            map["ComponentLayer"] = self.componentLayer!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.componentType != nil {
            map["ComponentType"] = self.componentType!
        }
        if self.effect != nil {
            map["Effect"] = self.effect!
        }
        if self.imageLayerContent != nil {
            map["ImageLayerContent"] = self.imageLayerContent!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.textLayerContent != nil {
            map["TextLayerContent"] = self.textLayerContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CaptionLayerContent") {
            self.captionLayerContent = dict["CaptionLayerContent"] as! String
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! String
        }
        if dict.keys.contains("ComponentLayer") {
            self.componentLayer = dict["ComponentLayer"] as! String
        }
        if dict.keys.contains("ComponentName") {
            self.componentName = dict["ComponentName"] as! String
        }
        if dict.keys.contains("ComponentType") {
            self.componentType = dict["ComponentType"] as! String
        }
        if dict.keys.contains("Effect") {
            self.effect = dict["Effect"] as! String
        }
        if dict.keys.contains("ImageLayerContent") {
            self.imageLayerContent = dict["ImageLayerContent"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("TextLayerContent") {
            self.textLayerContent = dict["TextLayerContent"] as! String
        }
    }
}

public class ModifyCasterComponentResponseBody : Tea.TeaModel {
    public var componentId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCasterComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCasterComponentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCasterEpisodeRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: [String]?

    public var endTime: String?

    public var episodeId: String?

    public var episodeName: String?

    public var ownerId: Int64?

    public var resourceId: String?

    public var startTime: String?

    public var switchType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.episodeName != nil {
            map["EpisodeName"] = self.episodeName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.switchType != nil {
            map["SwitchType"] = self.switchType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EpisodeId") {
            self.episodeId = dict["EpisodeId"] as! String
        }
        if dict.keys.contains("EpisodeName") {
            self.episodeName = dict["EpisodeName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("SwitchType") {
            self.switchType = dict["SwitchType"] as! String
        }
    }
}

public class ModifyCasterEpisodeResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var episodeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("EpisodeId") {
            self.episodeId = dict["EpisodeId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCasterEpisodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterEpisodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCasterEpisodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCasterLayoutRequest : Tea.TeaModel {
    public class AudioLayer : Tea.TeaModel {
        public var fixedDelayDuration: Int32?

        public var validChannel: String?

        public var volumeRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.validChannel != nil {
                map["ValidChannel"] = self.validChannel!
            }
            if self.volumeRate != nil {
                map["VolumeRate"] = self.volumeRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FixedDelayDuration") {
                self.fixedDelayDuration = dict["FixedDelayDuration"] as! Int32
            }
            if dict.keys.contains("ValidChannel") {
                self.validChannel = dict["ValidChannel"] as! String
            }
            if dict.keys.contains("VolumeRate") {
                self.volumeRate = dict["VolumeRate"] as! Double
            }
        }
    }
    public class VideoLayer : Tea.TeaModel {
        public var fillMode: String?

        public var fixedDelayDuration: Int32?

        public var heightNormalized: Double?

        public var positionNormalized: [Double]?

        public var positionRefer: String?

        public var widthNormalized: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fillMode != nil {
                map["FillMode"] = self.fillMode!
            }
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.heightNormalized != nil {
                map["HeightNormalized"] = self.heightNormalized!
            }
            if self.positionNormalized != nil {
                map["PositionNormalized"] = self.positionNormalized!
            }
            if self.positionRefer != nil {
                map["PositionRefer"] = self.positionRefer!
            }
            if self.widthNormalized != nil {
                map["WidthNormalized"] = self.widthNormalized!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FillMode") {
                self.fillMode = dict["FillMode"] as! String
            }
            if dict.keys.contains("FixedDelayDuration") {
                self.fixedDelayDuration = dict["FixedDelayDuration"] as! Int32
            }
            if dict.keys.contains("HeightNormalized") {
                self.heightNormalized = dict["HeightNormalized"] as! Double
            }
            if dict.keys.contains("PositionNormalized") {
                self.positionNormalized = dict["PositionNormalized"] as! [Double]
            }
            if dict.keys.contains("PositionRefer") {
                self.positionRefer = dict["PositionRefer"] as! String
            }
            if dict.keys.contains("WidthNormalized") {
                self.widthNormalized = dict["WidthNormalized"] as! Double
            }
        }
    }
    public var audioLayer: [ModifyCasterLayoutRequest.AudioLayer]?

    public var blendList: [String]?

    public var casterId: String?

    public var layoutId: String?

    public var mixList: [String]?

    public var ownerId: Int64?

    public var videoLayer: [ModifyCasterLayoutRequest.VideoLayer]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioLayer != nil {
            var tmp : [Any] = []
            for k in self.audioLayer! {
                tmp.append(k.toMap())
            }
            map["AudioLayer"] = tmp
        }
        if self.blendList != nil {
            map["BlendList"] = self.blendList!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.mixList != nil {
            map["MixList"] = self.mixList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.videoLayer != nil {
            var tmp : [Any] = []
            for k in self.videoLayer! {
                tmp.append(k.toMap())
            }
            map["VideoLayer"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioLayer") {
            self.audioLayer = dict["AudioLayer"] as! [ModifyCasterLayoutRequest.AudioLayer]
        }
        if dict.keys.contains("BlendList") {
            self.blendList = dict["BlendList"] as! [String]
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("MixList") {
            self.mixList = dict["MixList"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("VideoLayer") {
            self.videoLayer = dict["VideoLayer"] as! [ModifyCasterLayoutRequest.VideoLayer]
        }
    }
}

public class ModifyCasterLayoutResponseBody : Tea.TeaModel {
    public var layoutId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCasterLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCasterLayoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCasterProgramRequest : Tea.TeaModel {
    public class Episode : Tea.TeaModel {
        public var componentId: [String]?

        public var endTime: String?

        public var episodeId: String?

        public var episodeName: String?

        public var episodeType: String?

        public var resourceId: String?

        public var startTime: String?

        public var switchType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentId != nil {
                map["ComponentId"] = self.componentId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.episodeId != nil {
                map["EpisodeId"] = self.episodeId!
            }
            if self.episodeName != nil {
                map["EpisodeName"] = self.episodeName!
            }
            if self.episodeType != nil {
                map["EpisodeType"] = self.episodeType!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.switchType != nil {
                map["SwitchType"] = self.switchType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentId") {
                self.componentId = dict["ComponentId"] as! [String]
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("EpisodeId") {
                self.episodeId = dict["EpisodeId"] as! String
            }
            if dict.keys.contains("EpisodeName") {
                self.episodeName = dict["EpisodeName"] as! String
            }
            if dict.keys.contains("EpisodeType") {
                self.episodeType = dict["EpisodeType"] as! String
            }
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("SwitchType") {
                self.switchType = dict["SwitchType"] as! String
            }
        }
    }
    public var casterId: String?

    public var episode: [ModifyCasterProgramRequest.Episode]?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episode != nil {
            var tmp : [Any] = []
            for k in self.episode! {
                tmp.append(k.toMap())
            }
            map["Episode"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("Episode") {
            self.episode = dict["Episode"] as! [ModifyCasterProgramRequest.Episode]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class ModifyCasterProgramResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCasterProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCasterProgramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCasterVideoResourceRequest : Tea.TeaModel {
    public var beginOffset: Int32?

    public var casterId: String?

    public var endOffset: Int32?

    public var liveStreamUrl: String?

    public var materialId: String?

    public var ownerId: Int64?

    public var ptsCallbackInterval: Int32?

    public var repeatNum: Int32?

    public var resourceId: String?

    public var resourceName: String?

    public var vodUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginOffset != nil {
            map["BeginOffset"] = self.beginOffset!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.endOffset != nil {
            map["EndOffset"] = self.endOffset!
        }
        if self.liveStreamUrl != nil {
            map["LiveStreamUrl"] = self.liveStreamUrl!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ptsCallbackInterval != nil {
            map["PtsCallbackInterval"] = self.ptsCallbackInterval!
        }
        if self.repeatNum != nil {
            map["RepeatNum"] = self.repeatNum!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceName != nil {
            map["ResourceName"] = self.resourceName!
        }
        if self.vodUrl != nil {
            map["VodUrl"] = self.vodUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginOffset") {
            self.beginOffset = dict["BeginOffset"] as! Int32
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("EndOffset") {
            self.endOffset = dict["EndOffset"] as! Int32
        }
        if dict.keys.contains("LiveStreamUrl") {
            self.liveStreamUrl = dict["LiveStreamUrl"] as! String
        }
        if dict.keys.contains("MaterialId") {
            self.materialId = dict["MaterialId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PtsCallbackInterval") {
            self.ptsCallbackInterval = dict["PtsCallbackInterval"] as! Int32
        }
        if dict.keys.contains("RepeatNum") {
            self.repeatNum = dict["RepeatNum"] as! Int32
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceName") {
            self.resourceName = dict["ResourceName"] as! String
        }
        if dict.keys.contains("VodUrl") {
            self.vodUrl = dict["VodUrl"] as! String
        }
    }
}

public class ModifyCasterVideoResourceResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class ModifyCasterVideoResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterVideoResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCasterVideoResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLiveDomainSchdmByPropertyRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var property: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.property != nil {
            map["Property"] = self.property!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Property") {
            self.property = dict["Property"] as! String
        }
    }
}

public class ModifyLiveDomainSchdmByPropertyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLiveDomainSchdmByPropertyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveDomainSchdmByPropertyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyLiveDomainSchdmByPropertyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Logstore") {
            self.logstore = dict["Logstore"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Project") {
            self.project = dict["Project"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class ModifyLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyShowListRequest : Tea.TeaModel {
    public var casterId: String?

    public var highPriorityShowId: String?

    public var highPriorityShowStartTime: String?

    public var ownerId: Int64?

    public var repeatTimes: Int32?

    public var showId: String?

    public var spot: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.highPriorityShowId != nil {
            map["HighPriorityShowId"] = self.highPriorityShowId!
        }
        if self.highPriorityShowStartTime != nil {
            map["HighPriorityShowStartTime"] = self.highPriorityShowStartTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.repeatTimes != nil {
            map["RepeatTimes"] = self.repeatTimes!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.spot != nil {
            map["Spot"] = self.spot!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("HighPriorityShowId") {
            self.highPriorityShowId = dict["HighPriorityShowId"] as! String
        }
        if dict.keys.contains("HighPriorityShowStartTime") {
            self.highPriorityShowStartTime = dict["HighPriorityShowStartTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RepeatTimes") {
            self.repeatTimes = dict["RepeatTimes"] as! Int32
        }
        if dict.keys.contains("ShowId") {
            self.showId = dict["ShowId"] as! String
        }
        if dict.keys.contains("Spot") {
            self.spot = dict["Spot"] as! Int32
        }
    }
}

public class ModifyShowListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyShowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyShowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyShowListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyStudioLayoutRequest : Tea.TeaModel {
    public var bgImageConfig: String?

    public var casterId: String?

    public var commonConfig: String?

    public var layerOrderConfigList: String?

    public var layoutId: String?

    public var layoutName: String?

    public var mediaInputConfigList: String?

    public var ownerId: Int64?

    public var screenInputConfigList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgImageConfig != nil {
            map["BgImageConfig"] = self.bgImageConfig!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.commonConfig != nil {
            map["CommonConfig"] = self.commonConfig!
        }
        if self.layerOrderConfigList != nil {
            map["LayerOrderConfigList"] = self.layerOrderConfigList!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.layoutName != nil {
            map["LayoutName"] = self.layoutName!
        }
        if self.mediaInputConfigList != nil {
            map["MediaInputConfigList"] = self.mediaInputConfigList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.screenInputConfigList != nil {
            map["ScreenInputConfigList"] = self.screenInputConfigList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BgImageConfig") {
            self.bgImageConfig = dict["BgImageConfig"] as! String
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("CommonConfig") {
            self.commonConfig = dict["CommonConfig"] as! String
        }
        if dict.keys.contains("LayerOrderConfigList") {
            self.layerOrderConfigList = dict["LayerOrderConfigList"] as! String
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("LayoutName") {
            self.layoutName = dict["LayoutName"] as! String
        }
        if dict.keys.contains("MediaInputConfigList") {
            self.mediaInputConfigList = dict["MediaInputConfigList"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ScreenInputConfigList") {
            self.screenInputConfigList = dict["ScreenInputConfigList"] as! String
        }
    }
}

public class ModifyStudioLayoutResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyStudioLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStudioLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyStudioLayoutResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenLiveShiftRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var duration: Int32?

    public var ignoreTranscode: Bool?

    public var ownerId: Int64?

    public var streamName: String?

    public var vision: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.ignoreTranscode != nil {
            map["IgnoreTranscode"] = self.ignoreTranscode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.vision != nil {
            map["Vision"] = self.vision!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("IgnoreTranscode") {
            self.ignoreTranscode = dict["IgnoreTranscode"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
        if dict.keys.contains("Vision") {
            self.vision = dict["Vision"] as! Int32
        }
    }
}

public class OpenLiveShiftResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenLiveShiftResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenLiveShiftResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenLiveShiftResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PlayChoosenShowRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var showId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ShowId") {
            self.showId = dict["ShowId"] as! String
        }
    }
}

public class PlayChoosenShowResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var showId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ShowId") {
            self.showId = dict["ShowId"] as! String
        }
    }
}

public class PlayChoosenShowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PlayChoosenShowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PlayChoosenShowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishLiveStagingConfigToProductionRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class PublishLiveStagingConfigToProductionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PublishLiveStagingConfigToProductionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishLiveStagingConfigToProductionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PublishLiveStagingConfigToProductionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMessageAppRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("PageNum") {
            self.pageNum = dict["PageNum"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortType") {
            self.sortType = dict["SortType"] as! Int32
        }
    }
}

public class QueryMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AppList : Tea.TeaModel {
            public var appConfig: [String: String]?

            public var appId: String?

            public var appName: String?

            public var createTime: Int64?

            public var extension_: [String: String]?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appConfig != nil {
                    map["AppConfig"] = self.appConfig!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppConfig") {
                    self.appConfig = dict["AppConfig"] as! [String: String]
                }
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! [String: String]
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
            }
        }
        public var appList: [QueryMessageAppResponseBody.Result.AppList]?

        public var hasMore: Bool?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appList != nil {
                var tmp : [Any] = []
                for k in self.appList! {
                    tmp.append(k.toMap())
                }
                map["AppList"] = tmp
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppList") {
                self.appList = dict["AppList"] as! [QueryMessageAppResponseBody.Result.AppList]
            }
            if dict.keys.contains("HasMore") {
                self.hasMore = dict["HasMore"] as! Bool
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: [QueryMessageAppResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [QueryMessageAppResponseBody.Result]
        }
    }
}

public class QueryMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMessageAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySnapshotCallbackAuthRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class QuerySnapshotCallbackAuthResponseBody : Tea.TeaModel {
    public var callbackAuthKey: String?

    public var callbackReqAuth: String?

    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackAuthKey != nil {
            map["CallbackAuthKey"] = self.callbackAuthKey!
        }
        if self.callbackReqAuth != nil {
            map["CallbackReqAuth"] = self.callbackReqAuth!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackAuthKey") {
            self.callbackAuthKey = dict["CallbackAuthKey"] as! String
        }
        if dict.keys.contains("CallbackReqAuth") {
            self.callbackReqAuth = dict["CallbackReqAuth"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QuerySnapshotCallbackAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySnapshotCallbackAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySnapshotCallbackAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RealTimeRecordCommandRequest : Tea.TeaModel {
    public var appName: String?

    public var command: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class RealTimeRecordCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RealTimeRecordCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RealTimeRecordCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RealTimeRecordCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RealTimeSnapshotCommandRequest : Tea.TeaModel {
    public var appName: String?

    public var command: String?

    public var domainName: String?

    public var interval: Int32?

    public var mode: Int32?

    public var ownerId: Int64?

    public var source: Int32?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("Mode") {
            self.mode = dict["Mode"] as! Int32
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! Int32
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class RealTimeSnapshotCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RealTimeSnapshotCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RealTimeSnapshotCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RealTimeSnapshotCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveShowFromShowListRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var showId: String?

    public var isBatchMode: Bool?

    public var showIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.isBatchMode != nil {
            map["isBatchMode"] = self.isBatchMode!
        }
        if self.showIdList != nil {
            map["showIdList"] = self.showIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ShowId") {
            self.showId = dict["ShowId"] as! String
        }
        if dict.keys.contains("isBatchMode") {
            self.isBatchMode = dict["isBatchMode"] as! Bool
        }
        if dict.keys.contains("showIdList") {
            self.showIdList = dict["showIdList"] as! [String]
        }
    }
}

public class RemoveShowFromShowListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var showId: String?

    public var failedList: String?

    public var successfulShowIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.failedList != nil {
            map["failedList"] = self.failedList!
        }
        if self.successfulShowIds != nil {
            map["successfulShowIds"] = self.successfulShowIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ShowId") {
            self.showId = dict["ShowId"] as! String
        }
        if dict.keys.contains("failedList") {
            self.failedList = dict["failedList"] as! String
        }
        if dict.keys.contains("successfulShowIds") {
            self.successfulShowIds = dict["successfulShowIds"] as! String
        }
    }
}

public class RemoveShowFromShowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveShowFromShowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveShowFromShowListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartCasterRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class RestartCasterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RestartCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartCasterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeLiveStreamRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var liveStreamType: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.liveStreamType != nil {
            map["LiveStreamType"] = self.liveStreamType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("LiveStreamType") {
            self.liveStreamType = dict["LiveStreamType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class ResumeLiveStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResumeLiveStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeLiveStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeLiveStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackLiveStagingConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class RollbackLiveStagingConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RollbackLiveStagingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackLiveStagingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RollbackLiveStagingConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendLikeRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastType: Int32?

    public var count: String?

    public var groupId: String?

    public var operatorUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BroadCastType") {
            self.broadCastType = dict["BroadCastType"] as! Int32
        }
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OperatorUserId") {
            self.operatorUserId = dict["OperatorUserId"] as! String
        }
    }
}

public class SendLikeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var likeCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.likeCount != nil {
                map["LikeCount"] = self.likeCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LikeCount") {
                self.likeCount = dict["LikeCount"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: SendLikeResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = SendLikeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class SendLikeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLikeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendLikeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendMessageToGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var groupId: String?

    public var operatorUserId: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OperatorUserId") {
            self.operatorUserId = dict["OperatorUserId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class SendMessageToGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var messageId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.messageId != nil {
                map["MessageId"] = self.messageId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MessageId") {
                self.messageId = dict["MessageId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: SendMessageToGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = SendMessageToGroupResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class SendMessageToGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendMessageToGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendMessageToGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendMessageToGroupUsersRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var groupId: String?

    public var operatorUserId: String?

    public var receiverIdList: [String]?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        if self.receiverIdList != nil {
            map["ReceiverIdList"] = self.receiverIdList!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OperatorUserId") {
            self.operatorUserId = dict["OperatorUserId"] as! String
        }
        if dict.keys.contains("ReceiverIdList") {
            self.receiverIdList = dict["ReceiverIdList"] as! [String]
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class SendMessageToGroupUsersShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var groupId: String?

    public var operatorUserId: String?

    public var receiverIdListShrink: String?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        if self.receiverIdListShrink != nil {
            map["ReceiverIdList"] = self.receiverIdListShrink!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("OperatorUserId") {
            self.operatorUserId = dict["OperatorUserId"] as! String
        }
        if dict.keys.contains("ReceiverIdList") {
            self.receiverIdListShrink = dict["ReceiverIdList"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! Int32
        }
    }
}

public class SendMessageToGroupUsersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var messageId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.messageId != nil {
                map["MessageId"] = self.messageId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MessageId") {
                self.messageId = dict["MessageId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: SendMessageToGroupUsersResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = SendMessageToGroupUsersResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class SendMessageToGroupUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendMessageToGroupUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendMessageToGroupUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendRoomNotificationRequest : Tea.TeaModel {
    public var appId: String?

    public var appUid: String?

    public var data: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var roomId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appUid != nil {
            map["AppUid"] = self.appUid!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppUid") {
            self.appUid = dict["AppUid"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
    }
}

public class SendRoomNotificationResponseBody : Tea.TeaModel {
    public var messageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MessageId") {
            self.messageId = dict["MessageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendRoomNotificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendRoomNotificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendRoomNotificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendRoomUserNotificationRequest : Tea.TeaModel {
    public var appId: String?

    public var appUid: String?

    public var data: String?

    public var ownerId: Int64?

    public var priority: Int32?

    public var roomId: String?

    public var toAppUid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appUid != nil {
            map["AppUid"] = self.appUid!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.roomId != nil {
            map["RoomId"] = self.roomId!
        }
        if self.toAppUid != nil {
            map["ToAppUid"] = self.toAppUid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppUid") {
            self.appUid = dict["AppUid"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! Int32
        }
        if dict.keys.contains("RoomId") {
            self.roomId = dict["RoomId"] as! String
        }
        if dict.keys.contains("ToAppUid") {
            self.toAppUid = dict["ToAppUid"] as! String
        }
    }
}

public class SendRoomUserNotificationResponseBody : Tea.TeaModel {
    public var messageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MessageId") {
            self.messageId = dict["MessageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendRoomUserNotificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendRoomUserNotificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendRoomUserNotificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetCasterChannelRequest : Tea.TeaModel {
    public var casterId: String?

    public var channelId: String?

    public var faceBeauty: String?

    public var ownerId: Int64?

    public var playStatus: Int32?

    public var resourceId: String?

    public var seekOffset: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.faceBeauty != nil {
            map["FaceBeauty"] = self.faceBeauty!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.playStatus != nil {
            map["PlayStatus"] = self.playStatus!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.seekOffset != nil {
            map["SeekOffset"] = self.seekOffset!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("FaceBeauty") {
            self.faceBeauty = dict["FaceBeauty"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PlayStatus") {
            self.playStatus = dict["PlayStatus"] as! Int32
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("SeekOffset") {
            self.seekOffset = dict["SeekOffset"] as! Int32
        }
    }
}

public class SetCasterChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetCasterChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCasterChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetCasterChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetCasterConfigRequest : Tea.TeaModel {
    public var callbackUrl: String?

    public var casterId: String?

    public var casterName: String?

    public var channelEnable: Int32?

    public var delay: Double?

    public var domainName: String?

    public var ownerId: Int64?

    public var programEffect: Int32?

    public var programName: String?

    public var recordConfig: String?

    public var sideOutputUrl: String?

    public var sideOutputUrlList: String?

    public var syncGroupsConfig: String?

    public var transcodeConfig: String?

    public var urgentLiveStreamUrl: String?

    public var urgentMaterialId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.channelEnable != nil {
            map["ChannelEnable"] = self.channelEnable!
        }
        if self.delay != nil {
            map["Delay"] = self.delay!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programEffect != nil {
            map["ProgramEffect"] = self.programEffect!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.recordConfig != nil {
            map["RecordConfig"] = self.recordConfig!
        }
        if self.sideOutputUrl != nil {
            map["SideOutputUrl"] = self.sideOutputUrl!
        }
        if self.sideOutputUrlList != nil {
            map["SideOutputUrlList"] = self.sideOutputUrlList!
        }
        if self.syncGroupsConfig != nil {
            map["SyncGroupsConfig"] = self.syncGroupsConfig!
        }
        if self.transcodeConfig != nil {
            map["TranscodeConfig"] = self.transcodeConfig!
        }
        if self.urgentLiveStreamUrl != nil {
            map["UrgentLiveStreamUrl"] = self.urgentLiveStreamUrl!
        }
        if self.urgentMaterialId != nil {
            map["UrgentMaterialId"] = self.urgentMaterialId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackUrl") {
            self.callbackUrl = dict["CallbackUrl"] as! String
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("CasterName") {
            self.casterName = dict["CasterName"] as! String
        }
        if dict.keys.contains("ChannelEnable") {
            self.channelEnable = dict["ChannelEnable"] as! Int32
        }
        if dict.keys.contains("Delay") {
            self.delay = dict["Delay"] as! Double
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProgramEffect") {
            self.programEffect = dict["ProgramEffect"] as! Int32
        }
        if dict.keys.contains("ProgramName") {
            self.programName = dict["ProgramName"] as! String
        }
        if dict.keys.contains("RecordConfig") {
            self.recordConfig = dict["RecordConfig"] as! String
        }
        if dict.keys.contains("SideOutputUrl") {
            self.sideOutputUrl = dict["SideOutputUrl"] as! String
        }
        if dict.keys.contains("SideOutputUrlList") {
            self.sideOutputUrlList = dict["SideOutputUrlList"] as! String
        }
        if dict.keys.contains("SyncGroupsConfig") {
            self.syncGroupsConfig = dict["SyncGroupsConfig"] as! String
        }
        if dict.keys.contains("TranscodeConfig") {
            self.transcodeConfig = dict["TranscodeConfig"] as! String
        }
        if dict.keys.contains("UrgentLiveStreamUrl") {
            self.urgentLiveStreamUrl = dict["UrgentLiveStreamUrl"] as! String
        }
        if dict.keys.contains("UrgentMaterialId") {
            self.urgentMaterialId = dict["UrgentMaterialId"] as! String
        }
    }
}

public class SetCasterConfigResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetCasterConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCasterConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetCasterConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetCasterSceneConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: [String]?

    public var layoutId: String?

    public var ownerId: Int64?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! [String]
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
    }
}

public class SetCasterSceneConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetCasterSceneConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCasterSceneConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetCasterSceneConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetCasterSyncGroupRequest : Tea.TeaModel {
    public class SyncGroup : Tea.TeaModel {
        public var hostResourceId: String?

        public var mode: Int32?

        public var resourceIds: [String]?

        public var syncDelayThreshold: Int64?

        public var syncOffsets: [Int32]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hostResourceId != nil {
                map["HostResourceId"] = self.hostResourceId!
            }
            if self.mode != nil {
                map["Mode"] = self.mode!
            }
            if self.resourceIds != nil {
                map["ResourceIds"] = self.resourceIds!
            }
            if self.syncDelayThreshold != nil {
                map["SyncDelayThreshold"] = self.syncDelayThreshold!
            }
            if self.syncOffsets != nil {
                map["SyncOffsets"] = self.syncOffsets!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HostResourceId") {
                self.hostResourceId = dict["HostResourceId"] as! String
            }
            if dict.keys.contains("Mode") {
                self.mode = dict["Mode"] as! Int32
            }
            if dict.keys.contains("ResourceIds") {
                self.resourceIds = dict["ResourceIds"] as! [String]
            }
            if dict.keys.contains("SyncDelayThreshold") {
                self.syncDelayThreshold = dict["SyncDelayThreshold"] as! Int64
            }
            if dict.keys.contains("SyncOffsets") {
                self.syncOffsets = dict["SyncOffsets"] as! [Int32]
            }
        }
    }
    public var casterId: String?

    public var ownerId: Int64?

    public var syncGroup: [SetCasterSyncGroupRequest.SyncGroup]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.syncGroup != nil {
            var tmp : [Any] = []
            for k in self.syncGroup! {
                tmp.append(k.toMap())
            }
            map["SyncGroup"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SyncGroup") {
            self.syncGroup = dict["SyncGroup"] as! [SetCasterSyncGroupRequest.SyncGroup]
        }
    }
}

public class SetCasterSyncGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetCasterSyncGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCasterSyncGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetCasterSyncGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetCasterTimedEventRequest : Tea.TeaModel {
    public var casterId: String?

    public var eventName: String?

    public var ownerId: Int64?

    public var startTimeUTC: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.eventName != nil {
            map["EventName"] = self.eventName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.startTimeUTC != nil {
            map["StartTimeUTC"] = self.startTimeUTC!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("EventName") {
            self.eventName = dict["EventName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StartTimeUTC") {
            self.startTimeUTC = dict["StartTimeUTC"] as! String
        }
    }
}

public class SetCasterTimedEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetCasterTimedEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCasterTimedEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetCasterTimedEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLiveDomainCertificateRequest : Tea.TeaModel {
    public var certName: String?

    public var certType: String?

    public var domainName: String?

    public var forceSet: String?

    public var ownerId: Int64?

    public var SSLPri: String?

    public var SSLProtocol: String?

    public var SSLPub: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.certType != nil {
            map["CertType"] = self.certType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.forceSet != nil {
            map["ForceSet"] = self.forceSet!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.SSLPri != nil {
            map["SSLPri"] = self.SSLPri!
        }
        if self.SSLProtocol != nil {
            map["SSLProtocol"] = self.SSLProtocol!
        }
        if self.SSLPub != nil {
            map["SSLPub"] = self.SSLPub!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertName") {
            self.certName = dict["CertName"] as! String
        }
        if dict.keys.contains("CertType") {
            self.certType = dict["CertType"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("ForceSet") {
            self.forceSet = dict["ForceSet"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SSLPri") {
            self.SSLPri = dict["SSLPri"] as! String
        }
        if dict.keys.contains("SSLProtocol") {
            self.SSLProtocol = dict["SSLProtocol"] as! String
        }
        if dict.keys.contains("SSLPub") {
            self.SSLPub = dict["SSLPub"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class SetLiveDomainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLiveDomainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveDomainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLiveDomainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLiveDomainStagingConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var functions: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functions != nil {
            map["Functions"] = self.functions!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Functions") {
            self.functions = dict["Functions"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class SetLiveDomainStagingConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLiveDomainStagingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveDomainStagingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLiveDomainStagingConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLiveEdgeTransferRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var httpDns: String?

    public var ownerId: Int64?

    public var streamName: String?

    public var targetDomainList: String?

    public var transferArgs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.httpDns != nil {
            map["HttpDns"] = self.httpDns!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.targetDomainList != nil {
            map["TargetDomainList"] = self.targetDomainList!
        }
        if self.transferArgs != nil {
            map["TransferArgs"] = self.transferArgs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("HttpDns") {
            self.httpDns = dict["HttpDns"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
        if dict.keys.contains("TargetDomainList") {
            self.targetDomainList = dict["TargetDomainList"] as! String
        }
        if dict.keys.contains("TransferArgs") {
            self.transferArgs = dict["TransferArgs"] as! String
        }
    }
}

public class SetLiveEdgeTransferResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLiveEdgeTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveEdgeTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLiveEdgeTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLiveLazyPullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var pullAppName: String?

    public var pullDomainName: String?

    public var pullProtocol: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pullAppName != nil {
            map["PullAppName"] = self.pullAppName!
        }
        if self.pullDomainName != nil {
            map["PullDomainName"] = self.pullDomainName!
        }
        if self.pullProtocol != nil {
            map["PullProtocol"] = self.pullProtocol!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PullAppName") {
            self.pullAppName = dict["PullAppName"] as! String
        }
        if dict.keys.contains("PullDomainName") {
            self.pullDomainName = dict["PullDomainName"] as! String
        }
        if dict.keys.contains("PullProtocol") {
            self.pullProtocol = dict["PullProtocol"] as! String
        }
    }
}

public class SetLiveLazyPullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLiveLazyPullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveLazyPullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLiveLazyPullStreamInfoConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLiveStreamDelayConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var flvDelay: Int32?

    public var flvLevel: String?

    public var hlsDelay: Int32?

    public var hlsLevel: String?

    public var ownerId: Int64?

    public var rtmpDelay: Int32?

    public var rtmpLevel: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.flvDelay != nil {
            map["FlvDelay"] = self.flvDelay!
        }
        if self.flvLevel != nil {
            map["FlvLevel"] = self.flvLevel!
        }
        if self.hlsDelay != nil {
            map["HlsDelay"] = self.hlsDelay!
        }
        if self.hlsLevel != nil {
            map["HlsLevel"] = self.hlsLevel!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.rtmpDelay != nil {
            map["RtmpDelay"] = self.rtmpDelay!
        }
        if self.rtmpLevel != nil {
            map["RtmpLevel"] = self.rtmpLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("FlvDelay") {
            self.flvDelay = dict["FlvDelay"] as! Int32
        }
        if dict.keys.contains("FlvLevel") {
            self.flvLevel = dict["FlvLevel"] as! String
        }
        if dict.keys.contains("HlsDelay") {
            self.hlsDelay = dict["HlsDelay"] as! Int32
        }
        if dict.keys.contains("HlsLevel") {
            self.hlsLevel = dict["HlsLevel"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RtmpDelay") {
            self.rtmpDelay = dict["RtmpDelay"] as! Int32
        }
        if dict.keys.contains("RtmpLevel") {
            self.rtmpLevel = dict["RtmpLevel"] as! String
        }
    }
}

public class SetLiveStreamDelayConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLiveStreamDelayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveStreamDelayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLiveStreamDelayConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLiveStreamOptimizedFeatureConfigRequest : Tea.TeaModel {
    public var configName: String?

    public var configStatus: String?

    public var configValue: String?

    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configName != nil {
            map["ConfigName"] = self.configName!
        }
        if self.configStatus != nil {
            map["ConfigStatus"] = self.configStatus!
        }
        if self.configValue != nil {
            map["ConfigValue"] = self.configValue!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigName") {
            self.configName = dict["ConfigName"] as! String
        }
        if dict.keys.contains("ConfigStatus") {
            self.configStatus = dict["ConfigStatus"] as! String
        }
        if dict.keys.contains("ConfigValue") {
            self.configValue = dict["ConfigValue"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class SetLiveStreamOptimizedFeatureConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLiveStreamOptimizedFeatureConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveStreamOptimizedFeatureConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLiveStreamOptimizedFeatureConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetLiveStreamsNotifyUrlConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var notifyAuthKey: String?

    public var notifyReqAuth: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("NotifyAuthKey") {
            self.notifyAuthKey = dict["NotifyAuthKey"] as! String
        }
        if dict.keys.contains("NotifyReqAuth") {
            self.notifyReqAuth = dict["NotifyReqAuth"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class SetLiveStreamsNotifyUrlConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetLiveStreamsNotifyUrlConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveStreamsNotifyUrlConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetLiveStreamsNotifyUrlConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetSnapshotCallbackAuthRequest : Tea.TeaModel {
    public var callbackAuthKey: String?

    public var callbackReqAuth: String?

    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackAuthKey != nil {
            map["CallbackAuthKey"] = self.callbackAuthKey!
        }
        if self.callbackReqAuth != nil {
            map["CallbackReqAuth"] = self.callbackReqAuth!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallbackAuthKey") {
            self.callbackAuthKey = dict["CallbackAuthKey"] as! String
        }
        if dict.keys.contains("CallbackReqAuth") {
            self.callbackReqAuth = dict["CallbackReqAuth"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class SetSnapshotCallbackAuthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SetSnapshotCallbackAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetSnapshotCallbackAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetSnapshotCallbackAuthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartCasterRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class StartCasterResponseBody : Tea.TeaModel {
    public class PgmSceneInfos : Tea.TeaModel {
        public class SceneInfo : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public class StreamInfo : Tea.TeaModel {
                    public var outputStreamUrl: String?

                    public var transcodeConfig: String?

                    public var videoFormat: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outputStreamUrl != nil {
                            map["OutputStreamUrl"] = self.outputStreamUrl!
                        }
                        if self.transcodeConfig != nil {
                            map["TranscodeConfig"] = self.transcodeConfig!
                        }
                        if self.videoFormat != nil {
                            map["VideoFormat"] = self.videoFormat!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OutputStreamUrl") {
                            self.outputStreamUrl = dict["OutputStreamUrl"] as! String
                        }
                        if dict.keys.contains("TranscodeConfig") {
                            self.transcodeConfig = dict["TranscodeConfig"] as! String
                        }
                        if dict.keys.contains("VideoFormat") {
                            self.videoFormat = dict["VideoFormat"] as! String
                        }
                    }
                }
                public var streamInfo: [StartCasterResponseBody.PgmSceneInfos.SceneInfo.StreamInfos.StreamInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.streamInfo != nil {
                        var tmp : [Any] = []
                        for k in self.streamInfo! {
                            tmp.append(k.toMap())
                        }
                        map["StreamInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("StreamInfo") {
                        self.streamInfo = dict["StreamInfo"] as! [StartCasterResponseBody.PgmSceneInfos.SceneInfo.StreamInfos.StreamInfo]
                    }
                }
            }
            public var sceneId: String?

            public var streamInfos: StartCasterResponseBody.PgmSceneInfos.SceneInfo.StreamInfos?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.streamInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.streamInfos != nil {
                    map["StreamInfos"] = self.streamInfos?.toMap()
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SceneId") {
                    self.sceneId = dict["SceneId"] as! String
                }
                if dict.keys.contains("StreamInfos") {
                    var model = StartCasterResponseBody.PgmSceneInfos.SceneInfo.StreamInfos()
                    model.fromMap(dict["StreamInfos"] as! [String: Any])
                    self.streamInfos = model
                }
                if dict.keys.contains("StreamUrl") {
                    self.streamUrl = dict["StreamUrl"] as! String
                }
            }
        }
        public var sceneInfo: [StartCasterResponseBody.PgmSceneInfos.SceneInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sceneInfo != nil {
                var tmp : [Any] = []
                for k in self.sceneInfo! {
                    tmp.append(k.toMap())
                }
                map["SceneInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SceneInfo") {
                self.sceneInfo = dict["SceneInfo"] as! [StartCasterResponseBody.PgmSceneInfos.SceneInfo]
            }
        }
    }
    public class PvwSceneInfos : Tea.TeaModel {
        public class SceneInfo : Tea.TeaModel {
            public var sceneId: String?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SceneId") {
                    self.sceneId = dict["SceneId"] as! String
                }
                if dict.keys.contains("StreamUrl") {
                    self.streamUrl = dict["StreamUrl"] as! String
                }
            }
        }
        public var sceneInfo: [StartCasterResponseBody.PvwSceneInfos.SceneInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sceneInfo != nil {
                var tmp : [Any] = []
                for k in self.sceneInfo! {
                    tmp.append(k.toMap())
                }
                map["SceneInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SceneInfo") {
                self.sceneInfo = dict["SceneInfo"] as! [StartCasterResponseBody.PvwSceneInfos.SceneInfo]
            }
        }
    }
    public var pgmSceneInfos: StartCasterResponseBody.PgmSceneInfos?

    public var pvwSceneInfos: StartCasterResponseBody.PvwSceneInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pgmSceneInfos?.validate()
        try self.pvwSceneInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pgmSceneInfos != nil {
            map["PgmSceneInfos"] = self.pgmSceneInfos?.toMap()
        }
        if self.pvwSceneInfos != nil {
            map["PvwSceneInfos"] = self.pvwSceneInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PgmSceneInfos") {
            var model = StartCasterResponseBody.PgmSceneInfos()
            model.fromMap(dict["PgmSceneInfos"] as! [String: Any])
            self.pgmSceneInfos = model
        }
        if dict.keys.contains("PvwSceneInfos") {
            var model = StartCasterResponseBody.PvwSceneInfos()
            model.fromMap(dict["PvwSceneInfos"] as! [String: Any])
            self.pvwSceneInfos = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartCasterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartCasterSceneRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
    }
}

public class StartCasterSceneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var streamUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamUrl != nil {
            map["StreamUrl"] = self.streamUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StreamUrl") {
            self.streamUrl = dict["StreamUrl"] as! String
        }
    }
}

public class StartCasterSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartCasterSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartCasterSceneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartLiveDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class StartLiveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartLiveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartLiveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartLiveDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartLiveStreamMonitorRequest : Tea.TeaModel {
    public var monitorId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorId") {
            self.monitorId = dict["MonitorId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class StartLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartLiveStreamMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartPlaylistRequest : Tea.TeaModel {
    public var offset: Int32?

    public var ownerId: Int64?

    public var programId: String?

    public var resumeMode: String?

    public var startItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.resumeMode != nil {
            map["ResumeMode"] = self.resumeMode!
        }
        if self.startItemId != nil {
            map["StartItemId"] = self.startItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int32
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("ResumeMode") {
            self.resumeMode = dict["ResumeMode"] as! String
        }
        if dict.keys.contains("StartItemId") {
            self.startItemId = dict["StartItemId"] as! String
        }
    }
}

public class StartPlaylistResponseBody : Tea.TeaModel {
    public class StreamInfo : Tea.TeaModel {
        public class Streams : Tea.TeaModel {
            public class Stream : Tea.TeaModel {
                public var pullFlvUrl: String?

                public var pullM3U8Url: String?

                public var pullRtmpUrl: String?

                public var quality: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pullFlvUrl != nil {
                        map["PullFlvUrl"] = self.pullFlvUrl!
                    }
                    if self.pullM3U8Url != nil {
                        map["PullM3U8Url"] = self.pullM3U8Url!
                    }
                    if self.pullRtmpUrl != nil {
                        map["PullRtmpUrl"] = self.pullRtmpUrl!
                    }
                    if self.quality != nil {
                        map["Quality"] = self.quality!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PullFlvUrl") {
                        self.pullFlvUrl = dict["PullFlvUrl"] as! String
                    }
                    if dict.keys.contains("PullM3U8Url") {
                        self.pullM3U8Url = dict["PullM3U8Url"] as! String
                    }
                    if dict.keys.contains("PullRtmpUrl") {
                        self.pullRtmpUrl = dict["PullRtmpUrl"] as! String
                    }
                    if dict.keys.contains("Quality") {
                        self.quality = dict["Quality"] as! String
                    }
                }
            }
            public var stream: [StartPlaylistResponseBody.StreamInfo.Streams.Stream]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.stream != nil {
                    var tmp : [Any] = []
                    for k in self.stream! {
                        tmp.append(k.toMap())
                    }
                    map["Stream"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Stream") {
                    self.stream = dict["Stream"] as! [StartPlaylistResponseBody.StreamInfo.Streams.Stream]
                }
            }
        }
        public var appName: String?

        public var domainName: String?

        public var streamName: String?

        public var streams: StartPlaylistResponseBody.StreamInfo.Streams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.streams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.streams != nil {
                map["Streams"] = self.streams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("StreamName") {
                self.streamName = dict["StreamName"] as! String
            }
            if dict.keys.contains("Streams") {
                var model = StartPlaylistResponseBody.StreamInfo.Streams()
                model.fromMap(dict["Streams"] as! [String: Any])
                self.streams = model
            }
        }
    }
    public var programId: String?

    public var requestId: String?

    public var streamInfo: StartPlaylistResponseBody.StreamInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamInfo != nil {
            map["StreamInfo"] = self.streamInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StreamInfo") {
            var model = StartPlaylistResponseBody.StreamInfo()
            model.fromMap(dict["StreamInfo"] as! [String: Any])
            self.streamInfo = model
        }
    }
}

public class StartPlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartPlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartPlaylistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopCasterRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class StopCasterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopCasterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopCasterSceneRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
    }
}

public class StopCasterSceneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopCasterSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopCasterSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopCasterSceneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopLiveDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class StopLiveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopLiveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopLiveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopLiveDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopLiveStreamMonitorRequest : Tea.TeaModel {
    public var monitorId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorId") {
            self.monitorId = dict["MonitorId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class StopLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopLiveStreamMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopPlaylistRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
    }
}

public class StopPlaylistResponseBody : Tea.TeaModel {
    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProgramId") {
            self.programId = dict["ProgramId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopPlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopPlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopPlaylistResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagLiveResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerId: Int64?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagLiveResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! [TagLiveResourcesRequest.Tag]
        }
    }
}

public class TagLiveResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagLiveResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagLiveResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagLiveResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnTagLiveResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerId: Int64?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UnTagLiveResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnTagLiveResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnTagLiveResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnTagLiveResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCasterSceneAudioRequest : Tea.TeaModel {
    public class AudioLayer : Tea.TeaModel {
        public var fixedDelayDuration: Int32?

        public var validChannel: String?

        public var volumeRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.validChannel != nil {
                map["ValidChannel"] = self.validChannel!
            }
            if self.volumeRate != nil {
                map["VolumeRate"] = self.volumeRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FixedDelayDuration") {
                self.fixedDelayDuration = dict["FixedDelayDuration"] as! Int32
            }
            if dict.keys.contains("ValidChannel") {
                self.validChannel = dict["ValidChannel"] as! String
            }
            if dict.keys.contains("VolumeRate") {
                self.volumeRate = dict["VolumeRate"] as! Double
            }
        }
    }
    public var audioLayer: [UpdateCasterSceneAudioRequest.AudioLayer]?

    public var casterId: String?

    public var followEnable: Int32?

    public var mixList: [String]?

    public var ownerId: Int64?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioLayer != nil {
            var tmp : [Any] = []
            for k in self.audioLayer! {
                tmp.append(k.toMap())
            }
            map["AudioLayer"] = tmp
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.followEnable != nil {
            map["FollowEnable"] = self.followEnable!
        }
        if self.mixList != nil {
            map["MixList"] = self.mixList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioLayer") {
            self.audioLayer = dict["AudioLayer"] as! [UpdateCasterSceneAudioRequest.AudioLayer]
        }
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("FollowEnable") {
            self.followEnable = dict["FollowEnable"] as! Int32
        }
        if dict.keys.contains("MixList") {
            self.mixList = dict["MixList"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
    }
}

public class UpdateCasterSceneAudioResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCasterSceneAudioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCasterSceneAudioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCasterSceneAudioResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCasterSceneConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: [String]?

    public var layoutId: String?

    public var ownerId: Int64?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CasterId") {
            self.casterId = dict["CasterId"] as! String
        }
        if dict.keys.contains("ComponentId") {
            self.componentId = dict["ComponentId"] as! [String]
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SceneId") {
            self.sceneId = dict["SceneId"] as! String
        }
    }
}

public class UpdateCasterSceneConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCasterSceneConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCasterSceneConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCasterSceneConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveAppSnapshotConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var callback: String?

    public var domainName: String?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var overwriteOssObject: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var sequenceOssObject: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.callback != nil {
            map["Callback"] = self.callback!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.overwriteOssObject != nil {
            map["OverwriteOssObject"] = self.overwriteOssObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sequenceOssObject != nil {
            map["SequenceOssObject"] = self.sequenceOssObject!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Callback") {
            self.callback = dict["Callback"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssEndpoint") {
            self.ossEndpoint = dict["OssEndpoint"] as! String
        }
        if dict.keys.contains("OverwriteOssObject") {
            self.overwriteOssObject = dict["OverwriteOssObject"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SequenceOssObject") {
            self.sequenceOssObject = dict["SequenceOssObject"] as! String
        }
        if dict.keys.contains("TimeInterval") {
            self.timeInterval = dict["TimeInterval"] as! Int32
        }
    }
}

public class UpdateLiveAppSnapshotConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveAppSnapshotConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveAppSnapshotConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveAppSnapshotConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveAudioAuditConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var bizType: String?

    public var domainName: String?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("BizType") {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssEndpoint") {
            self.ossEndpoint = dict["OssEndpoint"] as! String
        }
        if dict.keys.contains("OssObject") {
            self.ossObject = dict["OssObject"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class UpdateLiveAudioAuditConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveAudioAuditConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveAudioAuditConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveAudioAuditConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveAudioAuditNotifyConfigRequest : Tea.TeaModel {
    public var callback: String?

    public var callbackTemplate: String?

    public var domainName: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callback != nil {
            map["Callback"] = self.callback!
        }
        if self.callbackTemplate != nil {
            map["CallbackTemplate"] = self.callbackTemplate!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callback") {
            self.callback = dict["Callback"] as! String
        }
        if dict.keys.contains("CallbackTemplate") {
            self.callbackTemplate = dict["CallbackTemplate"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class UpdateLiveAudioAuditNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveAudioAuditNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveAudioAuditNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveAudioAuditNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveDetectNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class UpdateLiveDetectNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveDetectNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveDetectNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveDetectNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLivePullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var sourceUrl: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.sourceUrl != nil {
            map["SourceUrl"] = self.sourceUrl!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SourceUrl") {
            self.sourceUrl = dict["SourceUrl"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StreamName") {
            self.streamName = dict["StreamName"] as! String
        }
    }
}

public class UpdateLivePullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLivePullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLivePullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLivePullStreamInfoConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveRecordNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var needStatusNotify: Bool?

    public var notifyUrl: String?

    public var onDemandUrl: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.needStatusNotify != nil {
            map["NeedStatusNotify"] = self.needStatusNotify!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.onDemandUrl != nil {
            map["OnDemandUrl"] = self.onDemandUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("NeedStatusNotify") {
            self.needStatusNotify = dict["NeedStatusNotify"] as! Bool
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("OnDemandUrl") {
            self.onDemandUrl = dict["OnDemandUrl"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class UpdateLiveRecordNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveRecordNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveRecordNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveRecordNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveSnapshotDetectPornConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var interval: Int32?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var scene: [String]?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! Int32
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssEndpoint") {
            self.ossEndpoint = dict["OssEndpoint"] as! String
        }
        if dict.keys.contains("OssObject") {
            self.ossObject = dict["OssObject"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! [String]
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class UpdateLiveSnapshotDetectPornConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveSnapshotDetectPornConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveSnapshotDetectPornConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveSnapshotDetectPornConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveSnapshotNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var notifyAuthKey: String?

    public var notifyReqAuth: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("NotifyAuthKey") {
            self.notifyAuthKey = dict["NotifyAuthKey"] as! String
        }
        if dict.keys.contains("NotifyReqAuth") {
            self.notifyReqAuth = dict["NotifyReqAuth"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class UpdateLiveSnapshotNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveSnapshotNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveSnapshotNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveSnapshotNotifyConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveStreamMonitorRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var inputList: String?

    public var monitorId: String?

    public var monitorName: String?

    public var outputTemplate: String?

    public var ownerId: Int64?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.inputList != nil {
            map["InputList"] = self.inputList!
        }
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.monitorName != nil {
            map["MonitorName"] = self.monitorName!
        }
        if self.outputTemplate != nil {
            map["OutputTemplate"] = self.outputTemplate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("App") {
            self.app = dict["App"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("InputList") {
            self.inputList = dict["InputList"] as! String
        }
        if dict.keys.contains("MonitorId") {
            self.monitorId = dict["MonitorId"] as! String
        }
        if dict.keys.contains("MonitorName") {
            self.monitorName = dict["MonitorName"] as! String
        }
        if dict.keys.contains("OutputTemplate") {
            self.outputTemplate = dict["OutputTemplate"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Stream") {
            self.stream = dict["Stream"] as! String
        }
    }
}

public class UpdateLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveStreamMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveStreamWatermarkRequest : Tea.TeaModel {
    public var description_: String?

    public var height: Int32?

    public var name: String?

    public var offsetCorner: String?

    public var ownerId: Int64?

    public var pictureUrl: String?

    public var refHeight: Int32?

    public var refWidth: Int32?

    public var templateId: String?

    public var transparency: Int32?

    public var XOffset: Double?

    public var YOffset: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.offsetCorner != nil {
            map["OffsetCorner"] = self.offsetCorner!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pictureUrl != nil {
            map["PictureUrl"] = self.pictureUrl!
        }
        if self.refHeight != nil {
            map["RefHeight"] = self.refHeight!
        }
        if self.refWidth != nil {
            map["RefWidth"] = self.refWidth!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.transparency != nil {
            map["Transparency"] = self.transparency!
        }
        if self.XOffset != nil {
            map["XOffset"] = self.XOffset!
        }
        if self.YOffset != nil {
            map["YOffset"] = self.YOffset!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OffsetCorner") {
            self.offsetCorner = dict["OffsetCorner"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PictureUrl") {
            self.pictureUrl = dict["PictureUrl"] as! String
        }
        if dict.keys.contains("RefHeight") {
            self.refHeight = dict["RefHeight"] as! Int32
        }
        if dict.keys.contains("RefWidth") {
            self.refWidth = dict["RefWidth"] as! Int32
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Transparency") {
            self.transparency = dict["Transparency"] as! Int32
        }
        if dict.keys.contains("XOffset") {
            self.XOffset = dict["XOffset"] as! Double
        }
        if dict.keys.contains("YOffset") {
            self.YOffset = dict["YOffset"] as! Double
        }
    }
}

public class UpdateLiveStreamWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveStreamWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveStreamWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveStreamWatermarkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveStreamWatermarkRuleRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var ownerId: Int64?

    public var ruleId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RuleId") {
            self.ruleId = dict["RuleId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class UpdateLiveStreamWatermarkRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveStreamWatermarkRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveStreamWatermarkRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveStreamWatermarkRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLiveTopLevelDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var securityToken: String?

    public var topLevelDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.topLevelDomain != nil {
            map["TopLevelDomain"] = self.topLevelDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("TopLevelDomain") {
            self.topLevelDomain = dict["TopLevelDomain"] as! String
        }
    }
}

public class UpdateLiveTopLevelDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLiveTopLevelDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveTopLevelDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLiveTopLevelDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMessageAppRequest : Tea.TeaModel {
    public var appConfig: [String: String]?

    public var appId: String?

    public var appName: String?

    public var extension_: [String: String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appConfig != nil {
            map["AppConfig"] = self.appConfig!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppConfig") {
            self.appConfig = dict["AppConfig"] as! [String: String]
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Extension") {
            self.extension_ = dict["Extension"] as! [String: String]
        }
    }
}

public class UpdateMessageAppShrinkRequest : Tea.TeaModel {
    public var appConfigShrink: String?

    public var appId: String?

    public var appName: String?

    public var extensionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appConfigShrink != nil {
            map["AppConfig"] = self.appConfigShrink!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extensionShrink != nil {
            map["Extension"] = self.extensionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppConfig") {
            self.appConfigShrink = dict["AppConfig"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("Extension") {
            self.extensionShrink = dict["Extension"] as! String
        }
    }
}

public class UpdateMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: UpdateMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateMessageAppResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMessageAppResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var extension_: [String: String]?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Extension") {
            self.extension_ = dict["Extension"] as! [String: String]
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
    }
}

public class UpdateMessageGroupShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var extensionShrink: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.extensionShrink != nil {
            map["Extension"] = self.extensionShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Extension") {
            self.extensionShrink = dict["Extension"] as! String
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
    }
}

public class UpdateMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: UpdateMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateMessageGroupResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMessageGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMixStreamRequest : Tea.TeaModel {
    public var domainName: String?

    public var inputStreamList: String?

    public var layoutId: String?

    public var mixStreamId: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.inputStreamList != nil {
            map["InputStreamList"] = self.inputStreamList!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("InputStreamList") {
            self.inputStreamList = dict["InputStreamList"] as! String
        }
        if dict.keys.contains("LayoutId") {
            self.layoutId = dict["LayoutId"] as! String
        }
        if dict.keys.contains("MixStreamId") {
            self.mixStreamId = dict["MixStreamId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
    }
}

public class UpdateMixStreamResponseBody : Tea.TeaModel {
    public var mixStreamId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MixStreamId") {
            self.mixStreamId = dict["MixStreamId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMixStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMixStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMixStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class VerifyLiveDomainOwnerRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var verifyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.verifyType != nil {
            map["VerifyType"] = self.verifyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("VerifyType") {
            self.verifyType = dict["VerifyType"] as! String
        }
    }
}

public class VerifyLiveDomainOwnerResponseBody : Tea.TeaModel {
    public var content: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class VerifyLiveDomainOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyLiveDomainOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = VerifyLiveDomainOwnerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
