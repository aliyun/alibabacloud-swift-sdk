import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AppInfoDTO : Tea.TeaModel {
    public class Platforms : Tea.TeaModel {
        public var itemId: String?

        public var licenseItemIds: [String]?

        public var pkgName: String?

        public var pkgSignature: String?

        public var platformType: Int64?

        public var type: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            if self.licenseItemIds != nil {
                map["LicenseItemIds"] = self.licenseItemIds!
            }
            if self.pkgName != nil {
                map["PkgName"] = self.pkgName!
            }
            if self.pkgSignature != nil {
                map["PkgSignature"] = self.pkgSignature!
            }
            if self.platformType != nil {
                map["PlatformType"] = self.platformType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ItemId"] as? String {
                self.itemId = value
            }
            if let value = dict["LicenseItemIds"] as? [String] {
                self.licenseItemIds = value
            }
            if let value = dict["PkgName"] as? String {
                self.pkgName = value
            }
            if let value = dict["PkgSignature"] as? String {
                self.pkgSignature = value
            }
            if let value = dict["PlatformType"] as? Int64 {
                self.platformType = value
            }
            if let value = dict["Type"] as? Int64 {
                self.type = value
            }
        }
    }
    public var appName: String?

    public var appType: Int32?

    public var creationTime: String?

    public var gmtCreate: String?

    public var gmtModified: String?

    public var itemId: String?

    public var modificationTime: String?

    public var platforms: [AppInfoDTO.Platforms]?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.modificationTime != nil {
            map["ModificationTime"] = self.modificationTime!
        }
        if self.platforms != nil {
            var tmp : [Any] = []
            for k in self.platforms! {
                tmp.append(k.toMap())
            }
            map["Platforms"] = tmp
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AppType"] as? Int32 {
            self.appType = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["GmtCreate"] as? String {
            self.gmtCreate = value
        }
        if let value = dict["GmtModified"] as? String {
            self.gmtModified = value
        }
        if let value = dict["ItemId"] as? String {
            self.itemId = value
        }
        if let value = dict["ModificationTime"] as? String {
            self.modificationTime = value
        }
        if let value = dict["Platforms"] as? [Any?] {
            var tmp : [AppInfoDTO.Platforms] = []
            for v in value {
                if v != nil {
                    var model = AppInfoDTO.Platforms()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.platforms = tmp
        }
        if let value = dict["UserId"] as? Int64 {
            self.userId = value
        }
    }
}

public class LicenseInstanceAppDTO : Tea.TeaModel {
    public class LicenseConfigs : Tea.TeaModel {
        public var businessType: String?

        public var featureIds: String?

        public var isTrial: Bool?

        public var sdkId: Int32?

        public var sdkName: String?

        public var subscription: String?

        public var subscriptionImp: String?

        public var subscriptionPkg: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.businessType != nil {
                map["BusinessType"] = self.businessType!
            }
            if self.featureIds != nil {
                map["FeatureIds"] = self.featureIds!
            }
            if self.isTrial != nil {
                map["IsTrial"] = self.isTrial!
            }
            if self.sdkId != nil {
                map["SdkId"] = self.sdkId!
            }
            if self.sdkName != nil {
                map["SdkName"] = self.sdkName!
            }
            if self.subscription != nil {
                map["Subscription"] = self.subscription!
            }
            if self.subscriptionImp != nil {
                map["SubscriptionImp"] = self.subscriptionImp!
            }
            if self.subscriptionPkg != nil {
                map["SubscriptionPkg"] = self.subscriptionPkg!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BusinessType"] as? String {
                self.businessType = value
            }
            if let value = dict["FeatureIds"] as? String {
                self.featureIds = value
            }
            if let value = dict["IsTrial"] as? Bool {
                self.isTrial = value
            }
            if let value = dict["SdkId"] as? Int32 {
                self.sdkId = value
            }
            if let value = dict["SdkName"] as? String {
                self.sdkName = value
            }
            if let value = dict["Subscription"] as? String {
                self.subscription = value
            }
            if let value = dict["SubscriptionImp"] as? String {
                self.subscriptionImp = value
            }
            if let value = dict["SubscriptionPkg"] as? String {
                self.subscriptionPkg = value
            }
        }
    }
    public var appId: String?

    public var beginOn: String?

    public var contractNo: String?

    public var creationTime: String?

    public var expiredOn: String?

    public var instanceId: String?

    public var itemId: String?

    public var licenseConfigs: [LicenseInstanceAppDTO.LicenseConfigs]?

    public var modificationTime: String?

    public var status: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.beginOn != nil {
            map["BeginOn"] = self.beginOn!
        }
        if self.contractNo != nil {
            map["ContractNo"] = self.contractNo!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.expiredOn != nil {
            map["ExpiredOn"] = self.expiredOn!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        if self.licenseConfigs != nil {
            var tmp : [Any] = []
            for k in self.licenseConfigs! {
                tmp.append(k.toMap())
            }
            map["LicenseConfigs"] = tmp
        }
        if self.modificationTime != nil {
            map["ModificationTime"] = self.modificationTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BeginOn"] as? String {
            self.beginOn = value
        }
        if let value = dict["ContractNo"] as? String {
            self.contractNo = value
        }
        if let value = dict["CreationTime"] as? String {
            self.creationTime = value
        }
        if let value = dict["ExpiredOn"] as? String {
            self.expiredOn = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["ItemId"] as? String {
            self.itemId = value
        }
        if let value = dict["LicenseConfigs"] as? [Any?] {
            var tmp : [LicenseInstanceAppDTO.LicenseConfigs] = []
            for v in value {
                if v != nil {
                    var model = LicenseInstanceAppDTO.LicenseConfigs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.licenseConfigs = tmp
        }
        if let value = dict["ModificationTime"] as? String {
            self.modificationTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["UserId"] as? Int64 {
            self.userId = value
        }
    }
}

public class AddCasterComponentRequest : Tea.TeaModel {
    public var captionLayerContent: String?

    public var casterId: String?

    public var componentLayer: String?

    public var componentName: String?

    public var componentType: String?

    public var effect: String?

    public var htmlLayerContent: String?

    public var imageLayerContent: String?

    public var layerOrder: String?

    public var locationId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var textLayerContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.captionLayerContent != nil {
            map["CaptionLayerContent"] = self.captionLayerContent!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentLayer != nil {
            map["ComponentLayer"] = self.componentLayer!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.componentType != nil {
            map["ComponentType"] = self.componentType!
        }
        if self.effect != nil {
            map["Effect"] = self.effect!
        }
        if self.htmlLayerContent != nil {
            map["HtmlLayerContent"] = self.htmlLayerContent!
        }
        if self.imageLayerContent != nil {
            map["ImageLayerContent"] = self.imageLayerContent!
        }
        if self.layerOrder != nil {
            map["LayerOrder"] = self.layerOrder!
        }
        if self.locationId != nil {
            map["LocationId"] = self.locationId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.textLayerContent != nil {
            map["TextLayerContent"] = self.textLayerContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CaptionLayerContent"] as? String {
            self.captionLayerContent = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ComponentLayer"] as? String {
            self.componentLayer = value
        }
        if let value = dict["ComponentName"] as? String {
            self.componentName = value
        }
        if let value = dict["ComponentType"] as? String {
            self.componentType = value
        }
        if let value = dict["Effect"] as? String {
            self.effect = value
        }
        if let value = dict["HtmlLayerContent"] as? String {
            self.htmlLayerContent = value
        }
        if let value = dict["ImageLayerContent"] as? String {
            self.imageLayerContent = value
        }
        if let value = dict["LayerOrder"] as? String {
            self.layerOrder = value
        }
        if let value = dict["LocationId"] as? String {
            self.locationId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TextLayerContent"] as? String {
            self.textLayerContent = value
        }
    }
}

public class AddCasterComponentResponseBody : Tea.TeaModel {
    public var componentId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComponentId"] as? String {
            self.componentId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCasterComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCasterComponentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddCasterEpisodeRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: [String]?

    public var endTime: String?

    public var episodeName: String?

    public var episodeType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var startTime: String?

    public var switchType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.episodeName != nil {
            map["EpisodeName"] = self.episodeName!
        }
        if self.episodeType != nil {
            map["EpisodeType"] = self.episodeType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.switchType != nil {
            map["SwitchType"] = self.switchType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ComponentId"] as? [String] {
            self.componentId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["EpisodeName"] as? String {
            self.episodeName = value
        }
        if let value = dict["EpisodeType"] as? String {
            self.episodeType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["SwitchType"] as? String {
            self.switchType = value
        }
    }
}

public class AddCasterEpisodeResponseBody : Tea.TeaModel {
    public var episodeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EpisodeId"] as? String {
            self.episodeId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCasterEpisodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterEpisodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCasterEpisodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddCasterEpisodeGroupRequest : Tea.TeaModel {
    public class Item : Tea.TeaModel {
        public var itemName: String?

        public var vodUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemName != nil {
                map["ItemName"] = self.itemName!
            }
            if self.vodUrl != nil {
                map["VodUrl"] = self.vodUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ItemName"] as? String {
                self.itemName = value
            }
            if let value = dict["VodUrl"] as? String {
                self.vodUrl = value
            }
        }
    }
    public var callbackUrl: String?

    public var clientToken: String?

    public var domainName: String?

    public var item: [AddCasterEpisodeGroupRequest.Item]?

    public var ownerId: Int64?

    public var regionId: String?

    public var repeatNum: Int32?

    public var sideOutputUrl: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.item != nil {
            var tmp : [Any] = []
            for k in self.item! {
                tmp.append(k.toMap())
            }
            map["Item"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatNum != nil {
            map["RepeatNum"] = self.repeatNum!
        }
        if self.sideOutputUrl != nil {
            map["SideOutputUrl"] = self.sideOutputUrl!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Item"] as? [Any?] {
            var tmp : [AddCasterEpisodeGroupRequest.Item] = []
            for v in value {
                if v != nil {
                    var model = AddCasterEpisodeGroupRequest.Item()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.item = tmp
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatNum"] as? Int32 {
            self.repeatNum = value
        }
        if let value = dict["SideOutputUrl"] as? String {
            self.sideOutputUrl = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class AddCasterEpisodeGroupResponseBody : Tea.TeaModel {
    public class ItemIds : Tea.TeaModel {
        public var itemId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ItemId"] as? [String] {
                self.itemId = value
            }
        }
    }
    public var itemIds: AddCasterEpisodeGroupResponseBody.ItemIds?

    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds?.toMap()
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ItemIds"] as? [String: Any?] {
            var model = AddCasterEpisodeGroupResponseBody.ItemIds()
            model.fromMap(value)
            self.itemIds = model
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCasterEpisodeGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterEpisodeGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCasterEpisodeGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddCasterEpisodeGroupContentRequest : Tea.TeaModel {
    public var clientToken: String?

    public var content: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class AddCasterEpisodeGroupContentResponseBody : Tea.TeaModel {
    public class ItemIds : Tea.TeaModel {
        public var itemId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.itemId != nil {
                map["ItemId"] = self.itemId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ItemId"] as? [String] {
                self.itemId = value
            }
        }
    }
    public var itemIds: AddCasterEpisodeGroupContentResponseBody.ItemIds?

    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.itemIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.itemIds != nil {
            map["ItemIds"] = self.itemIds?.toMap()
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ItemIds"] as? [String: Any?] {
            var model = AddCasterEpisodeGroupContentResponseBody.ItemIds()
            model.fromMap(value)
            self.itemIds = model
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCasterEpisodeGroupContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterEpisodeGroupContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCasterEpisodeGroupContentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddCasterLayoutRequest : Tea.TeaModel {
    public class AudioLayer : Tea.TeaModel {
        public var fixedDelayDuration: Int32?

        public var validChannel: String?

        public var volumeRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.validChannel != nil {
                map["ValidChannel"] = self.validChannel!
            }
            if self.volumeRate != nil {
                map["VolumeRate"] = self.volumeRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FixedDelayDuration"] as? Int32 {
                self.fixedDelayDuration = value
            }
            if let value = dict["ValidChannel"] as? String {
                self.validChannel = value
            }
            if let value = dict["VolumeRate"] as? Double {
                self.volumeRate = value
            }
        }
    }
    public class VideoLayer : Tea.TeaModel {
        public var fillMode: String?

        public var fixedDelayDuration: Int32?

        public var heightNormalized: Double?

        public var positionNormalized: [Double]?

        public var positionRefer: String?

        public var widthNormalized: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fillMode != nil {
                map["FillMode"] = self.fillMode!
            }
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.heightNormalized != nil {
                map["HeightNormalized"] = self.heightNormalized!
            }
            if self.positionNormalized != nil {
                map["PositionNormalized"] = self.positionNormalized!
            }
            if self.positionRefer != nil {
                map["PositionRefer"] = self.positionRefer!
            }
            if self.widthNormalized != nil {
                map["WidthNormalized"] = self.widthNormalized!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FillMode"] as? String {
                self.fillMode = value
            }
            if let value = dict["FixedDelayDuration"] as? Int32 {
                self.fixedDelayDuration = value
            }
            if let value = dict["HeightNormalized"] as? Double {
                self.heightNormalized = value
            }
            if let value = dict["PositionNormalized"] as? [Double] {
                self.positionNormalized = value
            }
            if let value = dict["PositionRefer"] as? String {
                self.positionRefer = value
            }
            if let value = dict["WidthNormalized"] as? Double {
                self.widthNormalized = value
            }
        }
    }
    public var audioLayer: [AddCasterLayoutRequest.AudioLayer]?

    public var blendList: [String]?

    public var casterId: String?

    public var mixList: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var videoLayer: [AddCasterLayoutRequest.VideoLayer]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioLayer != nil {
            var tmp : [Any] = []
            for k in self.audioLayer! {
                tmp.append(k.toMap())
            }
            map["AudioLayer"] = tmp
        }
        if self.blendList != nil {
            map["BlendList"] = self.blendList!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.mixList != nil {
            map["MixList"] = self.mixList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.videoLayer != nil {
            var tmp : [Any] = []
            for k in self.videoLayer! {
                tmp.append(k.toMap())
            }
            map["VideoLayer"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AudioLayer"] as? [Any?] {
            var tmp : [AddCasterLayoutRequest.AudioLayer] = []
            for v in value {
                if v != nil {
                    var model = AddCasterLayoutRequest.AudioLayer()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.audioLayer = tmp
        }
        if let value = dict["BlendList"] as? [String] {
            self.blendList = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["MixList"] as? [String] {
            self.mixList = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VideoLayer"] as? [Any?] {
            var tmp : [AddCasterLayoutRequest.VideoLayer] = []
            for v in value {
                if v != nil {
                    var model = AddCasterLayoutRequest.VideoLayer()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.videoLayer = tmp
        }
    }
}

public class AddCasterLayoutResponseBody : Tea.TeaModel {
    public var layoutId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCasterLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCasterLayoutResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddCasterProgramRequest : Tea.TeaModel {
    public class Episode : Tea.TeaModel {
        public var componentId: [String]?

        public var endTime: String?

        public var episodeName: String?

        public var episodeType: String?

        public var resourceId: String?

        public var startTime: String?

        public var switchType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentId != nil {
                map["ComponentId"] = self.componentId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.episodeName != nil {
                map["EpisodeName"] = self.episodeName!
            }
            if self.episodeType != nil {
                map["EpisodeType"] = self.episodeType!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.switchType != nil {
                map["SwitchType"] = self.switchType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComponentId"] as? [String] {
                self.componentId = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["EpisodeName"] as? String {
                self.episodeName = value
            }
            if let value = dict["EpisodeType"] as? String {
                self.episodeType = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["SwitchType"] as? String {
                self.switchType = value
            }
        }
    }
    public var casterId: String?

    public var episode: [AddCasterProgramRequest.Episode]?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episode != nil {
            var tmp : [Any] = []
            for k in self.episode! {
                tmp.append(k.toMap())
            }
            map["Episode"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["Episode"] as? [Any?] {
            var tmp : [AddCasterProgramRequest.Episode] = []
            for v in value {
                if v != nil {
                    var model = AddCasterProgramRequest.Episode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.episode = tmp
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class AddCasterProgramResponseBody : Tea.TeaModel {
    public class EpisodeIds : Tea.TeaModel {
        public class EpisodeId : Tea.TeaModel {
            public var episodeId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.episodeId != nil {
                    map["EpisodeId"] = self.episodeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EpisodeId"] as? String {
                    self.episodeId = value
                }
            }
        }
        public var episodeId: [AddCasterProgramResponseBody.EpisodeIds.EpisodeId]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.episodeId != nil {
                var tmp : [Any] = []
                for k in self.episodeId! {
                    tmp.append(k.toMap())
                }
                map["EpisodeId"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EpisodeId"] as? [Any?] {
                var tmp : [AddCasterProgramResponseBody.EpisodeIds.EpisodeId] = []
                for v in value {
                    if v != nil {
                        var model = AddCasterProgramResponseBody.EpisodeIds.EpisodeId()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.episodeId = tmp
            }
        }
    }
    public var episodeIds: AddCasterProgramResponseBody.EpisodeIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.episodeIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.episodeIds != nil {
            map["EpisodeIds"] = self.episodeIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EpisodeIds"] as? [String: Any?] {
            var model = AddCasterProgramResponseBody.EpisodeIds()
            model.fromMap(value)
            self.episodeIds = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCasterProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCasterProgramResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddCasterVideoResourceRequest : Tea.TeaModel {
    public var beginOffset: Int32?

    public var casterId: String?

    public var endOffset: Int32?

    public var fixedDelayDuration: Int32?

    public var imageId: String?

    public var imageUrl: String?

    public var liveStreamUrl: String?

    public var locationId: String?

    public var materialId: String?

    public var ownerId: Int64?

    public var ptsCallbackInterval: Int32?

    public var regionId: String?

    public var repeatNum: Int32?

    public var resourceName: String?

    public var vodUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginOffset != nil {
            map["BeginOffset"] = self.beginOffset!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.endOffset != nil {
            map["EndOffset"] = self.endOffset!
        }
        if self.fixedDelayDuration != nil {
            map["FixedDelayDuration"] = self.fixedDelayDuration!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.liveStreamUrl != nil {
            map["LiveStreamUrl"] = self.liveStreamUrl!
        }
        if self.locationId != nil {
            map["LocationId"] = self.locationId!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ptsCallbackInterval != nil {
            map["PtsCallbackInterval"] = self.ptsCallbackInterval!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatNum != nil {
            map["RepeatNum"] = self.repeatNum!
        }
        if self.resourceName != nil {
            map["ResourceName"] = self.resourceName!
        }
        if self.vodUrl != nil {
            map["VodUrl"] = self.vodUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BeginOffset"] as? Int32 {
            self.beginOffset = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["EndOffset"] as? Int32 {
            self.endOffset = value
        }
        if let value = dict["FixedDelayDuration"] as? Int32 {
            self.fixedDelayDuration = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["LiveStreamUrl"] as? String {
            self.liveStreamUrl = value
        }
        if let value = dict["LocationId"] as? String {
            self.locationId = value
        }
        if let value = dict["MaterialId"] as? String {
            self.materialId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PtsCallbackInterval"] as? Int32 {
            self.ptsCallbackInterval = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatNum"] as? Int32 {
            self.repeatNum = value
        }
        if let value = dict["ResourceName"] as? String {
            self.resourceName = value
        }
        if let value = dict["VodUrl"] as? String {
            self.vodUrl = value
        }
    }
}

public class AddCasterVideoResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
    }
}

public class AddCasterVideoResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasterVideoResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCasterVideoResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddCustomLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var audioBitrate: Int32?

    public var audioChannelNum: Int32?

    public var audioCodec: String?

    public var audioProfile: String?

    public var audioRate: Int32?

    public var bitrateWithSource: String?

    public var deInterlaced: Bool?

    public var domain: String?

    public var encryptParameters: String?

    public var extWithSource: String?

    public var FPS: Int32?

    public var fpsWithSource: String?

    public var gop: String?

    public var height: Int32?

    public var kmsKeyExpireInterval: String?

    public var kmsKeyID: String?

    public var kmsUID: String?

    public var lazy_: String?

    public var ownerId: Int64?

    public var profile: Int32?

    public var regionId: String?

    public var resWithSource: String?

    public var template: String?

    public var templateType: String?

    public var videoBitrate: Int32?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.audioBitrate != nil {
            map["AudioBitrate"] = self.audioBitrate!
        }
        if self.audioChannelNum != nil {
            map["AudioChannelNum"] = self.audioChannelNum!
        }
        if self.audioCodec != nil {
            map["AudioCodec"] = self.audioCodec!
        }
        if self.audioProfile != nil {
            map["AudioProfile"] = self.audioProfile!
        }
        if self.audioRate != nil {
            map["AudioRate"] = self.audioRate!
        }
        if self.bitrateWithSource != nil {
            map["BitrateWithSource"] = self.bitrateWithSource!
        }
        if self.deInterlaced != nil {
            map["DeInterlaced"] = self.deInterlaced!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.encryptParameters != nil {
            map["EncryptParameters"] = self.encryptParameters!
        }
        if self.extWithSource != nil {
            map["ExtWithSource"] = self.extWithSource!
        }
        if self.FPS != nil {
            map["FPS"] = self.FPS!
        }
        if self.fpsWithSource != nil {
            map["FpsWithSource"] = self.fpsWithSource!
        }
        if self.gop != nil {
            map["Gop"] = self.gop!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.kmsKeyExpireInterval != nil {
            map["KmsKeyExpireInterval"] = self.kmsKeyExpireInterval!
        }
        if self.kmsKeyID != nil {
            map["KmsKeyID"] = self.kmsKeyID!
        }
        if self.kmsUID != nil {
            map["KmsUID"] = self.kmsUID!
        }
        if self.lazy_ != nil {
            map["Lazy"] = self.lazy_!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.profile != nil {
            map["Profile"] = self.profile!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resWithSource != nil {
            map["ResWithSource"] = self.resWithSource!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.videoBitrate != nil {
            map["VideoBitrate"] = self.videoBitrate!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["AudioBitrate"] as? Int32 {
            self.audioBitrate = value
        }
        if let value = dict["AudioChannelNum"] as? Int32 {
            self.audioChannelNum = value
        }
        if let value = dict["AudioCodec"] as? String {
            self.audioCodec = value
        }
        if let value = dict["AudioProfile"] as? String {
            self.audioProfile = value
        }
        if let value = dict["AudioRate"] as? Int32 {
            self.audioRate = value
        }
        if let value = dict["BitrateWithSource"] as? String {
            self.bitrateWithSource = value
        }
        if let value = dict["DeInterlaced"] as? Bool {
            self.deInterlaced = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["EncryptParameters"] as? String {
            self.encryptParameters = value
        }
        if let value = dict["ExtWithSource"] as? String {
            self.extWithSource = value
        }
        if let value = dict["FPS"] as? Int32 {
            self.FPS = value
        }
        if let value = dict["FpsWithSource"] as? String {
            self.fpsWithSource = value
        }
        if let value = dict["Gop"] as? String {
            self.gop = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["KmsKeyExpireInterval"] as? String {
            self.kmsKeyExpireInterval = value
        }
        if let value = dict["KmsKeyID"] as? String {
            self.kmsKeyID = value
        }
        if let value = dict["KmsUID"] as? String {
            self.kmsUID = value
        }
        if let value = dict["Lazy"] as? String {
            self.lazy_ = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Profile"] as? Int32 {
            self.profile = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResWithSource"] as? String {
            self.resWithSource = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
        if let value = dict["TemplateType"] as? String {
            self.templateType = value
        }
        if let value = dict["VideoBitrate"] as? Int32 {
            self.videoBitrate = value
        }
        if let value = dict["Width"] as? Int32 {
            self.width = value
        }
    }
}

public class AddCustomLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddCustomLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCustomLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddCustomLiveStreamTranscodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveAIProduceRulesRequest : Tea.TeaModel {
    public var app: String?

    public var description_: String?

    public var domain: String?

    public var isLazy: Bool?

    public var liveTemplate: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var studioName: String?

    public var subtitleName: String?

    public var suffix: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.isLazy != nil {
            map["IsLazy"] = self.isLazy!
        }
        if self.liveTemplate != nil {
            map["LiveTemplate"] = self.liveTemplate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.studioName != nil {
            map["StudioName"] = self.studioName!
        }
        if self.subtitleName != nil {
            map["SubtitleName"] = self.subtitleName!
        }
        if self.suffix != nil {
            map["Suffix"] = self.suffix!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["IsLazy"] as? Bool {
            self.isLazy = value
        }
        if let value = dict["LiveTemplate"] as? String {
            self.liveTemplate = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StudioName"] as? String {
            self.studioName = value
        }
        if let value = dict["SubtitleName"] as? String {
            self.subtitleName = value
        }
        if let value = dict["Suffix"] as? String {
            self.suffix = value
        }
    }
}

public class AddLiveAIProduceRulesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var rulesId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rulesId != nil {
            map["RulesId"] = self.rulesId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RulesId"] as? String {
            self.rulesId = value
        }
    }
}

public class AddLiveAIProduceRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAIProduceRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveAIProduceRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveAISubtitleRequest : Tea.TeaModel {
    public var bgColor: String?

    public var bgWidthNormalized: Double?

    public var borderWidthNormalized: Double?

    public var copyFrom: String?

    public var description_: String?

    public var dstLanguage: String?

    public var fontColor: String?

    public var fontName: String?

    public var fontSizeNormalized: Double?

    public var height: String?

    public var maxLines: Int32?

    public var ownerId: Int64?

    public var positionNormalized: [Double]?

    public var regionId: String?

    public var showSourceLan: Bool?

    public var srcLanguage: String?

    public var subtitleName: String?

    public var width: String?

    public var wordPerLine: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgColor != nil {
            map["BgColor"] = self.bgColor!
        }
        if self.bgWidthNormalized != nil {
            map["BgWidthNormalized"] = self.bgWidthNormalized!
        }
        if self.borderWidthNormalized != nil {
            map["BorderWidthNormalized"] = self.borderWidthNormalized!
        }
        if self.copyFrom != nil {
            map["CopyFrom"] = self.copyFrom!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dstLanguage != nil {
            map["DstLanguage"] = self.dstLanguage!
        }
        if self.fontColor != nil {
            map["FontColor"] = self.fontColor!
        }
        if self.fontName != nil {
            map["FontName"] = self.fontName!
        }
        if self.fontSizeNormalized != nil {
            map["FontSizeNormalized"] = self.fontSizeNormalized!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.maxLines != nil {
            map["MaxLines"] = self.maxLines!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.positionNormalized != nil {
            map["PositionNormalized"] = self.positionNormalized!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showSourceLan != nil {
            map["ShowSourceLan"] = self.showSourceLan!
        }
        if self.srcLanguage != nil {
            map["SrcLanguage"] = self.srcLanguage!
        }
        if self.subtitleName != nil {
            map["SubtitleName"] = self.subtitleName!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        if self.wordPerLine != nil {
            map["WordPerLine"] = self.wordPerLine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgColor"] as? String {
            self.bgColor = value
        }
        if let value = dict["BgWidthNormalized"] as? Double {
            self.bgWidthNormalized = value
        }
        if let value = dict["BorderWidthNormalized"] as? Double {
            self.borderWidthNormalized = value
        }
        if let value = dict["CopyFrom"] as? String {
            self.copyFrom = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DstLanguage"] as? String {
            self.dstLanguage = value
        }
        if let value = dict["FontColor"] as? String {
            self.fontColor = value
        }
        if let value = dict["FontName"] as? String {
            self.fontName = value
        }
        if let value = dict["FontSizeNormalized"] as? Double {
            self.fontSizeNormalized = value
        }
        if let value = dict["Height"] as? String {
            self.height = value
        }
        if let value = dict["MaxLines"] as? Int32 {
            self.maxLines = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PositionNormalized"] as? [Double] {
            self.positionNormalized = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowSourceLan"] as? Bool {
            self.showSourceLan = value
        }
        if let value = dict["SrcLanguage"] as? String {
            self.srcLanguage = value
        }
        if let value = dict["SubtitleName"] as? String {
            self.subtitleName = value
        }
        if let value = dict["Width"] as? String {
            self.width = value
        }
        if let value = dict["WordPerLine"] as? Int32 {
            self.wordPerLine = value
        }
    }
}

public class AddLiveAISubtitleShrinkRequest : Tea.TeaModel {
    public var bgColor: String?

    public var bgWidthNormalized: Double?

    public var borderWidthNormalized: Double?

    public var copyFrom: String?

    public var description_: String?

    public var dstLanguage: String?

    public var fontColor: String?

    public var fontName: String?

    public var fontSizeNormalized: Double?

    public var height: String?

    public var maxLines: Int32?

    public var ownerId: Int64?

    public var positionNormalizedShrink: String?

    public var regionId: String?

    public var showSourceLan: Bool?

    public var srcLanguage: String?

    public var subtitleName: String?

    public var width: String?

    public var wordPerLine: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgColor != nil {
            map["BgColor"] = self.bgColor!
        }
        if self.bgWidthNormalized != nil {
            map["BgWidthNormalized"] = self.bgWidthNormalized!
        }
        if self.borderWidthNormalized != nil {
            map["BorderWidthNormalized"] = self.borderWidthNormalized!
        }
        if self.copyFrom != nil {
            map["CopyFrom"] = self.copyFrom!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dstLanguage != nil {
            map["DstLanguage"] = self.dstLanguage!
        }
        if self.fontColor != nil {
            map["FontColor"] = self.fontColor!
        }
        if self.fontName != nil {
            map["FontName"] = self.fontName!
        }
        if self.fontSizeNormalized != nil {
            map["FontSizeNormalized"] = self.fontSizeNormalized!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.maxLines != nil {
            map["MaxLines"] = self.maxLines!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.positionNormalizedShrink != nil {
            map["PositionNormalized"] = self.positionNormalizedShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showSourceLan != nil {
            map["ShowSourceLan"] = self.showSourceLan!
        }
        if self.srcLanguage != nil {
            map["SrcLanguage"] = self.srcLanguage!
        }
        if self.subtitleName != nil {
            map["SubtitleName"] = self.subtitleName!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        if self.wordPerLine != nil {
            map["WordPerLine"] = self.wordPerLine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgColor"] as? String {
            self.bgColor = value
        }
        if let value = dict["BgWidthNormalized"] as? Double {
            self.bgWidthNormalized = value
        }
        if let value = dict["BorderWidthNormalized"] as? Double {
            self.borderWidthNormalized = value
        }
        if let value = dict["CopyFrom"] as? String {
            self.copyFrom = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DstLanguage"] as? String {
            self.dstLanguage = value
        }
        if let value = dict["FontColor"] as? String {
            self.fontColor = value
        }
        if let value = dict["FontName"] as? String {
            self.fontName = value
        }
        if let value = dict["FontSizeNormalized"] as? Double {
            self.fontSizeNormalized = value
        }
        if let value = dict["Height"] as? String {
            self.height = value
        }
        if let value = dict["MaxLines"] as? Int32 {
            self.maxLines = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PositionNormalized"] as? String {
            self.positionNormalizedShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowSourceLan"] as? Bool {
            self.showSourceLan = value
        }
        if let value = dict["SrcLanguage"] as? String {
            self.srcLanguage = value
        }
        if let value = dict["SubtitleName"] as? String {
            self.subtitleName = value
        }
        if let value = dict["Width"] as? String {
            self.width = value
        }
        if let value = dict["WordPerLine"] as? Int32 {
            self.wordPerLine = value
        }
    }
}

public class AddLiveAISubtitleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var subtitleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subtitleId != nil {
            map["SubtitleId"] = self.subtitleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SubtitleId"] as? String {
            self.subtitleId = value
        }
    }
}

public class AddLiveAISubtitleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAISubtitleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveAISubtitleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveAppRecordConfigRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CycleDuration"] as? Int32 {
                self.cycleDuration = value
            }
            if let value = dict["Format"] as? String {
                self.format = value
            }
            if let value = dict["OssObjectPrefix"] as? String {
                self.ossObjectPrefix = value
            }
            if let value = dict["SliceDuration"] as? Int32 {
                self.sliceDuration = value
            }
            if let value = dict["SliceOssObjectPrefix"] as? String {
                self.sliceOssObjectPrefix = value
            }
        }
    }
    public class TranscodeRecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var ossObjectPrefix: String?

        public var sliceDuration: Int32?

        public var sliceOssObjectPrefix: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.ossObjectPrefix != nil {
                map["OssObjectPrefix"] = self.ossObjectPrefix!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            if self.sliceOssObjectPrefix != nil {
                map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CycleDuration"] as? Int32 {
                self.cycleDuration = value
            }
            if let value = dict["Format"] as? String {
                self.format = value
            }
            if let value = dict["OssObjectPrefix"] as? String {
                self.ossObjectPrefix = value
            }
            if let value = dict["SliceDuration"] as? Int32 {
                self.sliceDuration = value
            }
            if let value = dict["SliceOssObjectPrefix"] as? String {
                self.sliceOssObjectPrefix = value
            }
        }
    }
    public var appName: String?

    public var delayTime: Int32?

    public var domainName: String?

    public var endTime: String?

    public var onDemand: Int32?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ownerId: Int64?

    public var recordFormat: [AddLiveAppRecordConfigRequest.RecordFormat]?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public var transcodeRecordFormat: [AddLiveAppRecordConfigRequest.TranscodeRecordFormat]?

    public var transcodeTemplates: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.delayTime != nil {
            map["DelayTime"] = self.delayTime!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.onDemand != nil {
            map["OnDemand"] = self.onDemand!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.transcodeRecordFormat != nil {
            var tmp : [Any] = []
            for k in self.transcodeRecordFormat! {
                tmp.append(k.toMap())
            }
            map["TranscodeRecordFormat"] = tmp
        }
        if self.transcodeTemplates != nil {
            map["TranscodeTemplates"] = self.transcodeTemplates!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DelayTime"] as? Int32 {
            self.delayTime = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OnDemand"] as? Int32 {
            self.onDemand = value
        }
        if let value = dict["OssBucket"] as? String {
            self.ossBucket = value
        }
        if let value = dict["OssEndpoint"] as? String {
            self.ossEndpoint = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RecordFormat"] as? [Any?] {
            var tmp : [AddLiveAppRecordConfigRequest.RecordFormat] = []
            for v in value {
                if v != nil {
                    var model = AddLiveAppRecordConfigRequest.RecordFormat()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.recordFormat = tmp
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["TranscodeRecordFormat"] as? [Any?] {
            var tmp : [AddLiveAppRecordConfigRequest.TranscodeRecordFormat] = []
            for v in value {
                if v != nil {
                    var model = AddLiveAppRecordConfigRequest.TranscodeRecordFormat()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.transcodeRecordFormat = tmp
        }
        if let value = dict["TranscodeTemplates"] as? [String] {
            self.transcodeTemplates = value
        }
    }
}

public class AddLiveAppRecordConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveAppRecordConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAppRecordConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveAppRecordConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveAppSnapshotConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var callback: String?

    public var domainName: String?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var overwriteOssObject: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var sequenceOssObject: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.callback != nil {
            map["Callback"] = self.callback!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.overwriteOssObject != nil {
            map["OverwriteOssObject"] = self.overwriteOssObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sequenceOssObject != nil {
            map["SequenceOssObject"] = self.sequenceOssObject!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Callback"] as? String {
            self.callback = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OssBucket"] as? String {
            self.ossBucket = value
        }
        if let value = dict["OssEndpoint"] as? String {
            self.ossEndpoint = value
        }
        if let value = dict["OverwriteOssObject"] as? String {
            self.overwriteOssObject = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["SequenceOssObject"] as? String {
            self.sequenceOssObject = value
        }
        if let value = dict["TimeInterval"] as? Int32 {
            self.timeInterval = value
        }
    }
}

public class AddLiveAppSnapshotConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveAppSnapshotConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAppSnapshotConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveAppSnapshotConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveAudioAuditConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var bizType: String?

    public var domainName: String?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["BizType"] as? String {
            self.bizType = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OssBucket"] as? String {
            self.ossBucket = value
        }
        if let value = dict["OssEndpoint"] as? String {
            self.ossEndpoint = value
        }
        if let value = dict["OssObject"] as? String {
            self.ossObject = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class AddLiveAudioAuditConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveAudioAuditConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAudioAuditConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveAudioAuditConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveAudioAuditNotifyConfigRequest : Tea.TeaModel {
    public var callback: String?

    public var callbackTemplate: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callback != nil {
            map["Callback"] = self.callback!
        }
        if self.callbackTemplate != nil {
            map["CallbackTemplate"] = self.callbackTemplate!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Callback"] as? String {
            self.callback = value
        }
        if let value = dict["CallbackTemplate"] as? String {
            self.callbackTemplate = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class AddLiveAudioAuditNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveAudioAuditNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveAudioAuditNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveAudioAuditNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveCenterTransferRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var dstUrl: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var streamName: String?

    public var transferArgs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.dstUrl != nil {
            map["DstUrl"] = self.dstUrl!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.transferArgs != nil {
            map["TransferArgs"] = self.transferArgs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DstUrl"] as? String {
            self.dstUrl = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["TransferArgs"] as? String {
            self.transferArgs = value
        }
    }
}

public class AddLiveCenterTransferResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveCenterTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveCenterTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveCenterTransferResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveDetectNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class AddLiveDetectNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveDetectNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveDetectNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveDetectNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveDomainRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var checkUrl: String?

    public var domainName: String?

    public var liveDomainType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var region: String?

    public var resourceGroupId: String?

    public var scope: String?

    public var securityToken: String?

    public var tag: [AddLiveDomainRequest.Tag]?

    public var topLevelDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkUrl != nil {
            map["CheckUrl"] = self.checkUrl!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.liveDomainType != nil {
            map["LiveDomainType"] = self.liveDomainType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.topLevelDomain != nil {
            map["TopLevelDomain"] = self.topLevelDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CheckUrl"] as? String {
            self.checkUrl = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["LiveDomainType"] as? String {
            self.liveDomainType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Scope"] as? String {
            self.scope = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [AddLiveDomainRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = AddLiveDomainRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TopLevelDomain"] as? String {
            self.topLevelDomain = value
        }
    }
}

public class AddLiveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveDomainMappingRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var pullDomain: String?

    public var pushDomain: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pullDomain != nil {
            map["PullDomain"] = self.pullDomain!
        }
        if self.pushDomain != nil {
            map["PushDomain"] = self.pushDomain!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PullDomain"] as? String {
            self.pullDomain = value
        }
        if let value = dict["PushDomain"] as? String {
            self.pushDomain = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class AddLiveDomainMappingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveDomainMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveDomainMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveDomainMappingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveDomainPlayMappingRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var playDomain: String?

    public var pullDomain: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.playDomain != nil {
            map["PlayDomain"] = self.playDomain!
        }
        if self.pullDomain != nil {
            map["PullDomain"] = self.pullDomain!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PlayDomain"] as? String {
            self.playDomain = value
        }
        if let value = dict["PullDomain"] as? String {
            self.pullDomain = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class AddLiveDomainPlayMappingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveDomainPlayMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveDomainPlayMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveDomainPlayMappingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveMessageGroupBandRequest : Tea.TeaModel {
    public var appId: String?

    public var bannedUsers: [String]?

    public var dataCenter: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bannedUsers != nil {
            map["BannedUsers"] = self.bannedUsers!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BannedUsers"] as? [String] {
            self.bannedUsers = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class AddLiveMessageGroupBandShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var bannedUsersShrink: String?

    public var dataCenter: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bannedUsersShrink != nil {
            map["BannedUsers"] = self.bannedUsersShrink!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BannedUsers"] as? String {
            self.bannedUsersShrink = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class AddLiveMessageGroupBandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveMessageGroupBandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveMessageGroupBandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveMessageGroupBandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLivePackageConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ignoreTranscode: Bool?

    public var ownerId: Int64?

    public var partDuration: Int32?

    public var protocol_: String?

    public var regionId: String?

    public var segmentDuration: Int32?

    public var segmentNum: Int32?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ignoreTranscode != nil {
            map["IgnoreTranscode"] = self.ignoreTranscode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.partDuration != nil {
            map["PartDuration"] = self.partDuration!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.segmentDuration != nil {
            map["SegmentDuration"] = self.segmentDuration!
        }
        if self.segmentNum != nil {
            map["SegmentNum"] = self.segmentNum!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["IgnoreTranscode"] as? Bool {
            self.ignoreTranscode = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PartDuration"] as? Int32 {
            self.partDuration = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SegmentDuration"] as? Int32 {
            self.segmentDuration = value
        }
        if let value = dict["SegmentNum"] as? Int32 {
            self.segmentNum = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class AddLivePackageConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLivePackageConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLivePackageConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLivePackageConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLivePullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sourceUrl: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sourceUrl != nil {
            map["SourceUrl"] = self.sourceUrl!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SourceUrl"] as? String {
            self.sourceUrl = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class AddLivePullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLivePullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLivePullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLivePullStreamInfoConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveRecordNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var needStatusNotify: Bool?

    public var notifyAuthKey: String?

    public var notifyReqAuth: Bool?

    public var notifyUrl: String?

    public var onDemandUrl: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.needStatusNotify != nil {
            map["NeedStatusNotify"] = self.needStatusNotify!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.onDemandUrl != nil {
            map["OnDemandUrl"] = self.onDemandUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["NeedStatusNotify"] as? Bool {
            self.needStatusNotify = value
        }
        if let value = dict["NotifyAuthKey"] as? String {
            self.notifyAuthKey = value
        }
        if let value = dict["NotifyReqAuth"] as? Bool {
            self.notifyReqAuth = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["OnDemandUrl"] as? String {
            self.onDemandUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class AddLiveRecordNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveRecordNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveRecordNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveRecordNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveRecordVodConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var autoCompose: String?

    public var composeVodTranscodeGroupId: String?

    public var cycleDuration: Int32?

    public var domainName: String?

    public var onDemand: Int32?

    public var ownerId: Int64?

    public var regionId: String?

    public var storageLocation: String?

    public var streamName: String?

    public var vodTranscodeGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.autoCompose != nil {
            map["AutoCompose"] = self.autoCompose!
        }
        if self.composeVodTranscodeGroupId != nil {
            map["ComposeVodTranscodeGroupId"] = self.composeVodTranscodeGroupId!
        }
        if self.cycleDuration != nil {
            map["CycleDuration"] = self.cycleDuration!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.onDemand != nil {
            map["OnDemand"] = self.onDemand!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.storageLocation != nil {
            map["StorageLocation"] = self.storageLocation!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.vodTranscodeGroupId != nil {
            map["VodTranscodeGroupId"] = self.vodTranscodeGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AutoCompose"] as? String {
            self.autoCompose = value
        }
        if let value = dict["ComposeVodTranscodeGroupId"] as? String {
            self.composeVodTranscodeGroupId = value
        }
        if let value = dict["CycleDuration"] as? Int32 {
            self.cycleDuration = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OnDemand"] as? Int32 {
            self.onDemand = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StorageLocation"] as? String {
            self.storageLocation = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["VodTranscodeGroupId"] as? String {
            self.vodTranscodeGroupId = value
        }
    }
}

public class AddLiveRecordVodConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveRecordVodConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveRecordVodConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveRecordVodConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveSnapshotDetectPornConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var interval: Int32?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var scene: [String]?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["OssBucket"] as? String {
            self.ossBucket = value
        }
        if let value = dict["OssEndpoint"] as? String {
            self.ossEndpoint = value
        }
        if let value = dict["OssObject"] as? String {
            self.ossObject = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Scene"] as? [String] {
            self.scene = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class AddLiveSnapshotDetectPornConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveSnapshotDetectPornConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveSnapshotDetectPornConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveSnapshotDetectPornConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveSnapshotNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var notifyAuthKey: String?

    public var notifyReqAuth: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["NotifyAuthKey"] as? String {
            self.notifyAuthKey = value
        }
        if let value = dict["NotifyReqAuth"] as? String {
            self.notifyReqAuth = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class AddLiveSnapshotNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveSnapshotNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveSnapshotNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveSnapshotNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveStreamMergeRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var inAppName1: String?

    public var inAppName2: String?

    public var inStreamName1: String?

    public var inStreamName2: String?

    public var liveMerger: String?

    public var mergeParameters: String?

    public var ownerId: Int64?

    public var protocol_: String?

    public var regionId: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.inAppName1 != nil {
            map["InAppName1"] = self.inAppName1!
        }
        if self.inAppName2 != nil {
            map["InAppName2"] = self.inAppName2!
        }
        if self.inStreamName1 != nil {
            map["InStreamName1"] = self.inStreamName1!
        }
        if self.inStreamName2 != nil {
            map["InStreamName2"] = self.inStreamName2!
        }
        if self.liveMerger != nil {
            map["LiveMerger"] = self.liveMerger!
        }
        if self.mergeParameters != nil {
            map["MergeParameters"] = self.mergeParameters!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InAppName1"] as? String {
            self.inAppName1 = value
        }
        if let value = dict["InAppName2"] as? String {
            self.inAppName2 = value
        }
        if let value = dict["InStreamName1"] as? String {
            self.inStreamName1 = value
        }
        if let value = dict["InStreamName2"] as? String {
            self.inStreamName2 = value
        }
        if let value = dict["LiveMerger"] as? String {
            self.liveMerger = value
        }
        if let value = dict["MergeParameters"] as? String {
            self.mergeParameters = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class AddLiveStreamMergeResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveStreamMergeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveStreamMergeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveStreamMergeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var encryptParameters: String?

    public var lazy_: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.encryptParameters != nil {
            map["EncryptParameters"] = self.encryptParameters!
        }
        if self.lazy_ != nil {
            map["Lazy"] = self.lazy_!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["EncryptParameters"] as? String {
            self.encryptParameters = value
        }
        if let value = dict["Lazy"] as? String {
            self.lazy_ = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
    }
}

public class AddLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveStreamTranscodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveStreamWatermarkRequest : Tea.TeaModel {
    public var description_: String?

    public var domain: String?

    public var height: Int32?

    public var name: String?

    public var offsetCorner: String?

    public var ownerId: Int64?

    public var pictureUrl: String?

    public var refHeight: Int32?

    public var refWidth: Int32?

    public var regionId: String?

    public var transparency: Int32?

    public var type: Int32?

    public var XOffset: Double?

    public var YOffset: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.offsetCorner != nil {
            map["OffsetCorner"] = self.offsetCorner!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pictureUrl != nil {
            map["PictureUrl"] = self.pictureUrl!
        }
        if self.refHeight != nil {
            map["RefHeight"] = self.refHeight!
        }
        if self.refWidth != nil {
            map["RefWidth"] = self.refWidth!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.transparency != nil {
            map["Transparency"] = self.transparency!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.XOffset != nil {
            map["XOffset"] = self.XOffset!
        }
        if self.YOffset != nil {
            map["YOffset"] = self.YOffset!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OffsetCorner"] as? String {
            self.offsetCorner = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PictureUrl"] as? String {
            self.pictureUrl = value
        }
        if let value = dict["RefHeight"] as? Int32 {
            self.refHeight = value
        }
        if let value = dict["RefWidth"] as? Int32 {
            self.refWidth = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Transparency"] as? Int32 {
            self.transparency = value
        }
        if let value = dict["Type"] as? Int32 {
            self.type = value
        }
        if let value = dict["XOffset"] as? Double {
            self.XOffset = value
        }
        if let value = dict["YOffset"] as? Double {
            self.YOffset = value
        }
    }
}

public class AddLiveStreamWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class AddLiveStreamWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveStreamWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveStreamWatermarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddLiveStreamWatermarkRuleRequest : Tea.TeaModel {
    public var app: String?

    public var description_: String?

    public var domain: String?

    public var name: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var stream: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class AddLiveStreamWatermarkRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var ruleId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RuleId"] as? String {
            self.ruleId = value
        }
    }
}

public class AddLiveStreamWatermarkRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddLiveStreamWatermarkRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddLiveStreamWatermarkRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddPlaylistItemsRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var programConfig: String?

    public var programId: String?

    public var programItems: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programConfig != nil {
            map["ProgramConfig"] = self.programConfig!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.programItems != nil {
            map["ProgramItems"] = self.programItems!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProgramConfig"] as? String {
            self.programConfig = value
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["ProgramItems"] as? String {
            self.programItems = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class AddPlaylistItemsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class FailedItems : Tea.TeaModel {
            public var itemId: String?

            public var itemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ItemId"] as? String {
                    self.itemId = value
                }
                if let value = dict["ItemName"] as? String {
                    self.itemName = value
                }
            }
        }
        public class SuccessItems : Tea.TeaModel {
            public var itemId: String?

            public var itemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ItemId"] as? String {
                    self.itemId = value
                }
                if let value = dict["ItemName"] as? String {
                    self.itemName = value
                }
            }
        }
        public var failedItems: [AddPlaylistItemsResponseBody.Items.FailedItems]?

        public var successItems: [AddPlaylistItemsResponseBody.Items.SuccessItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedItems != nil {
                var tmp : [Any] = []
                for k in self.failedItems! {
                    tmp.append(k.toMap())
                }
                map["FailedItems"] = tmp
            }
            if self.successItems != nil {
                var tmp : [Any] = []
                for k in self.successItems! {
                    tmp.append(k.toMap())
                }
                map["SuccessItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FailedItems"] as? [Any?] {
                var tmp : [AddPlaylistItemsResponseBody.Items.FailedItems] = []
                for v in value {
                    if v != nil {
                        var model = AddPlaylistItemsResponseBody.Items.FailedItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.failedItems = tmp
            }
            if let value = dict["SuccessItems"] as? [Any?] {
                var tmp : [AddPlaylistItemsResponseBody.Items.SuccessItems] = []
                for v in value {
                    if v != nil {
                        var model = AddPlaylistItemsResponseBody.Items.SuccessItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.successItems = tmp
            }
        }
    }
    public var items: AddPlaylistItemsResponseBody.Items?

    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = AddPlaylistItemsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddPlaylistItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPlaylistItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddPlaylistItemsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddRtsLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var audioBitrate: Int32?

    public var audioChannelNum: Int32?

    public var audioCodec: String?

    public var audioProfile: String?

    public var audioRate: Int32?

    public var deleteBframes: Bool?

    public var domain: String?

    public var FPS: Int32?

    public var gop: String?

    public var height: Int32?

    public var lazy_: String?

    public var opus: Bool?

    public var ownerId: Int64?

    public var profile: Int32?

    public var regionId: String?

    public var template: String?

    public var templateType: String?

    public var videoBitrate: Int32?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.audioBitrate != nil {
            map["AudioBitrate"] = self.audioBitrate!
        }
        if self.audioChannelNum != nil {
            map["AudioChannelNum"] = self.audioChannelNum!
        }
        if self.audioCodec != nil {
            map["AudioCodec"] = self.audioCodec!
        }
        if self.audioProfile != nil {
            map["AudioProfile"] = self.audioProfile!
        }
        if self.audioRate != nil {
            map["AudioRate"] = self.audioRate!
        }
        if self.deleteBframes != nil {
            map["DeleteBframes"] = self.deleteBframes!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.FPS != nil {
            map["FPS"] = self.FPS!
        }
        if self.gop != nil {
            map["Gop"] = self.gop!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.lazy_ != nil {
            map["Lazy"] = self.lazy_!
        }
        if self.opus != nil {
            map["Opus"] = self.opus!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.profile != nil {
            map["Profile"] = self.profile!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.videoBitrate != nil {
            map["VideoBitrate"] = self.videoBitrate!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["AudioBitrate"] as? Int32 {
            self.audioBitrate = value
        }
        if let value = dict["AudioChannelNum"] as? Int32 {
            self.audioChannelNum = value
        }
        if let value = dict["AudioCodec"] as? String {
            self.audioCodec = value
        }
        if let value = dict["AudioProfile"] as? String {
            self.audioProfile = value
        }
        if let value = dict["AudioRate"] as? Int32 {
            self.audioRate = value
        }
        if let value = dict["DeleteBframes"] as? Bool {
            self.deleteBframes = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["FPS"] as? Int32 {
            self.FPS = value
        }
        if let value = dict["Gop"] as? String {
            self.gop = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["Lazy"] as? String {
            self.lazy_ = value
        }
        if let value = dict["Opus"] as? Bool {
            self.opus = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Profile"] as? Int32 {
            self.profile = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
        if let value = dict["TemplateType"] as? String {
            self.templateType = value
        }
        if let value = dict["VideoBitrate"] as? Int32 {
            self.videoBitrate = value
        }
        if let value = dict["Width"] as? Int32 {
            self.width = value
        }
    }
}

public class AddRtsLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddRtsLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddRtsLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddRtsLiveStreamTranscodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddShowIntoShowListRequest : Tea.TeaModel {
    public class ShowList : Tea.TeaModel {
        public var duration: Int64?

        public var liveInputType: Int32?

        public var repeatTimes: Int32?

        public var resourceId: String?

        public var resourceType: String?

        public var resourceUrl: String?

        public var showName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["duration"] = self.duration!
            }
            if self.liveInputType != nil {
                map["liveInputType"] = self.liveInputType!
            }
            if self.repeatTimes != nil {
                map["repeatTimes"] = self.repeatTimes!
            }
            if self.resourceId != nil {
                map["resourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["resourceType"] = self.resourceType!
            }
            if self.resourceUrl != nil {
                map["resourceUrl"] = self.resourceUrl!
            }
            if self.showName != nil {
                map["showName"] = self.showName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["duration"] as? Int64 {
                self.duration = value
            }
            if let value = dict["liveInputType"] as? Int32 {
                self.liveInputType = value
            }
            if let value = dict["repeatTimes"] as? Int32 {
                self.repeatTimes = value
            }
            if let value = dict["resourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["resourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["resourceUrl"] as? String {
                self.resourceUrl = value
            }
            if let value = dict["showName"] as? String {
                self.showName = value
            }
        }
    }
    public var casterId: String?

    public var duration: Int64?

    public var liveInputType: Int32?

    public var ownerId: Int64?

    public var regionId: String?

    public var repeatTimes: Int32?

    public var resourceId: String?

    public var resourceType: String?

    public var resourceUrl: String?

    public var showName: String?

    public var spot: Int32?

    public var isBatchMode: Bool?

    public var showList: [AddShowIntoShowListRequest.ShowList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.liveInputType != nil {
            map["LiveInputType"] = self.liveInputType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatTimes != nil {
            map["RepeatTimes"] = self.repeatTimes!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.resourceUrl != nil {
            map["ResourceUrl"] = self.resourceUrl!
        }
        if self.showName != nil {
            map["ShowName"] = self.showName!
        }
        if self.spot != nil {
            map["Spot"] = self.spot!
        }
        if self.isBatchMode != nil {
            map["isBatchMode"] = self.isBatchMode!
        }
        if self.showList != nil {
            var tmp : [Any] = []
            for k in self.showList! {
                tmp.append(k.toMap())
            }
            map["showList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["Duration"] as? Int64 {
            self.duration = value
        }
        if let value = dict["LiveInputType"] as? Int32 {
            self.liveInputType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatTimes"] as? Int32 {
            self.repeatTimes = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["ResourceUrl"] as? String {
            self.resourceUrl = value
        }
        if let value = dict["ShowName"] as? String {
            self.showName = value
        }
        if let value = dict["Spot"] as? Int32 {
            self.spot = value
        }
        if let value = dict["isBatchMode"] as? Bool {
            self.isBatchMode = value
        }
        if let value = dict["showList"] as? [Any?] {
            var tmp : [AddShowIntoShowListRequest.ShowList] = []
            for v in value {
                if v != nil {
                    var model = AddShowIntoShowListRequest.ShowList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.showList = tmp
        }
    }
}

public class AddShowIntoShowListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var showId: String?

    public var failedList: String?

    public var successfulShowIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.failedList != nil {
            map["failedList"] = self.failedList!
        }
        if self.successfulShowIds != nil {
            map["successfulShowIds"] = self.successfulShowIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ShowId"] as? String {
            self.showId = value
        }
        if let value = dict["failedList"] as? String {
            self.failedList = value
        }
        if let value = dict["successfulShowIds"] as? String {
            self.successfulShowIds = value
        }
    }
}

public class AddShowIntoShowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddShowIntoShowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddShowIntoShowListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddStudioLayoutRequest : Tea.TeaModel {
    public var bgImageConfig: String?

    public var casterId: String?

    public var commonConfig: String?

    public var layerOrderConfigList: String?

    public var layoutName: String?

    public var layoutType: String?

    public var mediaInputConfigList: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var screenInputConfigList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgImageConfig != nil {
            map["BgImageConfig"] = self.bgImageConfig!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.commonConfig != nil {
            map["CommonConfig"] = self.commonConfig!
        }
        if self.layerOrderConfigList != nil {
            map["LayerOrderConfigList"] = self.layerOrderConfigList!
        }
        if self.layoutName != nil {
            map["LayoutName"] = self.layoutName!
        }
        if self.layoutType != nil {
            map["LayoutType"] = self.layoutType!
        }
        if self.mediaInputConfigList != nil {
            map["MediaInputConfigList"] = self.mediaInputConfigList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.screenInputConfigList != nil {
            map["ScreenInputConfigList"] = self.screenInputConfigList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgImageConfig"] as? String {
            self.bgImageConfig = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["CommonConfig"] as? String {
            self.commonConfig = value
        }
        if let value = dict["LayerOrderConfigList"] as? String {
            self.layerOrderConfigList = value
        }
        if let value = dict["LayoutName"] as? String {
            self.layoutName = value
        }
        if let value = dict["LayoutType"] as? String {
            self.layoutType = value
        }
        if let value = dict["MediaInputConfigList"] as? String {
            self.mediaInputConfigList = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ScreenInputConfigList"] as? String {
            self.screenInputConfigList = value
        }
    }
}

public class AddStudioLayoutResponseBody : Tea.TeaModel {
    public var layoutId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddStudioLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddStudioLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddStudioLayoutResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddTrancodeSEIRequest : Tea.TeaModel {
    public var appName: String?

    public var delay: Int32?

    public var domainName: String?

    public var ownerId: Int64?

    public var pattern: String?

    public var regionId: String?

    public var repeat_: Int32?

    public var streamName: String?

    public var text: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.delay != nil {
            map["Delay"] = self.delay!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pattern != nil {
            map["Pattern"] = self.pattern!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeat_ != nil {
            map["Repeat"] = self.repeat_!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.text != nil {
            map["Text"] = self.text!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Delay"] as? Int32 {
            self.delay = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Pattern"] as? String {
            self.pattern = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Repeat"] as? Int32 {
            self.repeat_ = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["Text"] as? String {
            self.text = value
        }
    }
}

public class AddTrancodeSEIResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddTrancodeSEIResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTrancodeSEIResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddTrancodeSEIResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BanLiveMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var exceptUsers: [String]?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.exceptUsers != nil {
            map["ExceptUsers"] = self.exceptUsers!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["ExceptUsers"] as? [String] {
            self.exceptUsers = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class BanLiveMessageGroupShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var exceptUsersShrink: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.exceptUsersShrink != nil {
            map["ExceptUsers"] = self.exceptUsersShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["ExceptUsers"] as? String {
            self.exceptUsersShrink = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class BanLiveMessageGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class BanLiveMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BanLiveMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BanLiveMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BatchDeleteLiveDomainConfigsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var functionNames: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.functionNames != nil {
            map["FunctionNames"] = self.functionNames!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainNames"] as? String {
            self.domainNames = value
        }
        if let value = dict["FunctionNames"] as? String {
            self.functionNames = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class BatchDeleteLiveDomainConfigsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class BatchDeleteLiveDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchDeleteLiveDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BatchDeleteLiveDomainConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BatchGetOnlineUsersRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var userIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["UserIds"] as? String {
            self.userIds = value
        }
    }
}

public class BatchGetOnlineUsersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class OnlineUsers : Tea.TeaModel {
            public var joinTime: Int64?

            public var online: Bool?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.joinTime != nil {
                    map["JoinTime"] = self.joinTime!
                }
                if self.online != nil {
                    map["Online"] = self.online!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["JoinTime"] as? Int64 {
                    self.joinTime = value
                }
                if let value = dict["Online"] as? Bool {
                    self.online = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var onlineUsers: [BatchGetOnlineUsersResponseBody.Result.OnlineUsers]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.onlineUsers != nil {
                var tmp : [Any] = []
                for k in self.onlineUsers! {
                    tmp.append(k.toMap())
                }
                map["OnlineUsers"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OnlineUsers"] as? [Any?] {
                var tmp : [BatchGetOnlineUsersResponseBody.Result.OnlineUsers] = []
                for v in value {
                    if v != nil {
                        var model = BatchGetOnlineUsersResponseBody.Result.OnlineUsers()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.onlineUsers = tmp
            }
        }
    }
    public var requestId: String?

    public var result: BatchGetOnlineUsersResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = BatchGetOnlineUsersResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class BatchGetOnlineUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchGetOnlineUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BatchGetOnlineUsersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BatchSetLiveDomainConfigsRequest : Tea.TeaModel {
    public var domainNames: String?

    public var functions: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainNames != nil {
            map["DomainNames"] = self.domainNames!
        }
        if self.functions != nil {
            map["Functions"] = self.functions!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainNames"] as? String {
            self.domainNames = value
        }
        if let value = dict["Functions"] as? String {
            self.functions = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class BatchSetLiveDomainConfigsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class BatchSetLiveDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchSetLiveDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BatchSetLiveDomainConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelMuteAllGroupUserRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastType: Int32?

    public var groupId: String?

    public var operatorUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BroadCastType"] as? Int32 {
            self.broadCastType = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
    }
}

public class CancelMuteAllGroupUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var requestId: String?

    public var result: CancelMuteAllGroupUserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CancelMuteAllGroupUserResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CancelMuteAllGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelMuteAllGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelMuteAllGroupUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelMuteGroupUserRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastType: Int32?

    public var cancelMuteUserList: [String]?

    public var groupId: String?

    public var operatorUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.cancelMuteUserList != nil {
            map["CancelMuteUserList"] = self.cancelMuteUserList!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BroadCastType"] as? Int32 {
            self.broadCastType = value
        }
        if let value = dict["CancelMuteUserList"] as? [String] {
            self.cancelMuteUserList = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
    }
}

public class CancelMuteGroupUserShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastType: Int32?

    public var cancelMuteUserListShrink: String?

    public var groupId: String?

    public var operatorUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.cancelMuteUserListShrink != nil {
            map["CancelMuteUserList"] = self.cancelMuteUserListShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BroadCastType"] as? Int32 {
            self.broadCastType = value
        }
        if let value = dict["CancelMuteUserList"] as? String {
            self.cancelMuteUserListShrink = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
    }
}

public class CancelMuteGroupUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var requestId: String?

    public var result: CancelMuteGroupUserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CancelMuteGroupUserResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CancelMuteGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelMuteGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelMuteGroupUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ChangeLiveDomainResourceGroupRequest : Tea.TeaModel {
    public var domainName: String?

    public var newResourceGroupId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["NewResourceGroupId"] as? String {
            self.newResourceGroupId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ChangeLiveDomainResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ChangeLiveDomainResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeLiveDomainResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ChangeLiveDomainResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckLiveMessageUsersInGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
    }
}

public class CheckLiveMessageUsersInGroupShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var userIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userIdsShrink != nil {
            map["UserIds"] = self.userIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["UserIds"] as? String {
            self.userIdsShrink = value
        }
    }
}

public class CheckLiveMessageUsersInGroupResponseBody : Tea.TeaModel {
    public class Users : Tea.TeaModel {
        public var online: Bool?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.online != nil {
                map["Online"] = self.online!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Online"] as? Bool {
                self.online = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var requestId: String?

    public var users: [CheckLiveMessageUsersInGroupResponseBody.Users]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.users != nil {
            var tmp : [Any] = []
            for k in self.users! {
                tmp.append(k.toMap())
            }
            map["Users"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Users"] as? [Any?] {
            var tmp : [CheckLiveMessageUsersInGroupResponseBody.Users] = []
            for v in value {
                if v != nil {
                    var model = CheckLiveMessageUsersInGroupResponseBody.Users()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.users = tmp
        }
    }
}

public class CheckLiveMessageUsersInGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckLiveMessageUsersInGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckLiveMessageUsersInGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckLiveMessageUsersOnlineRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
    }
}

public class CheckLiveMessageUsersOnlineShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var userIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.userIdsShrink != nil {
            map["UserIds"] = self.userIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["UserIds"] as? String {
            self.userIdsShrink = value
        }
    }
}

public class CheckLiveMessageUsersOnlineResponseBody : Tea.TeaModel {
    public class UserList : Tea.TeaModel {
        public var online: Bool?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.online != nil {
                map["Online"] = self.online!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Online"] as? Bool {
                self.online = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var requestId: String?

    public var userList: [CheckLiveMessageUsersOnlineResponseBody.UserList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userList != nil {
            var tmp : [Any] = []
            for k in self.userList! {
                tmp.append(k.toMap())
            }
            map["UserList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UserList"] as? [Any?] {
            var tmp : [CheckLiveMessageUsersOnlineResponseBody.UserList] = []
            for v in value {
                if v != nil {
                    var model = CheckLiveMessageUsersOnlineResponseBody.UserList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.userList = tmp
        }
    }
}

public class CheckLiveMessageUsersOnlineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckLiveMessageUsersOnlineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckLiveMessageUsersOnlineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CloseLiveShiftRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class CloseLiveShiftResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CloseLiveShiftResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseLiveShiftResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CloseLiveShiftResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopyCasterRequest : Tea.TeaModel {
    public var casterName: String?

    public var clientToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var srcCasterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.srcCasterId != nil {
            map["SrcCasterId"] = self.srcCasterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterName"] as? String {
            self.casterName = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SrcCasterId"] as? String {
            self.srcCasterId = value
        }
    }
}

public class CopyCasterResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CopyCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopyCasterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CopyCasterSceneConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var fromSceneId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var toSceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.fromSceneId != nil {
            map["FromSceneId"] = self.fromSceneId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.toSceneId != nil {
            map["ToSceneId"] = self.toSceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["FromSceneId"] as? String {
            self.fromSceneId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ToSceneId"] as? String {
            self.toSceneId = value
        }
    }
}

public class CopyCasterSceneConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CopyCasterSceneConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyCasterSceneConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CopyCasterSceneConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCasterRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var casterName: String?

    public var casterTemplate: String?

    public var chargeType: String?

    public var clientToken: String?

    public var expireTime: String?

    public var normType: Int32?

    public var ownerId: Int64?

    public var purchaseTime: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [CreateCasterRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.casterTemplate != nil {
            map["CasterTemplate"] = self.casterTemplate!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.normType != nil {
            map["NormType"] = self.normType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.purchaseTime != nil {
            map["PurchaseTime"] = self.purchaseTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterName"] as? String {
            self.casterName = value
        }
        if let value = dict["CasterTemplate"] as? String {
            self.casterTemplate = value
        }
        if let value = dict["ChargeType"] as? String {
            self.chargeType = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ExpireTime"] as? String {
            self.expireTime = value
        }
        if let value = dict["NormType"] as? Int32 {
            self.normType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PurchaseTime"] as? String {
            self.purchaseTime = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateCasterRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateCasterRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class CreateCasterResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCasterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCustomTemplateRequest : Tea.TeaModel {
    public var customTemplate: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomTemplate"] as? String {
            self.customTemplate = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
    }
}

public class CreateCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCustomTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateEdgeTranscodeJobRequest : Tea.TeaModel {
    public var clusterId: String?

    public var name: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamInput: String?

    public var streamOutput: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput!
        }
        if self.streamOutput != nil {
            map["StreamOutput"] = self.streamOutput!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamInput"] as? String {
            self.streamInput = value
        }
        if let value = dict["StreamOutput"] as? String {
            self.streamOutput = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class CreateEdgeTranscodeJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateEdgeTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEdgeTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateEdgeTranscodeJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateEventSubRequest : Tea.TeaModel {
    public var appId: String?

    public var callbackUrl: String?

    public var channelId: String?

    public var events: [String]?

    public var users: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.events != nil {
            map["Events"] = self.events!
        }
        if self.users != nil {
            map["Users"] = self.users!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["Events"] as? [String] {
            self.events = value
        }
        if let value = dict["Users"] as? [String] {
            self.users = value
        }
    }
}

public class CreateEventSubResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var subscribeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subscribeId != nil {
            map["SubscribeId"] = self.subscribeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SubscribeId"] as? String {
            self.subscribeId = value
        }
    }
}

public class CreateEventSubResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEventSubResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateEventSubResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLiveAIStudioRequest : Tea.TeaModel {
    public class MattingLayout : Tea.TeaModel {
        public var heightNormalized: Double?

        public var positionX: Double?

        public var positionY: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.heightNormalized != nil {
                map["HeightNormalized"] = self.heightNormalized!
            }
            if self.positionX != nil {
                map["PositionX"] = self.positionX!
            }
            if self.positionY != nil {
                map["PositionY"] = self.positionY!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HeightNormalized"] as? Double {
                self.heightNormalized = value
            }
            if let value = dict["PositionX"] as? Double {
                self.positionX = value
            }
            if let value = dict["PositionY"] as? Double {
                self.positionY = value
            }
        }
    }
    public class MediaLayout : Tea.TeaModel {
        public var heightNormalized: Double?

        public var positionX: Double?

        public var positionY: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.heightNormalized != nil {
                map["HeightNormalized"] = self.heightNormalized!
            }
            if self.positionX != nil {
                map["PositionX"] = self.positionX!
            }
            if self.positionY != nil {
                map["PositionY"] = self.positionY!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HeightNormalized"] as? Double {
                self.heightNormalized = value
            }
            if let value = dict["PositionX"] as? Double {
                self.positionX = value
            }
            if let value = dict["PositionY"] as? Double {
                self.positionY = value
            }
        }
    }
    public var backgroundResourceId: String?

    public var backgroundResourceUrl: String?

    public var backgroundType: String?

    public var description_: String?

    public var height: Int32?

    public var mattingLayout: CreateLiveAIStudioRequest.MattingLayout?

    public var mattingType: String?

    public var mediaLayout: CreateLiveAIStudioRequest.MediaLayout?

    public var mediaResourceId: String?

    public var mediaResourceUrl: String?

    public var mediaType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var studioName: String?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mattingLayout?.validate()
        try self.mediaLayout?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundResourceId != nil {
            map["BackgroundResourceId"] = self.backgroundResourceId!
        }
        if self.backgroundResourceUrl != nil {
            map["BackgroundResourceUrl"] = self.backgroundResourceUrl!
        }
        if self.backgroundType != nil {
            map["BackgroundType"] = self.backgroundType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.mattingLayout != nil {
            map["MattingLayout"] = self.mattingLayout?.toMap()
        }
        if self.mattingType != nil {
            map["MattingType"] = self.mattingType!
        }
        if self.mediaLayout != nil {
            map["MediaLayout"] = self.mediaLayout?.toMap()
        }
        if self.mediaResourceId != nil {
            map["MediaResourceId"] = self.mediaResourceId!
        }
        if self.mediaResourceUrl != nil {
            map["MediaResourceUrl"] = self.mediaResourceUrl!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.studioName != nil {
            map["StudioName"] = self.studioName!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackgroundResourceId"] as? String {
            self.backgroundResourceId = value
        }
        if let value = dict["BackgroundResourceUrl"] as? String {
            self.backgroundResourceUrl = value
        }
        if let value = dict["BackgroundType"] as? String {
            self.backgroundType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["MattingLayout"] as? [String: Any?] {
            var model = CreateLiveAIStudioRequest.MattingLayout()
            model.fromMap(value)
            self.mattingLayout = model
        }
        if let value = dict["MattingType"] as? String {
            self.mattingType = value
        }
        if let value = dict["MediaLayout"] as? [String: Any?] {
            var model = CreateLiveAIStudioRequest.MediaLayout()
            model.fromMap(value)
            self.mediaLayout = model
        }
        if let value = dict["MediaResourceId"] as? String {
            self.mediaResourceId = value
        }
        if let value = dict["MediaResourceUrl"] as? String {
            self.mediaResourceUrl = value
        }
        if let value = dict["MediaType"] as? String {
            self.mediaType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StudioName"] as? String {
            self.studioName = value
        }
        if let value = dict["Width"] as? Int32 {
            self.width = value
        }
    }
}

public class CreateLiveAIStudioShrinkRequest : Tea.TeaModel {
    public var backgroundResourceId: String?

    public var backgroundResourceUrl: String?

    public var backgroundType: String?

    public var description_: String?

    public var height: Int32?

    public var mattingLayoutShrink: String?

    public var mattingType: String?

    public var mediaLayoutShrink: String?

    public var mediaResourceId: String?

    public var mediaResourceUrl: String?

    public var mediaType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var studioName: String?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundResourceId != nil {
            map["BackgroundResourceId"] = self.backgroundResourceId!
        }
        if self.backgroundResourceUrl != nil {
            map["BackgroundResourceUrl"] = self.backgroundResourceUrl!
        }
        if self.backgroundType != nil {
            map["BackgroundType"] = self.backgroundType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.mattingLayoutShrink != nil {
            map["MattingLayout"] = self.mattingLayoutShrink!
        }
        if self.mattingType != nil {
            map["MattingType"] = self.mattingType!
        }
        if self.mediaLayoutShrink != nil {
            map["MediaLayout"] = self.mediaLayoutShrink!
        }
        if self.mediaResourceId != nil {
            map["MediaResourceId"] = self.mediaResourceId!
        }
        if self.mediaResourceUrl != nil {
            map["MediaResourceUrl"] = self.mediaResourceUrl!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.studioName != nil {
            map["StudioName"] = self.studioName!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackgroundResourceId"] as? String {
            self.backgroundResourceId = value
        }
        if let value = dict["BackgroundResourceUrl"] as? String {
            self.backgroundResourceUrl = value
        }
        if let value = dict["BackgroundType"] as? String {
            self.backgroundType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["MattingLayout"] as? String {
            self.mattingLayoutShrink = value
        }
        if let value = dict["MattingType"] as? String {
            self.mattingType = value
        }
        if let value = dict["MediaLayout"] as? String {
            self.mediaLayoutShrink = value
        }
        if let value = dict["MediaResourceId"] as? String {
            self.mediaResourceId = value
        }
        if let value = dict["MediaResourceUrl"] as? String {
            self.mediaResourceUrl = value
        }
        if let value = dict["MediaType"] as? String {
            self.mediaType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StudioName"] as? String {
            self.studioName = value
        }
        if let value = dict["Width"] as? Int32 {
            self.width = value
        }
    }
}

public class CreateLiveAIStudioResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var studioId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.studioId != nil {
            map["StudioId"] = self.studioId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StudioId"] as? String {
            self.studioId = value
        }
    }
}

public class CreateLiveAIStudioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveAIStudioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLiveAIStudioResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLiveDelayConfigRequest : Tea.TeaModel {
    public var app: String?

    public var delayTime: Int32?

    public var domain: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var stream: String?

    public var taskTriggerMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.delayTime != nil {
            map["DelayTime"] = self.delayTime!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        if self.taskTriggerMode != nil {
            map["TaskTriggerMode"] = self.taskTriggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["DelayTime"] as? Int32 {
            self.delayTime = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
        if let value = dict["TaskTriggerMode"] as? String {
            self.taskTriggerMode = value
        }
    }
}

public class CreateLiveDelayConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLiveDelayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveDelayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLiveDelayConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLiveMessageAppRequest : Tea.TeaModel {
    public var appName: String?

    public var auditType: Int32?

    public var auditUrl: String?

    public var dataCenter: String?

    public var eventCallbackUrl: String?

    public var msgLifeCycle: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.auditType != nil {
            map["AuditType"] = self.auditType!
        }
        if self.auditUrl != nil {
            map["AuditUrl"] = self.auditUrl!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.eventCallbackUrl != nil {
            map["EventCallbackUrl"] = self.eventCallbackUrl!
        }
        if self.msgLifeCycle != nil {
            map["MsgLifeCycle"] = self.msgLifeCycle!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AuditType"] as? Int32 {
            self.auditType = value
        }
        if let value = dict["AuditUrl"] as? String {
            self.auditUrl = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["EventCallbackUrl"] as? String {
            self.eventCallbackUrl = value
        }
        if let value = dict["MsgLifeCycle"] as? Int32 {
            self.msgLifeCycle = value
        }
    }
}

public class CreateLiveMessageAppResponseBody : Tea.TeaModel {
    public var appId: String?

    public var appKey: String?

    public var appSign: String?

    public var dataCenter: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.appSign != nil {
            map["AppSign"] = self.appSign!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppKey"] as? String {
            self.appKey = value
        }
        if let value = dict["AppSign"] as? String {
            self.appSign = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLiveMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLiveMessageAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLiveMessageGroupRequest : Tea.TeaModel {
    public var administrators: [String]?

    public var appId: String?

    public var creatorId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var groupInfo: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.administrators != nil {
            map["Administrators"] = self.administrators!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupInfo != nil {
            map["GroupInfo"] = self.groupInfo!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Administrators"] as? [String] {
            self.administrators = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CreatorId"] as? String {
            self.creatorId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupInfo"] as? String {
            self.groupInfo = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
    }
}

public class CreateLiveMessageGroupShrinkRequest : Tea.TeaModel {
    public var administratorsShrink: String?

    public var appId: String?

    public var creatorId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var groupInfo: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.administratorsShrink != nil {
            map["Administrators"] = self.administratorsShrink!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupInfo != nil {
            map["GroupInfo"] = self.groupInfo!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Administrators"] as? String {
            self.administratorsShrink = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CreatorId"] as? String {
            self.creatorId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupInfo"] as? String {
            self.groupInfo = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
    }
}

public class CreateLiveMessageGroupResponseBody : Tea.TeaModel {
    public var alreadyDelete: Bool?

    public var alreadyExists: Bool?

    public var groupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alreadyDelete != nil {
            map["AlreadyDelete"] = self.alreadyDelete!
        }
        if self.alreadyExists != nil {
            map["AlreadyExists"] = self.alreadyExists!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlreadyDelete"] as? Bool {
            self.alreadyDelete = value
        }
        if let value = dict["AlreadyExists"] as? Bool {
            self.alreadyExists = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLiveMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLiveMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLivePrivateLineRequest : Tea.TeaModel {
    public var accelerationArea: String?

    public var accelerationType: String?

    public var appName: String?

    public var domainName: String?

    public var instanceId: String?

    public var maxBandwidth: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reuse: String?

    public var streamName: String?

    public var videoCenter: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerationArea != nil {
            map["AccelerationArea"] = self.accelerationArea!
        }
        if self.accelerationType != nil {
            map["AccelerationType"] = self.accelerationType!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxBandwidth != nil {
            map["MaxBandwidth"] = self.maxBandwidth!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reuse != nil {
            map["Reuse"] = self.reuse!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.videoCenter != nil {
            map["VideoCenter"] = self.videoCenter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccelerationArea"] as? String {
            self.accelerationArea = value
        }
        if let value = dict["AccelerationType"] as? String {
            self.accelerationType = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxBandwidth"] as? String {
            self.maxBandwidth = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Reuse"] as? String {
            self.reuse = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["VideoCenter"] as? String {
            self.videoCenter = value
        }
    }
}

public class CreateLivePrivateLineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLivePrivateLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLivePrivateLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLivePrivateLineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLivePullToPushRequest : Tea.TeaModel {
    public var callbackUrl: String?

    public var dstUrl: String?

    public var endTime: String?

    public var fileIndex: Int32?

    public var offset: Int32?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var repeatNumber: Int32?

    public var retryCount: Int32?

    public var retryInterval: Int32?

    public var sourceProtocol: String?

    public var sourceType: String?

    public var sourceUrls: [String]?

    public var startTime: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.dstUrl != nil {
            map["DstUrl"] = self.dstUrl!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.fileIndex != nil {
            map["FileIndex"] = self.fileIndex!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatNumber != nil {
            map["RepeatNumber"] = self.repeatNumber!
        }
        if self.retryCount != nil {
            map["RetryCount"] = self.retryCount!
        }
        if self.retryInterval != nil {
            map["RetryInterval"] = self.retryInterval!
        }
        if self.sourceProtocol != nil {
            map["SourceProtocol"] = self.sourceProtocol!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.sourceUrls != nil {
            map["SourceUrls"] = self.sourceUrls!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["DstUrl"] as? String {
            self.dstUrl = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FileIndex"] as? Int32 {
            self.fileIndex = value
        }
        if let value = dict["Offset"] as? Int32 {
            self.offset = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatNumber"] as? Int32 {
            self.repeatNumber = value
        }
        if let value = dict["RetryCount"] as? Int32 {
            self.retryCount = value
        }
        if let value = dict["RetryInterval"] as? Int32 {
            self.retryInterval = value
        }
        if let value = dict["SourceProtocol"] as? String {
            self.sourceProtocol = value
        }
        if let value = dict["SourceType"] as? String {
            self.sourceType = value
        }
        if let value = dict["SourceUrls"] as? [String] {
            self.sourceUrls = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class CreateLivePullToPushShrinkRequest : Tea.TeaModel {
    public var callbackUrl: String?

    public var dstUrl: String?

    public var endTime: String?

    public var fileIndex: Int32?

    public var offset: Int32?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var repeatNumber: Int32?

    public var retryCount: Int32?

    public var retryInterval: Int32?

    public var sourceProtocol: String?

    public var sourceType: String?

    public var sourceUrlsShrink: String?

    public var startTime: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.dstUrl != nil {
            map["DstUrl"] = self.dstUrl!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.fileIndex != nil {
            map["FileIndex"] = self.fileIndex!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatNumber != nil {
            map["RepeatNumber"] = self.repeatNumber!
        }
        if self.retryCount != nil {
            map["RetryCount"] = self.retryCount!
        }
        if self.retryInterval != nil {
            map["RetryInterval"] = self.retryInterval!
        }
        if self.sourceProtocol != nil {
            map["SourceProtocol"] = self.sourceProtocol!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        if self.sourceUrlsShrink != nil {
            map["SourceUrls"] = self.sourceUrlsShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["DstUrl"] as? String {
            self.dstUrl = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FileIndex"] as? Int32 {
            self.fileIndex = value
        }
        if let value = dict["Offset"] as? Int32 {
            self.offset = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatNumber"] as? Int32 {
            self.repeatNumber = value
        }
        if let value = dict["RetryCount"] as? Int32 {
            self.retryCount = value
        }
        if let value = dict["RetryInterval"] as? Int32 {
            self.retryInterval = value
        }
        if let value = dict["SourceProtocol"] as? String {
            self.sourceProtocol = value
        }
        if let value = dict["SourceType"] as? String {
            self.sourceType = value
        }
        if let value = dict["SourceUrls"] as? String {
            self.sourceUrlsShrink = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class CreateLivePullToPushResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetCode"] as? Int32 {
            self.retCode = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class CreateLivePullToPushResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLivePullToPushResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLivePullToPushResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLiveRealTimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Logstore"] as? String {
            self.logstore = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Project"] as? String {
            self.project = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class CreateLiveRealTimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLiveRealTimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveRealTimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLiveRealTimeLogDeliveryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLiveStreamMonitorRequest : Tea.TeaModel {
    public var app: String?

    public var callbackUrl: String?

    public var dingTalkWebHookUrl: String?

    public var domain: String?

    public var inputList: String?

    public var monitorConfig: String?

    public var monitorName: String?

    public var outputTemplate: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.dingTalkWebHookUrl != nil {
            map["DingTalkWebHookUrl"] = self.dingTalkWebHookUrl!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.inputList != nil {
            map["InputList"] = self.inputList!
        }
        if self.monitorConfig != nil {
            map["MonitorConfig"] = self.monitorConfig!
        }
        if self.monitorName != nil {
            map["MonitorName"] = self.monitorName!
        }
        if self.outputTemplate != nil {
            map["OutputTemplate"] = self.outputTemplate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["DingTalkWebHookUrl"] as? String {
            self.dingTalkWebHookUrl = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["InputList"] as? String {
            self.inputList = value
        }
        if let value = dict["MonitorConfig"] as? String {
            self.monitorConfig = value
        }
        if let value = dict["MonitorName"] as? String {
            self.monitorName = value
        }
        if let value = dict["OutputTemplate"] as? String {
            self.outputTemplate = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
    }
}

public class CreateLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var monitorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorId"] as? String {
            self.monitorId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLiveStreamMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLiveStreamRecordIndexFilesRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var endTimeIncluded: Bool?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endTimeIncluded != nil {
            map["EndTimeIncluded"] = self.endTimeIncluded!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["EndTimeIncluded"] as? Bool {
            self.endTimeIncluded = value
        }
        if let value = dict["OssBucket"] as? String {
            self.ossBucket = value
        }
        if let value = dict["OssEndpoint"] as? String {
            self.ossEndpoint = value
        }
        if let value = dict["OssObject"] as? String {
            self.ossObject = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class CreateLiveStreamRecordIndexFilesResponseBody : Tea.TeaModel {
    public class RecordInfo : Tea.TeaModel {
        public var appName: String?

        public var createTime: String?

        public var domainName: String?

        public var duration: Double?

        public var endTime: String?

        public var height: Int32?

        public var ossBucket: String?

        public var ossEndpoint: String?

        public var ossObject: String?

        public var recordId: String?

        public var recordUrl: String?

        public var startTime: String?

        public var streamName: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.ossObject != nil {
                map["OssObject"] = self.ossObject!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordUrl != nil {
                map["RecordUrl"] = self.recordUrl!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["Duration"] as? Double {
                self.duration = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["Height"] as? Int32 {
                self.height = value
            }
            if let value = dict["OssBucket"] as? String {
                self.ossBucket = value
            }
            if let value = dict["OssEndpoint"] as? String {
                self.ossEndpoint = value
            }
            if let value = dict["OssObject"] as? String {
                self.ossObject = value
            }
            if let value = dict["RecordId"] as? String {
                self.recordId = value
            }
            if let value = dict["RecordUrl"] as? String {
                self.recordUrl = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
            if let value = dict["Width"] as? Int32 {
                self.width = value
            }
        }
    }
    public var recordInfo: CreateLiveStreamRecordIndexFilesResponseBody.RecordInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordInfo != nil {
            map["RecordInfo"] = self.recordInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordInfo"] as? [String: Any?] {
            var model = CreateLiveStreamRecordIndexFilesResponseBody.RecordInfo()
            model.fromMap(value)
            self.recordInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateLiveStreamRecordIndexFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLiveStreamRecordIndexFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLiveStreamRecordIndexFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateMessageAppRequest : Tea.TeaModel {
    public var appConfig: [String: String]?

    public var appName: String?

    public var extension_: [String: String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appConfig != nil {
            map["AppConfig"] = self.appConfig!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppConfig"] as? [String: String] {
            self.appConfig = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Extension"] as? [String: String] {
            self.extension_ = value
        }
    }
}

public class CreateMessageAppShrinkRequest : Tea.TeaModel {
    public var appConfigShrink: String?

    public var appName: String?

    public var extensionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appConfigShrink != nil {
            map["AppConfig"] = self.appConfigShrink!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extensionShrink != nil {
            map["Extension"] = self.extensionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppConfig"] as? String {
            self.appConfigShrink = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Extension"] as? String {
            self.extensionShrink = value
        }
    }
}

public class CreateMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var appId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
        }
    }
    public var requestId: String?

    public var result: CreateMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CreateMessageAppResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CreateMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateMessageAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var creatorId: String?

    public var extension_: [String: String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CreatorId"] as? String {
            self.creatorId = value
        }
        if let value = dict["Extension"] as? [String: String] {
            self.extension_ = value
        }
    }
}

public class CreateMessageGroupShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var creatorId: String?

    public var extensionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.extensionShrink != nil {
            map["Extension"] = self.extensionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CreatorId"] as? String {
            self.creatorId = value
        }
        if let value = dict["Extension"] as? String {
            self.extensionShrink = value
        }
    }
}

public class CreateMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var extension_: [String: Any]?

        public var groupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Extension"] as? [String: Any] {
                self.extension_ = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
        }
    }
    public var requestId: String?

    public var result: CreateMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CreateMessageGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CreateMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateMixStreamRequest : Tea.TeaModel {
    public var callbackConfig: String?

    public var domainName: String?

    public var inputStreamList: String?

    public var layoutId: String?

    public var outputConfig: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackConfig != nil {
            map["CallbackConfig"] = self.callbackConfig!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.inputStreamList != nil {
            map["InputStreamList"] = self.inputStreamList!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.outputConfig != nil {
            map["OutputConfig"] = self.outputConfig!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallbackConfig"] as? String {
            self.callbackConfig = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["InputStreamList"] as? String {
            self.inputStreamList = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["OutputConfig"] as? String {
            self.outputConfig = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class CreateMixStreamResponseBody : Tea.TeaModel {
    public var mixStreamId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MixStreamId"] as? String {
            self.mixStreamId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateMixStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateMixStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateMixStreamResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRTCWhipStreamAddressRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var clientToken: String?

    public var displayName: String?

    public var expireTime: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DisplayName"] as? String {
            self.displayName = value
        }
        if let value = dict["ExpireTime"] as? Int32 {
            self.expireTime = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class CreateRTCWhipStreamAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var whipAddress: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.whipAddress != nil {
            map["WhipAddress"] = self.whipAddress!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["WhipAddress"] as? String {
            self.whipAddress = value
        }
    }
}

public class CreateRTCWhipStreamAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRTCWhipStreamAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRTCWhipStreamAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRoomRealTimeStreamAddressRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var displayName: String?

    public var expireTime: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.expireTime != nil {
            map["ExpireTime"] = self.expireTime!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["DisplayName"] as? String {
            self.displayName = value
        }
        if let value = dict["ExpireTime"] as? Int32 {
            self.expireTime = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class CreateRoomRealTimeStreamAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var rtmpAddress: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rtmpAddress != nil {
            map["RtmpAddress"] = self.rtmpAddress!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RtmpAddress"] as? String {
            self.rtmpAddress = value
        }
    }
}

public class CreateRoomRealTimeStreamAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRoomRealTimeStreamAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRoomRealTimeStreamAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRtcAsrTaskRequest : Tea.TeaModel {
    public var authKey: String?

    public var autoTerminateDelay: Int64?

    public var autoTerminateEnabled: Bool?

    public var callbackURL: String?

    public var channelID: String?

    public var language: String?

    public var mode: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reportInterval: Int64?

    public var rtcUserId: String?

    public var SDKAppID: String?

    public var streamURL: String?

    public var targetLanguages: String?

    public var translateEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authKey != nil {
            map["AuthKey"] = self.authKey!
        }
        if self.autoTerminateDelay != nil {
            map["AutoTerminateDelay"] = self.autoTerminateDelay!
        }
        if self.autoTerminateEnabled != nil {
            map["AutoTerminateEnabled"] = self.autoTerminateEnabled!
        }
        if self.callbackURL != nil {
            map["CallbackURL"] = self.callbackURL!
        }
        if self.channelID != nil {
            map["ChannelID"] = self.channelID!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportInterval != nil {
            map["ReportInterval"] = self.reportInterval!
        }
        if self.rtcUserId != nil {
            map["RtcUserId"] = self.rtcUserId!
        }
        if self.SDKAppID != nil {
            map["SDKAppID"] = self.SDKAppID!
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.targetLanguages != nil {
            map["TargetLanguages"] = self.targetLanguages!
        }
        if self.translateEnabled != nil {
            map["TranslateEnabled"] = self.translateEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthKey"] as? String {
            self.authKey = value
        }
        if let value = dict["AutoTerminateDelay"] as? Int64 {
            self.autoTerminateDelay = value
        }
        if let value = dict["AutoTerminateEnabled"] as? Bool {
            self.autoTerminateEnabled = value
        }
        if let value = dict["CallbackURL"] as? String {
            self.callbackURL = value
        }
        if let value = dict["ChannelID"] as? String {
            self.channelID = value
        }
        if let value = dict["Language"] as? String {
            self.language = value
        }
        if let value = dict["Mode"] as? String {
            self.mode = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReportInterval"] as? Int64 {
            self.reportInterval = value
        }
        if let value = dict["RtcUserId"] as? String {
            self.rtcUserId = value
        }
        if let value = dict["SDKAppID"] as? String {
            self.SDKAppID = value
        }
        if let value = dict["StreamURL"] as? String {
            self.streamURL = value
        }
        if let value = dict["TargetLanguages"] as? String {
            self.targetLanguages = value
        }
        if let value = dict["TranslateEnabled"] as? Bool {
            self.translateEnabled = value
        }
    }
}

public class CreateRtcAsrTaskResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var retCode: Int64?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetCode"] as? Int64 {
            self.retCode = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class CreateRtcAsrTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRtcAsrTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRtcAsrTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateRtcMPUEventSubRequest : Tea.TeaModel {
    public var appId: String?

    public var callbackUrl: String?

    public var channelIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.channelIds != nil {
            map["ChannelIds"] = self.channelIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["ChannelIds"] as? String {
            self.channelIds = value
        }
    }
}

public class CreateRtcMPUEventSubResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var subId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subId != nil {
            map["SubId"] = self.subId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SubId"] as? String {
            self.subId = value
        }
    }
}

public class CreateRtcMPUEventSubResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRtcMPUEventSubResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateRtcMPUEventSubResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCasterRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteCasterResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCasterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCasterComponentRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ComponentId"] as? String {
            self.componentId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteCasterComponentResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var componentId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ComponentId"] as? String {
            self.componentId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCasterComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCasterComponentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCasterEpisodeRequest : Tea.TeaModel {
    public var casterId: String?

    public var episodeId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["EpisodeId"] as? String {
            self.episodeId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteCasterEpisodeResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var episodeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["EpisodeId"] as? String {
            self.episodeId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCasterEpisodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterEpisodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCasterEpisodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCasterEpisodeGroupRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteCasterEpisodeGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCasterEpisodeGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterEpisodeGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCasterEpisodeGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCasterLayoutRequest : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteCasterLayoutResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCasterLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCasterLayoutResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCasterProgramRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteCasterProgramResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCasterProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCasterProgramResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCasterSceneConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sceneId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DeleteCasterSceneConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCasterSceneConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterSceneConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCasterSceneConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCasterVideoResourceRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
    }
}

public class DeleteCasterVideoResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCasterVideoResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCasterVideoResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCasterVideoResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteChannelRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
    }
}

public class DeleteChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCustomTemplateRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
    }
}

public class DeleteCustomTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCustomTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteEdgeTranscodeJobRequest : Tea.TeaModel {
    public var clusterId: String?

    public var jobId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteEdgeTranscodeJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteEdgeTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEdgeTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteEdgeTranscodeJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteEventSubRequest : Tea.TeaModel {
    public var appId: String?

    public var subscribeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.subscribeId != nil {
            map["SubscribeId"] = self.subscribeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["SubscribeId"] as? String {
            self.subscribeId = value
        }
    }
}

public class DeleteEventSubResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteEventSubResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEventSubResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteEventSubResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveAIProduceRulesRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var rulesId: String?

    public var suffixName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rulesId != nil {
            map["RulesId"] = self.rulesId!
        }
        if self.suffixName != nil {
            map["SuffixName"] = self.suffixName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RulesId"] as? String {
            self.rulesId = value
        }
        if let value = dict["SuffixName"] as? String {
            self.suffixName = value
        }
    }
}

public class DeleteLiveAIProduceRulesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveAIProduceRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAIProduceRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveAIProduceRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveAIStudioRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var studioId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.studioId != nil {
            map["StudioId"] = self.studioId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StudioId"] as? String {
            self.studioId = value
        }
    }
}

public class DeleteLiveAIStudioResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveAIStudioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAIStudioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveAIStudioResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveAISubtitleRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var subtitleId: String?

    public var subtitleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.subtitleId != nil {
            map["SubtitleId"] = self.subtitleId!
        }
        if self.subtitleName != nil {
            map["SubtitleName"] = self.subtitleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SubtitleId"] as? String {
            self.subtitleId = value
        }
        if let value = dict["SubtitleName"] as? String {
            self.subtitleName = value
        }
    }
}

public class DeleteLiveAISubtitleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveAISubtitleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAISubtitleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveAISubtitleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveAppRecordConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLiveAppRecordConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveAppRecordConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAppRecordConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveAppRecordConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveAppSnapshotConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DeleteLiveAppSnapshotConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveAppSnapshotConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAppSnapshotConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveAppSnapshotConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveAudioAuditConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLiveAudioAuditConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveAudioAuditConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAudioAuditConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveAudioAuditConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveAudioAuditNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLiveAudioAuditNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveAudioAuditNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveAudioAuditNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveAudioAuditNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveCenterTransferRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var dstUrl: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.dstUrl != nil {
            map["DstUrl"] = self.dstUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DstUrl"] as? String {
            self.dstUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLiveCenterTransferResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveCenterTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveCenterTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveCenterTransferResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveDelayConfigRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
    }
}

public class DeleteLiveDelayConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveDelayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveDelayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveDelayConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveDetectNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DeleteLiveDetectNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveDetectNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveDetectNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveDetectNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DeleteLiveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveDomainMappingRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var pullDomain: String?

    public var pushDomain: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pullDomain != nil {
            map["PullDomain"] = self.pullDomain!
        }
        if self.pushDomain != nil {
            map["PushDomain"] = self.pushDomain!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PullDomain"] as? String {
            self.pullDomain = value
        }
        if let value = dict["PushDomain"] as? String {
            self.pushDomain = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DeleteLiveDomainMappingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveDomainMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveDomainMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveDomainMappingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveDomainPlayMappingRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var playDomain: String?

    public var pullDomain: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.playDomain != nil {
            map["PlayDomain"] = self.playDomain!
        }
        if self.pullDomain != nil {
            map["PullDomain"] = self.pullDomain!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PlayDomain"] as? String {
            self.playDomain = value
        }
        if let value = dict["PullDomain"] as? String {
            self.pullDomain = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLiveDomainPlayMappingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveDomainPlayMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveDomainPlayMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveDomainPlayMappingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveEdgeTransferRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLiveEdgeTransferResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveEdgeTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveEdgeTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveEdgeTransferResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveLazyPullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLiveLazyPullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveLazyPullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveLazyPullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveLazyPullStreamInfoConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var operatorId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorId != nil {
            map["OperatorId"] = self.operatorId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorId"] as? String {
            self.operatorId = value
        }
    }
}

public class DeleteLiveMessageGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveMessageGroupMessageRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var deleterId: String?

    public var deleterInfo: String?

    public var groupId: String?

    public var messageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.deleterId != nil {
            map["DeleterId"] = self.deleterId!
        }
        if self.deleterInfo != nil {
            map["DeleterInfo"] = self.deleterInfo!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["DeleterId"] as? String {
            self.deleterId = value
        }
        if let value = dict["DeleterInfo"] as? String {
            self.deleterInfo = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["MessageId"] as? String {
            self.messageId = value
        }
    }
}

public class DeleteLiveMessageGroupMessageResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var messageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["MessageId"] as? String {
            self.messageId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveMessageGroupMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveMessageGroupMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveMessageGroupMessageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveMessageUserMessageRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var deleterId: String?

    public var deleterInfo: String?

    public var messageId: String?

    public var receiverId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.deleterId != nil {
            map["DeleterId"] = self.deleterId!
        }
        if self.deleterInfo != nil {
            map["DeleterInfo"] = self.deleterInfo!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.receiverId != nil {
            map["ReceiverId"] = self.receiverId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["DeleterId"] as? String {
            self.deleterId = value
        }
        if let value = dict["DeleterInfo"] as? String {
            self.deleterInfo = value
        }
        if let value = dict["MessageId"] as? String {
            self.messageId = value
        }
        if let value = dict["ReceiverId"] as? String {
            self.receiverId = value
        }
    }
}

public class DeleteLiveMessageUserMessageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveMessageUserMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveMessageUserMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveMessageUserMessageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLivePackageConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLivePackageConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLivePackageConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLivePackageConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLivePackageConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLivePrivateLineRequest : Tea.TeaModel {
    public var accelerationType: String?

    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerationType != nil {
            map["AccelerationType"] = self.accelerationType!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccelerationType"] as? String {
            self.accelerationType = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLivePrivateLineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLivePrivateLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLivePrivateLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLivePrivateLineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLivePullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLivePullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLivePullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLivePullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLivePullStreamInfoConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLivePullToPushRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DeleteLivePullToPushResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetCode"] as? Int32 {
            self.retCode = value
        }
    }
}

public class DeleteLivePullToPushResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLivePullToPushResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLivePullToPushResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveRealTimeLogLogstoreRequest : Tea.TeaModel {
    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Logstore"] as? String {
            self.logstore = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Project"] as? String {
            self.project = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLiveRealTimeLogLogstoreResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveRealTimeLogLogstoreResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRealTimeLogLogstoreResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveRealTimeLogLogstoreResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Logstore"] as? String {
            self.logstore = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Project"] as? String {
            self.project = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveRecordNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DeleteLiveRecordNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveRecordNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveRecordNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveRecordVodConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLiveRecordVodConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveRecordVodConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveRecordVodConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveRecordVodConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotDetectPornConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DeleteLiveSnapshotDetectPornConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveSnapshotDetectPornConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotDetectPornConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveSnapshotDetectPornConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveSnapshotNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLiveSnapshotNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveSnapshotNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSnapshotNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveSnapshotNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveSpecificStagingConfigRequest : Tea.TeaModel {
    public var configId: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configId != nil {
            map["ConfigId"] = self.configId!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigId"] as? String {
            self.configId = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DeleteLiveSpecificStagingConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveSpecificStagingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveSpecificStagingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveSpecificStagingConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveStreamBlockRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLiveStreamBlockResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DeleteLiveStreamBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveStreamBlockResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveStreamMergeRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLiveStreamMergeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveStreamMergeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamMergeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveStreamMergeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveStreamMonitorRequest : Tea.TeaModel {
    public var monitorId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorId"] as? String {
            self.monitorId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveStreamMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveStreamRecordIndexFilesRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var recordId: [String]?

    public var regionId: String?

    public var removeFile: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeFile != nil {
            map["RemoveFile"] = self.removeFile!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RecordId"] as? [String] {
            self.recordId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoveFile"] as? String {
            self.removeFile = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteLiveStreamRecordIndexFilesResponseBody : Tea.TeaModel {
    public class RecordDeleteInfoList : Tea.TeaModel {
        public class RecordDeleteInfo : Tea.TeaModel {
            public var message: String?

            public var recordId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["RecordId"] as? String {
                    self.recordId = value
                }
            }
        }
        public var recordDeleteInfo: [DeleteLiveStreamRecordIndexFilesResponseBody.RecordDeleteInfoList.RecordDeleteInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordDeleteInfo != nil {
                var tmp : [Any] = []
                for k in self.recordDeleteInfo! {
                    tmp.append(k.toMap())
                }
                map["RecordDeleteInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RecordDeleteInfo"] as? [Any?] {
                var tmp : [DeleteLiveStreamRecordIndexFilesResponseBody.RecordDeleteInfoList.RecordDeleteInfo] = []
                for v in value {
                    if v != nil {
                        var model = DeleteLiveStreamRecordIndexFilesResponseBody.RecordDeleteInfoList.RecordDeleteInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.recordDeleteInfo = tmp
            }
        }
    }
    public var code: String?

    public var message: String?

    public var recordDeleteInfoList: DeleteLiveStreamRecordIndexFilesResponseBody.RecordDeleteInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordDeleteInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.recordDeleteInfoList != nil {
            map["RecordDeleteInfoList"] = self.recordDeleteInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RecordDeleteInfoList"] as? [String: Any?] {
            var model = DeleteLiveStreamRecordIndexFilesResponseBody.RecordDeleteInfoList()
            model.fromMap(value)
            self.recordDeleteInfoList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveStreamRecordIndexFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamRecordIndexFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveStreamRecordIndexFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
    }
}

public class DeleteLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveStreamTranscodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveStreamWatermarkRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class DeleteLiveStreamWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveStreamWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveStreamWatermarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveStreamWatermarkRuleRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var ruleId: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RuleId"] as? String {
            self.ruleId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
    }
}

public class DeleteLiveStreamWatermarkRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveStreamWatermarkRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamWatermarkRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveStreamWatermarkRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLiveStreamsNotifyUrlConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLiveStreamsNotifyUrlConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLiveStreamsNotifyUrlConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLiveStreamsNotifyUrlConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLiveStreamsNotifyUrlConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteMessageAppRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DeleteMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var requestId: String?

    public var result: DeleteMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DeleteMessageAppResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DeleteMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteMessageAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteMixStreamRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var mixStreamId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["MixStreamId"] as? String {
            self.mixStreamId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteMixStreamResponseBody : Tea.TeaModel {
    public var mixStreamId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MixStreamId"] as? String {
            self.mixStreamId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteMixStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMixStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteMixStreamResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePlaylistRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeletePlaylistResponseBody : Tea.TeaModel {
    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePlaylistResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePlaylistItemsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public var programItemIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.programItemIds != nil {
            map["ProgramItemIds"] = self.programItemIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["ProgramItemIds"] as? String {
            self.programItemIds = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeletePlaylistItemsResponseBody : Tea.TeaModel {
    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePlaylistItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePlaylistItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePlaylistItemsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRtcAsrTaskRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DeleteRtcAsrTaskResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var retCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetCode"] as? Int64 {
            self.retCode = value
        }
    }
}

public class DeleteRtcAsrTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRtcAsrTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRtcAsrTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteRtcMPUEventSubRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DeleteRtcMPUEventSubResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteRtcMPUEventSubResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRtcMPUEventSubResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteRtcMPUEventSubResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSnapshotCallbackAuthRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteSnapshotCallbackAuthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSnapshotCallbackAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotCallbackAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSnapshotCallbackAuthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSnapshotFilesRequest : Tea.TeaModel {
    public var appName: String?

    public var createTimestampList: [Int64]?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removeFile: Bool?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.createTimestampList != nil {
            map["CreateTimestampList"] = self.createTimestampList!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeFile != nil {
            map["RemoveFile"] = self.removeFile!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["CreateTimestampList"] as? [Int64] {
            self.createTimestampList = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RemoveFile"] as? Bool {
            self.removeFile = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DeleteSnapshotFilesResponseBody : Tea.TeaModel {
    public class SnapshotDeleteInfoList : Tea.TeaModel {
        public class SnapshotDeleteInfo : Tea.TeaModel {
            public var createTimestamp: Int64?

            public var message: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
            }
        }
        public var snapshotDeleteInfo: [DeleteSnapshotFilesResponseBody.SnapshotDeleteInfoList.SnapshotDeleteInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotDeleteInfo != nil {
                var tmp : [Any] = []
                for k in self.snapshotDeleteInfo! {
                    tmp.append(k.toMap())
                }
                map["SnapshotDeleteInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SnapshotDeleteInfo"] as? [Any?] {
                var tmp : [DeleteSnapshotFilesResponseBody.SnapshotDeleteInfoList.SnapshotDeleteInfo] = []
                for v in value {
                    if v != nil {
                        var model = DeleteSnapshotFilesResponseBody.SnapshotDeleteInfoList.SnapshotDeleteInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.snapshotDeleteInfo = tmp
            }
        }
    }
    public var failureCount: Int32?

    public var requestId: String?

    public var snapshotDeleteInfoList: DeleteSnapshotFilesResponseBody.SnapshotDeleteInfoList?

    public var successCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotDeleteInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failureCount != nil {
            map["FailureCount"] = self.failureCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotDeleteInfoList != nil {
            map["SnapshotDeleteInfoList"] = self.snapshotDeleteInfoList?.toMap()
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailureCount"] as? Int32 {
            self.failureCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotDeleteInfoList"] as? [String: Any?] {
            var model = DeleteSnapshotFilesResponseBody.SnapshotDeleteInfoList()
            model.fromMap(value)
            self.snapshotDeleteInfoList = model
        }
        if let value = dict["SuccessCount"] as? Int32 {
            self.successCount = value
        }
    }
}

public class DeleteSnapshotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSnapshotFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteStudioLayoutRequest : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteStudioLayoutResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteStudioLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStudioLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteStudioLayoutResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAutoShowListTasksRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeAutoShowListTasksResponseBody : Tea.TeaModel {
    public var autoShowListTasks: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoShowListTasks != nil {
            map["AutoShowListTasks"] = self.autoShowListTasks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoShowListTasks"] as? String {
            self.autoShowListTasks = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAutoShowListTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoShowListTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAutoShowListTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCasterChannelsRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeCasterChannelsResponseBody : Tea.TeaModel {
    public class Channels : Tea.TeaModel {
        public class Channel : Tea.TeaModel {
            public var channelId: String?

            public var faceBeauty: String?

            public var resourceId: String?

            public var rtmpUrl: String?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.faceBeauty != nil {
                    map["FaceBeauty"] = self.faceBeauty!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.rtmpUrl != nil {
                    map["RtmpUrl"] = self.rtmpUrl!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChannelId"] as? String {
                    self.channelId = value
                }
                if let value = dict["FaceBeauty"] as? String {
                    self.faceBeauty = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["RtmpUrl"] as? String {
                    self.rtmpUrl = value
                }
                if let value = dict["StreamUrl"] as? String {
                    self.streamUrl = value
                }
            }
        }
        public var channel: [DescribeCasterChannelsResponseBody.Channels.Channel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channel != nil {
                var tmp : [Any] = []
                for k in self.channel! {
                    tmp.append(k.toMap())
                }
                map["Channel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Channel"] as? [Any?] {
                var tmp : [DescribeCasterChannelsResponseBody.Channels.Channel] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCasterChannelsResponseBody.Channels.Channel()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.channel = tmp
            }
        }
    }
    public var channels: DescribeCasterChannelsResponseBody.Channels?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.channels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channels != nil {
            map["Channels"] = self.channels?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Channels"] as? [String: Any?] {
            var model = DescribeCasterChannelsResponseBody.Channels()
            model.fromMap(value)
            self.channels = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeCasterChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCasterChannelsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCasterComponentsRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ComponentId"] as? String {
            self.componentId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeCasterComponentsResponseBody : Tea.TeaModel {
    public class Components : Tea.TeaModel {
        public class Component : Tea.TeaModel {
            public class CaptionLayerContent : Tea.TeaModel {
                public var borderColor: String?

                public var borderWidthNormalized: Double?

                public var color: String?

                public var fontName: String?

                public var lineSpaceNormalized: Double?

                public var locationId: String?

                public var ptsOffset: Int32?

                public var showSourceLan: Bool?

                public var sizeNormalized: Double?

                public var sourceLan: String?

                public var targetLan: String?

                public var wordCountPerLine: Int32?

                public var wordSpaceNormalized: Double?

                public var wordsCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.borderColor != nil {
                        map["BorderColor"] = self.borderColor!
                    }
                    if self.borderWidthNormalized != nil {
                        map["BorderWidthNormalized"] = self.borderWidthNormalized!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.fontName != nil {
                        map["FontName"] = self.fontName!
                    }
                    if self.lineSpaceNormalized != nil {
                        map["LineSpaceNormalized"] = self.lineSpaceNormalized!
                    }
                    if self.locationId != nil {
                        map["LocationId"] = self.locationId!
                    }
                    if self.ptsOffset != nil {
                        map["PtsOffset"] = self.ptsOffset!
                    }
                    if self.showSourceLan != nil {
                        map["ShowSourceLan"] = self.showSourceLan!
                    }
                    if self.sizeNormalized != nil {
                        map["SizeNormalized"] = self.sizeNormalized!
                    }
                    if self.sourceLan != nil {
                        map["SourceLan"] = self.sourceLan!
                    }
                    if self.targetLan != nil {
                        map["TargetLan"] = self.targetLan!
                    }
                    if self.wordCountPerLine != nil {
                        map["WordCountPerLine"] = self.wordCountPerLine!
                    }
                    if self.wordSpaceNormalized != nil {
                        map["WordSpaceNormalized"] = self.wordSpaceNormalized!
                    }
                    if self.wordsCount != nil {
                        map["WordsCount"] = self.wordsCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BorderColor"] as? String {
                        self.borderColor = value
                    }
                    if let value = dict["BorderWidthNormalized"] as? Double {
                        self.borderWidthNormalized = value
                    }
                    if let value = dict["Color"] as? String {
                        self.color = value
                    }
                    if let value = dict["FontName"] as? String {
                        self.fontName = value
                    }
                    if let value = dict["LineSpaceNormalized"] as? Double {
                        self.lineSpaceNormalized = value
                    }
                    if let value = dict["LocationId"] as? String {
                        self.locationId = value
                    }
                    if let value = dict["PtsOffset"] as? Int32 {
                        self.ptsOffset = value
                    }
                    if let value = dict["ShowSourceLan"] as? Bool {
                        self.showSourceLan = value
                    }
                    if let value = dict["SizeNormalized"] as? Double {
                        self.sizeNormalized = value
                    }
                    if let value = dict["SourceLan"] as? String {
                        self.sourceLan = value
                    }
                    if let value = dict["TargetLan"] as? String {
                        self.targetLan = value
                    }
                    if let value = dict["WordCountPerLine"] as? Int32 {
                        self.wordCountPerLine = value
                    }
                    if let value = dict["WordSpaceNormalized"] as? Double {
                        self.wordSpaceNormalized = value
                    }
                    if let value = dict["WordsCount"] as? Int32 {
                        self.wordsCount = value
                    }
                }
            }
            public class ComponentLayer : Tea.TeaModel {
                public class PositionNormalizeds : Tea.TeaModel {
                    public var position: [Double]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.position != nil {
                            map["Position"] = self.position!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Position"] as? [Double] {
                            self.position = value
                        }
                    }
                }
                public var heightNormalized: Double?

                public var positionNormalizeds: DescribeCasterComponentsResponseBody.Components.Component.ComponentLayer.PositionNormalizeds?

                public var positionRefer: String?

                public var transparency: Int32?

                public var widthNormalized: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.positionNormalizeds?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.heightNormalized != nil {
                        map["HeightNormalized"] = self.heightNormalized!
                    }
                    if self.positionNormalizeds != nil {
                        map["PositionNormalizeds"] = self.positionNormalizeds?.toMap()
                    }
                    if self.positionRefer != nil {
                        map["PositionRefer"] = self.positionRefer!
                    }
                    if self.transparency != nil {
                        map["Transparency"] = self.transparency!
                    }
                    if self.widthNormalized != nil {
                        map["WidthNormalized"] = self.widthNormalized!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["HeightNormalized"] as? Double {
                        self.heightNormalized = value
                    }
                    if let value = dict["PositionNormalizeds"] as? [String: Any?] {
                        var model = DescribeCasterComponentsResponseBody.Components.Component.ComponentLayer.PositionNormalizeds()
                        model.fromMap(value)
                        self.positionNormalizeds = model
                    }
                    if let value = dict["PositionRefer"] as? String {
                        self.positionRefer = value
                    }
                    if let value = dict["Transparency"] as? Int32 {
                        self.transparency = value
                    }
                    if let value = dict["WidthNormalized"] as? Double {
                        self.widthNormalized = value
                    }
                }
            }
            public class ImageLayerContent : Tea.TeaModel {
                public var materialId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.materialId != nil {
                        map["MaterialId"] = self.materialId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MaterialId"] as? String {
                        self.materialId = value
                    }
                }
            }
            public class TextLayerContent : Tea.TeaModel {
                public var borderColor: String?

                public var borderWidthNormalized: Double?

                public var color: String?

                public var fontName: String?

                public var sizeNormalized: Double?

                public var text: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.borderColor != nil {
                        map["BorderColor"] = self.borderColor!
                    }
                    if self.borderWidthNormalized != nil {
                        map["BorderWidthNormalized"] = self.borderWidthNormalized!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.fontName != nil {
                        map["FontName"] = self.fontName!
                    }
                    if self.sizeNormalized != nil {
                        map["SizeNormalized"] = self.sizeNormalized!
                    }
                    if self.text != nil {
                        map["Text"] = self.text!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BorderColor"] as? String {
                        self.borderColor = value
                    }
                    if let value = dict["BorderWidthNormalized"] as? Double {
                        self.borderWidthNormalized = value
                    }
                    if let value = dict["Color"] as? String {
                        self.color = value
                    }
                    if let value = dict["FontName"] as? String {
                        self.fontName = value
                    }
                    if let value = dict["SizeNormalized"] as? Double {
                        self.sizeNormalized = value
                    }
                    if let value = dict["Text"] as? String {
                        self.text = value
                    }
                }
            }
            public var captionLayerContent: DescribeCasterComponentsResponseBody.Components.Component.CaptionLayerContent?

            public var componentId: String?

            public var componentLayer: DescribeCasterComponentsResponseBody.Components.Component.ComponentLayer?

            public var componentName: String?

            public var componentType: String?

            public var effect: String?

            public var imageLayerContent: DescribeCasterComponentsResponseBody.Components.Component.ImageLayerContent?

            public var locationId: String?

            public var textLayerContent: DescribeCasterComponentsResponseBody.Components.Component.TextLayerContent?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.captionLayerContent?.validate()
                try self.componentLayer?.validate()
                try self.imageLayerContent?.validate()
                try self.textLayerContent?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.captionLayerContent != nil {
                    map["CaptionLayerContent"] = self.captionLayerContent?.toMap()
                }
                if self.componentId != nil {
                    map["ComponentId"] = self.componentId!
                }
                if self.componentLayer != nil {
                    map["ComponentLayer"] = self.componentLayer?.toMap()
                }
                if self.componentName != nil {
                    map["ComponentName"] = self.componentName!
                }
                if self.componentType != nil {
                    map["ComponentType"] = self.componentType!
                }
                if self.effect != nil {
                    map["Effect"] = self.effect!
                }
                if self.imageLayerContent != nil {
                    map["ImageLayerContent"] = self.imageLayerContent?.toMap()
                }
                if self.locationId != nil {
                    map["LocationId"] = self.locationId!
                }
                if self.textLayerContent != nil {
                    map["TextLayerContent"] = self.textLayerContent?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CaptionLayerContent"] as? [String: Any?] {
                    var model = DescribeCasterComponentsResponseBody.Components.Component.CaptionLayerContent()
                    model.fromMap(value)
                    self.captionLayerContent = model
                }
                if let value = dict["ComponentId"] as? String {
                    self.componentId = value
                }
                if let value = dict["ComponentLayer"] as? [String: Any?] {
                    var model = DescribeCasterComponentsResponseBody.Components.Component.ComponentLayer()
                    model.fromMap(value)
                    self.componentLayer = model
                }
                if let value = dict["ComponentName"] as? String {
                    self.componentName = value
                }
                if let value = dict["ComponentType"] as? String {
                    self.componentType = value
                }
                if let value = dict["Effect"] as? String {
                    self.effect = value
                }
                if let value = dict["ImageLayerContent"] as? [String: Any?] {
                    var model = DescribeCasterComponentsResponseBody.Components.Component.ImageLayerContent()
                    model.fromMap(value)
                    self.imageLayerContent = model
                }
                if let value = dict["LocationId"] as? String {
                    self.locationId = value
                }
                if let value = dict["TextLayerContent"] as? [String: Any?] {
                    var model = DescribeCasterComponentsResponseBody.Components.Component.TextLayerContent()
                    model.fromMap(value)
                    self.textLayerContent = model
                }
            }
        }
        public var component: [DescribeCasterComponentsResponseBody.Components.Component]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.component != nil {
                var tmp : [Any] = []
                for k in self.component! {
                    tmp.append(k.toMap())
                }
                map["Component"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Component"] as? [Any?] {
                var tmp : [DescribeCasterComponentsResponseBody.Components.Component] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCasterComponentsResponseBody.Components.Component()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.component = tmp
            }
        }
    }
    public var components: DescribeCasterComponentsResponseBody.Components?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.components?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.components != nil {
            map["Components"] = self.components?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Components"] as? [String: Any?] {
            var model = DescribeCasterComponentsResponseBody.Components()
            model.fromMap(value)
            self.components = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeCasterComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCasterComponentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCasterConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeCasterConfigResponseBody : Tea.TeaModel {
    public class RecordConfig : Tea.TeaModel {
        public class RecordFormat : Tea.TeaModel {
            public class RecordFormat : Tea.TeaModel {
                public var cycleDuration: Int32?

                public var format: String?

                public var ossObjectPrefix: String?

                public var sliceOssObjectPrefix: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cycleDuration != nil {
                        map["CycleDuration"] = self.cycleDuration!
                    }
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    if self.ossObjectPrefix != nil {
                        map["OssObjectPrefix"] = self.ossObjectPrefix!
                    }
                    if self.sliceOssObjectPrefix != nil {
                        map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CycleDuration"] as? Int32 {
                        self.cycleDuration = value
                    }
                    if let value = dict["Format"] as? String {
                        self.format = value
                    }
                    if let value = dict["OssObjectPrefix"] as? String {
                        self.ossObjectPrefix = value
                    }
                    if let value = dict["SliceOssObjectPrefix"] as? String {
                        self.sliceOssObjectPrefix = value
                    }
                }
            }
            public var recordFormat: [DescribeCasterConfigResponseBody.RecordConfig.RecordFormat.RecordFormat]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.recordFormat != nil {
                    var tmp : [Any] = []
                    for k in self.recordFormat! {
                        tmp.append(k.toMap())
                    }
                    map["RecordFormat"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RecordFormat"] as? [Any?] {
                    var tmp : [DescribeCasterConfigResponseBody.RecordConfig.RecordFormat.RecordFormat] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCasterConfigResponseBody.RecordConfig.RecordFormat.RecordFormat()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.recordFormat = tmp
                }
            }
        }
        public var onDemand: Int32?

        public var ossBucket: String?

        public var ossEndpoint: String?

        public var recordFormat: DescribeCasterConfigResponseBody.RecordConfig.RecordFormat?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordFormat?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.onDemand != nil {
                map["OnDemand"] = self.onDemand!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.recordFormat != nil {
                map["RecordFormat"] = self.recordFormat?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OnDemand"] as? Int32 {
                self.onDemand = value
            }
            if let value = dict["OssBucket"] as? String {
                self.ossBucket = value
            }
            if let value = dict["OssEndpoint"] as? String {
                self.ossEndpoint = value
            }
            if let value = dict["RecordFormat"] as? [String: Any?] {
                var model = DescribeCasterConfigResponseBody.RecordConfig.RecordFormat()
                model.fromMap(value)
                self.recordFormat = model
            }
        }
    }
    public class SyncGroupsConfig : Tea.TeaModel {
        public class SyncGroup : Tea.TeaModel {
            public class ResourceIds : Tea.TeaModel {
                public var resourceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceId != nil {
                        map["ResourceId"] = self.resourceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ResourceId"] as? [String] {
                        self.resourceId = value
                    }
                }
            }
            public var hostResourceId: String?

            public var mode: Int32?

            public var resourceIds: DescribeCasterConfigResponseBody.SyncGroupsConfig.SyncGroup.ResourceIds?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.resourceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostResourceId != nil {
                    map["HostResourceId"] = self.hostResourceId!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.resourceIds != nil {
                    map["ResourceIds"] = self.resourceIds?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["HostResourceId"] as? String {
                    self.hostResourceId = value
                }
                if let value = dict["Mode"] as? Int32 {
                    self.mode = value
                }
                if let value = dict["ResourceIds"] as? [String: Any?] {
                    var model = DescribeCasterConfigResponseBody.SyncGroupsConfig.SyncGroup.ResourceIds()
                    model.fromMap(value)
                    self.resourceIds = model
                }
            }
        }
        public var syncGroup: [DescribeCasterConfigResponseBody.SyncGroupsConfig.SyncGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.syncGroup != nil {
                var tmp : [Any] = []
                for k in self.syncGroup! {
                    tmp.append(k.toMap())
                }
                map["SyncGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SyncGroup"] as? [Any?] {
                var tmp : [DescribeCasterConfigResponseBody.SyncGroupsConfig.SyncGroup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCasterConfigResponseBody.SyncGroupsConfig.SyncGroup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.syncGroup = tmp
            }
        }
    }
    public class TranscodeConfig : Tea.TeaModel {
        public class CustomParams : Tea.TeaModel {
            public class Video : Tea.TeaModel {
                public var bitrate: Int32?

                public var fps: Int32?

                public var height: Int32?

                public var width: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["bitrate"] = self.bitrate!
                    }
                    if self.fps != nil {
                        map["fps"] = self.fps!
                    }
                    if self.height != nil {
                        map["height"] = self.height!
                    }
                    if self.width != nil {
                        map["width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["bitrate"] as? Int32 {
                        self.bitrate = value
                    }
                    if let value = dict["fps"] as? Int32 {
                        self.fps = value
                    }
                    if let value = dict["height"] as? Int32 {
                        self.height = value
                    }
                    if let value = dict["width"] as? Int32 {
                        self.width = value
                    }
                }
            }
            public var video: DescribeCasterConfigResponseBody.TranscodeConfig.CustomParams.Video?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.video?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.video != nil {
                    map["video"] = self.video?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["video"] as? [String: Any?] {
                    var model = DescribeCasterConfigResponseBody.TranscodeConfig.CustomParams.Video()
                    model.fromMap(value)
                    self.video = model
                }
            }
        }
        public class LiveTemplateIds : Tea.TeaModel {
            public var locationId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.locationId != nil {
                    map["LocationId"] = self.locationId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocationId"] as? [String] {
                    self.locationId = value
                }
            }
        }
        public var casterTemplate: String?

        public var customParams: DescribeCasterConfigResponseBody.TranscodeConfig.CustomParams?

        public var liveTemplateIds: DescribeCasterConfigResponseBody.TranscodeConfig.LiveTemplateIds?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.customParams?.validate()
            try self.liveTemplateIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.casterTemplate != nil {
                map["CasterTemplate"] = self.casterTemplate!
            }
            if self.customParams != nil {
                map["CustomParams"] = self.customParams?.toMap()
            }
            if self.liveTemplateIds != nil {
                map["LiveTemplateIds"] = self.liveTemplateIds?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CasterTemplate"] as? String {
                self.casterTemplate = value
            }
            if let value = dict["CustomParams"] as? [String: Any?] {
                var model = DescribeCasterConfigResponseBody.TranscodeConfig.CustomParams()
                model.fromMap(value)
                self.customParams = model
            }
            if let value = dict["LiveTemplateIds"] as? [String: Any?] {
                var model = DescribeCasterConfigResponseBody.TranscodeConfig.LiveTemplateIds()
                model.fromMap(value)
                self.liveTemplateIds = model
            }
        }
    }
    public var autoSwitchUrgentConfig: String?

    public var autoSwitchUrgentOn: String?

    public var callbackUrl: String?

    public var casterId: String?

    public var casterName: String?

    public var channelEnable: Int32?

    public var delay: Double?

    public var domainName: String?

    public var programEffect: Int32?

    public var programName: String?

    public var recordConfig: DescribeCasterConfigResponseBody.RecordConfig?

    public var requestId: String?

    public var sideOutputUrl: String?

    public var sideOutputUrlList: String?

    public var syncGroupsConfig: DescribeCasterConfigResponseBody.SyncGroupsConfig?

    public var transcodeConfig: DescribeCasterConfigResponseBody.TranscodeConfig?

    public var urgentImageId: String?

    public var urgentImageUrl: String?

    public var urgentLiveStreamUrl: String?

    public var urgentMaterialId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordConfig?.validate()
        try self.syncGroupsConfig?.validate()
        try self.transcodeConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSwitchUrgentConfig != nil {
            map["AutoSwitchUrgentConfig"] = self.autoSwitchUrgentConfig!
        }
        if self.autoSwitchUrgentOn != nil {
            map["AutoSwitchUrgentOn"] = self.autoSwitchUrgentOn!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.channelEnable != nil {
            map["ChannelEnable"] = self.channelEnable!
        }
        if self.delay != nil {
            map["Delay"] = self.delay!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.programEffect != nil {
            map["ProgramEffect"] = self.programEffect!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.recordConfig != nil {
            map["RecordConfig"] = self.recordConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sideOutputUrl != nil {
            map["SideOutputUrl"] = self.sideOutputUrl!
        }
        if self.sideOutputUrlList != nil {
            map["SideOutputUrlList"] = self.sideOutputUrlList!
        }
        if self.syncGroupsConfig != nil {
            map["SyncGroupsConfig"] = self.syncGroupsConfig?.toMap()
        }
        if self.transcodeConfig != nil {
            map["TranscodeConfig"] = self.transcodeConfig?.toMap()
        }
        if self.urgentImageId != nil {
            map["UrgentImageId"] = self.urgentImageId!
        }
        if self.urgentImageUrl != nil {
            map["UrgentImageUrl"] = self.urgentImageUrl!
        }
        if self.urgentLiveStreamUrl != nil {
            map["UrgentLiveStreamUrl"] = self.urgentLiveStreamUrl!
        }
        if self.urgentMaterialId != nil {
            map["UrgentMaterialId"] = self.urgentMaterialId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoSwitchUrgentConfig"] as? String {
            self.autoSwitchUrgentConfig = value
        }
        if let value = dict["AutoSwitchUrgentOn"] as? String {
            self.autoSwitchUrgentOn = value
        }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["CasterName"] as? String {
            self.casterName = value
        }
        if let value = dict["ChannelEnable"] as? Int32 {
            self.channelEnable = value
        }
        if let value = dict["Delay"] as? Double {
            self.delay = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["ProgramEffect"] as? Int32 {
            self.programEffect = value
        }
        if let value = dict["ProgramName"] as? String {
            self.programName = value
        }
        if let value = dict["RecordConfig"] as? [String: Any?] {
            var model = DescribeCasterConfigResponseBody.RecordConfig()
            model.fromMap(value)
            self.recordConfig = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SideOutputUrl"] as? String {
            self.sideOutputUrl = value
        }
        if let value = dict["SideOutputUrlList"] as? String {
            self.sideOutputUrlList = value
        }
        if let value = dict["SyncGroupsConfig"] as? [String: Any?] {
            var model = DescribeCasterConfigResponseBody.SyncGroupsConfig()
            model.fromMap(value)
            self.syncGroupsConfig = model
        }
        if let value = dict["TranscodeConfig"] as? [String: Any?] {
            var model = DescribeCasterConfigResponseBody.TranscodeConfig()
            model.fromMap(value)
            self.transcodeConfig = model
        }
        if let value = dict["UrgentImageId"] as? String {
            self.urgentImageId = value
        }
        if let value = dict["UrgentImageUrl"] as? String {
            self.urgentImageUrl = value
        }
        if let value = dict["UrgentLiveStreamUrl"] as? String {
            self.urgentLiveStreamUrl = value
        }
        if let value = dict["UrgentMaterialId"] as? String {
            self.urgentMaterialId = value
        }
    }
}

public class DescribeCasterConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCasterConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCasterLayoutsRequest : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeCasterLayoutsResponseBody : Tea.TeaModel {
    public class Layouts : Tea.TeaModel {
        public class Layout : Tea.TeaModel {
            public class AudioLayers : Tea.TeaModel {
                public class AudioLayer : Tea.TeaModel {
                    public var fixedDelayDuration: Int32?

                    public var validChannel: String?

                    public var volumeRate: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fixedDelayDuration != nil {
                            map["FixedDelayDuration"] = self.fixedDelayDuration!
                        }
                        if self.validChannel != nil {
                            map["ValidChannel"] = self.validChannel!
                        }
                        if self.volumeRate != nil {
                            map["VolumeRate"] = self.volumeRate!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["FixedDelayDuration"] as? Int32 {
                            self.fixedDelayDuration = value
                        }
                        if let value = dict["ValidChannel"] as? String {
                            self.validChannel = value
                        }
                        if let value = dict["VolumeRate"] as? Double {
                            self.volumeRate = value
                        }
                    }
                }
                public var audioLayer: [DescribeCasterLayoutsResponseBody.Layouts.Layout.AudioLayers.AudioLayer]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioLayer != nil {
                        var tmp : [Any] = []
                        for k in self.audioLayer! {
                            tmp.append(k.toMap())
                        }
                        map["AudioLayer"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AudioLayer"] as? [Any?] {
                        var tmp : [DescribeCasterLayoutsResponseBody.Layouts.Layout.AudioLayers.AudioLayer] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.AudioLayers.AudioLayer()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.audioLayer = tmp
                    }
                }
            }
            public class BlendList : Tea.TeaModel {
                public var locationId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.locationId != nil {
                        map["LocationId"] = self.locationId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LocationId"] as? [String] {
                        self.locationId = value
                    }
                }
            }
            public class MixList : Tea.TeaModel {
                public var locationId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.locationId != nil {
                        map["LocationId"] = self.locationId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LocationId"] as? [String] {
                        self.locationId = value
                    }
                }
            }
            public class VideoLayers : Tea.TeaModel {
                public class VideoLayer : Tea.TeaModel {
                    public class PositionNormalizeds : Tea.TeaModel {
                        public var position: [Double]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.position != nil {
                                map["Position"] = self.position!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Position"] as? [Double] {
                                self.position = value
                            }
                        }
                    }
                    public var fillMode: String?

                    public var fixedDelayDuration: Int32?

                    public var heightNormalized: Double?

                    public var positionNormalizeds: DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers.VideoLayer.PositionNormalizeds?

                    public var positionRefer: String?

                    public var widthNormalized: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.positionNormalizeds?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fillMode != nil {
                            map["FillMode"] = self.fillMode!
                        }
                        if self.fixedDelayDuration != nil {
                            map["FixedDelayDuration"] = self.fixedDelayDuration!
                        }
                        if self.heightNormalized != nil {
                            map["HeightNormalized"] = self.heightNormalized!
                        }
                        if self.positionNormalizeds != nil {
                            map["PositionNormalizeds"] = self.positionNormalizeds?.toMap()
                        }
                        if self.positionRefer != nil {
                            map["PositionRefer"] = self.positionRefer!
                        }
                        if self.widthNormalized != nil {
                            map["WidthNormalized"] = self.widthNormalized!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["FillMode"] as? String {
                            self.fillMode = value
                        }
                        if let value = dict["FixedDelayDuration"] as? Int32 {
                            self.fixedDelayDuration = value
                        }
                        if let value = dict["HeightNormalized"] as? Double {
                            self.heightNormalized = value
                        }
                        if let value = dict["PositionNormalizeds"] as? [String: Any?] {
                            var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers.VideoLayer.PositionNormalizeds()
                            model.fromMap(value)
                            self.positionNormalizeds = model
                        }
                        if let value = dict["PositionRefer"] as? String {
                            self.positionRefer = value
                        }
                        if let value = dict["WidthNormalized"] as? Double {
                            self.widthNormalized = value
                        }
                    }
                }
                public var videoLayer: [DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers.VideoLayer]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoLayer != nil {
                        var tmp : [Any] = []
                        for k in self.videoLayer! {
                            tmp.append(k.toMap())
                        }
                        map["VideoLayer"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VideoLayer"] as? [Any?] {
                        var tmp : [DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers.VideoLayer] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers.VideoLayer()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.videoLayer = tmp
                    }
                }
            }
            public var audioLayers: DescribeCasterLayoutsResponseBody.Layouts.Layout.AudioLayers?

            public var blendList: DescribeCasterLayoutsResponseBody.Layouts.Layout.BlendList?

            public var layoutId: String?

            public var mixList: DescribeCasterLayoutsResponseBody.Layouts.Layout.MixList?

            public var videoLayers: DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioLayers?.validate()
                try self.blendList?.validate()
                try self.mixList?.validate()
                try self.videoLayers?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioLayers != nil {
                    map["AudioLayers"] = self.audioLayers?.toMap()
                }
                if self.blendList != nil {
                    map["BlendList"] = self.blendList?.toMap()
                }
                if self.layoutId != nil {
                    map["LayoutId"] = self.layoutId!
                }
                if self.mixList != nil {
                    map["MixList"] = self.mixList?.toMap()
                }
                if self.videoLayers != nil {
                    map["VideoLayers"] = self.videoLayers?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AudioLayers"] as? [String: Any?] {
                    var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.AudioLayers()
                    model.fromMap(value)
                    self.audioLayers = model
                }
                if let value = dict["BlendList"] as? [String: Any?] {
                    var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.BlendList()
                    model.fromMap(value)
                    self.blendList = model
                }
                if let value = dict["LayoutId"] as? String {
                    self.layoutId = value
                }
                if let value = dict["MixList"] as? [String: Any?] {
                    var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.MixList()
                    model.fromMap(value)
                    self.mixList = model
                }
                if let value = dict["VideoLayers"] as? [String: Any?] {
                    var model = DescribeCasterLayoutsResponseBody.Layouts.Layout.VideoLayers()
                    model.fromMap(value)
                    self.videoLayers = model
                }
            }
        }
        public var layout: [DescribeCasterLayoutsResponseBody.Layouts.Layout]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.layout != nil {
                var tmp : [Any] = []
                for k in self.layout! {
                    tmp.append(k.toMap())
                }
                map["Layout"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Layout"] as? [Any?] {
                var tmp : [DescribeCasterLayoutsResponseBody.Layouts.Layout] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCasterLayoutsResponseBody.Layouts.Layout()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.layout = tmp
            }
        }
    }
    public var layouts: DescribeCasterLayoutsResponseBody.Layouts?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.layouts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.layouts != nil {
            map["Layouts"] = self.layouts?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Layouts"] as? [String: Any?] {
            var model = DescribeCasterLayoutsResponseBody.Layouts()
            model.fromMap(value)
            self.layouts = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeCasterLayoutsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterLayoutsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCasterLayoutsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCasterProgramRequest : Tea.TeaModel {
    public var casterId: String?

    public var endTime: String?

    public var episodeId: String?

    public var episodeType: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.episodeType != nil {
            map["EpisodeType"] = self.episodeType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["EpisodeId"] as? String {
            self.episodeId = value
        }
        if let value = dict["EpisodeType"] as? String {
            self.episodeType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
    }
}

public class DescribeCasterProgramResponseBody : Tea.TeaModel {
    public class Episodes : Tea.TeaModel {
        public class Episode : Tea.TeaModel {
            public class ComponentIds : Tea.TeaModel {
                public var componentId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.componentId != nil {
                        map["ComponentId"] = self.componentId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ComponentId"] as? [String] {
                        self.componentId = value
                    }
                }
            }
            public var componentIds: DescribeCasterProgramResponseBody.Episodes.Episode.ComponentIds?

            public var endTime: String?

            public var episodeId: String?

            public var episodeName: String?

            public var episodeType: String?

            public var resourceId: String?

            public var startTime: String?

            public var status: Int32?

            public var switchType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.componentIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.componentIds != nil {
                    map["ComponentIds"] = self.componentIds?.toMap()
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.episodeId != nil {
                    map["EpisodeId"] = self.episodeId!
                }
                if self.episodeName != nil {
                    map["EpisodeName"] = self.episodeName!
                }
                if self.episodeType != nil {
                    map["EpisodeType"] = self.episodeType!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.switchType != nil {
                    map["SwitchType"] = self.switchType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComponentIds"] as? [String: Any?] {
                    var model = DescribeCasterProgramResponseBody.Episodes.Episode.ComponentIds()
                    model.fromMap(value)
                    self.componentIds = model
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["EpisodeId"] as? String {
                    self.episodeId = value
                }
                if let value = dict["EpisodeName"] as? String {
                    self.episodeName = value
                }
                if let value = dict["EpisodeType"] as? String {
                    self.episodeType = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["SwitchType"] as? String {
                    self.switchType = value
                }
            }
        }
        public var episode: [DescribeCasterProgramResponseBody.Episodes.Episode]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.episode != nil {
                var tmp : [Any] = []
                for k in self.episode! {
                    tmp.append(k.toMap())
                }
                map["Episode"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Episode"] as? [Any?] {
                var tmp : [DescribeCasterProgramResponseBody.Episodes.Episode] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCasterProgramResponseBody.Episodes.Episode()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.episode = tmp
            }
        }
    }
    public var casterId: String?

    public var episodes: DescribeCasterProgramResponseBody.Episodes?

    public var programEffect: Int32?

    public var programName: String?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.episodes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episodes != nil {
            map["Episodes"] = self.episodes?.toMap()
        }
        if self.programEffect != nil {
            map["ProgramEffect"] = self.programEffect!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["Episodes"] as? [String: Any?] {
            var model = DescribeCasterProgramResponseBody.Episodes()
            model.fromMap(value)
            self.episodes = model
        }
        if let value = dict["ProgramEffect"] as? Int32 {
            self.programEffect = value
        }
        if let value = dict["ProgramName"] as? String {
            self.programName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeCasterProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCasterProgramResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCasterSceneAudioRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
    }
}

public class DescribeCasterSceneAudioResponseBody : Tea.TeaModel {
    public class AudioLayers : Tea.TeaModel {
        public class AudioLayer : Tea.TeaModel {
            public var fixedDelayDuration: Int32?

            public var validChannel: String?

            public var volumeRate: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fixedDelayDuration != nil {
                    map["FixedDelayDuration"] = self.fixedDelayDuration!
                }
                if self.validChannel != nil {
                    map["ValidChannel"] = self.validChannel!
                }
                if self.volumeRate != nil {
                    map["VolumeRate"] = self.volumeRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FixedDelayDuration"] as? Int32 {
                    self.fixedDelayDuration = value
                }
                if let value = dict["ValidChannel"] as? String {
                    self.validChannel = value
                }
                if let value = dict["VolumeRate"] as? Double {
                    self.volumeRate = value
                }
            }
        }
        public var audioLayer: [DescribeCasterSceneAudioResponseBody.AudioLayers.AudioLayer]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioLayer != nil {
                var tmp : [Any] = []
                for k in self.audioLayer! {
                    tmp.append(k.toMap())
                }
                map["AudioLayer"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AudioLayer"] as? [Any?] {
                var tmp : [DescribeCasterSceneAudioResponseBody.AudioLayers.AudioLayer] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCasterSceneAudioResponseBody.AudioLayers.AudioLayer()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.audioLayer = tmp
            }
        }
    }
    public class MixList : Tea.TeaModel {
        public var locationId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.locationId != nil {
                map["LocationId"] = self.locationId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LocationId"] as? [String] {
                self.locationId = value
            }
        }
    }
    public var audioLayers: DescribeCasterSceneAudioResponseBody.AudioLayers?

    public var casterId: String?

    public var followEnable: Int32?

    public var mixList: DescribeCasterSceneAudioResponseBody.MixList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.audioLayers?.validate()
        try self.mixList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioLayers != nil {
            map["AudioLayers"] = self.audioLayers?.toMap()
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.followEnable != nil {
            map["FollowEnable"] = self.followEnable!
        }
        if self.mixList != nil {
            map["MixList"] = self.mixList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AudioLayers"] as? [String: Any?] {
            var model = DescribeCasterSceneAudioResponseBody.AudioLayers()
            model.fromMap(value)
            self.audioLayers = model
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["FollowEnable"] as? Int32 {
            self.followEnable = value
        }
        if let value = dict["MixList"] as? [String: Any?] {
            var model = DescribeCasterSceneAudioResponseBody.MixList()
            model.fromMap(value)
            self.mixList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCasterSceneAudioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterSceneAudioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCasterSceneAudioResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCasterScenesRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
    }
}

public class DescribeCasterScenesResponseBody : Tea.TeaModel {
    public class SceneList : Tea.TeaModel {
        public class Scene : Tea.TeaModel {
            public class ComponentIds : Tea.TeaModel {
                public var componentId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.componentId != nil {
                        map["componentId"] = self.componentId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["componentId"] as? [String] {
                        self.componentId = value
                    }
                }
            }
            public class StreamInfos : Tea.TeaModel {
                public class StreamInfo : Tea.TeaModel {
                    public var outputStreamUrl: String?

                    public var transcodeConfig: String?

                    public var videoFormat: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outputStreamUrl != nil {
                            map["OutputStreamUrl"] = self.outputStreamUrl!
                        }
                        if self.transcodeConfig != nil {
                            map["TranscodeConfig"] = self.transcodeConfig!
                        }
                        if self.videoFormat != nil {
                            map["VideoFormat"] = self.videoFormat!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["OutputStreamUrl"] as? String {
                            self.outputStreamUrl = value
                        }
                        if let value = dict["TranscodeConfig"] as? String {
                            self.transcodeConfig = value
                        }
                        if let value = dict["VideoFormat"] as? String {
                            self.videoFormat = value
                        }
                    }
                }
                public var streamInfo: [DescribeCasterScenesResponseBody.SceneList.Scene.StreamInfos.StreamInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.streamInfo != nil {
                        var tmp : [Any] = []
                        for k in self.streamInfo! {
                            tmp.append(k.toMap())
                        }
                        map["StreamInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["StreamInfo"] as? [Any?] {
                        var tmp : [DescribeCasterScenesResponseBody.SceneList.Scene.StreamInfos.StreamInfo] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCasterScenesResponseBody.SceneList.Scene.StreamInfos.StreamInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.streamInfo = tmp
                    }
                }
            }
            public var componentIds: DescribeCasterScenesResponseBody.SceneList.Scene.ComponentIds?

            public var layoutId: String?

            public var outputType: String?

            public var sceneId: String?

            public var sceneName: String?

            public var status: Int32?

            public var streamInfos: DescribeCasterScenesResponseBody.SceneList.Scene.StreamInfos?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.componentIds?.validate()
                try self.streamInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.componentIds != nil {
                    map["ComponentIds"] = self.componentIds?.toMap()
                }
                if self.layoutId != nil {
                    map["LayoutId"] = self.layoutId!
                }
                if self.outputType != nil {
                    map["OutputType"] = self.outputType!
                }
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.sceneName != nil {
                    map["SceneName"] = self.sceneName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.streamInfos != nil {
                    map["StreamInfos"] = self.streamInfos?.toMap()
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ComponentIds"] as? [String: Any?] {
                    var model = DescribeCasterScenesResponseBody.SceneList.Scene.ComponentIds()
                    model.fromMap(value)
                    self.componentIds = model
                }
                if let value = dict["LayoutId"] as? String {
                    self.layoutId = value
                }
                if let value = dict["OutputType"] as? String {
                    self.outputType = value
                }
                if let value = dict["SceneId"] as? String {
                    self.sceneId = value
                }
                if let value = dict["SceneName"] as? String {
                    self.sceneName = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["StreamInfos"] as? [String: Any?] {
                    var model = DescribeCasterScenesResponseBody.SceneList.Scene.StreamInfos()
                    model.fromMap(value)
                    self.streamInfos = model
                }
                if let value = dict["StreamUrl"] as? String {
                    self.streamUrl = value
                }
            }
        }
        public var scene: [DescribeCasterScenesResponseBody.SceneList.Scene]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scene != nil {
                var tmp : [Any] = []
                for k in self.scene! {
                    tmp.append(k.toMap())
                }
                map["Scene"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Scene"] as? [Any?] {
                var tmp : [DescribeCasterScenesResponseBody.SceneList.Scene] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCasterScenesResponseBody.SceneList.Scene()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.scene = tmp
            }
        }
    }
    public var requestId: String?

    public var sceneList: DescribeCasterScenesResponseBody.SceneList?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sceneList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sceneList != nil {
            map["SceneList"] = self.sceneList?.toMap()
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SceneList"] as? [String: Any?] {
            var model = DescribeCasterScenesResponseBody.SceneList()
            model.fromMap(value)
            self.sceneList = model
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeCasterScenesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterScenesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCasterScenesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCasterStreamUrlRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeCasterStreamUrlResponseBody : Tea.TeaModel {
    public class CasterStreams : Tea.TeaModel {
        public class CasterStream : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public class StreamInfo : Tea.TeaModel {
                    public var outputStreamUrl: String?

                    public var transcodeConfig: String?

                    public var videoFormat: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outputStreamUrl != nil {
                            map["OutputStreamUrl"] = self.outputStreamUrl!
                        }
                        if self.transcodeConfig != nil {
                            map["TranscodeConfig"] = self.transcodeConfig!
                        }
                        if self.videoFormat != nil {
                            map["VideoFormat"] = self.videoFormat!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["OutputStreamUrl"] as? String {
                            self.outputStreamUrl = value
                        }
                        if let value = dict["TranscodeConfig"] as? String {
                            self.transcodeConfig = value
                        }
                        if let value = dict["VideoFormat"] as? String {
                            self.videoFormat = value
                        }
                    }
                }
                public var streamInfo: [DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream.StreamInfos.StreamInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.streamInfo != nil {
                        var tmp : [Any] = []
                        for k in self.streamInfo! {
                            tmp.append(k.toMap())
                        }
                        map["StreamInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["StreamInfo"] as? [Any?] {
                        var tmp : [DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream.StreamInfos.StreamInfo] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream.StreamInfos.StreamInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.streamInfo = tmp
                    }
                }
            }
            public var outputType: Int32?

            public var rtmpUrl: String?

            public var sceneId: String?

            public var streamInfos: DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream.StreamInfos?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.streamInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.outputType != nil {
                    map["OutputType"] = self.outputType!
                }
                if self.rtmpUrl != nil {
                    map["RtmpUrl"] = self.rtmpUrl!
                }
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.streamInfos != nil {
                    map["StreamInfos"] = self.streamInfos?.toMap()
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OutputType"] as? Int32 {
                    self.outputType = value
                }
                if let value = dict["RtmpUrl"] as? String {
                    self.rtmpUrl = value
                }
                if let value = dict["SceneId"] as? String {
                    self.sceneId = value
                }
                if let value = dict["StreamInfos"] as? [String: Any?] {
                    var model = DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream.StreamInfos()
                    model.fromMap(value)
                    self.streamInfos = model
                }
                if let value = dict["StreamUrl"] as? String {
                    self.streamUrl = value
                }
            }
        }
        public var casterStream: [DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.casterStream != nil {
                var tmp : [Any] = []
                for k in self.casterStream! {
                    tmp.append(k.toMap())
                }
                map["CasterStream"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CasterStream"] as? [Any?] {
                var tmp : [DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCasterStreamUrlResponseBody.CasterStreams.CasterStream()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.casterStream = tmp
            }
        }
    }
    public var casterId: String?

    public var casterStreams: DescribeCasterStreamUrlResponseBody.CasterStreams?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.casterStreams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.casterStreams != nil {
            map["CasterStreams"] = self.casterStreams?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["CasterStreams"] as? [String: Any?] {
            var model = DescribeCasterStreamUrlResponseBody.CasterStreams()
            model.fromMap(value)
            self.casterStreams = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeCasterStreamUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterStreamUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCasterStreamUrlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCasterVideoResourcesRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeCasterVideoResourcesResponseBody : Tea.TeaModel {
    public class VideoResources : Tea.TeaModel {
        public class VideoResource : Tea.TeaModel {
            public var beginOffset: Int32?

            public var endOffset: Int32?

            public var flvUrl: String?

            public var imageId: String?

            public var imageUrl: String?

            public var liveStreamUrl: String?

            public var locationId: String?

            public var materialId: String?

            public var ptsCallbackInterval: Int32?

            public var repeatNum: Int32?

            public var resourceId: String?

            public var resourceName: String?

            public var vodUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginOffset != nil {
                    map["BeginOffset"] = self.beginOffset!
                }
                if self.endOffset != nil {
                    map["EndOffset"] = self.endOffset!
                }
                if self.flvUrl != nil {
                    map["FlvUrl"] = self.flvUrl!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.liveStreamUrl != nil {
                    map["LiveStreamUrl"] = self.liveStreamUrl!
                }
                if self.locationId != nil {
                    map["LocationId"] = self.locationId!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                if self.ptsCallbackInterval != nil {
                    map["PtsCallbackInterval"] = self.ptsCallbackInterval!
                }
                if self.repeatNum != nil {
                    map["RepeatNum"] = self.repeatNum!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceName != nil {
                    map["ResourceName"] = self.resourceName!
                }
                if self.vodUrl != nil {
                    map["VodUrl"] = self.vodUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BeginOffset"] as? Int32 {
                    self.beginOffset = value
                }
                if let value = dict["EndOffset"] as? Int32 {
                    self.endOffset = value
                }
                if let value = dict["FlvUrl"] as? String {
                    self.flvUrl = value
                }
                if let value = dict["ImageId"] as? String {
                    self.imageId = value
                }
                if let value = dict["ImageUrl"] as? String {
                    self.imageUrl = value
                }
                if let value = dict["LiveStreamUrl"] as? String {
                    self.liveStreamUrl = value
                }
                if let value = dict["LocationId"] as? String {
                    self.locationId = value
                }
                if let value = dict["MaterialId"] as? String {
                    self.materialId = value
                }
                if let value = dict["PtsCallbackInterval"] as? Int32 {
                    self.ptsCallbackInterval = value
                }
                if let value = dict["RepeatNum"] as? Int32 {
                    self.repeatNum = value
                }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceName"] as? String {
                    self.resourceName = value
                }
                if let value = dict["VodUrl"] as? String {
                    self.vodUrl = value
                }
            }
        }
        public var videoResource: [DescribeCasterVideoResourcesResponseBody.VideoResources.VideoResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.videoResource != nil {
                var tmp : [Any] = []
                for k in self.videoResource! {
                    tmp.append(k.toMap())
                }
                map["VideoResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["VideoResource"] as? [Any?] {
                var tmp : [DescribeCasterVideoResourcesResponseBody.VideoResources.VideoResource] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCasterVideoResourcesResponseBody.VideoResources.VideoResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.videoResource = tmp
            }
        }
    }
    public var requestId: String?

    public var total: Int32?

    public var videoResources: DescribeCasterVideoResourcesResponseBody.VideoResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.videoResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.videoResources != nil {
            map["VideoResources"] = self.videoResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
        if let value = dict["VideoResources"] as? [String: Any?] {
            var model = DescribeCasterVideoResourcesResponseBody.VideoResources()
            model.fromMap(value)
            self.videoResources = model
        }
    }
}

public class DescribeCasterVideoResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCasterVideoResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCasterVideoResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCastersRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var casterId: String?

    public var casterName: String?

    public var chargeType: Int32?

    public var endTime: String?

    public var normType: String?

    public var orderByModifyAsc: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var startTime: String?

    public var status: Int32?

    public var tag: [DescribeCastersRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.normType != nil {
            map["NormType"] = self.normType!
        }
        if self.orderByModifyAsc != nil {
            map["OrderByModifyAsc"] = self.orderByModifyAsc!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["CasterName"] as? String {
            self.casterName = value
        }
        if let value = dict["ChargeType"] as? Int32 {
            self.chargeType = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["NormType"] as? String {
            self.normType = value
        }
        if let value = dict["OrderByModifyAsc"] as? String {
            self.orderByModifyAsc = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeCastersRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeCastersRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeCastersResponseBody : Tea.TeaModel {
    public class CasterList : Tea.TeaModel {
        public class Caster : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TagKey"] as? String {
                            self.tagKey = value
                        }
                        if let value = dict["TagValue"] as? String {
                            self.tagValue = value
                        }
                    }
                }
                public var tag: [DescribeCastersResponseBody.CasterList.Caster.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["tag"] as? [Any?] {
                        var tmp : [DescribeCastersResponseBody.CasterList.Caster.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeCastersResponseBody.CasterList.Caster.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public var casterId: String?

            public var casterName: String?

            public var casterTemplate: String?

            public var channelEnable: Int32?

            public var chargeType: String?

            public var clientTokenId: String?

            public var createTime: String?

            public var duration: String?

            public var expireTime: String?

            public var lastModified: String?

            public var normType: Int32?

            public var purchaseTime: String?

            public var resourceGroupId: String?

            public var startTime: String?

            public var status: Int32?

            public var tags: DescribeCastersResponseBody.CasterList.Caster.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.casterId != nil {
                    map["CasterId"] = self.casterId!
                }
                if self.casterName != nil {
                    map["CasterName"] = self.casterName!
                }
                if self.casterTemplate != nil {
                    map["CasterTemplate"] = self.casterTemplate!
                }
                if self.channelEnable != nil {
                    map["ChannelEnable"] = self.channelEnable!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.clientTokenId != nil {
                    map["ClientTokenId"] = self.clientTokenId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.lastModified != nil {
                    map["LastModified"] = self.lastModified!
                }
                if self.normType != nil {
                    map["NormType"] = self.normType!
                }
                if self.purchaseTime != nil {
                    map["PurchaseTime"] = self.purchaseTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CasterId"] as? String {
                    self.casterId = value
                }
                if let value = dict["CasterName"] as? String {
                    self.casterName = value
                }
                if let value = dict["CasterTemplate"] as? String {
                    self.casterTemplate = value
                }
                if let value = dict["ChannelEnable"] as? Int32 {
                    self.channelEnable = value
                }
                if let value = dict["ChargeType"] as? String {
                    self.chargeType = value
                }
                if let value = dict["ClientTokenId"] as? String {
                    self.clientTokenId = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Duration"] as? String {
                    self.duration = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["LastModified"] as? String {
                    self.lastModified = value
                }
                if let value = dict["NormType"] as? Int32 {
                    self.normType = value
                }
                if let value = dict["PurchaseTime"] as? String {
                    self.purchaseTime = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeCastersResponseBody.CasterList.Caster.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
            }
        }
        public var caster: [DescribeCastersResponseBody.CasterList.Caster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caster != nil {
                var tmp : [Any] = []
                for k in self.caster! {
                    tmp.append(k.toMap())
                }
                map["Caster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Caster"] as? [Any?] {
                var tmp : [DescribeCastersResponseBody.CasterList.Caster] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCastersResponseBody.CasterList.Caster()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.caster = tmp
            }
        }
    }
    public var casterList: DescribeCastersResponseBody.CasterList?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.casterList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterList != nil {
            map["CasterList"] = self.casterList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterList"] as? [String: Any?] {
            var model = DescribeCastersResponseBody.CasterList()
            model.fromMap(value)
            self.casterList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeCastersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCastersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCastersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeChannelParticipantsRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class DescribeChannelParticipantsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var times: Int64?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public var userList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.times != nil {
            map["Times"] = self.times!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        if self.userList != nil {
            map["UserList"] = self.userList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Times"] as? Int64 {
            self.times = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
        if let value = dict["UserList"] as? [String] {
            self.userList = value
        }
    }
}

public class DescribeChannelParticipantsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChannelParticipantsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeChannelParticipantsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeChannelUsersRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
    }
}

public class DescribeChannelUsersResponseBody : Tea.TeaModel {
    public var interactiveUserList: [String]?

    public var interactiveUserNumber: Int32?

    public var isChannelExists: Bool?

    public var liveUserList: [String]?

    public var liveUserNumber: Int32?

    public var requestId: String?

    public var timestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.interactiveUserList != nil {
            map["InteractiveUserList"] = self.interactiveUserList!
        }
        if self.interactiveUserNumber != nil {
            map["InteractiveUserNumber"] = self.interactiveUserNumber!
        }
        if self.isChannelExists != nil {
            map["IsChannelExists"] = self.isChannelExists!
        }
        if self.liveUserList != nil {
            map["LiveUserList"] = self.liveUserList!
        }
        if self.liveUserNumber != nil {
            map["LiveUserNumber"] = self.liveUserNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timestamp != nil {
            map["Timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InteractiveUserList"] as? [String] {
            self.interactiveUserList = value
        }
        if let value = dict["InteractiveUserNumber"] as? Int32 {
            self.interactiveUserNumber = value
        }
        if let value = dict["IsChannelExists"] as? Bool {
            self.isChannelExists = value
        }
        if let value = dict["LiveUserList"] as? [String] {
            self.liveUserList = value
        }
        if let value = dict["LiveUserNumber"] as? Int32 {
            self.liveUserNumber = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Timestamp"] as? Int64 {
            self.timestamp = value
        }
    }
}

public class DescribeChannelUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChannelUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeChannelUsersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainUsageDataRequest : Tea.TeaModel {
    public var area: String?

    public var dataProtocol: String?

    public var domainName: String?

    public var endTime: String?

    public var field: String?

    public var interval: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.dataProtocol != nil {
            map["DataProtocol"] = self.dataProtocol!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.field != nil {
            map["Field"] = self.field!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Area"] as? String {
            self.area = value
        }
        if let value = dict["DataProtocol"] as? String {
            self.dataProtocol = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Field"] as? String {
            self.field = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeDomainUsageDataResponseBody : Tea.TeaModel {
    public class UsageDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var dataModule: [DescribeDomainUsageDataResponseBody.UsageDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeDomainUsageDataResponseBody.UsageDataPerInterval.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDomainUsageDataResponseBody.UsageDataPerInterval.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var area: String?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var type: String?

    public var usageDataPerInterval: DescribeDomainUsageDataResponseBody.UsageDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.usageDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.usageDataPerInterval != nil {
            map["UsageDataPerInterval"] = self.usageDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Area"] as? String {
            self.area = value
        }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UsageDataPerInterval"] as? [String: Any?] {
            var model = DescribeDomainUsageDataResponseBody.UsageDataPerInterval()
            model.fromMap(value)
            self.usageDataPerInterval = model
        }
    }
}

public class DescribeDomainUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainUsageDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDomainWithIntegrityRequest : Tea.TeaModel {
    public var endTime: String?

    public var integrity: Double?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.integrity != nil {
            map["Integrity"] = self.integrity!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Integrity"] as? Double {
            self.integrity = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDomainWithIntegrityResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var columns: [String]?

        public var name: String?

        public var points: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columns != nil {
                map["Columns"] = self.columns!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.points != nil {
                map["Points"] = self.points!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Columns"] as? [String] {
                self.columns = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Points"] as? [String] {
                self.points = value
            }
        }
    }
    public var content: [DescribeDomainWithIntegrityResponseBody.Content]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["Content"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? [Any?] {
            var tmp : [DescribeDomainWithIntegrityResponseBody.Content] = []
            for v in value {
                if v != nil {
                    var model = DescribeDomainWithIntegrityResponseBody.Content()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.content = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDomainWithIntegrityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDomainWithIntegrityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDomainWithIntegrityResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeHlsLiveStreamRealTimeBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Time"] as? String {
            self.time = value
        }
    }
}

public class DescribeHlsLiveStreamRealTimeBpsDataResponseBody : Tea.TeaModel {
    public class UsageData : Tea.TeaModel {
        public class StreamInfos : Tea.TeaModel {
            public class Infos : Tea.TeaModel {
                public var downFlow: Double?

                public var online: Double?

                public var rate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.downFlow != nil {
                        map["DownFlow"] = self.downFlow!
                    }
                    if self.online != nil {
                        map["Online"] = self.online!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DownFlow"] as? Double {
                        self.downFlow = value
                    }
                    if let value = dict["Online"] as? Double {
                        self.online = value
                    }
                    if let value = dict["Rate"] as? String {
                        self.rate = value
                    }
                }
            }
            public var infos: [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos.Infos]?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.infos != nil {
                    var tmp : [Any] = []
                    for k in self.infos! {
                        tmp.append(k.toMap())
                    }
                    map["Infos"] = tmp
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Infos"] as? [Any?] {
                    var tmp : [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos.Infos] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos.Infos()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.infos = tmp
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
            }
        }
        public var domainName: String?

        public var streamInfos: [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.streamInfos != nil {
                var tmp : [Any] = []
                for k in self.streamInfos! {
                    tmp.append(k.toMap())
                }
                map["StreamInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["StreamInfos"] as? [Any?] {
                var tmp : [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos] = []
                for v in value {
                    if v != nil {
                        var model = DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData.StreamInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.streamInfos = tmp
            }
        }
    }
    public var requestId: String?

    public var time: String?

    public var usageData: [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.usageData != nil {
            var tmp : [Any] = []
            for k in self.usageData! {
                tmp.append(k.toMap())
            }
            map["UsageData"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Time"] as? String {
            self.time = value
        }
        if let value = dict["UsageData"] as? [Any?] {
            var tmp : [DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData] = []
            for v in value {
                if v != nil {
                    var model = DescribeHlsLiveStreamRealTimeBpsDataResponseBody.UsageData()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.usageData = tmp
        }
    }
}

public class DescribeHlsLiveStreamRealTimeBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHlsLiveStreamRealTimeBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeHlsLiveStreamRealTimeBpsDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveAIProduceRulesRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var rulesId: String?

    public var suffixName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rulesId != nil {
            map["RulesId"] = self.rulesId!
        }
        if self.suffixName != nil {
            map["SuffixName"] = self.suffixName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RulesId"] as? String {
            self.rulesId = value
        }
        if let value = dict["SuffixName"] as? String {
            self.suffixName = value
        }
    }
}

public class DescribeLiveAIProduceRulesResponseBody : Tea.TeaModel {
    public class RuleInfoList : Tea.TeaModel {
        public class RuleInfo : Tea.TeaModel {
            public var app: String?

            public var description_: String?

            public var domain: String?

            public var gmtModifyTime: String?

            public var isLazy: Bool?

            public var liveTemplate: String?

            public var rulesId: String?

            public var studioName: String?

            public var subtitleName: String?

            public var suffixName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.app != nil {
                    map["App"] = self.app!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.gmtModifyTime != nil {
                    map["GmtModifyTime"] = self.gmtModifyTime!
                }
                if self.isLazy != nil {
                    map["IsLazy"] = self.isLazy!
                }
                if self.liveTemplate != nil {
                    map["LiveTemplate"] = self.liveTemplate!
                }
                if self.rulesId != nil {
                    map["RulesId"] = self.rulesId!
                }
                if self.studioName != nil {
                    map["StudioName"] = self.studioName!
                }
                if self.subtitleName != nil {
                    map["SubtitleName"] = self.subtitleName!
                }
                if self.suffixName != nil {
                    map["SuffixName"] = self.suffixName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["App"] as? String {
                    self.app = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["GmtModifyTime"] as? String {
                    self.gmtModifyTime = value
                }
                if let value = dict["IsLazy"] as? Bool {
                    self.isLazy = value
                }
                if let value = dict["LiveTemplate"] as? String {
                    self.liveTemplate = value
                }
                if let value = dict["RulesId"] as? String {
                    self.rulesId = value
                }
                if let value = dict["StudioName"] as? String {
                    self.studioName = value
                }
                if let value = dict["SubtitleName"] as? String {
                    self.subtitleName = value
                }
                if let value = dict["SuffixName"] as? String {
                    self.suffixName = value
                }
            }
        }
        public var ruleInfo: [DescribeLiveAIProduceRulesResponseBody.RuleInfoList.RuleInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleInfo != nil {
                var tmp : [Any] = []
                for k in self.ruleInfo! {
                    tmp.append(k.toMap())
                }
                map["RuleInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RuleInfo"] as? [Any?] {
                var tmp : [DescribeLiveAIProduceRulesResponseBody.RuleInfoList.RuleInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveAIProduceRulesResponseBody.RuleInfoList.RuleInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ruleInfo = tmp
            }
        }
    }
    public var requestId: String?

    public var ruleInfoList: DescribeLiveAIProduceRulesResponseBody.RuleInfoList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ruleInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleInfoList != nil {
            map["RuleInfoList"] = self.ruleInfoList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RuleInfoList"] as? [String: Any?] {
            var model = DescribeLiveAIProduceRulesResponseBody.RuleInfoList()
            model.fromMap(value)
            self.ruleInfoList = model
        }
    }
}

public class DescribeLiveAIProduceRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveAIProduceRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveAIProduceRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveAIStudioRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var studioId: String?

    public var studioName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.studioId != nil {
            map["StudioId"] = self.studioId!
        }
        if self.studioName != nil {
            map["StudioName"] = self.studioName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StudioId"] as? String {
            self.studioId = value
        }
        if let value = dict["StudioName"] as? String {
            self.studioName = value
        }
    }
}

public class DescribeLiveAIStudioResponseBody : Tea.TeaModel {
    public class StudioConfigs : Tea.TeaModel {
        public class SubtitleConfig : Tea.TeaModel {
            public class RuleIds : Tea.TeaModel {
                public var ruleId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ruleId != nil {
                        map["ruleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ruleId"] as? [String] {
                        self.ruleId = value
                    }
                }
            }
            public var backgroundResourceId: String?

            public var backgroundResourceUrl: String?

            public var backgroundType: String?

            public var description_: String?

            public var height: String?

            public var mattingLayout: String?

            public var mattingType: String?

            public var mediaLayout: String?

            public var mediaResourceId: String?

            public var mediaResourceUrl: String?

            public var mediaType: String?

            public var ruleIds: DescribeLiveAIStudioResponseBody.StudioConfigs.SubtitleConfig.RuleIds?

            public var templateId: String?

            public var templateName: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ruleIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backgroundResourceId != nil {
                    map["BackgroundResourceId"] = self.backgroundResourceId!
                }
                if self.backgroundResourceUrl != nil {
                    map["BackgroundResourceUrl"] = self.backgroundResourceUrl!
                }
                if self.backgroundType != nil {
                    map["BackgroundType"] = self.backgroundType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mattingLayout != nil {
                    map["MattingLayout"] = self.mattingLayout!
                }
                if self.mattingType != nil {
                    map["MattingType"] = self.mattingType!
                }
                if self.mediaLayout != nil {
                    map["MediaLayout"] = self.mediaLayout!
                }
                if self.mediaResourceId != nil {
                    map["MediaResourceId"] = self.mediaResourceId!
                }
                if self.mediaResourceUrl != nil {
                    map["MediaResourceUrl"] = self.mediaResourceUrl!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.ruleIds != nil {
                    map["RuleIds"] = self.ruleIds?.toMap()
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BackgroundResourceId"] as? String {
                    self.backgroundResourceId = value
                }
                if let value = dict["BackgroundResourceUrl"] as? String {
                    self.backgroundResourceUrl = value
                }
                if let value = dict["BackgroundType"] as? String {
                    self.backgroundType = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Height"] as? String {
                    self.height = value
                }
                if let value = dict["MattingLayout"] as? String {
                    self.mattingLayout = value
                }
                if let value = dict["MattingType"] as? String {
                    self.mattingType = value
                }
                if let value = dict["MediaLayout"] as? String {
                    self.mediaLayout = value
                }
                if let value = dict["MediaResourceId"] as? String {
                    self.mediaResourceId = value
                }
                if let value = dict["MediaResourceUrl"] as? String {
                    self.mediaResourceUrl = value
                }
                if let value = dict["MediaType"] as? String {
                    self.mediaType = value
                }
                if let value = dict["RuleIds"] as? [String: Any?] {
                    var model = DescribeLiveAIStudioResponseBody.StudioConfigs.SubtitleConfig.RuleIds()
                    model.fromMap(value)
                    self.ruleIds = model
                }
                if let value = dict["TemplateId"] as? String {
                    self.templateId = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
                if let value = dict["Width"] as? String {
                    self.width = value
                }
            }
        }
        public var subtitleConfig: [DescribeLiveAIStudioResponseBody.StudioConfigs.SubtitleConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subtitleConfig != nil {
                var tmp : [Any] = []
                for k in self.subtitleConfig! {
                    tmp.append(k.toMap())
                }
                map["SubtitleConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SubtitleConfig"] as? [Any?] {
                var tmp : [DescribeLiveAIStudioResponseBody.StudioConfigs.SubtitleConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveAIStudioResponseBody.StudioConfigs.SubtitleConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.subtitleConfig = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var studioConfigs: DescribeLiveAIStudioResponseBody.StudioConfigs?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.studioConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.studioConfigs != nil {
            map["StudioConfigs"] = self.studioConfigs?.toMap()
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StudioConfigs"] as? [String: Any?] {
            var model = DescribeLiveAIStudioResponseBody.StudioConfigs()
            model.fromMap(value)
            self.studioConfigs = model
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeLiveAIStudioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveAIStudioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveAIStudioResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveAISubtitleRequest : Tea.TeaModel {
    public var isDefault: Bool?

    public var ownerId: Int64?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var subtitleId: String?

    public var subtitleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.subtitleId != nil {
            map["SubtitleId"] = self.subtitleId!
        }
        if self.subtitleName != nil {
            map["SubtitleName"] = self.subtitleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IsDefault"] as? Bool {
            self.isDefault = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SubtitleId"] as? String {
            self.subtitleId = value
        }
        if let value = dict["SubtitleName"] as? String {
            self.subtitleName = value
        }
    }
}

public class DescribeLiveAISubtitleResponseBody : Tea.TeaModel {
    public class SubtitleConfigs : Tea.TeaModel {
        public class SubtitleConfig : Tea.TeaModel {
            public class PositionNormalized : Tea.TeaModel {
                public var position: [Double]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.position != nil {
                        map["Position"] = self.position!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Position"] as? [Double] {
                        self.position = value
                    }
                }
            }
            public class RulesRefer : Tea.TeaModel {
                public var rulesId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.rulesId != nil {
                        map["RulesId"] = self.rulesId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RulesId"] as? [String] {
                        self.rulesId = value
                    }
                }
            }
            public var bgColor: String?

            public var bgWidthNormalized: Double?

            public var borderWidthNormalized: Double?

            public var description_: String?

            public var dstLanguage: String?

            public var fontColor: String?

            public var fontName: String?

            public var fontSizeNormalized: String?

            public var height: String?

            public var maxLines: Int32?

            public var positionNormalized: DescribeLiveAISubtitleResponseBody.SubtitleConfigs.SubtitleConfig.PositionNormalized?

            public var rulesRefer: DescribeLiveAISubtitleResponseBody.SubtitleConfigs.SubtitleConfig.RulesRefer?

            public var showSourceLan: Int32?

            public var srcLanguage: String?

            public var subtitleId: String?

            public var subtitleName: String?

            public var width: String?

            public var wordPerline: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.positionNormalized?.validate()
                try self.rulesRefer?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bgColor != nil {
                    map["BgColor"] = self.bgColor!
                }
                if self.bgWidthNormalized != nil {
                    map["BgWidthNormalized"] = self.bgWidthNormalized!
                }
                if self.borderWidthNormalized != nil {
                    map["BorderWidthNormalized"] = self.borderWidthNormalized!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dstLanguage != nil {
                    map["DstLanguage"] = self.dstLanguage!
                }
                if self.fontColor != nil {
                    map["FontColor"] = self.fontColor!
                }
                if self.fontName != nil {
                    map["FontName"] = self.fontName!
                }
                if self.fontSizeNormalized != nil {
                    map["FontSizeNormalized"] = self.fontSizeNormalized!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.maxLines != nil {
                    map["MaxLines"] = self.maxLines!
                }
                if self.positionNormalized != nil {
                    map["PositionNormalized"] = self.positionNormalized?.toMap()
                }
                if self.rulesRefer != nil {
                    map["RulesRefer"] = self.rulesRefer?.toMap()
                }
                if self.showSourceLan != nil {
                    map["ShowSourceLan"] = self.showSourceLan!
                }
                if self.srcLanguage != nil {
                    map["SrcLanguage"] = self.srcLanguage!
                }
                if self.subtitleId != nil {
                    map["SubtitleId"] = self.subtitleId!
                }
                if self.subtitleName != nil {
                    map["SubtitleName"] = self.subtitleName!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                if self.wordPerline != nil {
                    map["WordPerline"] = self.wordPerline!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BgColor"] as? String {
                    self.bgColor = value
                }
                if let value = dict["BgWidthNormalized"] as? Double {
                    self.bgWidthNormalized = value
                }
                if let value = dict["BorderWidthNormalized"] as? Double {
                    self.borderWidthNormalized = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DstLanguage"] as? String {
                    self.dstLanguage = value
                }
                if let value = dict["FontColor"] as? String {
                    self.fontColor = value
                }
                if let value = dict["FontName"] as? String {
                    self.fontName = value
                }
                if let value = dict["FontSizeNormalized"] as? String {
                    self.fontSizeNormalized = value
                }
                if let value = dict["Height"] as? String {
                    self.height = value
                }
                if let value = dict["MaxLines"] as? Int32 {
                    self.maxLines = value
                }
                if let value = dict["PositionNormalized"] as? [String: Any?] {
                    var model = DescribeLiveAISubtitleResponseBody.SubtitleConfigs.SubtitleConfig.PositionNormalized()
                    model.fromMap(value)
                    self.positionNormalized = model
                }
                if let value = dict["RulesRefer"] as? [String: Any?] {
                    var model = DescribeLiveAISubtitleResponseBody.SubtitleConfigs.SubtitleConfig.RulesRefer()
                    model.fromMap(value)
                    self.rulesRefer = model
                }
                if let value = dict["ShowSourceLan"] as? Int32 {
                    self.showSourceLan = value
                }
                if let value = dict["SrcLanguage"] as? String {
                    self.srcLanguage = value
                }
                if let value = dict["SubtitleId"] as? String {
                    self.subtitleId = value
                }
                if let value = dict["SubtitleName"] as? String {
                    self.subtitleName = value
                }
                if let value = dict["Width"] as? String {
                    self.width = value
                }
                if let value = dict["WordPerline"] as? Int32 {
                    self.wordPerline = value
                }
            }
        }
        public var subtitleConfig: [DescribeLiveAISubtitleResponseBody.SubtitleConfigs.SubtitleConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subtitleConfig != nil {
                var tmp : [Any] = []
                for k in self.subtitleConfig! {
                    tmp.append(k.toMap())
                }
                map["SubtitleConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SubtitleConfig"] as? [Any?] {
                var tmp : [DescribeLiveAISubtitleResponseBody.SubtitleConfigs.SubtitleConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveAISubtitleResponseBody.SubtitleConfigs.SubtitleConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.subtitleConfig = tmp
            }
        }
    }
    public var requestId: String?

    public var subtitleConfigs: DescribeLiveAISubtitleResponseBody.SubtitleConfigs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subtitleConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subtitleConfigs != nil {
            map["SubtitleConfigs"] = self.subtitleConfigs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SubtitleConfigs"] as? [String: Any?] {
            var model = DescribeLiveAISubtitleResponseBody.SubtitleConfigs()
            model.fromMap(value)
            self.subtitleConfigs = model
        }
    }
}

public class DescribeLiveAISubtitleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveAISubtitleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveAISubtitleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveAudioAuditConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveAudioAuditConfigResponseBody : Tea.TeaModel {
    public class LiveAudioAuditConfigList : Tea.TeaModel {
        public class LiveAudioAuditConfig : Tea.TeaModel {
            public class Scenes : Tea.TeaModel {
                public var scene: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.scene != nil {
                        map["scene"] = self.scene!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["scene"] as? [String] {
                        self.scene = value
                    }
                }
            }
            public var appName: String?

            public var bizType: String?

            public var domainName: String?

            public var scenes: DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList.LiveAudioAuditConfig.Scenes?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scenes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.scenes != nil {
                    map["Scenes"] = self.scenes?.toMap()
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["BizType"] as? String {
                    self.bizType = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Scenes"] as? [String: Any?] {
                    var model = DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList.LiveAudioAuditConfig.Scenes()
                    model.fromMap(value)
                    self.scenes = model
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
            }
        }
        public var liveAudioAuditConfig: [DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList.LiveAudioAuditConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveAudioAuditConfig != nil {
                var tmp : [Any] = []
                for k in self.liveAudioAuditConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveAudioAuditConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveAudioAuditConfig"] as? [Any?] {
                var tmp : [DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList.LiveAudioAuditConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList.LiveAudioAuditConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveAudioAuditConfig = tmp
            }
        }
    }
    public var liveAudioAuditConfigList: DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveAudioAuditConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveAudioAuditConfigList != nil {
            map["LiveAudioAuditConfigList"] = self.liveAudioAuditConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveAudioAuditConfigList"] as? [String: Any?] {
            var model = DescribeLiveAudioAuditConfigResponseBody.LiveAudioAuditConfigList()
            model.fromMap(value)
            self.liveAudioAuditConfigList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveAudioAuditConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveAudioAuditConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveAudioAuditConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveAudioAuditNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveAudioAuditNotifyConfigResponseBody : Tea.TeaModel {
    public class LiveAudioAuditNotifyConfigList : Tea.TeaModel {
        public class LiveAudioAuditNotifyConfig : Tea.TeaModel {
            public var callback: String?

            public var callbackTemplate: String?

            public var domainName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callback != nil {
                    map["Callback"] = self.callback!
                }
                if self.callbackTemplate != nil {
                    map["CallbackTemplate"] = self.callbackTemplate!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Callback"] as? String {
                    self.callback = value
                }
                if let value = dict["CallbackTemplate"] as? String {
                    self.callbackTemplate = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
            }
        }
        public var liveAudioAuditNotifyConfig: [DescribeLiveAudioAuditNotifyConfigResponseBody.LiveAudioAuditNotifyConfigList.LiveAudioAuditNotifyConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveAudioAuditNotifyConfig != nil {
                var tmp : [Any] = []
                for k in self.liveAudioAuditNotifyConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveAudioAuditNotifyConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveAudioAuditNotifyConfig"] as? [Any?] {
                var tmp : [DescribeLiveAudioAuditNotifyConfigResponseBody.LiveAudioAuditNotifyConfigList.LiveAudioAuditNotifyConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveAudioAuditNotifyConfigResponseBody.LiveAudioAuditNotifyConfigList.LiveAudioAuditNotifyConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveAudioAuditNotifyConfig = tmp
            }
        }
    }
    public var liveAudioAuditNotifyConfigList: DescribeLiveAudioAuditNotifyConfigResponseBody.LiveAudioAuditNotifyConfigList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveAudioAuditNotifyConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveAudioAuditNotifyConfigList != nil {
            map["LiveAudioAuditNotifyConfigList"] = self.liveAudioAuditNotifyConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveAudioAuditNotifyConfigList"] as? [String: Any?] {
            var model = DescribeLiveAudioAuditNotifyConfigResponseBody.LiveAudioAuditNotifyConfigList()
            model.fromMap(value)
            self.liveAudioAuditNotifyConfigList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveAudioAuditNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveAudioAuditNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveAudioAuditNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveCdnDiagnoseInfoRequest : Tea.TeaModel {
    public var securityToken: String?

    public var app: String?

    public var domain: String?

    public var endTime: Int64?

    public var intervalType: String?

    public var phase: Int32?

    public var requestType: String?

    public var startTime: Int64?

    public var streamName: String?

    public var streamSuffix: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.app != nil {
            map["app"] = self.app!
        }
        if self.domain != nil {
            map["domain"] = self.domain!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.intervalType != nil {
            map["intervalType"] = self.intervalType!
        }
        if self.phase != nil {
            map["phase"] = self.phase!
        }
        if self.requestType != nil {
            map["requestType"] = self.requestType!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["streamName"] = self.streamName!
        }
        if self.streamSuffix != nil {
            map["streamSuffix"] = self.streamSuffix!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["app"] as? String {
            self.app = value
        }
        if let value = dict["domain"] as? String {
            self.domain = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["intervalType"] as? String {
            self.intervalType = value
        }
        if let value = dict["phase"] as? Int32 {
            self.phase = value
        }
        if let value = dict["requestType"] as? String {
            self.requestType = value
        }
        if let value = dict["startTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["streamName"] as? String {
            self.streamName = value
        }
        if let value = dict["streamSuffix"] as? String {
            self.streamSuffix = value
        }
    }
}

public class DescribeLiveCdnDiagnoseInfoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveCdnDiagnoseInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveCdnDiagnoseInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveCdnDiagnoseInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveCenterStreamRateDataRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveCenterStreamRateDataResponseBody : Tea.TeaModel {
    public class RateDatas : Tea.TeaModel {
        public var audioFps: String?

        public var audioRate: String?

        public var time: String?

        public var videoFps: String?

        public var videoRate: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioFps != nil {
                map["AudioFps"] = self.audioFps!
            }
            if self.audioRate != nil {
                map["AudioRate"] = self.audioRate!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.videoFps != nil {
                map["VideoFps"] = self.videoFps!
            }
            if self.videoRate != nil {
                map["VideoRate"] = self.videoRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AudioFps"] as? String {
                self.audioFps = value
            }
            if let value = dict["AudioRate"] as? String {
                self.audioRate = value
            }
            if let value = dict["Time"] as? String {
                self.time = value
            }
            if let value = dict["VideoFps"] as? String {
                self.videoFps = value
            }
            if let value = dict["VideoRate"] as? String {
                self.videoRate = value
            }
        }
    }
    public var rateDatas: [DescribeLiveCenterStreamRateDataResponseBody.RateDatas]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.rateDatas != nil {
            var tmp : [Any] = []
            for k in self.rateDatas! {
                tmp.append(k.toMap())
            }
            map["RateDatas"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RateDatas"] as? [Any?] {
            var tmp : [DescribeLiveCenterStreamRateDataResponseBody.RateDatas] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveCenterStreamRateDataResponseBody.RateDatas()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.rateDatas = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveCenterStreamRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveCenterStreamRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveCenterStreamRateDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveCenterTransferRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var dstUrl: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.dstUrl != nil {
            map["DstUrl"] = self.dstUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DstUrl"] as? String {
            self.dstUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveCenterTransferResponseBody : Tea.TeaModel {
    public class LiveCenterTransferInfoList : Tea.TeaModel {
        public class LiveCenterTransferInfo : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var dstUrl: String?

            public var endTime: String?

            public var startTime: String?

            public var streamName: String?

            public var transferArgs: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.dstUrl != nil {
                    map["DstUrl"] = self.dstUrl!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.transferArgs != nil {
                    map["TransferArgs"] = self.transferArgs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["DstUrl"] as? String {
                    self.dstUrl = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["TransferArgs"] as? String {
                    self.transferArgs = value
                }
            }
        }
        public var liveCenterTransferInfo: [DescribeLiveCenterTransferResponseBody.LiveCenterTransferInfoList.LiveCenterTransferInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveCenterTransferInfo != nil {
                var tmp : [Any] = []
                for k in self.liveCenterTransferInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveCenterTransferInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveCenterTransferInfo"] as? [Any?] {
                var tmp : [DescribeLiveCenterTransferResponseBody.LiveCenterTransferInfoList.LiveCenterTransferInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveCenterTransferResponseBody.LiveCenterTransferInfoList.LiveCenterTransferInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveCenterTransferInfo = tmp
            }
        }
    }
    public var liveCenterTransferInfoList: DescribeLiveCenterTransferResponseBody.LiveCenterTransferInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveCenterTransferInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveCenterTransferInfoList != nil {
            map["LiveCenterTransferInfoList"] = self.liveCenterTransferInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveCenterTransferInfoList"] as? [String: Any?] {
            var model = DescribeLiveCenterTransferResponseBody.LiveCenterTransferInfoList()
            model.fromMap(value)
            self.liveCenterTransferInfoList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveCenterTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveCenterTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveCenterTransferResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveCertificateDetailRequest : Tea.TeaModel {
    public var certName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertName"] as? String {
            self.certName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeLiveCertificateDetailResponseBody : Tea.TeaModel {
    public var cert: String?

    public var certId: Int64?

    public var certName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cert != nil {
            map["Cert"] = self.cert!
        }
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cert"] as? String {
            self.cert = value
        }
        if let value = dict["CertId"] as? Int64 {
            self.certId = value
        }
        if let value = dict["CertName"] as? String {
            self.certName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveCertificateDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveCertificateDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveCertificateDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveCertificateListRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeLiveCertificateListResponseBody : Tea.TeaModel {
    public class CertificateListModel : Tea.TeaModel {
        public class CertList : Tea.TeaModel {
            public class Cert : Tea.TeaModel {
                public var certId: Int64?

                public var certName: String?

                public var common: String?

                public var fingerprint: String?

                public var issuer: String?

                public var lastTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.certId != nil {
                        map["CertId"] = self.certId!
                    }
                    if self.certName != nil {
                        map["CertName"] = self.certName!
                    }
                    if self.common != nil {
                        map["Common"] = self.common!
                    }
                    if self.fingerprint != nil {
                        map["Fingerprint"] = self.fingerprint!
                    }
                    if self.issuer != nil {
                        map["Issuer"] = self.issuer!
                    }
                    if self.lastTime != nil {
                        map["LastTime"] = self.lastTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CertId"] as? Int64 {
                        self.certId = value
                    }
                    if let value = dict["CertName"] as? String {
                        self.certName = value
                    }
                    if let value = dict["Common"] as? String {
                        self.common = value
                    }
                    if let value = dict["Fingerprint"] as? String {
                        self.fingerprint = value
                    }
                    if let value = dict["Issuer"] as? String {
                        self.issuer = value
                    }
                    if let value = dict["LastTime"] as? Int64 {
                        self.lastTime = value
                    }
                }
            }
            public var cert: [DescribeLiveCertificateListResponseBody.CertificateListModel.CertList.Cert]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cert != nil {
                    var tmp : [Any] = []
                    for k in self.cert! {
                        tmp.append(k.toMap())
                    }
                    map["Cert"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cert"] as? [Any?] {
                    var tmp : [DescribeLiveCertificateListResponseBody.CertificateListModel.CertList.Cert] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeLiveCertificateListResponseBody.CertificateListModel.CertList.Cert()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.cert = tmp
                }
            }
        }
        public var certList: DescribeLiveCertificateListResponseBody.CertificateListModel.CertList?

        public var count: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.certList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certList != nil {
                map["CertList"] = self.certList?.toMap()
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CertList"] as? [String: Any?] {
                var model = DescribeLiveCertificateListResponseBody.CertificateListModel.CertList()
                model.fromMap(value)
                self.certList = model
            }
            if let value = dict["Count"] as? Int32 {
                self.count = value
            }
        }
    }
    public var certificateListModel: DescribeLiveCertificateListResponseBody.CertificateListModel?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certificateListModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificateListModel != nil {
            map["CertificateListModel"] = self.certificateListModel?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertificateListModel"] as? [String: Any?] {
            var model = DescribeLiveCertificateListResponseBody.CertificateListModel()
            model.fromMap(value)
            self.certificateListModel = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveCertificateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveCertificateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveCertificateListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDelayConfigRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
    }
}

public class DescribeLiveDelayConfigResponseBody : Tea.TeaModel {
    public var app: String?

    public var delayTime: String?

    public var domain: String?

    public var requestId: String?

    public var stream: String?

    public var taskTriggerMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.delayTime != nil {
            map["DelayTime"] = self.delayTime!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        if self.taskTriggerMode != nil {
            map["TaskTriggerMode"] = self.taskTriggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["DelayTime"] as? String {
            self.delayTime = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
        if let value = dict["TaskTriggerMode"] as? String {
            self.taskTriggerMode = value
        }
    }
}

public class DescribeLiveDelayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDelayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDelayConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDelayedStreamingUsageRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var splitBy: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SplitBy"] as? String {
            self.splitBy = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveDelayedStreamingUsageResponseBody : Tea.TeaModel {
    public class DelayData : Tea.TeaModel {
        public class DelayDataItem : Tea.TeaModel {
            public var domainName: String?

            public var duration: Int64?

            public var region: String?

            public var streamName: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Duration"] as? Int64 {
                    self.duration = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var delayDataItem: [DescribeLiveDelayedStreamingUsageResponseBody.DelayData.DelayDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delayDataItem != nil {
                var tmp : [Any] = []
                for k in self.delayDataItem! {
                    tmp.append(k.toMap())
                }
                map["DelayDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DelayDataItem"] as? [Any?] {
                var tmp : [DescribeLiveDelayedStreamingUsageResponseBody.DelayData.DelayDataItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDelayedStreamingUsageResponseBody.DelayData.DelayDataItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.delayDataItem = tmp
            }
        }
    }
    public var delayData: DescribeLiveDelayedStreamingUsageResponseBody.DelayData?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.delayData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.delayData != nil {
            map["DelayData"] = self.delayData?.toMap()
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DelayData"] as? [String: Any?] {
            var model = DescribeLiveDelayedStreamingUsageResponseBody.DelayData()
            model.fromMap(value)
            self.delayData = model
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDelayedStreamingUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDelayedStreamingUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDelayedStreamingUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDetectNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeLiveDetectNotifyConfigResponseBody : Tea.TeaModel {
    public class LiveDetectNotifyConfig : Tea.TeaModel {
        public var domainName: String?

        public var notifyUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["NotifyUrl"] as? String {
                self.notifyUrl = value
            }
        }
    }
    public var liveDetectNotifyConfig: DescribeLiveDetectNotifyConfigResponseBody.LiveDetectNotifyConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveDetectNotifyConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveDetectNotifyConfig != nil {
            map["LiveDetectNotifyConfig"] = self.liveDetectNotifyConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveDetectNotifyConfig"] as? [String: Any?] {
            var model = DescribeLiveDetectNotifyConfigResponseBody.LiveDetectNotifyConfig()
            model.fromMap(value)
            self.liveDetectNotifyConfig = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDetectNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDetectNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDetectNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDetectPornDataRequest : Tea.TeaModel {
    public var app: String?

    public var domainName: String?

    public var endTime: String?

    public var fee: String?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var scene: String?

    public var splitBy: String?

    public var startTime: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.fee != nil {
            map["Fee"] = self.fee!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Fee"] as? String {
            self.fee = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Scene"] as? String {
            self.scene = value
        }
        if let value = dict["SplitBy"] as? String {
            self.splitBy = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
    }
}

public class DescribeLiveDetectPornDataResponseBody : Tea.TeaModel {
    public class DetectPornData : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var app: String?

            public var count: Int64?

            public var domain: String?

            public var fee: String?

            public var region: String?

            public var scene: String?

            public var stream: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.app != nil {
                    map["App"] = self.app!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.fee != nil {
                    map["Fee"] = self.fee!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.stream != nil {
                    map["Stream"] = self.stream!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["App"] as? String {
                    self.app = value
                }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["Fee"] as? String {
                    self.fee = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["Scene"] as? String {
                    self.scene = value
                }
                if let value = dict["Stream"] as? String {
                    self.stream = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var dataModule: [DescribeLiveDetectPornDataResponseBody.DetectPornData.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDetectPornDataResponseBody.DetectPornData.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDetectPornDataResponseBody.DetectPornData.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var detectPornData: DescribeLiveDetectPornDataResponseBody.DetectPornData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detectPornData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detectPornData != nil {
            map["DetectPornData"] = self.detectPornData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DetectPornData"] as? [String: Any?] {
            var model = DescribeLiveDetectPornDataResponseBody.DetectPornData()
            model.fromMap(value)
            self.detectPornData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDetectPornDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDetectPornDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDetectPornDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["IspNameEn"] as? String {
            self.ispNameEn = value
        }
        if let value = dict["LocationNameEn"] as? String {
            self.locationNameEn = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainBpsDataResponseBody : Tea.TeaModel {
    public class BpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var bpsValue: String?

            public var httpBpsValue: String?

            public var httpsBpsValue: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bpsValue != nil {
                    map["BpsValue"] = self.bpsValue!
                }
                if self.httpBpsValue != nil {
                    map["HttpBpsValue"] = self.httpBpsValue!
                }
                if self.httpsBpsValue != nil {
                    map["HttpsBpsValue"] = self.httpsBpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BpsValue"] as? String {
                    self.bpsValue = value
                }
                if let value = dict["HttpBpsValue"] as? String {
                    self.httpBpsValue = value
                }
                if let value = dict["HttpsBpsValue"] as? String {
                    self.httpsBpsValue = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var dataModule: [DescribeLiveDomainBpsDataResponseBody.BpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDomainBpsDataResponseBody.BpsDataPerInterval.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainBpsDataResponseBody.BpsDataPerInterval.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var bpsDataPerInterval: DescribeLiveDomainBpsDataResponseBody.BpsDataPerInterval?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataPerInterval != nil {
            map["BpsDataPerInterval"] = self.bpsDataPerInterval?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BpsDataPerInterval"] as? [String: Any?] {
            var model = DescribeLiveDomainBpsDataResponseBody.BpsDataPerInterval()
            model.fromMap(value)
            self.bpsDataPerInterval = model
        }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainBpsDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainBpsDataByLayerRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var layer: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.layer != nil {
            map["Layer"] = self.layer!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["IspNameEn"] as? String {
            self.ispNameEn = value
        }
        if let value = dict["Layer"] as? String {
            self.layer = value
        }
        if let value = dict["LocationNameEn"] as? String {
            self.locationNameEn = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainBpsDataByLayerResponseBody : Tea.TeaModel {
    public class BpsDataInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var trafficValue: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.trafficValue != nil {
                    map["TrafficValue"] = self.trafficValue!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["TrafficValue"] as? String {
                    self.trafficValue = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var dataModule: [DescribeLiveDomainBpsDataByLayerResponseBody.BpsDataInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDomainBpsDataByLayerResponseBody.BpsDataInterval.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainBpsDataByLayerResponseBody.BpsDataInterval.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var bpsDataInterval: DescribeLiveDomainBpsDataByLayerResponseBody.BpsDataInterval?

    public var dataInterval: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataInterval != nil {
            map["BpsDataInterval"] = self.bpsDataInterval?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BpsDataInterval"] as? [String: Any?] {
            var model = DescribeLiveDomainBpsDataByLayerResponseBody.BpsDataInterval()
            model.fromMap(value)
            self.bpsDataInterval = model
        }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainBpsDataByLayerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainBpsDataByLayerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainBpsDataByLayerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainByCertificateRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var SSLPub: String?

    public var SSLStatus: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.SSLPub != nil {
            map["SSLPub"] = self.SSLPub!
        }
        if self.SSLStatus != nil {
            map["SSLStatus"] = self.SSLStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SSLPub"] as? String {
            self.SSLPub = value
        }
        if let value = dict["SSLStatus"] as? Bool {
            self.SSLStatus = value
        }
    }
}

public class DescribeLiveDomainByCertificateResponseBody : Tea.TeaModel {
    public class CertInfos : Tea.TeaModel {
        public class CertInfo : Tea.TeaModel {
            public var certCaIsLegacy: String?

            public var certExpireTime: String?

            public var certExpired: String?

            public var certStartTime: String?

            public var certSubjectCommonName: String?

            public var certType: String?

            public var domainList: String?

            public var domainNames: String?

            public var issuer: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certCaIsLegacy != nil {
                    map["CertCaIsLegacy"] = self.certCaIsLegacy!
                }
                if self.certExpireTime != nil {
                    map["CertExpireTime"] = self.certExpireTime!
                }
                if self.certExpired != nil {
                    map["CertExpired"] = self.certExpired!
                }
                if self.certStartTime != nil {
                    map["CertStartTime"] = self.certStartTime!
                }
                if self.certSubjectCommonName != nil {
                    map["CertSubjectCommonName"] = self.certSubjectCommonName!
                }
                if self.certType != nil {
                    map["CertType"] = self.certType!
                }
                if self.domainList != nil {
                    map["DomainList"] = self.domainList!
                }
                if self.domainNames != nil {
                    map["DomainNames"] = self.domainNames!
                }
                if self.issuer != nil {
                    map["Issuer"] = self.issuer!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CertCaIsLegacy"] as? String {
                    self.certCaIsLegacy = value
                }
                if let value = dict["CertExpireTime"] as? String {
                    self.certExpireTime = value
                }
                if let value = dict["CertExpired"] as? String {
                    self.certExpired = value
                }
                if let value = dict["CertStartTime"] as? String {
                    self.certStartTime = value
                }
                if let value = dict["CertSubjectCommonName"] as? String {
                    self.certSubjectCommonName = value
                }
                if let value = dict["CertType"] as? String {
                    self.certType = value
                }
                if let value = dict["DomainList"] as? String {
                    self.domainList = value
                }
                if let value = dict["DomainNames"] as? String {
                    self.domainNames = value
                }
                if let value = dict["Issuer"] as? String {
                    self.issuer = value
                }
            }
        }
        public var certInfo: [DescribeLiveDomainByCertificateResponseBody.CertInfos.CertInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certInfo != nil {
                var tmp : [Any] = []
                for k in self.certInfo! {
                    tmp.append(k.toMap())
                }
                map["CertInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CertInfo"] as? [Any?] {
                var tmp : [DescribeLiveDomainByCertificateResponseBody.CertInfos.CertInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainByCertificateResponseBody.CertInfos.CertInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.certInfo = tmp
            }
        }
    }
    public var certInfos: DescribeLiveDomainByCertificateResponseBody.CertInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certInfos != nil {
            map["CertInfos"] = self.certInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertInfos"] as? [String: Any?] {
            var model = DescribeLiveDomainByCertificateResponseBody.CertInfos()
            model.fromMap(value)
            self.certInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainByCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainByCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainByCertificateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainCertificateInfoRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveDomainCertificateInfoResponseBody : Tea.TeaModel {
    public class CertInfos : Tea.TeaModel {
        public class CertInfo : Tea.TeaModel {
            public var certDomainName: String?

            public var certExpireTime: String?

            public var certLife: String?

            public var certName: String?

            public var certOrg: String?

            public var certType: String?

            public var domainName: String?

            public var SSLProtocol: String?

            public var SSLPub: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certDomainName != nil {
                    map["CertDomainName"] = self.certDomainName!
                }
                if self.certExpireTime != nil {
                    map["CertExpireTime"] = self.certExpireTime!
                }
                if self.certLife != nil {
                    map["CertLife"] = self.certLife!
                }
                if self.certName != nil {
                    map["CertName"] = self.certName!
                }
                if self.certOrg != nil {
                    map["CertOrg"] = self.certOrg!
                }
                if self.certType != nil {
                    map["CertType"] = self.certType!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.SSLProtocol != nil {
                    map["SSLProtocol"] = self.SSLProtocol!
                }
                if self.SSLPub != nil {
                    map["SSLPub"] = self.SSLPub!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CertDomainName"] as? String {
                    self.certDomainName = value
                }
                if let value = dict["CertExpireTime"] as? String {
                    self.certExpireTime = value
                }
                if let value = dict["CertLife"] as? String {
                    self.certLife = value
                }
                if let value = dict["CertName"] as? String {
                    self.certName = value
                }
                if let value = dict["CertOrg"] as? String {
                    self.certOrg = value
                }
                if let value = dict["CertType"] as? String {
                    self.certType = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["SSLProtocol"] as? String {
                    self.SSLProtocol = value
                }
                if let value = dict["SSLPub"] as? String {
                    self.SSLPub = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var certInfo: [DescribeLiveDomainCertificateInfoResponseBody.CertInfos.CertInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certInfo != nil {
                var tmp : [Any] = []
                for k in self.certInfo! {
                    tmp.append(k.toMap())
                }
                map["CertInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CertInfo"] as? [Any?] {
                var tmp : [DescribeLiveDomainCertificateInfoResponseBody.CertInfos.CertInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainCertificateInfoResponseBody.CertInfos.CertInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.certInfo = tmp
            }
        }
    }
    public var certInfos: DescribeLiveDomainCertificateInfoResponseBody.CertInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certInfos != nil {
            map["CertInfos"] = self.certInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertInfos"] as? [String: Any?] {
            var model = DescribeLiveDomainCertificateInfoResponseBody.CertInfos()
            model.fromMap(value)
            self.certInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainCertificateInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainCertificateInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainCertificateInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainConfigsRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionNames: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionNames != nil {
            map["FunctionNames"] = self.functionNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["FunctionNames"] as? String {
            self.functionNames = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeLiveDomainConfigsResponseBody : Tea.TeaModel {
    public class DomainConfigs : Tea.TeaModel {
        public class DomainConfig : Tea.TeaModel {
            public class FunctionArgs : Tea.TeaModel {
                public class FunctionArg : Tea.TeaModel {
                    public var argName: String?

                    public var argValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.argName != nil {
                            map["ArgName"] = self.argName!
                        }
                        if self.argValue != nil {
                            map["ArgValue"] = self.argValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ArgName"] as? String {
                            self.argName = value
                        }
                        if let value = dict["ArgValue"] as? String {
                            self.argValue = value
                        }
                    }
                }
                public var functionArg: [DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.functionArg != nil {
                        var tmp : [Any] = []
                        for k in self.functionArg! {
                            tmp.append(k.toMap())
                        }
                        map["FunctionArg"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FunctionArg"] as? [Any?] {
                        var tmp : [DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs.FunctionArg()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.functionArg = tmp
                    }
                }
            }
            public var configId: String?

            public var functionArgs: DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs?

            public var functionName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.functionArgs?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configId != nil {
                    map["ConfigId"] = self.configId!
                }
                if self.functionArgs != nil {
                    map["FunctionArgs"] = self.functionArgs?.toMap()
                }
                if self.functionName != nil {
                    map["FunctionName"] = self.functionName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigId"] as? String {
                    self.configId = value
                }
                if let value = dict["FunctionArgs"] as? [String: Any?] {
                    var model = DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig.FunctionArgs()
                    model.fromMap(value)
                    self.functionArgs = model
                }
                if let value = dict["FunctionName"] as? String {
                    self.functionName = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var domainConfig: [DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainConfig != nil {
                var tmp : [Any] = []
                for k in self.domainConfig! {
                    tmp.append(k.toMap())
                }
                map["DomainConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainConfig"] as? [Any?] {
                var tmp : [DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainConfigsResponseBody.DomainConfigs.DomainConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainConfig = tmp
            }
        }
    }
    public var domainConfigs: DescribeLiveDomainConfigsResponseBody.DomainConfigs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainConfigs != nil {
            map["DomainConfigs"] = self.domainConfigs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainConfigs"] as? [String: Any?] {
            var model = DescribeLiveDomainConfigsResponseBody.DomainConfigs()
            model.fromMap(value)
            self.domainConfigs = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainDetailRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeLiveDomainDetailResponseBody : Tea.TeaModel {
    public class DomainDetail : Tea.TeaModel {
        public var certName: String?

        public var cname: String?

        public var description_: String?

        public var domainName: String?

        public var domainStatus: String?

        public var gmtCreated: String?

        public var gmtModified: String?

        public var liveDomainType: String?

        public var region: String?

        public var resourceGroupId: String?

        public var SSLProtocol: String?

        public var SSLPub: String?

        public var scope: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certName != nil {
                map["CertName"] = self.certName!
            }
            if self.cname != nil {
                map["Cname"] = self.cname!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.domainStatus != nil {
                map["DomainStatus"] = self.domainStatus!
            }
            if self.gmtCreated != nil {
                map["GmtCreated"] = self.gmtCreated!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.liveDomainType != nil {
                map["LiveDomainType"] = self.liveDomainType!
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.SSLProtocol != nil {
                map["SSLProtocol"] = self.SSLProtocol!
            }
            if self.SSLPub != nil {
                map["SSLPub"] = self.SSLPub!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CertName"] as? String {
                self.certName = value
            }
            if let value = dict["Cname"] as? String {
                self.cname = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["DomainStatus"] as? String {
                self.domainStatus = value
            }
            if let value = dict["GmtCreated"] as? String {
                self.gmtCreated = value
            }
            if let value = dict["GmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["LiveDomainType"] as? String {
                self.liveDomainType = value
            }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["SSLProtocol"] as? String {
                self.SSLProtocol = value
            }
            if let value = dict["SSLPub"] as? String {
                self.SSLPub = value
            }
            if let value = dict["Scope"] as? String {
                self.scope = value
            }
        }
    }
    public var domainDetail: DescribeLiveDomainDetailResponseBody.DomainDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainDetail != nil {
            map["DomainDetail"] = self.domainDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainDetail"] as? [String: Any?] {
            var model = DescribeLiveDomainDetailResponseBody.DomainDetail()
            model.fromMap(value)
            self.domainDetail = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainEdgeLogRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainEdgeLogResponseBody : Tea.TeaModel {
    public class DomainLogDetails : Tea.TeaModel {
        public class DomainLogDetail : Tea.TeaModel {
            public class LogInfos : Tea.TeaModel {
                public class LogInfoDetail : Tea.TeaModel {
                    public var endTime: String?

                    public var logName: String?

                    public var logPath: String?

                    public var logSize: Int64?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.logName != nil {
                            map["LogName"] = self.logName!
                        }
                        if self.logPath != nil {
                            map["LogPath"] = self.logPath!
                        }
                        if self.logSize != nil {
                            map["LogSize"] = self.logSize!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["LogName"] as? String {
                            self.logName = value
                        }
                        if let value = dict["LogPath"] as? String {
                            self.logPath = value
                        }
                        if let value = dict["LogSize"] as? Int64 {
                            self.logSize = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                    }
                }
                public var logInfoDetail: [DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logInfoDetail != nil {
                        var tmp : [Any] = []
                        for k in self.logInfoDetail! {
                            tmp.append(k.toMap())
                        }
                        map["LogInfoDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LogInfoDetail"] as? [Any?] {
                        var tmp : [DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.logInfoDetail = tmp
                    }
                }
            }
            public class PageInfos : Tea.TeaModel {
                public var pageIndex: Int64?

                public var pageSize: Int64?

                public var total: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pageIndex != nil {
                        map["PageIndex"] = self.pageIndex!
                    }
                    if self.pageSize != nil {
                        map["PageSize"] = self.pageSize!
                    }
                    if self.total != nil {
                        map["Total"] = self.total!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PageIndex"] as? Int64 {
                        self.pageIndex = value
                    }
                    if let value = dict["PageSize"] as? Int64 {
                        self.pageSize = value
                    }
                    if let value = dict["Total"] as? Int64 {
                        self.total = value
                    }
                }
            }
            public var logCount: Int64?

            public var logInfos: DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos?

            public var pageInfos: DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.logInfos?.validate()
                try self.pageInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.logInfos != nil {
                    map["LogInfos"] = self.logInfos?.toMap()
                }
                if self.pageInfos != nil {
                    map["PageInfos"] = self.pageInfos?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LogCount"] as? Int64 {
                    self.logCount = value
                }
                if let value = dict["LogInfos"] as? [String: Any?] {
                    var model = DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos()
                    model.fromMap(value)
                    self.logInfos = model
                }
                if let value = dict["PageInfos"] as? [String: Any?] {
                    var model = DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos()
                    model.fromMap(value)
                    self.pageInfos = model
                }
            }
        }
        public var domainLogDetail: [DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLogDetail != nil {
                var tmp : [Any] = []
                for k in self.domainLogDetail! {
                    tmp.append(k.toMap())
                }
                map["DomainLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainLogDetail"] as? [Any?] {
                var tmp : [DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails.DomainLogDetail()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainLogDetail = tmp
            }
        }
    }
    public var domainLogDetails: DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails?

    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogDetails != nil {
            map["DomainLogDetails"] = self.domainLogDetails?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainLogDetails"] as? [String: Any?] {
            var model = DescribeLiveDomainEdgeLogResponseBody.DomainLogDetails()
            model.fromMap(value)
            self.domainLogDetails = model
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainEdgeLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainEdgeLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainEdgeLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainFrameRateAndBitRateDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var queryTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.queryTime != nil {
            map["QueryTime"] = self.queryTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QueryTime"] as? String {
            self.queryTime = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveDomainFrameRateAndBitRateDataResponseBody : Tea.TeaModel {
    public class FrameRateAndBitRateInfos : Tea.TeaModel {
        public class FrameRateAndBitRateInfo : Tea.TeaModel {
            public var audioFrameRate: Double?

            public var bitRate: Double?

            public var streamUrl: String?

            public var videoFrameRate: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioFrameRate != nil {
                    map["AudioFrameRate"] = self.audioFrameRate!
                }
                if self.bitRate != nil {
                    map["BitRate"] = self.bitRate!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                if self.videoFrameRate != nil {
                    map["VideoFrameRate"] = self.videoFrameRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AudioFrameRate"] as? Double {
                    self.audioFrameRate = value
                }
                if let value = dict["BitRate"] as? Double {
                    self.bitRate = value
                }
                if let value = dict["StreamUrl"] as? String {
                    self.streamUrl = value
                }
                if let value = dict["VideoFrameRate"] as? Double {
                    self.videoFrameRate = value
                }
            }
        }
        public var frameRateAndBitRateInfo: [DescribeLiveDomainFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.frameRateAndBitRateInfo != nil {
                var tmp : [Any] = []
                for k in self.frameRateAndBitRateInfo! {
                    tmp.append(k.toMap())
                }
                map["FrameRateAndBitRateInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FrameRateAndBitRateInfo"] as? [Any?] {
                var tmp : [DescribeLiveDomainFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.frameRateAndBitRateInfo = tmp
            }
        }
    }
    public var frameRateAndBitRateInfos: DescribeLiveDomainFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.frameRateAndBitRateInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.frameRateAndBitRateInfos != nil {
            map["FrameRateAndBitRateInfos"] = self.frameRateAndBitRateInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FrameRateAndBitRateInfos"] as? [String: Any?] {
            var model = DescribeLiveDomainFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos()
            model.fromMap(value)
            self.frameRateAndBitRateInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainFrameRateAndBitRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainFrameRateAndBitRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainFrameRateAndBitRateDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainLimitRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveDomainLimitResponseBody : Tea.TeaModel {
    public class LiveDomainLimitList : Tea.TeaModel {
        public class LiveDomainLimit : Tea.TeaModel {
            public var currentNum: Int32?

            public var currentTranscodeNum: Int32?

            public var currentTransferNum: Int32?

            public var domainName: String?

            public var limitNum: Int32?

            public var limitTranscodeNum: Int32?

            public var limitTransferNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currentNum != nil {
                    map["CurrentNum"] = self.currentNum!
                }
                if self.currentTranscodeNum != nil {
                    map["CurrentTranscodeNum"] = self.currentTranscodeNum!
                }
                if self.currentTransferNum != nil {
                    map["CurrentTransferNum"] = self.currentTransferNum!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.limitNum != nil {
                    map["LimitNum"] = self.limitNum!
                }
                if self.limitTranscodeNum != nil {
                    map["LimitTranscodeNum"] = self.limitTranscodeNum!
                }
                if self.limitTransferNum != nil {
                    map["LimitTransferNum"] = self.limitTransferNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CurrentNum"] as? Int32 {
                    self.currentNum = value
                }
                if let value = dict["CurrentTranscodeNum"] as? Int32 {
                    self.currentTranscodeNum = value
                }
                if let value = dict["CurrentTransferNum"] as? Int32 {
                    self.currentTransferNum = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["LimitNum"] as? Int32 {
                    self.limitNum = value
                }
                if let value = dict["LimitTranscodeNum"] as? Int32 {
                    self.limitTranscodeNum = value
                }
                if let value = dict["LimitTransferNum"] as? Int32 {
                    self.limitTransferNum = value
                }
            }
        }
        public var liveDomainLimit: [DescribeLiveDomainLimitResponseBody.LiveDomainLimitList.LiveDomainLimit]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveDomainLimit != nil {
                var tmp : [Any] = []
                for k in self.liveDomainLimit! {
                    tmp.append(k.toMap())
                }
                map["LiveDomainLimit"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveDomainLimit"] as? [Any?] {
                var tmp : [DescribeLiveDomainLimitResponseBody.LiveDomainLimitList.LiveDomainLimit] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainLimitResponseBody.LiveDomainLimitList.LiveDomainLimit()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveDomainLimit = tmp
            }
        }
    }
    public var liveDomainLimitList: DescribeLiveDomainLimitResponseBody.LiveDomainLimitList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveDomainLimitList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveDomainLimitList != nil {
            map["LiveDomainLimitList"] = self.liveDomainLimitList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveDomainLimitList"] as? [String: Any?] {
            var model = DescribeLiveDomainLimitResponseBody.LiveDomainLimitList()
            model.fromMap(value)
            self.liveDomainLimitList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainLimitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainLogRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainLogResponseBody : Tea.TeaModel {
    public class DomainLogDetails : Tea.TeaModel {
        public class DomainLogDetail : Tea.TeaModel {
            public class LogInfos : Tea.TeaModel {
                public class LogInfoDetail : Tea.TeaModel {
                    public var endTime: String?

                    public var logName: String?

                    public var logPath: String?

                    public var logSize: Int64?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.logName != nil {
                            map["LogName"] = self.logName!
                        }
                        if self.logPath != nil {
                            map["LogPath"] = self.logPath!
                        }
                        if self.logSize != nil {
                            map["LogSize"] = self.logSize!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["LogName"] as? String {
                            self.logName = value
                        }
                        if let value = dict["LogPath"] as? String {
                            self.logPath = value
                        }
                        if let value = dict["LogSize"] as? Int64 {
                            self.logSize = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                    }
                }
                public var logInfoDetail: [DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logInfoDetail != nil {
                        var tmp : [Any] = []
                        for k in self.logInfoDetail! {
                            tmp.append(k.toMap())
                        }
                        map["LogInfoDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LogInfoDetail"] as? [Any?] {
                        var tmp : [DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.logInfoDetail = tmp
                    }
                }
            }
            public class PageInfos : Tea.TeaModel {
                public var pageIndex: Int64?

                public var pageSize: Int64?

                public var total: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pageIndex != nil {
                        map["PageIndex"] = self.pageIndex!
                    }
                    if self.pageSize != nil {
                        map["PageSize"] = self.pageSize!
                    }
                    if self.total != nil {
                        map["Total"] = self.total!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PageIndex"] as? Int64 {
                        self.pageIndex = value
                    }
                    if let value = dict["PageSize"] as? Int64 {
                        self.pageSize = value
                    }
                    if let value = dict["Total"] as? Int64 {
                        self.total = value
                    }
                }
            }
            public var logCount: Int64?

            public var logInfos: DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos?

            public var pageInfos: DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.logInfos?.validate()
                try self.pageInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.logInfos != nil {
                    map["LogInfos"] = self.logInfos?.toMap()
                }
                if self.pageInfos != nil {
                    map["PageInfos"] = self.pageInfos?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LogCount"] as? Int64 {
                    self.logCount = value
                }
                if let value = dict["LogInfos"] as? [String: Any?] {
                    var model = DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos()
                    model.fromMap(value)
                    self.logInfos = model
                }
                if let value = dict["PageInfos"] as? [String: Any?] {
                    var model = DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos()
                    model.fromMap(value)
                    self.pageInfos = model
                }
            }
        }
        public var domainLogDetail: [DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLogDetail != nil {
                var tmp : [Any] = []
                for k in self.domainLogDetail! {
                    tmp.append(k.toMap())
                }
                map["DomainLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainLogDetail"] as? [Any?] {
                var tmp : [DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainLogResponseBody.DomainLogDetails.DomainLogDetail()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainLogDetail = tmp
            }
        }
    }
    public var domainLogDetails: DescribeLiveDomainLogResponseBody.DomainLogDetails?

    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogDetails != nil {
            map["DomainLogDetails"] = self.domainLogDetails?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainLogDetails"] as? [String: Any?] {
            var model = DescribeLiveDomainLogResponseBody.DomainLogDetails()
            model.fromMap(value)
            self.domainLogDetails = model
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainLogExTtlRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainLogExTtlResponseBody : Tea.TeaModel {
    public class DomainLogDetails : Tea.TeaModel {
        public class DomainLogDetail : Tea.TeaModel {
            public class LogInfos : Tea.TeaModel {
                public class LogInfoDetail : Tea.TeaModel {
                    public var endTime: String?

                    public var logName: String?

                    public var logPath: String?

                    public var logSize: Int64?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.logName != nil {
                            map["LogName"] = self.logName!
                        }
                        if self.logPath != nil {
                            map["LogPath"] = self.logPath!
                        }
                        if self.logSize != nil {
                            map["LogSize"] = self.logSize!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["LogName"] as? String {
                            self.logName = value
                        }
                        if let value = dict["LogPath"] as? String {
                            self.logPath = value
                        }
                        if let value = dict["LogSize"] as? Int64 {
                            self.logSize = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                    }
                }
                public var logInfoDetail: [DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logInfoDetail != nil {
                        var tmp : [Any] = []
                        for k in self.logInfoDetail! {
                            tmp.append(k.toMap())
                        }
                        map["LogInfoDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LogInfoDetail"] as? [Any?] {
                        var tmp : [DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.logInfoDetail = tmp
                    }
                }
            }
            public class PageInfos : Tea.TeaModel {
                public var pageIndex: Int64?

                public var pageSize: Int64?

                public var total: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pageIndex != nil {
                        map["PageIndex"] = self.pageIndex!
                    }
                    if self.pageSize != nil {
                        map["PageSize"] = self.pageSize!
                    }
                    if self.total != nil {
                        map["Total"] = self.total!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PageIndex"] as? Int64 {
                        self.pageIndex = value
                    }
                    if let value = dict["PageSize"] as? Int64 {
                        self.pageSize = value
                    }
                    if let value = dict["Total"] as? Int64 {
                        self.total = value
                    }
                }
            }
            public var logCount: Int64?

            public var logInfos: DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail.LogInfos?

            public var pageInfos: DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail.PageInfos?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.logInfos?.validate()
                try self.pageInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.logInfos != nil {
                    map["LogInfos"] = self.logInfos?.toMap()
                }
                if self.pageInfos != nil {
                    map["PageInfos"] = self.pageInfos?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LogCount"] as? Int64 {
                    self.logCount = value
                }
                if let value = dict["LogInfos"] as? [String: Any?] {
                    var model = DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail.LogInfos()
                    model.fromMap(value)
                    self.logInfos = model
                }
                if let value = dict["PageInfos"] as? [String: Any?] {
                    var model = DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail.PageInfos()
                    model.fromMap(value)
                    self.pageInfos = model
                }
            }
        }
        public var domainLogDetail: [DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLogDetail != nil {
                var tmp : [Any] = []
                for k in self.domainLogDetail! {
                    tmp.append(k.toMap())
                }
                map["DomainLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainLogDetail"] as? [Any?] {
                var tmp : [DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails.DomainLogDetail()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainLogDetail = tmp
            }
        }
    }
    public var domainLogDetails: DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails?

    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogDetails != nil {
            map["DomainLogDetails"] = self.domainLogDetails?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainLogDetails"] as? [String: Any?] {
            var model = DescribeLiveDomainLogExTtlResponseBody.DomainLogDetails()
            model.fromMap(value)
            self.domainLogDetails = model
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainLogExTtlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainLogExTtlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainLogExTtlResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainMappingRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveDomainMappingResponseBody : Tea.TeaModel {
    public class LiveDomainModels : Tea.TeaModel {
        public class LiveDomainModel : Tea.TeaModel {
            public var domainName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var liveDomainModel: [DescribeLiveDomainMappingResponseBody.LiveDomainModels.LiveDomainModel]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveDomainModel != nil {
                var tmp : [Any] = []
                for k in self.liveDomainModel! {
                    tmp.append(k.toMap())
                }
                map["LiveDomainModel"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveDomainModel"] as? [Any?] {
                var tmp : [DescribeLiveDomainMappingResponseBody.LiveDomainModels.LiveDomainModel] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainMappingResponseBody.LiveDomainModels.LiveDomainModel()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveDomainModel = tmp
            }
        }
    }
    public var liveDomainModels: DescribeLiveDomainMappingResponseBody.LiveDomainModels?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveDomainModels?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveDomainModels != nil {
            map["LiveDomainModels"] = self.liveDomainModels?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveDomainModels"] as? [String: Any?] {
            var model = DescribeLiveDomainMappingResponseBody.LiveDomainModels()
            model.fromMap(value)
            self.liveDomainModels = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainMappingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainMappingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainMappingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainMonitoringUsageDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var instanceId: String?

    public var interval: String?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var splitBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SplitBy"] as? String {
            self.splitBy = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainMonitoringUsageDataResponseBody : Tea.TeaModel {
    public class MonitoringData : Tea.TeaModel {
        public class MonitoringDataItem : Tea.TeaModel {
            public var domainName: String?

            public var duration: Int32?

            public var instanceId: String?

            public var region: String?

            public var resolution: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resolution != nil {
                    map["Resolution"] = self.resolution!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Duration"] as? Int32 {
                    self.duration = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["Resolution"] as? String {
                    self.resolution = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var monitoringDataItem: [DescribeLiveDomainMonitoringUsageDataResponseBody.MonitoringData.MonitoringDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.monitoringDataItem != nil {
                var tmp : [Any] = []
                for k in self.monitoringDataItem! {
                    tmp.append(k.toMap())
                }
                map["MonitoringDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MonitoringDataItem"] as? [Any?] {
                var tmp : [DescribeLiveDomainMonitoringUsageDataResponseBody.MonitoringData.MonitoringDataItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainMonitoringUsageDataResponseBody.MonitoringData.MonitoringDataItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.monitoringDataItem = tmp
            }
        }
    }
    public var domainName: String?

    public var endTime: String?

    public var instanceId: String?

    public var monitoringData: DescribeLiveDomainMonitoringUsageDataResponseBody.MonitoringData?

    public var region: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitoringData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.monitoringData != nil {
            map["MonitoringData"] = self.monitoringData?.toMap()
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MonitoringData"] as? [String: Any?] {
            var model = DescribeLiveDomainMonitoringUsageDataResponseBody.MonitoringData()
            model.fromMap(value)
            self.monitoringData = model
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainMonitoringUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainMonitoringUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainMonitoringUsageDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainMultiStreamConfigRequest : Tea.TeaModel {
    public var domain: String?

    public var ownerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
    }
}

public class DescribeLiveDomainMultiStreamConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var switch_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.switch_ != nil {
            map["Switch"] = self.switch_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Switch"] as? String {
            self.switch_ = value
        }
    }
}

public class DescribeLiveDomainMultiStreamConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainMultiStreamConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainMultiStreamConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainOnlineUserNumRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var queryTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.queryTime != nil {
            map["QueryTime"] = self.queryTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["QueryTime"] as? String {
            self.queryTime = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveDomainOnlineUserNumResponseBody : Tea.TeaModel {
    public class OnlineUserInfo : Tea.TeaModel {
        public class LiveStreamOnlineUserNumInfo : Tea.TeaModel {
            public class Infos : Tea.TeaModel {
                public class Info : Tea.TeaModel {
                    public var transcodeTemplate: String?

                    public var userNumber: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.transcodeTemplate != nil {
                            map["TranscodeTemplate"] = self.transcodeTemplate!
                        }
                        if self.userNumber != nil {
                            map["UserNumber"] = self.userNumber!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["TranscodeTemplate"] as? String {
                            self.transcodeTemplate = value
                        }
                        if let value = dict["UserNumber"] as? Int64 {
                            self.userNumber = value
                        }
                    }
                }
                public var info: [DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo.Infos.Info]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.info != nil {
                        var tmp : [Any] = []
                        for k in self.info! {
                            tmp.append(k.toMap())
                        }
                        map["Info"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Info"] as? [Any?] {
                        var tmp : [DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo.Infos.Info] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo.Infos.Info()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.info = tmp
                    }
                }
            }
            public var infos: DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo.Infos?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.infos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.infos != nil {
                    map["Infos"] = self.infos?.toMap()
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Infos"] as? [String: Any?] {
                    var model = DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo.Infos()
                    model.fromMap(value)
                    self.infos = model
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
            }
        }
        public var liveStreamOnlineUserNumInfo: [DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamOnlineUserNumInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamOnlineUserNumInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamOnlineUserNumInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveStreamOnlineUserNumInfo"] as? [Any?] {
                var tmp : [DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo.LiveStreamOnlineUserNumInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveStreamOnlineUserNumInfo = tmp
            }
        }
    }
    public var onlineUserInfo: DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo?

    public var requestId: String?

    public var streamCount: Int32?

    public var userCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.onlineUserInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onlineUserInfo != nil {
            map["OnlineUserInfo"] = self.onlineUserInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamCount != nil {
            map["StreamCount"] = self.streamCount!
        }
        if self.userCount != nil {
            map["UserCount"] = self.userCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OnlineUserInfo"] as? [String: Any?] {
            var model = DescribeLiveDomainOnlineUserNumResponseBody.OnlineUserInfo()
            model.fromMap(value)
            self.onlineUserInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamCount"] as? Int32 {
            self.streamCount = value
        }
        if let value = dict["UserCount"] as? Int32 {
            self.userCount = value
        }
    }
}

public class DescribeLiveDomainOnlineUserNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainOnlineUserNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainOnlineUserNumResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainPublishErrorCodeRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainPublishErrorCodeResponseBody : Tea.TeaModel {
    public class RealTimeCodeData : Tea.TeaModel {
        public class CodeData : Tea.TeaModel {
            public var code: String?

            public var count: String?

            public var proportion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.proportion != nil {
                    map["Proportion"] = self.proportion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Code"] as? String {
                    self.code = value
                }
                if let value = dict["Count"] as? String {
                    self.count = value
                }
                if let value = dict["Proportion"] as? String {
                    self.proportion = value
                }
            }
        }
        public var codeData: [DescribeLiveDomainPublishErrorCodeResponseBody.RealTimeCodeData.CodeData]?

        public var timeStamp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.codeData != nil {
                var tmp : [Any] = []
                for k in self.codeData! {
                    tmp.append(k.toMap())
                }
                map["CodeData"] = tmp
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CodeData"] as? [Any?] {
                var tmp : [DescribeLiveDomainPublishErrorCodeResponseBody.RealTimeCodeData.CodeData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainPublishErrorCodeResponseBody.RealTimeCodeData.CodeData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.codeData = tmp
            }
            if let value = dict["TimeStamp"] as? String {
                self.timeStamp = value
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var realTimeCodeData: [DescribeLiveDomainPublishErrorCodeResponseBody.RealTimeCodeData]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.realTimeCodeData != nil {
            var tmp : [Any] = []
            for k in self.realTimeCodeData! {
                tmp.append(k.toMap())
            }
            map["RealTimeCodeData"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RealTimeCodeData"] as? [Any?] {
            var tmp : [DescribeLiveDomainPublishErrorCodeResponseBody.RealTimeCodeData] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveDomainPublishErrorCodeResponseBody.RealTimeCodeData()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.realTimeCodeData = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainPublishErrorCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainPublishErrorCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainPublishErrorCodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainPushBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["IspNameEn"] as? String {
            self.ispNameEn = value
        }
        if let value = dict["LocationNameEn"] as? String {
            self.locationNameEn = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainPushBpsDataResponseBody : Tea.TeaModel {
    public class BpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var bpsValue: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bpsValue != nil {
                    map["BpsValue"] = self.bpsValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BpsValue"] as? String {
                    self.bpsValue = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var dataModule: [DescribeLiveDomainPushBpsDataResponseBody.BpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDomainPushBpsDataResponseBody.BpsDataPerInterval.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainPushBpsDataResponseBody.BpsDataPerInterval.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var bpsDataPerInterval: DescribeLiveDomainPushBpsDataResponseBody.BpsDataPerInterval?

    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bpsDataPerInterval != nil {
            map["BpsDataPerInterval"] = self.bpsDataPerInterval?.toMap()
        }
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BpsDataPerInterval"] as? [String: Any?] {
            var model = DescribeLiveDomainPushBpsDataResponseBody.BpsDataPerInterval()
            model.fromMap(value)
            self.bpsDataPerInterval = model
        }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainPushBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainPushBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainPushBpsDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainPushTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["IspNameEn"] as? String {
            self.ispNameEn = value
        }
        if let value = dict["LocationNameEn"] as? String {
            self.locationNameEn = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainPushTrafficDataResponseBody : Tea.TeaModel {
    public class TrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var trafficValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.trafficValue != nil {
                    map["TrafficValue"] = self.trafficValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["TrafficValue"] as? String {
                    self.trafficValue = value
                }
            }
        }
        public var dataModule: [DescribeLiveDomainPushTrafficDataResponseBody.TrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDomainPushTrafficDataResponseBody.TrafficDataPerInterval.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainPushTrafficDataResponseBody.TrafficDataPerInterval.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var trafficDataPerInterval: DescribeLiveDomainPushTrafficDataResponseBody.TrafficDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.trafficDataPerInterval != nil {
            map["TrafficDataPerInterval"] = self.trafficDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TrafficDataPerInterval"] as? [String: Any?] {
            var model = DescribeLiveDomainPushTrafficDataResponseBody.TrafficDataPerInterval()
            model.fromMap(value)
            self.trafficDataPerInterval = model
        }
    }
}

public class DescribeLiveDomainPushTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainPushTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainPushTrafficDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainPvUvDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainPvUvDataResponseBody : Tea.TeaModel {
    public class PvUvDataInfos : Tea.TeaModel {
        public class PvUvDataInfo : Tea.TeaModel {
            public var PV: String?

            public var timeStamp: String?

            public var UV: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.PV != nil {
                    map["PV"] = self.PV!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.UV != nil {
                    map["UV"] = self.UV!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PV"] as? String {
                    self.PV = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["UV"] as? String {
                    self.UV = value
                }
            }
        }
        public var pvUvDataInfo: [DescribeLiveDomainPvUvDataResponseBody.PvUvDataInfos.PvUvDataInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pvUvDataInfo != nil {
                var tmp : [Any] = []
                for k in self.pvUvDataInfo! {
                    tmp.append(k.toMap())
                }
                map["PvUvDataInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PvUvDataInfo"] as? [Any?] {
                var tmp : [DescribeLiveDomainPvUvDataResponseBody.PvUvDataInfos.PvUvDataInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainPvUvDataResponseBody.PvUvDataInfos.PvUvDataInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.pvUvDataInfo = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var pvUvDataInfos: DescribeLiveDomainPvUvDataResponseBody.PvUvDataInfos?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pvUvDataInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pvUvDataInfos != nil {
            map["PvUvDataInfos"] = self.pvUvDataInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PvUvDataInfos"] as? [String: Any?] {
            var model = DescribeLiveDomainPvUvDataResponseBody.PvUvDataInfos()
            model.fromMap(value)
            self.pvUvDataInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainPvUvDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainPvUvDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainPvUvDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainRealTimeBpsDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["IspNameEn"] as? String {
            self.ispNameEn = value
        }
        if let value = dict["LocationNameEn"] as? String {
            self.locationNameEn = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainRealTimeBpsDataResponseBody : Tea.TeaModel {
    public class RealTimeBpsDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var dataModule: [DescribeLiveDomainRealTimeBpsDataResponseBody.RealTimeBpsDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDomainRealTimeBpsDataResponseBody.RealTimeBpsDataPerInterval.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainRealTimeBpsDataResponseBody.RealTimeBpsDataPerInterval.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var realTimeBpsDataPerInterval: DescribeLiveDomainRealTimeBpsDataResponseBody.RealTimeBpsDataPerInterval?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeBpsDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.realTimeBpsDataPerInterval != nil {
            map["RealTimeBpsDataPerInterval"] = self.realTimeBpsDataPerInterval?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RealTimeBpsDataPerInterval"] as? [String: Any?] {
            var model = DescribeLiveDomainRealTimeBpsDataResponseBody.RealTimeBpsDataPerInterval()
            model.fromMap(value)
            self.realTimeBpsDataPerInterval = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainRealTimeBpsDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRealTimeBpsDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainRealTimeBpsDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainRealTimeHttpCodeDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["IspNameEn"] as? String {
            self.ispNameEn = value
        }
        if let value = dict["LocationNameEn"] as? String {
            self.locationNameEn = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainRealTimeHttpCodeDataResponseBody : Tea.TeaModel {
    public class RealTimeHttpCodeData : Tea.TeaModel {
        public class UsageData : Tea.TeaModel {
            public class Value : Tea.TeaModel {
                public class RealTimeCodeProportionData : Tea.TeaModel {
                    public var code: String?

                    public var count: String?

                    public var proportion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.proportion != nil {
                            map["Proportion"] = self.proportion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Code"] as? String {
                            self.code = value
                        }
                        if let value = dict["Count"] as? String {
                            self.count = value
                        }
                        if let value = dict["Proportion"] as? String {
                            self.proportion = value
                        }
                    }
                }
                public var realTimeCodeProportionData: [DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value.RealTimeCodeProportionData]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.realTimeCodeProportionData != nil {
                        var tmp : [Any] = []
                        for k in self.realTimeCodeProportionData! {
                            tmp.append(k.toMap())
                        }
                        map["RealTimeCodeProportionData"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RealTimeCodeProportionData"] as? [Any?] {
                        var tmp : [DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value.RealTimeCodeProportionData] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value.RealTimeCodeProportionData()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.realTimeCodeProportionData = tmp
                    }
                }
            }
            public var timeStamp: String?

            public var value: DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.value?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["Value"] as? [String: Any?] {
                    var model = DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData.Value()
                    model.fromMap(value)
                    self.value = model
                }
            }
        }
        public var usageData: [DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.usageData != nil {
                var tmp : [Any] = []
                for k in self.usageData! {
                    tmp.append(k.toMap())
                }
                map["UsageData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["UsageData"] as? [Any?] {
                var tmp : [DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData.UsageData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.usageData = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var realTimeHttpCodeData: DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeHttpCodeData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.realTimeHttpCodeData != nil {
            map["RealTimeHttpCodeData"] = self.realTimeHttpCodeData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RealTimeHttpCodeData"] as? [String: Any?] {
            var model = DescribeLiveDomainRealTimeHttpCodeDataResponseBody.RealTimeHttpCodeData()
            model.fromMap(value)
            self.realTimeHttpCodeData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainRealTimeHttpCodeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRealTimeHttpCodeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainRealTimeHttpCodeDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainRealTimeTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["IspNameEn"] as? String {
            self.ispNameEn = value
        }
        if let value = dict["LocationNameEn"] as? String {
            self.locationNameEn = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainRealTimeTrafficDataResponseBody : Tea.TeaModel {
    public class RealTimeTrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var timeStamp: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var dataModule: [DescribeLiveDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var realTimeTrafficDataPerInterval: DescribeLiveDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeTrafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.realTimeTrafficDataPerInterval != nil {
            map["RealTimeTrafficDataPerInterval"] = self.realTimeTrafficDataPerInterval?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RealTimeTrafficDataPerInterval"] as? [String: Any?] {
            var model = DescribeLiveDomainRealTimeTrafficDataResponseBody.RealTimeTrafficDataPerInterval()
            model.fromMap(value)
            self.realTimeTrafficDataPerInterval = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainRealTimeTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRealTimeTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainRealTimeTrafficDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveDomainRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var logstore: String?

    public var project: String?

    public var region: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Logstore"] as? String {
            self.logstore = value
        }
        if let value = dict["Project"] as? String {
            self.project = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeLiveDomainRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainRealtimeLogDeliveryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainRecordUsageDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var splitBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SplitBy"] as? String {
            self.splitBy = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainRecordUsageDataResponseBody : Tea.TeaModel {
    public class RecordUsageData : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var count: Int64?

            public var domain: String?

            public var duration: Int64?

            public var region: String?

            public var timeStamp: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["Duration"] as? Int64 {
                    self.duration = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var dataModule: [DescribeLiveDomainRecordUsageDataResponseBody.RecordUsageData.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDomainRecordUsageDataResponseBody.RecordUsageData.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainRecordUsageDataResponseBody.RecordUsageData.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var endTime: String?

    public var recordUsageData: DescribeLiveDomainRecordUsageDataResponseBody.RecordUsageData?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordUsageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.recordUsageData != nil {
            map["RecordUsageData"] = self.recordUsageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RecordUsageData"] as? [String: Any?] {
            var model = DescribeLiveDomainRecordUsageDataResponseBody.RecordUsageData()
            model.fromMap(value)
            self.recordUsageData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainRecordUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainRecordUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainRecordUsageDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainSnapshotDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainSnapshotDataResponseBody : Tea.TeaModel {
    public class SnapshotDataInfos : Tea.TeaModel {
        public class SnapshotDataInfo : Tea.TeaModel {
            public var date: String?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.date != nil {
                    map["Date"] = self.date!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Date"] as? String {
                    self.date = value
                }
                if let value = dict["Total"] as? Int32 {
                    self.total = value
                }
            }
        }
        public var snapshotDataInfo: [DescribeLiveDomainSnapshotDataResponseBody.SnapshotDataInfos.SnapshotDataInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotDataInfo != nil {
                var tmp : [Any] = []
                for k in self.snapshotDataInfo! {
                    tmp.append(k.toMap())
                }
                map["SnapshotDataInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SnapshotDataInfo"] as? [Any?] {
                var tmp : [DescribeLiveDomainSnapshotDataResponseBody.SnapshotDataInfos.SnapshotDataInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainSnapshotDataResponseBody.SnapshotDataInfos.SnapshotDataInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.snapshotDataInfo = tmp
            }
        }
    }
    public var requestId: String?

    public var snapshotDataInfos: DescribeLiveDomainSnapshotDataResponseBody.SnapshotDataInfos?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotDataInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotDataInfos != nil {
            map["SnapshotDataInfos"] = self.snapshotDataInfos?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SnapshotDataInfos"] as? [String: Any?] {
            var model = DescribeLiveDomainSnapshotDataResponseBody.SnapshotDataInfos()
            model.fromMap(value)
            self.snapshotDataInfos = model
        }
    }
}

public class DescribeLiveDomainSnapshotDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainSnapshotDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainSnapshotDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainStagingConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionNames: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionNames != nil {
            map["FunctionNames"] = self.functionNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["FunctionNames"] as? String {
            self.functionNames = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveDomainStagingConfigResponseBody : Tea.TeaModel {
    public class DomainConfigs : Tea.TeaModel {
        public class FunctionArgs : Tea.TeaModel {
            public var argName: String?

            public var argValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.argName != nil {
                    map["ArgName"] = self.argName!
                }
                if self.argValue != nil {
                    map["ArgValue"] = self.argValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ArgName"] as? String {
                    self.argName = value
                }
                if let value = dict["ArgValue"] as? String {
                    self.argValue = value
                }
            }
        }
        public var configId: String?

        public var functionArgs: [DescribeLiveDomainStagingConfigResponseBody.DomainConfigs.FunctionArgs]?

        public var functionName: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configId != nil {
                map["ConfigId"] = self.configId!
            }
            if self.functionArgs != nil {
                var tmp : [Any] = []
                for k in self.functionArgs! {
                    tmp.append(k.toMap())
                }
                map["FunctionArgs"] = tmp
            }
            if self.functionName != nil {
                map["FunctionName"] = self.functionName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigId"] as? String {
                self.configId = value
            }
            if let value = dict["FunctionArgs"] as? [Any?] {
                var tmp : [DescribeLiveDomainStagingConfigResponseBody.DomainConfigs.FunctionArgs] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainStagingConfigResponseBody.DomainConfigs.FunctionArgs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.functionArgs = tmp
            }
            if let value = dict["FunctionName"] as? String {
                self.functionName = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var domainConfigs: [DescribeLiveDomainStagingConfigResponseBody.DomainConfigs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainConfigs != nil {
            var tmp : [Any] = []
            for k in self.domainConfigs! {
                tmp.append(k.toMap())
            }
            map["DomainConfigs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainConfigs"] as? [Any?] {
            var tmp : [DescribeLiveDomainStagingConfigResponseBody.DomainConfigs] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveDomainStagingConfigResponseBody.DomainConfigs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.domainConfigs = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainStagingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainStagingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainStagingConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainStreamTranscodeDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var precision: String?

    public var regionId: String?

    public var split: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.precision != nil {
            map["Precision"] = self.precision!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.split != nil {
            map["Split"] = self.split!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Precision"] as? String {
            self.precision = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Split"] as? String {
            self.split = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainStreamTranscodeDataResponseBody : Tea.TeaModel {
    public class TranscodeDataList : Tea.TeaModel {
        public class TranscodeData : Tea.TeaModel {
            public var domain: String?

            public var duration: Int32?

            public var fps: String?

            public var region: String?

            public var resolution: String?

            public var tanscodeType: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resolution != nil {
                    map["Resolution"] = self.resolution!
                }
                if self.tanscodeType != nil {
                    map["TanscodeType"] = self.tanscodeType!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["Duration"] as? Int32 {
                    self.duration = value
                }
                if let value = dict["Fps"] as? String {
                    self.fps = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["Resolution"] as? String {
                    self.resolution = value
                }
                if let value = dict["TanscodeType"] as? String {
                    self.tanscodeType = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var transcodeData: [DescribeLiveDomainStreamTranscodeDataResponseBody.TranscodeDataList.TranscodeData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.transcodeData != nil {
                var tmp : [Any] = []
                for k in self.transcodeData! {
                    tmp.append(k.toMap())
                }
                map["TranscodeData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TranscodeData"] as? [Any?] {
                var tmp : [DescribeLiveDomainStreamTranscodeDataResponseBody.TranscodeDataList.TranscodeData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainStreamTranscodeDataResponseBody.TranscodeDataList.TranscodeData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.transcodeData = tmp
            }
        }
    }
    public var requestId: String?

    public var transcodeDataList: DescribeLiveDomainStreamTranscodeDataResponseBody.TranscodeDataList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.transcodeDataList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.transcodeDataList != nil {
            map["TranscodeDataList"] = self.transcodeDataList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TranscodeDataList"] as? [String: Any?] {
            var model = DescribeLiveDomainStreamTranscodeDataResponseBody.TranscodeDataList()
            model.fromMap(value)
            self.transcodeDataList = model
        }
    }
}

public class DescribeLiveDomainStreamTranscodeDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainStreamTranscodeDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainStreamTranscodeDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainTimeShiftDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainTimeShiftDataResponseBody : Tea.TeaModel {
    public class TimeShiftData : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var size: String?

            public var timeStamp: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Size"] as? String {
                    self.size = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var dataModule: [DescribeLiveDomainTimeShiftDataResponseBody.TimeShiftData.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDomainTimeShiftDataResponseBody.TimeShiftData.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainTimeShiftDataResponseBody.TimeShiftData.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var requestId: String?

    public var timeShiftData: DescribeLiveDomainTimeShiftDataResponseBody.TimeShiftData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.timeShiftData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.timeShiftData != nil {
            map["TimeShiftData"] = self.timeShiftData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TimeShiftData"] as? [String: Any?] {
            var model = DescribeLiveDomainTimeShiftDataResponseBody.TimeShiftData()
            model.fromMap(value)
            self.timeShiftData = model
        }
    }
}

public class DescribeLiveDomainTimeShiftDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainTimeShiftDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainTimeShiftDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainTrafficDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ispNameEn: String?

    public var locationNameEn: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ispNameEn != nil {
            map["IspNameEn"] = self.ispNameEn!
        }
        if self.locationNameEn != nil {
            map["LocationNameEn"] = self.locationNameEn!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["IspNameEn"] as? String {
            self.ispNameEn = value
        }
        if let value = dict["LocationNameEn"] as? String {
            self.locationNameEn = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDomainTrafficDataResponseBody : Tea.TeaModel {
    public class TrafficDataPerInterval : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var httpTrafficValue: String?

            public var httpsTrafficValue: String?

            public var timeStamp: String?

            public var trafficValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpTrafficValue != nil {
                    map["HttpTrafficValue"] = self.httpTrafficValue!
                }
                if self.httpsTrafficValue != nil {
                    map["HttpsTrafficValue"] = self.httpsTrafficValue!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.trafficValue != nil {
                    map["TrafficValue"] = self.trafficValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["HttpTrafficValue"] as? String {
                    self.httpTrafficValue = value
                }
                if let value = dict["HttpsTrafficValue"] as? String {
                    self.httpsTrafficValue = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["TrafficValue"] as? String {
                    self.trafficValue = value
                }
            }
        }
        public var dataModule: [DescribeLiveDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDomainTrafficDataResponseBody.TrafficDataPerInterval.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var dataInterval: String?

    public var domainName: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var trafficDataPerInterval: DescribeLiveDomainTrafficDataResponseBody.TrafficDataPerInterval?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.trafficDataPerInterval?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.trafficDataPerInterval != nil {
            map["TrafficDataPerInterval"] = self.trafficDataPerInterval?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TrafficDataPerInterval"] as? [String: Any?] {
            var model = DescribeLiveDomainTrafficDataResponseBody.TrafficDataPerInterval()
            model.fromMap(value)
            self.trafficDataPerInterval = model
        }
    }
}

public class DescribeLiveDomainTrafficDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainTrafficDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainTrafficDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDomainTranscodeParamsRequest : Tea.TeaModel {
    public var securityToken: String?

    public var app: String?

    public var pushdomain: String?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.app != nil {
            map["app"] = self.app!
        }
        if self.pushdomain != nil {
            map["pushdomain"] = self.pushdomain!
        }
        if self.templateName != nil {
            map["template_name"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["app"] as? String {
            self.app = value
        }
        if let value = dict["pushdomain"] as? String {
            self.pushdomain = value
        }
        if let value = dict["template_name"] as? String {
            self.templateName = value
        }
    }
}

public class DescribeLiveDomainTranscodeParamsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDomainTranscodeParamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDomainTranscodeParamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDomainTranscodeParamsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveDrmUsageDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var splitBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SplitBy"] as? String {
            self.splitBy = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveDrmUsageDataResponseBody : Tea.TeaModel {
    public class DrmUsageData : Tea.TeaModel {
        public class DataModule : Tea.TeaModel {
            public var count: Int64?

            public var domain: String?

            public var drmType: String?

            public var region: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.drmType != nil {
                    map["DrmType"] = self.drmType!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["DrmType"] as? String {
                    self.drmType = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var dataModule: [DescribeLiveDrmUsageDataResponseBody.DrmUsageData.DataModule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataModule != nil {
                var tmp : [Any] = []
                for k in self.dataModule! {
                    tmp.append(k.toMap())
                }
                map["DataModule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataModule"] as? [Any?] {
                var tmp : [DescribeLiveDrmUsageDataResponseBody.DrmUsageData.DataModule] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveDrmUsageDataResponseBody.DrmUsageData.DataModule()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataModule = tmp
            }
        }
    }
    public var drmUsageData: DescribeLiveDrmUsageDataResponseBody.DrmUsageData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.drmUsageData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.drmUsageData != nil {
            map["DrmUsageData"] = self.drmUsageData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DrmUsageData"] as? [String: Any?] {
            var model = DescribeLiveDrmUsageDataResponseBody.DrmUsageData()
            model.fromMap(value)
            self.drmUsageData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveDrmUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveDrmUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveDrmUsageDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveEdgeTransferRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveEdgeTransferResponseBody : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var httpDns: String?

    public var requestId: String?

    public var streamName: String?

    public var targetDomainList: String?

    public var transferArgs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.httpDns != nil {
            map["HttpDns"] = self.httpDns!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.targetDomainList != nil {
            map["TargetDomainList"] = self.targetDomainList!
        }
        if self.transferArgs != nil {
            map["TransferArgs"] = self.transferArgs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["HttpDns"] as? String {
            self.httpDns = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["TargetDomainList"] as? String {
            self.targetDomainList = value
        }
        if let value = dict["TransferArgs"] as? String {
            self.transferArgs = value
        }
    }
}

public class DescribeLiveEdgeTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveEdgeTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveEdgeTransferResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveGrtnDurationRequest : Tea.TeaModel {
    public var appId: String?

    public var area: String?

    public var endTime: String?

    public var interval: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Area"] as? String {
            self.area = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveGrtnDurationResponseBody : Tea.TeaModel {
    public class StreamDetailData : Tea.TeaModel {
        public class StreamData : Tea.TeaModel {
            public var appId: String?

            public var duration: Int64?

            public var mediaProfile: String?

            public var mediaType: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.mediaProfile != nil {
                    map["MediaProfile"] = self.mediaProfile!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["Duration"] as? Int64 {
                    self.duration = value
                }
                if let value = dict["MediaProfile"] as? String {
                    self.mediaProfile = value
                }
                if let value = dict["MediaType"] as? String {
                    self.mediaType = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var streamData: [DescribeLiveGrtnDurationResponseBody.StreamDetailData.StreamData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamData != nil {
                var tmp : [Any] = []
                for k in self.streamData! {
                    tmp.append(k.toMap())
                }
                map["StreamData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StreamData"] as? [Any?] {
                var tmp : [DescribeLiveGrtnDurationResponseBody.StreamDetailData.StreamData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveGrtnDurationResponseBody.StreamDetailData.StreamData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.streamData = tmp
            }
        }
    }
    public var requestId: String?

    public var streamDetailData: DescribeLiveGrtnDurationResponseBody.StreamDetailData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamDetailData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamDetailData != nil {
            map["StreamDetailData"] = self.streamDetailData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamDetailData"] as? [String: Any?] {
            var model = DescribeLiveGrtnDurationResponseBody.StreamDetailData()
            model.fromMap(value)
            self.streamDetailData = model
        }
    }
}

public class DescribeLiveGrtnDurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveGrtnDurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveGrtnDurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveHttpsDomainListRequest : Tea.TeaModel {
    public var keyword: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveHttpsDomainListResponseBody : Tea.TeaModel {
    public class CertInfos : Tea.TeaModel {
        public class CertInfo : Tea.TeaModel {
            public var certCommonName: String?

            public var certExpireTime: String?

            public var certName: String?

            public var certStartTime: String?

            public var certStatus: String?

            public var certType: String?

            public var certUpdateTime: String?

            public var domainName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certCommonName != nil {
                    map["CertCommonName"] = self.certCommonName!
                }
                if self.certExpireTime != nil {
                    map["CertExpireTime"] = self.certExpireTime!
                }
                if self.certName != nil {
                    map["CertName"] = self.certName!
                }
                if self.certStartTime != nil {
                    map["CertStartTime"] = self.certStartTime!
                }
                if self.certStatus != nil {
                    map["CertStatus"] = self.certStatus!
                }
                if self.certType != nil {
                    map["CertType"] = self.certType!
                }
                if self.certUpdateTime != nil {
                    map["CertUpdateTime"] = self.certUpdateTime!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CertCommonName"] as? String {
                    self.certCommonName = value
                }
                if let value = dict["CertExpireTime"] as? String {
                    self.certExpireTime = value
                }
                if let value = dict["CertName"] as? String {
                    self.certName = value
                }
                if let value = dict["CertStartTime"] as? String {
                    self.certStartTime = value
                }
                if let value = dict["CertStatus"] as? String {
                    self.certStatus = value
                }
                if let value = dict["CertType"] as? String {
                    self.certType = value
                }
                if let value = dict["CertUpdateTime"] as? String {
                    self.certUpdateTime = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
            }
        }
        public var certInfo: [DescribeLiveHttpsDomainListResponseBody.CertInfos.CertInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certInfo != nil {
                var tmp : [Any] = []
                for k in self.certInfo! {
                    tmp.append(k.toMap())
                }
                map["CertInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CertInfo"] as? [Any?] {
                var tmp : [DescribeLiveHttpsDomainListResponseBody.CertInfos.CertInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveHttpsDomainListResponseBody.CertInfos.CertInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.certInfo = tmp
            }
        }
    }
    public var certInfos: DescribeLiveHttpsDomainListResponseBody.CertInfos?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certInfos != nil {
            map["CertInfos"] = self.certInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertInfos"] as? [String: Any?] {
            var model = DescribeLiveHttpsDomainListResponseBody.CertInfos()
            model.fromMap(value)
            self.certInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeLiveHttpsDomainListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveHttpsDomainListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveHttpsDomainListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveInteractionMetricDataRequest : Tea.TeaModel {
    public var appId: String?

    public var beginTs: Int64?

    public var endTs: Int64?

    public var metricType: String?

    public var os: String?

    public var terminalType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.beginTs != nil {
            map["BeginTs"] = self.beginTs!
        }
        if self.endTs != nil {
            map["EndTs"] = self.endTs!
        }
        if self.metricType != nil {
            map["MetricType"] = self.metricType!
        }
        if self.os != nil {
            map["Os"] = self.os!
        }
        if self.terminalType != nil {
            map["TerminalType"] = self.terminalType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BeginTs"] as? Int64 {
            self.beginTs = value
        }
        if let value = dict["EndTs"] as? Int64 {
            self.endTs = value
        }
        if let value = dict["MetricType"] as? String {
            self.metricType = value
        }
        if let value = dict["Os"] as? String {
            self.os = value
        }
        if let value = dict["TerminalType"] as? String {
            self.terminalType = value
        }
    }
}

public class DescribeLiveInteractionMetricDataResponseBody : Tea.TeaModel {
    public class Nodes : Tea.TeaModel {
        public var timestamp: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Timestamp"] as? String {
                self.timestamp = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var nodes: [DescribeLiveInteractionMetricDataResponseBody.Nodes]?

    public var requestId: String?

    public var summaryData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodes != nil {
            var tmp : [Any] = []
            for k in self.nodes! {
                tmp.append(k.toMap())
            }
            map["Nodes"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.summaryData != nil {
            map["SummaryData"] = self.summaryData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Nodes"] as? [Any?] {
            var tmp : [DescribeLiveInteractionMetricDataResponseBody.Nodes] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveInteractionMetricDataResponseBody.Nodes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.nodes = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SummaryData"] as? String {
            self.summaryData = value
        }
    }
}

public class DescribeLiveInteractionMetricDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveInteractionMetricDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveInteractionMetricDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveIpInfoRequest : Tea.TeaModel {
    public var IP: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.IP != nil {
            map["IP"] = self.IP!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IP"] as? String {
            self.IP = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveIpInfoResponseBody : Tea.TeaModel {
    public var ISP: String?

    public var ispEname: String?

    public var region: String?

    public var regionEname: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.ispEname != nil {
            map["IspEname"] = self.ispEname!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionEname != nil {
            map["RegionEname"] = self.regionEname!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ISP"] as? String {
            self.ISP = value
        }
        if let value = dict["IspEname"] as? String {
            self.ispEname = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionEname"] as? String {
            self.regionEname = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveIpInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveIpInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveIpInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveLazyPullStreamConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveLazyPullStreamConfigResponseBody : Tea.TeaModel {
    public class LiveLazyPullConfigList : Tea.TeaModel {
        public class LiveLazyPullConfig : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var pullAppName: String?

            public var pullArgs: String?

            public var pullDomainName: String?

            public var pullProtocol: String?

            public var transcodeLazy: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.pullAppName != nil {
                    map["PullAppName"] = self.pullAppName!
                }
                if self.pullArgs != nil {
                    map["PullArgs"] = self.pullArgs!
                }
                if self.pullDomainName != nil {
                    map["PullDomainName"] = self.pullDomainName!
                }
                if self.pullProtocol != nil {
                    map["PullProtocol"] = self.pullProtocol!
                }
                if self.transcodeLazy != nil {
                    map["TranscodeLazy"] = self.transcodeLazy!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["PullAppName"] as? String {
                    self.pullAppName = value
                }
                if let value = dict["PullArgs"] as? String {
                    self.pullArgs = value
                }
                if let value = dict["PullDomainName"] as? String {
                    self.pullDomainName = value
                }
                if let value = dict["PullProtocol"] as? String {
                    self.pullProtocol = value
                }
                if let value = dict["TranscodeLazy"] as? String {
                    self.transcodeLazy = value
                }
            }
        }
        public var liveLazyPullConfig: [DescribeLiveLazyPullStreamConfigResponseBody.LiveLazyPullConfigList.LiveLazyPullConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveLazyPullConfig != nil {
                var tmp : [Any] = []
                for k in self.liveLazyPullConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveLazyPullConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveLazyPullConfig"] as? [Any?] {
                var tmp : [DescribeLiveLazyPullStreamConfigResponseBody.LiveLazyPullConfigList.LiveLazyPullConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveLazyPullStreamConfigResponseBody.LiveLazyPullConfigList.LiveLazyPullConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveLazyPullConfig = tmp
            }
        }
    }
    public var liveLazyPullConfigList: DescribeLiveLazyPullStreamConfigResponseBody.LiveLazyPullConfigList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveLazyPullConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveLazyPullConfigList != nil {
            map["LiveLazyPullConfigList"] = self.liveLazyPullConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveLazyPullConfigList"] as? [String: Any?] {
            var model = DescribeLiveLazyPullStreamConfigResponseBody.LiveLazyPullConfigList()
            model.fromMap(value)
            self.liveLazyPullConfigList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveLazyPullStreamConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveLazyPullStreamConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveLazyPullStreamConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveMessageAppRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
    }
}

public class DescribeLiveMessageAppResponseBody : Tea.TeaModel {
    public var appId: String?

    public var appKey: String?

    public var appName: String?

    public var appSign: String?

    public var auditType: Int32?

    public var auditUrl: String?

    public var createTime: Int64?

    public var dataCenter: String?

    public var disable: Bool?

    public var eventCallbackUrl: String?

    public var modifyTime: Int64?

    public var msgLifeCycle: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appKey != nil {
            map["AppKey"] = self.appKey!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appSign != nil {
            map["AppSign"] = self.appSign!
        }
        if self.auditType != nil {
            map["AuditType"] = self.auditType!
        }
        if self.auditUrl != nil {
            map["AuditUrl"] = self.auditUrl!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.disable != nil {
            map["Disable"] = self.disable!
        }
        if self.eventCallbackUrl != nil {
            map["EventCallbackUrl"] = self.eventCallbackUrl!
        }
        if self.modifyTime != nil {
            map["ModifyTime"] = self.modifyTime!
        }
        if self.msgLifeCycle != nil {
            map["MsgLifeCycle"] = self.msgLifeCycle!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppKey"] as? String {
            self.appKey = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AppSign"] as? String {
            self.appSign = value
        }
        if let value = dict["AuditType"] as? Int32 {
            self.auditType = value
        }
        if let value = dict["AuditUrl"] as? String {
            self.auditUrl = value
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["Disable"] as? Bool {
            self.disable = value
        }
        if let value = dict["EventCallbackUrl"] as? String {
            self.eventCallbackUrl = value
        }
        if let value = dict["ModifyTime"] as? Int64 {
            self.modifyTime = value
        }
        if let value = dict["MsgLifeCycle"] as? Int32 {
            self.msgLifeCycle = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveMessageAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class DescribeLiveMessageGroupResponseBody : Tea.TeaModel {
    public var adminList: [String]?

    public var createtime: Int64?

    public var creatorId: String?

    public var deletatime: Int64?

    public var delete: Bool?

    public var deletor: String?

    public var groupId: String?

    public var groupInfo: String?

    public var groupName: String?

    public var msgAmount: [String: Int64]?

    public var onlineUserCounts: Int64?

    public var requestId: String?

    public var superLargeGroup: Bool?

    public var totalTimes: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminList != nil {
            map["AdminList"] = self.adminList!
        }
        if self.createtime != nil {
            map["Createtime"] = self.createtime!
        }
        if self.creatorId != nil {
            map["CreatorId"] = self.creatorId!
        }
        if self.deletatime != nil {
            map["Deletatime"] = self.deletatime!
        }
        if self.delete != nil {
            map["Delete"] = self.delete!
        }
        if self.deletor != nil {
            map["Deletor"] = self.deletor!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupInfo != nil {
            map["GroupInfo"] = self.groupInfo!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.msgAmount != nil {
            map["MsgAmount"] = self.msgAmount!
        }
        if self.onlineUserCounts != nil {
            map["OnlineUserCounts"] = self.onlineUserCounts!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.superLargeGroup != nil {
            map["SuperLargeGroup"] = self.superLargeGroup!
        }
        if self.totalTimes != nil {
            map["TotalTimes"] = self.totalTimes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdminList"] as? [String] {
            self.adminList = value
        }
        if let value = dict["Createtime"] as? Int64 {
            self.createtime = value
        }
        if let value = dict["CreatorId"] as? String {
            self.creatorId = value
        }
        if let value = dict["Deletatime"] as? Int64 {
            self.deletatime = value
        }
        if let value = dict["Delete"] as? Bool {
            self.delete = value
        }
        if let value = dict["Deletor"] as? String {
            self.deletor = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupInfo"] as? String {
            self.groupInfo = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["MsgAmount"] as? [String: Int64] {
            self.msgAmount = value
        }
        if let value = dict["OnlineUserCounts"] as? Int64 {
            self.onlineUserCounts = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuperLargeGroup"] as? Bool {
            self.superLargeGroup = value
        }
        if let value = dict["TotalTimes"] as? Int64 {
            self.totalTimes = value
        }
    }
}

public class DescribeLiveMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveMessageGroupBandRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class DescribeLiveMessageGroupBandResponseBody : Tea.TeaModel {
    public var bannedUserList: [String]?

    public var groupId: String?

    public var isbannedAll: Bool?

    public var requestId: String?

    public var unbannedUserList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bannedUserList != nil {
            map["BannedUserList"] = self.bannedUserList!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.isbannedAll != nil {
            map["IsbannedAll"] = self.isbannedAll!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.unbannedUserList != nil {
            map["UnbannedUserList"] = self.unbannedUserList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BannedUserList"] as? [String] {
            self.bannedUserList = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["IsbannedAll"] as? Bool {
            self.isbannedAll = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UnbannedUserList"] as? [String] {
            self.unbannedUserList = value
        }
    }
}

public class DescribeLiveMessageGroupBandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveMessageGroupBandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveMessageGroupBandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLivePackageConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLivePackageConfigResponseBody : Tea.TeaModel {
    public class LivePackageConfigList : Tea.TeaModel {
        public class LivePackageConfig : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var ignoreTranscode: Bool?

            public var partDuration: Int32?

            public var protocol_: String?

            public var segmentDuration: Int32?

            public var segmentNum: Int32?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.ignoreTranscode != nil {
                    map["IgnoreTranscode"] = self.ignoreTranscode!
                }
                if self.partDuration != nil {
                    map["PartDuration"] = self.partDuration!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.segmentDuration != nil {
                    map["SegmentDuration"] = self.segmentDuration!
                }
                if self.segmentNum != nil {
                    map["SegmentNum"] = self.segmentNum!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["IgnoreTranscode"] as? Bool {
                    self.ignoreTranscode = value
                }
                if let value = dict["PartDuration"] as? Int32 {
                    self.partDuration = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["SegmentDuration"] as? Int32 {
                    self.segmentDuration = value
                }
                if let value = dict["SegmentNum"] as? Int32 {
                    self.segmentNum = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
            }
        }
        public var livePackageConfig: [DescribeLivePackageConfigResponseBody.LivePackageConfigList.LivePackageConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.livePackageConfig != nil {
                var tmp : [Any] = []
                for k in self.livePackageConfig! {
                    tmp.append(k.toMap())
                }
                map["LivePackageConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LivePackageConfig"] as? [Any?] {
                var tmp : [DescribeLivePackageConfigResponseBody.LivePackageConfigList.LivePackageConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLivePackageConfigResponseBody.LivePackageConfigList.LivePackageConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.livePackageConfig = tmp
            }
        }
    }
    public var livePackageConfigList: DescribeLivePackageConfigResponseBody.LivePackageConfigList?

    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePackageConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePackageConfigList != nil {
            map["LivePackageConfigList"] = self.livePackageConfigList?.toMap()
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LivePackageConfigList"] as? [String: Any?] {
            var model = DescribeLivePackageConfigResponseBody.LivePackageConfigList()
            model.fromMap(value)
            self.livePackageConfigList = model
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLivePackageConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLivePackageConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLivePackageConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLivePrivateLineAreasRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLivePrivateLineAreasResponseBody : Tea.TeaModel {
    public class LiveAreasList : Tea.TeaModel {
        public class LiveArea : Tea.TeaModel {
            public class Regions : Tea.TeaModel {
                public class Region : Tea.TeaModel {
                    public var localName: String?

                    public var regionId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.localName != nil {
                            map["LocalName"] = self.localName!
                        }
                        if self.regionId != nil {
                            map["RegionId"] = self.regionId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LocalName"] as? String {
                            self.localName = value
                        }
                        if let value = dict["RegionId"] as? String {
                            self.regionId = value
                        }
                    }
                }
                public var region: [DescribeLivePrivateLineAreasResponseBody.LiveAreasList.LiveArea.Regions.Region]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.region != nil {
                        var tmp : [Any] = []
                        for k in self.region! {
                            tmp.append(k.toMap())
                        }
                        map["Region"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Region"] as? [Any?] {
                        var tmp : [DescribeLivePrivateLineAreasResponseBody.LiveAreasList.LiveArea.Regions.Region] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLivePrivateLineAreasResponseBody.LiveAreasList.LiveArea.Regions.Region()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.region = tmp
                    }
                }
            }
            public var regionType: String?

            public var regions: DescribeLivePrivateLineAreasResponseBody.LiveAreasList.LiveArea.Regions?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.regions?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.regionType != nil {
                    map["RegionType"] = self.regionType!
                }
                if self.regions != nil {
                    map["Regions"] = self.regions?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RegionType"] as? String {
                    self.regionType = value
                }
                if let value = dict["Regions"] as? [String: Any?] {
                    var model = DescribeLivePrivateLineAreasResponseBody.LiveAreasList.LiveArea.Regions()
                    model.fromMap(value)
                    self.regions = model
                }
            }
        }
        public var liveArea: [DescribeLivePrivateLineAreasResponseBody.LiveAreasList.LiveArea]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveArea != nil {
                var tmp : [Any] = []
                for k in self.liveArea! {
                    tmp.append(k.toMap())
                }
                map["LiveArea"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveArea"] as? [Any?] {
                var tmp : [DescribeLivePrivateLineAreasResponseBody.LiveAreasList.LiveArea] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLivePrivateLineAreasResponseBody.LiveAreasList.LiveArea()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveArea = tmp
            }
        }
    }
    public var liveAreasList: DescribeLivePrivateLineAreasResponseBody.LiveAreasList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveAreasList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveAreasList != nil {
            map["LiveAreasList"] = self.liveAreasList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveAreasList"] as? [String: Any?] {
            var model = DescribeLivePrivateLineAreasResponseBody.LiveAreasList()
            model.fromMap(value)
            self.liveAreasList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLivePrivateLineAreasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLivePrivateLineAreasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLivePrivateLineAreasResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLivePrivateLineAvailGARequest : Tea.TeaModel {
    public var accelerationArea: String?

    public var appName: String?

    public var domainName: String?

    public var isGaInstance: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public var videoCenter: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerationArea != nil {
            map["AccelerationArea"] = self.accelerationArea!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.isGaInstance != nil {
            map["IsGaInstance"] = self.isGaInstance!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.videoCenter != nil {
            map["VideoCenter"] = self.videoCenter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccelerationArea"] as? String {
            self.accelerationArea = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["IsGaInstance"] as? String {
            self.isGaInstance = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["VideoCenter"] as? String {
            self.videoCenter = value
        }
    }
}

public class DescribeLivePrivateLineAvailGAResponseBody : Tea.TeaModel {
    public class LivePrivateLineAvailGAs : Tea.TeaModel {
        public class LivePrivateLineAvailGA : Tea.TeaModel {
            public var accelerationArea: String?

            public var accelerationType: String?

            public var appName: String?

            public var bindingStatus: String?

            public var domainName: String?

            public var IP: String?

            public var instanceId: String?

            public var status: String?

            public var streamName: String?

            public var uid: String?

            public var videoCenter: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accelerationArea != nil {
                    map["AccelerationArea"] = self.accelerationArea!
                }
                if self.accelerationType != nil {
                    map["AccelerationType"] = self.accelerationType!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.bindingStatus != nil {
                    map["BindingStatus"] = self.bindingStatus!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.IP != nil {
                    map["IP"] = self.IP!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.uid != nil {
                    map["Uid"] = self.uid!
                }
                if self.videoCenter != nil {
                    map["VideoCenter"] = self.videoCenter!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccelerationArea"] as? String {
                    self.accelerationArea = value
                }
                if let value = dict["AccelerationType"] as? String {
                    self.accelerationType = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["BindingStatus"] as? String {
                    self.bindingStatus = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["IP"] as? String {
                    self.IP = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["Uid"] as? String {
                    self.uid = value
                }
                if let value = dict["VideoCenter"] as? String {
                    self.videoCenter = value
                }
            }
        }
        public var livePrivateLineAvailGA: [DescribeLivePrivateLineAvailGAResponseBody.LivePrivateLineAvailGAs.LivePrivateLineAvailGA]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.livePrivateLineAvailGA != nil {
                var tmp : [Any] = []
                for k in self.livePrivateLineAvailGA! {
                    tmp.append(k.toMap())
                }
                map["LivePrivateLineAvailGA"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LivePrivateLineAvailGA"] as? [Any?] {
                var tmp : [DescribeLivePrivateLineAvailGAResponseBody.LivePrivateLineAvailGAs.LivePrivateLineAvailGA] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLivePrivateLineAvailGAResponseBody.LivePrivateLineAvailGAs.LivePrivateLineAvailGA()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.livePrivateLineAvailGA = tmp
            }
        }
    }
    public var livePrivateLineAvailGAs: DescribeLivePrivateLineAvailGAResponseBody.LivePrivateLineAvailGAs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.livePrivateLineAvailGAs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.livePrivateLineAvailGAs != nil {
            map["LivePrivateLineAvailGAs"] = self.livePrivateLineAvailGAs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LivePrivateLineAvailGAs"] as? [String: Any?] {
            var model = DescribeLivePrivateLineAvailGAResponseBody.LivePrivateLineAvailGAs()
            model.fromMap(value)
            self.livePrivateLineAvailGAs = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLivePrivateLineAvailGAResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLivePrivateLineAvailGAResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLivePrivateLineAvailGAResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveProducerUsageDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var instance: String?

    public var interval: String?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var splitBy: String?

    public var startTime: String?

    public var type: String?

    public var app: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instance != nil {
            map["Instance"] = self.instance!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.app != nil {
            map["app"] = self.app!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Instance"] as? String {
            self.instance = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SplitBy"] as? String {
            self.splitBy = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["app"] as? String {
            self.app = value
        }
    }
}

public class DescribeLiveProducerUsageDataResponseBody : Tea.TeaModel {
    public class BillProducerData : Tea.TeaModel {
        public class BillProducerDataItem : Tea.TeaModel {
            public var domainName: String?

            public var instance: String?

            public var outputHdDuration: Int64?

            public var outputLdDuration: Int64?

            public var outputSdDuration: Int64?

            public var region: String?

            public var timeStamp: String?

            public var tranHdDuration: Int64?

            public var tranLdDuration: Int64?

            public var tranSdDuration: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.instance != nil {
                    map["Instance"] = self.instance!
                }
                if self.outputHdDuration != nil {
                    map["OutputHdDuration"] = self.outputHdDuration!
                }
                if self.outputLdDuration != nil {
                    map["OutputLdDuration"] = self.outputLdDuration!
                }
                if self.outputSdDuration != nil {
                    map["OutputSdDuration"] = self.outputSdDuration!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.tranHdDuration != nil {
                    map["TranHdDuration"] = self.tranHdDuration!
                }
                if self.tranLdDuration != nil {
                    map["TranLdDuration"] = self.tranLdDuration!
                }
                if self.tranSdDuration != nil {
                    map["TranSdDuration"] = self.tranSdDuration!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Instance"] as? String {
                    self.instance = value
                }
                if let value = dict["OutputHdDuration"] as? Int64 {
                    self.outputHdDuration = value
                }
                if let value = dict["OutputLdDuration"] as? Int64 {
                    self.outputLdDuration = value
                }
                if let value = dict["OutputSdDuration"] as? Int64 {
                    self.outputSdDuration = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["TranHdDuration"] as? Int64 {
                    self.tranHdDuration = value
                }
                if let value = dict["TranLdDuration"] as? Int64 {
                    self.tranLdDuration = value
                }
                if let value = dict["TranSdDuration"] as? Int64 {
                    self.tranSdDuration = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var billProducerDataItem: [DescribeLiveProducerUsageDataResponseBody.BillProducerData.BillProducerDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.billProducerDataItem != nil {
                var tmp : [Any] = []
                for k in self.billProducerDataItem! {
                    tmp.append(k.toMap())
                }
                map["BillProducerDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BillProducerDataItem"] as? [Any?] {
                var tmp : [DescribeLiveProducerUsageDataResponseBody.BillProducerData.BillProducerDataItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveProducerUsageDataResponseBody.BillProducerData.BillProducerDataItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.billProducerDataItem = tmp
            }
        }
    }
    public var billProducerData: DescribeLiveProducerUsageDataResponseBody.BillProducerData?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.billProducerData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.billProducerData != nil {
            map["BillProducerData"] = self.billProducerData?.toMap()
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BillProducerData"] as? [String: Any?] {
            var model = DescribeLiveProducerUsageDataResponseBody.BillProducerData()
            model.fromMap(value)
            self.billProducerData = model
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveProducerUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveProducerUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveProducerUsageDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLivePullStreamConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLivePullStreamConfigResponseBody : Tea.TeaModel {
    public class LiveAppRecordList : Tea.TeaModel {
        public class LiveAppRecord : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var endTime: String?

            public var sourceUrl: String?

            public var sourceUsing: String?

            public var startTime: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.sourceUrl != nil {
                    map["SourceUrl"] = self.sourceUrl!
                }
                if self.sourceUsing != nil {
                    map["SourceUsing"] = self.sourceUsing!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["SourceUrl"] as? String {
                    self.sourceUrl = value
                }
                if let value = dict["SourceUsing"] as? String {
                    self.sourceUsing = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
            }
        }
        public var liveAppRecord: [DescribeLivePullStreamConfigResponseBody.LiveAppRecordList.LiveAppRecord]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveAppRecord != nil {
                var tmp : [Any] = []
                for k in self.liveAppRecord! {
                    tmp.append(k.toMap())
                }
                map["LiveAppRecord"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveAppRecord"] as? [Any?] {
                var tmp : [DescribeLivePullStreamConfigResponseBody.LiveAppRecordList.LiveAppRecord] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLivePullStreamConfigResponseBody.LiveAppRecordList.LiveAppRecord()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveAppRecord = tmp
            }
        }
    }
    public var liveAppRecordList: DescribeLivePullStreamConfigResponseBody.LiveAppRecordList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveAppRecordList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveAppRecordList != nil {
            map["LiveAppRecordList"] = self.liveAppRecordList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveAppRecordList"] as? [String: Any?] {
            var model = DescribeLivePullStreamConfigResponseBody.LiveAppRecordList()
            model.fromMap(value)
            self.liveAppRecordList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLivePullStreamConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLivePullStreamConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLivePullStreamConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLivePullToPushRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DescribeLivePullToPushResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public var callbackURL: String?

        public var dstUrl: String?

        public var endTime: String?

        public var fileIndex: Int32?

        public var offset: Int32?

        public var repeatNumber: Int32?

        public var retryCount: Int32?

        public var retryInterval: Int32?

        public var sourceProtocol: String?

        public var sourceType: String?

        public var sourceUrls: [String]?

        public var startTime: String?

        public var taskId: String?

        public var taskName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callbackURL != nil {
                map["CallbackURL"] = self.callbackURL!
            }
            if self.dstUrl != nil {
                map["DstUrl"] = self.dstUrl!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.fileIndex != nil {
                map["FileIndex"] = self.fileIndex!
            }
            if self.offset != nil {
                map["Offset"] = self.offset!
            }
            if self.repeatNumber != nil {
                map["RepeatNumber"] = self.repeatNumber!
            }
            if self.retryCount != nil {
                map["RetryCount"] = self.retryCount!
            }
            if self.retryInterval != nil {
                map["RetryInterval"] = self.retryInterval!
            }
            if self.sourceProtocol != nil {
                map["SourceProtocol"] = self.sourceProtocol!
            }
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.sourceUrls != nil {
                map["SourceUrls"] = self.sourceUrls!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CallbackURL"] as? String {
                self.callbackURL = value
            }
            if let value = dict["DstUrl"] as? String {
                self.dstUrl = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["FileIndex"] as? Int32 {
                self.fileIndex = value
            }
            if let value = dict["Offset"] as? Int32 {
                self.offset = value
            }
            if let value = dict["RepeatNumber"] as? Int32 {
                self.repeatNumber = value
            }
            if let value = dict["RetryCount"] as? Int32 {
                self.retryCount = value
            }
            if let value = dict["RetryInterval"] as? Int32 {
                self.retryInterval = value
            }
            if let value = dict["SourceProtocol"] as? String {
                self.sourceProtocol = value
            }
            if let value = dict["SourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["SourceUrls"] as? [String] {
                self.sourceUrls = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskName"] as? String {
                self.taskName = value
            }
        }
    }
    public var currentFileIndex: Int32?

    public var currentOffset: Int32?

    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public var taskExitReason: String?

    public var taskExitTime: Int32?

    public var taskId: String?

    public var taskInfo: DescribeLivePullToPushResponseBody.TaskInfo?

    public var taskInvalidReason: String?

    public var taskStatus: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentFileIndex != nil {
            map["CurrentFileIndex"] = self.currentFileIndex!
        }
        if self.currentOffset != nil {
            map["CurrentOffset"] = self.currentOffset!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        if self.taskExitReason != nil {
            map["TaskExitReason"] = self.taskExitReason!
        }
        if self.taskExitTime != nil {
            map["TaskExitTime"] = self.taskExitTime!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        if self.taskInvalidReason != nil {
            map["TaskInvalidReason"] = self.taskInvalidReason!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CurrentFileIndex"] as? Int32 {
            self.currentFileIndex = value
        }
        if let value = dict["CurrentOffset"] as? Int32 {
            self.currentOffset = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetCode"] as? Int32 {
            self.retCode = value
        }
        if let value = dict["TaskExitReason"] as? String {
            self.taskExitReason = value
        }
        if let value = dict["TaskExitTime"] as? Int32 {
            self.taskExitTime = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TaskInfo"] as? [String: Any?] {
            var model = DescribeLivePullToPushResponseBody.TaskInfo()
            model.fromMap(value)
            self.taskInfo = model
        }
        if let value = dict["TaskInvalidReason"] as? String {
            self.taskInvalidReason = value
        }
        if let value = dict["TaskStatus"] as? Int32 {
            self.taskStatus = value
        }
    }
}

public class DescribeLivePullToPushResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLivePullToPushResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLivePullToPushResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLivePullToPushListRequest : Tea.TeaModel {
    public var dstUrl: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var regionId: String?

    public var taskId: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dstUrl != nil {
            map["DstUrl"] = self.dstUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DstUrl"] as? String {
            self.dstUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class DescribeLivePullToPushListResponseBody : Tea.TeaModel {
    public class TaskList : Tea.TeaModel {
        public class TaskInfo : Tea.TeaModel {
            public var callbackURL: String?

            public var dstUrl: String?

            public var endTime: String?

            public var fileIndex: Int32?

            public var offset: Int32?

            public var repeatNumber: Int32?

            public var retryCount: Int32?

            public var retryInterval: Int32?

            public var sourceProtocol: String?

            public var sourceType: String?

            public var sourceUrls: [String]?

            public var startTime: String?

            public var taskId: String?

            public var taskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callbackURL != nil {
                    map["CallbackURL"] = self.callbackURL!
                }
                if self.dstUrl != nil {
                    map["DstUrl"] = self.dstUrl!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.fileIndex != nil {
                    map["FileIndex"] = self.fileIndex!
                }
                if self.offset != nil {
                    map["Offset"] = self.offset!
                }
                if self.repeatNumber != nil {
                    map["RepeatNumber"] = self.repeatNumber!
                }
                if self.retryCount != nil {
                    map["RetryCount"] = self.retryCount!
                }
                if self.retryInterval != nil {
                    map["RetryInterval"] = self.retryInterval!
                }
                if self.sourceProtocol != nil {
                    map["SourceProtocol"] = self.sourceProtocol!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.sourceUrls != nil {
                    map["SourceUrls"] = self.sourceUrls!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CallbackURL"] as? String {
                    self.callbackURL = value
                }
                if let value = dict["DstUrl"] as? String {
                    self.dstUrl = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["FileIndex"] as? Int32 {
                    self.fileIndex = value
                }
                if let value = dict["Offset"] as? Int32 {
                    self.offset = value
                }
                if let value = dict["RepeatNumber"] as? Int32 {
                    self.repeatNumber = value
                }
                if let value = dict["RetryCount"] as? Int32 {
                    self.retryCount = value
                }
                if let value = dict["RetryInterval"] as? Int32 {
                    self.retryInterval = value
                }
                if let value = dict["SourceProtocol"] as? String {
                    self.sourceProtocol = value
                }
                if let value = dict["SourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["SourceUrls"] as? [String] {
                    self.sourceUrls = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
                if let value = dict["TaskName"] as? String {
                    self.taskName = value
                }
            }
        }
        public var currentFileIndex: Int32?

        public var currentOffset: Int32?

        public var taskExitReason: String?

        public var taskExitTime: Int32?

        public var taskId: String?

        public var taskInfo: DescribeLivePullToPushListResponseBody.TaskList.TaskInfo?

        public var taskInvalidReason: String?

        public var taskStatus: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.taskInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentFileIndex != nil {
                map["CurrentFileIndex"] = self.currentFileIndex!
            }
            if self.currentOffset != nil {
                map["CurrentOffset"] = self.currentOffset!
            }
            if self.taskExitReason != nil {
                map["TaskExitReason"] = self.taskExitReason!
            }
            if self.taskExitTime != nil {
                map["TaskExitTime"] = self.taskExitTime!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskInfo != nil {
                map["TaskInfo"] = self.taskInfo?.toMap()
            }
            if self.taskInvalidReason != nil {
                map["TaskInvalidReason"] = self.taskInvalidReason!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentFileIndex"] as? Int32 {
                self.currentFileIndex = value
            }
            if let value = dict["CurrentOffset"] as? Int32 {
                self.currentOffset = value
            }
            if let value = dict["TaskExitReason"] as? String {
                self.taskExitReason = value
            }
            if let value = dict["TaskExitTime"] as? Int32 {
                self.taskExitTime = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskInfo"] as? [String: Any?] {
                var model = DescribeLivePullToPushListResponseBody.TaskList.TaskInfo()
                model.fromMap(value)
                self.taskInfo = model
            }
            if let value = dict["TaskInvalidReason"] as? String {
                self.taskInvalidReason = value
            }
            if let value = dict["TaskStatus"] as? Int32 {
                self.taskStatus = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var taskList: [DescribeLivePullToPushListResponseBody.TaskList]?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskList != nil {
            var tmp : [Any] = []
            for k in self.taskList! {
                tmp.append(k.toMap())
            }
            map["TaskList"] = tmp
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskList"] as? [Any?] {
            var tmp : [DescribeLivePullToPushListResponseBody.TaskList] = []
            for v in value {
                if v != nil {
                    var model = DescribeLivePullToPushListResponseBody.TaskList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.taskList = tmp
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeLivePullToPushListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLivePullToPushListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLivePullToPushListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLivePushProxyLogRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLivePushProxyLogResponseBody : Tea.TeaModel {
    public class DomainLogDetails : Tea.TeaModel {
        public class DomainLogDetail : Tea.TeaModel {
            public class LogInfos : Tea.TeaModel {
                public class LogInfoDetail : Tea.TeaModel {
                    public var endTime: String?

                    public var logName: String?

                    public var logPath: String?

                    public var logSize: Int64?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.logName != nil {
                            map["LogName"] = self.logName!
                        }
                        if self.logPath != nil {
                            map["LogPath"] = self.logPath!
                        }
                        if self.logSize != nil {
                            map["LogSize"] = self.logSize!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["LogName"] as? String {
                            self.logName = value
                        }
                        if let value = dict["LogPath"] as? String {
                            self.logPath = value
                        }
                        if let value = dict["LogSize"] as? Int64 {
                            self.logSize = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                    }
                }
                public var logInfoDetail: [DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logInfoDetail != nil {
                        var tmp : [Any] = []
                        for k in self.logInfoDetail! {
                            tmp.append(k.toMap())
                        }
                        map["LogInfoDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LogInfoDetail"] as? [Any?] {
                        var tmp : [DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.logInfoDetail = tmp
                    }
                }
            }
            public class PageInfos : Tea.TeaModel {
                public var pageIndex: Int64?

                public var pageSize: Int64?

                public var total: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pageIndex != nil {
                        map["PageIndex"] = self.pageIndex!
                    }
                    if self.pageSize != nil {
                        map["PageSize"] = self.pageSize!
                    }
                    if self.total != nil {
                        map["Total"] = self.total!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PageIndex"] as? Int64 {
                        self.pageIndex = value
                    }
                    if let value = dict["PageSize"] as? Int64 {
                        self.pageSize = value
                    }
                    if let value = dict["Total"] as? Int64 {
                        self.total = value
                    }
                }
            }
            public var logCount: Int64?

            public var logInfos: DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos?

            public var pageInfos: DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.logInfos?.validate()
                try self.pageInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.logInfos != nil {
                    map["LogInfos"] = self.logInfos?.toMap()
                }
                if self.pageInfos != nil {
                    map["PageInfos"] = self.pageInfos?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LogCount"] as? Int64 {
                    self.logCount = value
                }
                if let value = dict["LogInfos"] as? [String: Any?] {
                    var model = DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos()
                    model.fromMap(value)
                    self.logInfos = model
                }
                if let value = dict["PageInfos"] as? [String: Any?] {
                    var model = DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos()
                    model.fromMap(value)
                    self.pageInfos = model
                }
            }
        }
        public var domainLogDetail: [DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLogDetail != nil {
                var tmp : [Any] = []
                for k in self.domainLogDetail! {
                    tmp.append(k.toMap())
                }
                map["DomainLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainLogDetail"] as? [Any?] {
                var tmp : [DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLivePushProxyLogResponseBody.DomainLogDetails.DomainLogDetail()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainLogDetail = tmp
            }
        }
    }
    public var domainLogDetails: DescribeLivePushProxyLogResponseBody.DomainLogDetails?

    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogDetails != nil {
            map["DomainLogDetails"] = self.domainLogDetails?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainLogDetails"] as? [String: Any?] {
            var model = DescribeLivePushProxyLogResponseBody.DomainLogDetails()
            model.fromMap(value)
            self.domainLogDetails = model
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLivePushProxyLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLivePushProxyLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLivePushProxyLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLivePushProxyUsageDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var splitBy: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.splitBy != nil {
            map["SplitBy"] = self.splitBy!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SplitBy"] as? String {
            self.splitBy = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLivePushProxyUsageDataResponseBody : Tea.TeaModel {
    public class PushProxyData : Tea.TeaModel {
        public class PushProxyDataItem : Tea.TeaModel {
            public var domainName: String?

            public var region: String?

            public var streamCount: Int64?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.streamCount != nil {
                    map["StreamCount"] = self.streamCount!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["StreamCount"] as? Int64 {
                    self.streamCount = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var pushProxyDataItem: [DescribeLivePushProxyUsageDataResponseBody.PushProxyData.PushProxyDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pushProxyDataItem != nil {
                var tmp : [Any] = []
                for k in self.pushProxyDataItem! {
                    tmp.append(k.toMap())
                }
                map["PushProxyDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PushProxyDataItem"] as? [Any?] {
                var tmp : [DescribeLivePushProxyUsageDataResponseBody.PushProxyData.PushProxyDataItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLivePushProxyUsageDataResponseBody.PushProxyData.PushProxyDataItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.pushProxyDataItem = tmp
            }
        }
    }
    public var endTime: String?

    public var pushProxyData: DescribeLivePushProxyUsageDataResponseBody.PushProxyData?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pushProxyData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pushProxyData != nil {
            map["PushProxyData"] = self.pushProxyData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PushProxyData"] as? [String: Any?] {
            var model = DescribeLivePushProxyUsageDataResponseBody.PushProxyData()
            model.fromMap(value)
            self.pushProxyData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLivePushProxyUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLivePushProxyUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLivePushProxyUsageDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveRealtimeDeliveryAccRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var interval: String?

    public var logStore: String?

    public var ownerId: Int64?

    public var project: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.logStore != nil {
            map["LogStore"] = self.logStore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["LogStore"] as? String {
            self.logStore = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Project"] as? String {
            self.project = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveRealtimeDeliveryAccResponseBody : Tea.TeaModel {
    public class RealTimeDeliveryAccData : Tea.TeaModel {
        public class AccData : Tea.TeaModel {
            public var failedNum: Int32?

            public var successNum: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.failedNum != nil {
                    map["FailedNum"] = self.failedNum!
                }
                if self.successNum != nil {
                    map["SuccessNum"] = self.successNum!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FailedNum"] as? Int32 {
                    self.failedNum = value
                }
                if let value = dict["SuccessNum"] as? Int32 {
                    self.successNum = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var accData: [DescribeLiveRealtimeDeliveryAccResponseBody.RealTimeDeliveryAccData.AccData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accData != nil {
                var tmp : [Any] = []
                for k in self.accData! {
                    tmp.append(k.toMap())
                }
                map["AccData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccData"] as? [Any?] {
                var tmp : [DescribeLiveRealtimeDeliveryAccResponseBody.RealTimeDeliveryAccData.AccData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveRealtimeDeliveryAccResponseBody.RealTimeDeliveryAccData.AccData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.accData = tmp
            }
        }
    }
    public var realTimeDeliveryAccData: DescribeLiveRealtimeDeliveryAccResponseBody.RealTimeDeliveryAccData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.realTimeDeliveryAccData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.realTimeDeliveryAccData != nil {
            map["RealTimeDeliveryAccData"] = self.realTimeDeliveryAccData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RealTimeDeliveryAccData"] as? [String: Any?] {
            var model = DescribeLiveRealtimeDeliveryAccResponseBody.RealTimeDeliveryAccData()
            model.fromMap(value)
            self.realTimeDeliveryAccData = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveRealtimeDeliveryAccResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRealtimeDeliveryAccResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveRealtimeDeliveryAccResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveRealtimeLogAuthorizedRequest : Tea.TeaModel {
    public var liveOpenapiReserve: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveOpenapiReserve != nil {
            map["LiveOpenapiReserve"] = self.liveOpenapiReserve!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveOpenapiReserve"] as? String {
            self.liveOpenapiReserve = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveRealtimeLogAuthorizedResponseBody : Tea.TeaModel {
    public var authorizedStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizedStatus != nil {
            map["AuthorizedStatus"] = self.authorizedStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthorizedStatus"] as? String {
            self.authorizedStatus = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveRealtimeLogAuthorizedResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRealtimeLogAuthorizedResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveRealtimeLogAuthorizedResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveRecordConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveRecordConfigResponseBody : Tea.TeaModel {
    public class LiveAppRecordList : Tea.TeaModel {
        public class LiveAppRecord : Tea.TeaModel {
            public class RecordFormatList : Tea.TeaModel {
                public class RecordFormat : Tea.TeaModel {
                    public var cycleDuration: Int32?

                    public var format: String?

                    public var ossObjectPrefix: String?

                    public var sliceDuration: Int32?

                    public var sliceOssObjectPrefix: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleDuration != nil {
                            map["CycleDuration"] = self.cycleDuration!
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.ossObjectPrefix != nil {
                            map["OssObjectPrefix"] = self.ossObjectPrefix!
                        }
                        if self.sliceDuration != nil {
                            map["SliceDuration"] = self.sliceDuration!
                        }
                        if self.sliceOssObjectPrefix != nil {
                            map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CycleDuration"] as? Int32 {
                            self.cycleDuration = value
                        }
                        if let value = dict["Format"] as? String {
                            self.format = value
                        }
                        if let value = dict["OssObjectPrefix"] as? String {
                            self.ossObjectPrefix = value
                        }
                        if let value = dict["SliceDuration"] as? Int32 {
                            self.sliceDuration = value
                        }
                        if let value = dict["SliceOssObjectPrefix"] as? String {
                            self.sliceOssObjectPrefix = value
                        }
                    }
                }
                public var recordFormat: [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.RecordFormatList.RecordFormat]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recordFormat != nil {
                        var tmp : [Any] = []
                        for k in self.recordFormat! {
                            tmp.append(k.toMap())
                        }
                        map["RecordFormat"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RecordFormat"] as? [Any?] {
                        var tmp : [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.RecordFormatList.RecordFormat] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.RecordFormatList.RecordFormat()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.recordFormat = tmp
                    }
                }
            }
            public class TranscodeRecordFormatList : Tea.TeaModel {
                public class RecordFormat : Tea.TeaModel {
                    public var cycleDuration: Int32?

                    public var format: String?

                    public var ossObjectPrefix: String?

                    public var sliceDuration: Int32?

                    public var sliceOssObjectPrefix: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cycleDuration != nil {
                            map["CycleDuration"] = self.cycleDuration!
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.ossObjectPrefix != nil {
                            map["OssObjectPrefix"] = self.ossObjectPrefix!
                        }
                        if self.sliceDuration != nil {
                            map["SliceDuration"] = self.sliceDuration!
                        }
                        if self.sliceOssObjectPrefix != nil {
                            map["SliceOssObjectPrefix"] = self.sliceOssObjectPrefix!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CycleDuration"] as? Int32 {
                            self.cycleDuration = value
                        }
                        if let value = dict["Format"] as? String {
                            self.format = value
                        }
                        if let value = dict["OssObjectPrefix"] as? String {
                            self.ossObjectPrefix = value
                        }
                        if let value = dict["SliceDuration"] as? Int32 {
                            self.sliceDuration = value
                        }
                        if let value = dict["SliceOssObjectPrefix"] as? String {
                            self.sliceOssObjectPrefix = value
                        }
                    }
                }
                public var recordFormat: [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeRecordFormatList.RecordFormat]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recordFormat != nil {
                        var tmp : [Any] = []
                        for k in self.recordFormat! {
                            tmp.append(k.toMap())
                        }
                        map["RecordFormat"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RecordFormat"] as? [Any?] {
                        var tmp : [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeRecordFormatList.RecordFormat] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeRecordFormatList.RecordFormat()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.recordFormat = tmp
                    }
                }
            }
            public class TranscodeTemplates : Tea.TeaModel {
                public var templates: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.templates != nil {
                        map["Templates"] = self.templates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Templates"] as? [String] {
                        self.templates = value
                    }
                }
            }
            public var appName: String?

            public var createTime: String?

            public var delayTime: Int32?

            public var domainName: String?

            public var endTime: String?

            public var onDemond: Int32?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var recordFormatList: DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.RecordFormatList?

            public var startTime: String?

            public var streamName: String?

            public var transcodeRecordFormatList: DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeRecordFormatList?

            public var transcodeTemplates: DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeTemplates?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.recordFormatList?.validate()
                try self.transcodeRecordFormatList?.validate()
                try self.transcodeTemplates?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.delayTime != nil {
                    map["DelayTime"] = self.delayTime!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.onDemond != nil {
                    map["OnDemond"] = self.onDemond!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.recordFormatList != nil {
                    map["RecordFormatList"] = self.recordFormatList?.toMap()
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.transcodeRecordFormatList != nil {
                    map["TranscodeRecordFormatList"] = self.transcodeRecordFormatList?.toMap()
                }
                if self.transcodeTemplates != nil {
                    map["TranscodeTemplates"] = self.transcodeTemplates?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DelayTime"] as? Int32 {
                    self.delayTime = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["OnDemond"] as? Int32 {
                    self.onDemond = value
                }
                if let value = dict["OssBucket"] as? String {
                    self.ossBucket = value
                }
                if let value = dict["OssEndpoint"] as? String {
                    self.ossEndpoint = value
                }
                if let value = dict["RecordFormatList"] as? [String: Any?] {
                    var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.RecordFormatList()
                    model.fromMap(value)
                    self.recordFormatList = model
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["TranscodeRecordFormatList"] as? [String: Any?] {
                    var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeRecordFormatList()
                    model.fromMap(value)
                    self.transcodeRecordFormatList = model
                }
                if let value = dict["TranscodeTemplates"] as? [String: Any?] {
                    var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord.TranscodeTemplates()
                    model.fromMap(value)
                    self.transcodeTemplates = model
                }
            }
        }
        public var liveAppRecord: [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveAppRecord != nil {
                var tmp : [Any] = []
                for k in self.liveAppRecord! {
                    tmp.append(k.toMap())
                }
                map["LiveAppRecord"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveAppRecord"] as? [Any?] {
                var tmp : [DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList.LiveAppRecord()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveAppRecord = tmp
            }
        }
    }
    public var liveAppRecordList: DescribeLiveRecordConfigResponseBody.LiveAppRecordList?

    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveAppRecordList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveAppRecordList != nil {
            map["LiveAppRecordList"] = self.liveAppRecordList?.toMap()
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveAppRecordList"] as? [String: Any?] {
            var model = DescribeLiveRecordConfigResponseBody.LiveAppRecordList()
            model.fromMap(value)
            self.liveAppRecordList = model
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveRecordConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRecordConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveRecordConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveRecordNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeLiveRecordNotifyConfigResponseBody : Tea.TeaModel {
    public class LiveRecordNotifyConfig : Tea.TeaModel {
        public var domainName: String?

        public var needStatusNotify: Bool?

        public var notifyAuthKey: String?

        public var notifyReqAuth: Bool?

        public var notifyUrl: String?

        public var onDemandUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.needStatusNotify != nil {
                map["NeedStatusNotify"] = self.needStatusNotify!
            }
            if self.notifyAuthKey != nil {
                map["NotifyAuthKey"] = self.notifyAuthKey!
            }
            if self.notifyReqAuth != nil {
                map["NotifyReqAuth"] = self.notifyReqAuth!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.onDemandUrl != nil {
                map["OnDemandUrl"] = self.onDemandUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["NeedStatusNotify"] as? Bool {
                self.needStatusNotify = value
            }
            if let value = dict["NotifyAuthKey"] as? String {
                self.notifyAuthKey = value
            }
            if let value = dict["NotifyReqAuth"] as? Bool {
                self.notifyReqAuth = value
            }
            if let value = dict["NotifyUrl"] as? String {
                self.notifyUrl = value
            }
            if let value = dict["OnDemandUrl"] as? String {
                self.onDemandUrl = value
            }
        }
    }
    public var liveRecordNotifyConfig: DescribeLiveRecordNotifyConfigResponseBody.LiveRecordNotifyConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveRecordNotifyConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordNotifyConfig != nil {
            map["LiveRecordNotifyConfig"] = self.liveRecordNotifyConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveRecordNotifyConfig"] as? [String: Any?] {
            var model = DescribeLiveRecordNotifyConfigResponseBody.LiveRecordNotifyConfig()
            model.fromMap(value)
            self.liveRecordNotifyConfig = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveRecordNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRecordNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveRecordNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveRecordNotifyRecordsRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var startTime: String?

    public var status: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveRecordNotifyRecordsResponseBody : Tea.TeaModel {
    public class CallbackList : Tea.TeaModel {
        public var appName: String?

        public var description_: String?

        public var domainName: String?

        public var notifyContent: String?

        public var notifyHeader: String?

        public var notifyResponse: String?

        public var notifyResult: String?

        public var notifyTime: String?

        public var notifyType: String?

        public var notifyUrl: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.notifyContent != nil {
                map["NotifyContent"] = self.notifyContent!
            }
            if self.notifyHeader != nil {
                map["NotifyHeader"] = self.notifyHeader!
            }
            if self.notifyResponse != nil {
                map["NotifyResponse"] = self.notifyResponse!
            }
            if self.notifyResult != nil {
                map["NotifyResult"] = self.notifyResult!
            }
            if self.notifyTime != nil {
                map["NotifyTime"] = self.notifyTime!
            }
            if self.notifyType != nil {
                map["NotifyType"] = self.notifyType!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["NotifyContent"] as? String {
                self.notifyContent = value
            }
            if let value = dict["NotifyHeader"] as? String {
                self.notifyHeader = value
            }
            if let value = dict["NotifyResponse"] as? String {
                self.notifyResponse = value
            }
            if let value = dict["NotifyResult"] as? String {
                self.notifyResult = value
            }
            if let value = dict["NotifyTime"] as? String {
                self.notifyTime = value
            }
            if let value = dict["NotifyType"] as? String {
                self.notifyType = value
            }
            if let value = dict["NotifyUrl"] as? String {
                self.notifyUrl = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
        }
    }
    public var callbackList: [DescribeLiveRecordNotifyRecordsResponseBody.CallbackList]?

    public var code: Int32?

    public var msg: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackList != nil {
            var tmp : [Any] = []
            for k in self.callbackList! {
                tmp.append(k.toMap())
            }
            map["CallbackList"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallbackList"] as? [Any?] {
            var tmp : [DescribeLiveRecordNotifyRecordsResponseBody.CallbackList] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveRecordNotifyRecordsResponseBody.CallbackList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.callbackList = tmp
        }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Msg"] as? String {
            self.msg = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveRecordNotifyRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRecordNotifyRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveRecordNotifyRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveRecordVodConfigsRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var pageNum: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int64 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveRecordVodConfigsResponseBody : Tea.TeaModel {
    public class LiveRecordVodConfigs : Tea.TeaModel {
        public class LiveRecordVodConfig : Tea.TeaModel {
            public var appName: String?

            public var autoCompose: String?

            public var composeVodTranscodeGroupId: String?

            public var createTime: String?

            public var cycleDuration: Int32?

            public var domainName: String?

            public var onDemand: Int32?

            public var storageLocation: String?

            public var streamName: String?

            public var vodTranscodeGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.autoCompose != nil {
                    map["AutoCompose"] = self.autoCompose!
                }
                if self.composeVodTranscodeGroupId != nil {
                    map["ComposeVodTranscodeGroupId"] = self.composeVodTranscodeGroupId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.cycleDuration != nil {
                    map["CycleDuration"] = self.cycleDuration!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.onDemand != nil {
                    map["OnDemand"] = self.onDemand!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.vodTranscodeGroupId != nil {
                    map["VodTranscodeGroupId"] = self.vodTranscodeGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["AutoCompose"] as? String {
                    self.autoCompose = value
                }
                if let value = dict["ComposeVodTranscodeGroupId"] as? String {
                    self.composeVodTranscodeGroupId = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CycleDuration"] as? Int32 {
                    self.cycleDuration = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["OnDemand"] as? Int32 {
                    self.onDemand = value
                }
                if let value = dict["StorageLocation"] as? String {
                    self.storageLocation = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["VodTranscodeGroupId"] as? String {
                    self.vodTranscodeGroupId = value
                }
            }
        }
        public var liveRecordVodConfig: [DescribeLiveRecordVodConfigsResponseBody.LiveRecordVodConfigs.LiveRecordVodConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveRecordVodConfig != nil {
                var tmp : [Any] = []
                for k in self.liveRecordVodConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveRecordVodConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveRecordVodConfig"] as? [Any?] {
                var tmp : [DescribeLiveRecordVodConfigsResponseBody.LiveRecordVodConfigs.LiveRecordVodConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveRecordVodConfigsResponseBody.LiveRecordVodConfigs.LiveRecordVodConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveRecordVodConfig = tmp
            }
        }
    }
    public var liveRecordVodConfigs: DescribeLiveRecordVodConfigsResponseBody.LiveRecordVodConfigs?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveRecordVodConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveRecordVodConfigs != nil {
            map["LiveRecordVodConfigs"] = self.liveRecordVodConfigs?.toMap()
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveRecordVodConfigs"] as? [String: Any?] {
            var model = DescribeLiveRecordVodConfigsResponseBody.LiveRecordVodConfigs()
            model.fromMap(value)
            self.liveRecordVodConfigs = model
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? String {
            self.total = value
        }
    }
}

public class DescribeLiveRecordVodConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRecordVodConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveRecordVodConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveRtcRecordUsageDataRequest : Tea.TeaModel {
    public var appId: String?

    public var endTime: String?

    public var interval: String?

    public var recordMode: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.recordMode != nil {
            map["RecordMode"] = self.recordMode!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["RecordMode"] as? String {
            self.recordMode = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveRtcRecordUsageDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var audioDuration: Double?

        public var timestamp: String?

        public var totalDuration: Double?

        public var v1080Duration: Double?

        public var v480Duration: Double?

        public var v720Duration: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioDuration != nil {
                map["AudioDuration"] = self.audioDuration!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalDuration != nil {
                map["TotalDuration"] = self.totalDuration!
            }
            if self.v1080Duration != nil {
                map["V1080Duration"] = self.v1080Duration!
            }
            if self.v480Duration != nil {
                map["V480Duration"] = self.v480Duration!
            }
            if self.v720Duration != nil {
                map["V720Duration"] = self.v720Duration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AudioDuration"] as? Double {
                self.audioDuration = value
            }
            if let value = dict["Timestamp"] as? String {
                self.timestamp = value
            }
            if let value = dict["TotalDuration"] as? Double {
                self.totalDuration = value
            }
            if let value = dict["V1080Duration"] as? Double {
                self.v1080Duration = value
            }
            if let value = dict["V480Duration"] as? Double {
                self.v480Duration = value
            }
            if let value = dict["V720Duration"] as? Double {
                self.v720Duration = value
            }
        }
    }
    public var appId: String?

    public var audioSummaryDuration: Double?

    public var data: [DescribeLiveRtcRecordUsageDataResponseBody.Data]?

    public var recordMode: String?

    public var requestId: String?

    public var totalSummaryDuration: Double?

    public var v1080SummaryDuration: Double?

    public var v480SummaryDuration: Double?

    public var v720SummaryDuration: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.audioSummaryDuration != nil {
            map["AudioSummaryDuration"] = self.audioSummaryDuration!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.recordMode != nil {
            map["RecordMode"] = self.recordMode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalSummaryDuration != nil {
            map["TotalSummaryDuration"] = self.totalSummaryDuration!
        }
        if self.v1080SummaryDuration != nil {
            map["V1080SummaryDuration"] = self.v1080SummaryDuration!
        }
        if self.v480SummaryDuration != nil {
            map["V480SummaryDuration"] = self.v480SummaryDuration!
        }
        if self.v720SummaryDuration != nil {
            map["V720SummaryDuration"] = self.v720SummaryDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AudioSummaryDuration"] as? Double {
            self.audioSummaryDuration = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeLiveRtcRecordUsageDataResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveRtcRecordUsageDataResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["RecordMode"] as? String {
            self.recordMode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalSummaryDuration"] as? Double {
            self.totalSummaryDuration = value
        }
        if let value = dict["V1080SummaryDuration"] as? Double {
            self.v1080SummaryDuration = value
        }
        if let value = dict["V480SummaryDuration"] as? Double {
            self.v480SummaryDuration = value
        }
        if let value = dict["V720SummaryDuration"] as? Double {
            self.v720SummaryDuration = value
        }
    }
}

public class DescribeLiveRtcRecordUsageDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveRtcRecordUsageDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveRtcRecordUsageDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveShiftConfigsRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveShiftConfigsResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class Config : Tea.TeaModel {
            public var appName: String?

            public var domainName: String?

            public var ignoreTranscode: Bool?

            public var streamName: String?

            public var vision: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.ignoreTranscode != nil {
                    map["IgnoreTranscode"] = self.ignoreTranscode!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.vision != nil {
                    map["Vision"] = self.vision!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["IgnoreTranscode"] as? Bool {
                    self.ignoreTranscode = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["Vision"] as? Int32 {
                    self.vision = value
                }
            }
        }
        public var config: [DescribeLiveShiftConfigsResponseBody.Content.Config]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                var tmp : [Any] = []
                for k in self.config! {
                    tmp.append(k.toMap())
                }
                map["Config"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Config"] as? [Any?] {
                var tmp : [DescribeLiveShiftConfigsResponseBody.Content.Config] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveShiftConfigsResponseBody.Content.Config()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.config = tmp
            }
        }
    }
    public var content: DescribeLiveShiftConfigsResponseBody.Content?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? [String: Any?] {
            var model = DescribeLiveShiftConfigsResponseBody.Content()
            model.fromMap(value)
            self.content = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveShiftConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveShiftConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveShiftConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveSnapshotConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeLiveSnapshotConfigResponseBody : Tea.TeaModel {
    public class LiveStreamSnapshotConfigList : Tea.TeaModel {
        public class LiveStreamSnapshotConfig : Tea.TeaModel {
            public var appName: String?

            public var callback: String?

            public var createTime: String?

            public var domainName: String?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var overwriteOssObject: String?

            public var sequenceOssObject: String?

            public var timeInterval: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.callback != nil {
                    map["Callback"] = self.callback!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.overwriteOssObject != nil {
                    map["OverwriteOssObject"] = self.overwriteOssObject!
                }
                if self.sequenceOssObject != nil {
                    map["SequenceOssObject"] = self.sequenceOssObject!
                }
                if self.timeInterval != nil {
                    map["TimeInterval"] = self.timeInterval!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["Callback"] as? String {
                    self.callback = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["OssBucket"] as? String {
                    self.ossBucket = value
                }
                if let value = dict["OssEndpoint"] as? String {
                    self.ossEndpoint = value
                }
                if let value = dict["OverwriteOssObject"] as? String {
                    self.overwriteOssObject = value
                }
                if let value = dict["SequenceOssObject"] as? String {
                    self.sequenceOssObject = value
                }
                if let value = dict["TimeInterval"] as? Int32 {
                    self.timeInterval = value
                }
            }
        }
        public var liveStreamSnapshotConfig: [DescribeLiveSnapshotConfigResponseBody.LiveStreamSnapshotConfigList.LiveStreamSnapshotConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamSnapshotConfig != nil {
                var tmp : [Any] = []
                for k in self.liveStreamSnapshotConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamSnapshotConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveStreamSnapshotConfig"] as? [Any?] {
                var tmp : [DescribeLiveSnapshotConfigResponseBody.LiveStreamSnapshotConfigList.LiveStreamSnapshotConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveSnapshotConfigResponseBody.LiveStreamSnapshotConfigList.LiveStreamSnapshotConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveStreamSnapshotConfig = tmp
            }
        }
    }
    public var liveStreamSnapshotConfigList: DescribeLiveSnapshotConfigResponseBody.LiveStreamSnapshotConfigList?

    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamSnapshotConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamSnapshotConfigList != nil {
            map["LiveStreamSnapshotConfigList"] = self.liveStreamSnapshotConfigList?.toMap()
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveStreamSnapshotConfigList"] as? [String: Any?] {
            var model = DescribeLiveSnapshotConfigResponseBody.LiveStreamSnapshotConfigList()
            model.fromMap(value)
            self.liveStreamSnapshotConfigList = model
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveSnapshotConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveSnapshotConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveSnapshotConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveSnapshotDetectPornConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeLiveSnapshotDetectPornConfigResponseBody : Tea.TeaModel {
    public class LiveSnapshotDetectPornConfigList : Tea.TeaModel {
        public class LiveSnapshotDetectPornConfig : Tea.TeaModel {
            public class Scenes : Tea.TeaModel {
                public var scene: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.scene != nil {
                        map["scene"] = self.scene!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["scene"] as? [String] {
                        self.scene = value
                    }
                }
            }
            public var appName: String?

            public var domainName: String?

            public var interval: Int32?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var ossObject: String?

            public var scenes: DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList.LiveSnapshotDetectPornConfig.Scenes?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.scenes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.ossObject != nil {
                    map["OssObject"] = self.ossObject!
                }
                if self.scenes != nil {
                    map["Scenes"] = self.scenes?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Interval"] as? Int32 {
                    self.interval = value
                }
                if let value = dict["OssBucket"] as? String {
                    self.ossBucket = value
                }
                if let value = dict["OssEndpoint"] as? String {
                    self.ossEndpoint = value
                }
                if let value = dict["OssObject"] as? String {
                    self.ossObject = value
                }
                if let value = dict["Scenes"] as? [String: Any?] {
                    var model = DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList.LiveSnapshotDetectPornConfig.Scenes()
                    model.fromMap(value)
                    self.scenes = model
                }
            }
        }
        public var liveSnapshotDetectPornConfig: [DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList.LiveSnapshotDetectPornConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveSnapshotDetectPornConfig != nil {
                var tmp : [Any] = []
                for k in self.liveSnapshotDetectPornConfig! {
                    tmp.append(k.toMap())
                }
                map["LiveSnapshotDetectPornConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveSnapshotDetectPornConfig"] as? [Any?] {
                var tmp : [DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList.LiveSnapshotDetectPornConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList.LiveSnapshotDetectPornConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveSnapshotDetectPornConfig = tmp
            }
        }
    }
    public var liveSnapshotDetectPornConfigList: DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList?

    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveSnapshotDetectPornConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveSnapshotDetectPornConfigList != nil {
            map["LiveSnapshotDetectPornConfigList"] = self.liveSnapshotDetectPornConfigList?.toMap()
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveSnapshotDetectPornConfigList"] as? [String: Any?] {
            var model = DescribeLiveSnapshotDetectPornConfigResponseBody.LiveSnapshotDetectPornConfigList()
            model.fromMap(value)
            self.liveSnapshotDetectPornConfigList = model
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveSnapshotDetectPornConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveSnapshotDetectPornConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveSnapshotDetectPornConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveSnapshotNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveSnapshotNotifyConfigResponseBody : Tea.TeaModel {
    public var domainName: String?

    public var notifyAuthKey: String?

    public var notifyReqAuth: String?

    public var notifyUrl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["NotifyAuthKey"] as? String {
            self.notifyAuthKey = value
        }
        if let value = dict["NotifyReqAuth"] as? String {
            self.notifyReqAuth = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveSnapshotNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveSnapshotNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveSnapshotNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamAuthCheckingRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Url"] as? String {
            self.url = value
        }
    }
}

public class DescribeLiveStreamAuthCheckingResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeLiveStreamAuthCheckingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamAuthCheckingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamAuthCheckingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamBitRateDataRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamBitRateDataResponseBody : Tea.TeaModel {
    public class FrameRateAndBitRateInfos : Tea.TeaModel {
        public class FrameRateAndBitRateInfo : Tea.TeaModel {
            public var audioFrameRate: Double?

            public var bitRate: Double?

            public var streamUrl: String?

            public var time: String?

            public var videoFrameRate: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioFrameRate != nil {
                    map["AudioFrameRate"] = self.audioFrameRate!
                }
                if self.bitRate != nil {
                    map["BitRate"] = self.bitRate!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.videoFrameRate != nil {
                    map["VideoFrameRate"] = self.videoFrameRate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AudioFrameRate"] as? Double {
                    self.audioFrameRate = value
                }
                if let value = dict["BitRate"] as? Double {
                    self.bitRate = value
                }
                if let value = dict["StreamUrl"] as? String {
                    self.streamUrl = value
                }
                if let value = dict["Time"] as? String {
                    self.time = value
                }
                if let value = dict["VideoFrameRate"] as? Double {
                    self.videoFrameRate = value
                }
            }
        }
        public var frameRateAndBitRateInfo: [DescribeLiveStreamBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.frameRateAndBitRateInfo != nil {
                var tmp : [Any] = []
                for k in self.frameRateAndBitRateInfo! {
                    tmp.append(k.toMap())
                }
                map["FrameRateAndBitRateInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FrameRateAndBitRateInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamBitRateDataResponseBody.FrameRateAndBitRateInfos.FrameRateAndBitRateInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.frameRateAndBitRateInfo = tmp
            }
        }
    }
    public var frameRateAndBitRateInfos: DescribeLiveStreamBitRateDataResponseBody.FrameRateAndBitRateInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.frameRateAndBitRateInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.frameRateAndBitRateInfos != nil {
            map["FrameRateAndBitRateInfos"] = self.frameRateAndBitRateInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FrameRateAndBitRateInfos"] as? [String: Any?] {
            var model = DescribeLiveStreamBitRateDataResponseBody.FrameRateAndBitRateInfos()
            model.fromMap(value)
            self.frameRateAndBitRateInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamBitRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamBitRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamBitRateDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamCountRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveStreamCountResponseBody : Tea.TeaModel {
    public class StreamCountInfos : Tea.TeaModel {
        public class StreamCountInfo : Tea.TeaModel {
            public class StreamCountDetails : Tea.TeaModel {
                public class StreamCountDetail : Tea.TeaModel {
                    public var count: Int64?

                    public var format: String?

                    public var videoDataRate: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.videoDataRate != nil {
                            map["VideoDataRate"] = self.videoDataRate!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Count"] as? Int64 {
                            self.count = value
                        }
                        if let value = dict["Format"] as? String {
                            self.format = value
                        }
                        if let value = dict["VideoDataRate"] as? Int64 {
                            self.videoDataRate = value
                        }
                    }
                }
                public var streamCountDetail: [DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo.StreamCountDetails.StreamCountDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.streamCountDetail != nil {
                        var tmp : [Any] = []
                        for k in self.streamCountDetail! {
                            tmp.append(k.toMap())
                        }
                        map["StreamCountDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["StreamCountDetail"] as? [Any?] {
                        var tmp : [DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo.StreamCountDetails.StreamCountDetail] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo.StreamCountDetails.StreamCountDetail()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.streamCountDetail = tmp
                    }
                }
            }
            public var count: Int64?

            public var limit: Int64?

            public var streamCountDetails: DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo.StreamCountDetails?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.streamCountDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.limit != nil {
                    map["Limit"] = self.limit!
                }
                if self.streamCountDetails != nil {
                    map["StreamCountDetails"] = self.streamCountDetails?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["Limit"] as? Int64 {
                    self.limit = value
                }
                if let value = dict["StreamCountDetails"] as? [String: Any?] {
                    var model = DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo.StreamCountDetails()
                    model.fromMap(value)
                    self.streamCountDetails = model
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var streamCountInfo: [DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamCountInfo != nil {
                var tmp : [Any] = []
                for k in self.streamCountInfo! {
                    tmp.append(k.toMap())
                }
                map["StreamCountInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StreamCountInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamCountResponseBody.StreamCountInfos.StreamCountInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.streamCountInfo = tmp
            }
        }
    }
    public var requestId: String?

    public var streamCountInfos: DescribeLiveStreamCountResponseBody.StreamCountInfos?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamCountInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamCountInfos != nil {
            map["StreamCountInfos"] = self.streamCountInfos?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamCountInfos"] as? [String: Any?] {
            var model = DescribeLiveStreamCountResponseBody.StreamCountInfos()
            model.fromMap(value)
            self.streamCountInfos = model
        }
    }
}

public class DescribeLiveStreamCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamCountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamDelayConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveStreamDelayConfigResponseBody : Tea.TeaModel {
    public class LiveStreamFlvDelayConfig : Tea.TeaModel {
        public var delay: Int32?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Delay"] as? Int32 {
                self.delay = value
            }
            if let value = dict["Level"] as? String {
                self.level = value
            }
        }
    }
    public class LiveStreamHlsDelayConfig : Tea.TeaModel {
        public var delay: Int32?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Delay"] as? Int32 {
                self.delay = value
            }
            if let value = dict["Level"] as? String {
                self.level = value
            }
        }
    }
    public class LiveStreamRtmpDelayConfig : Tea.TeaModel {
        public var delay: Int32?

        public var level: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Delay"] as? Int32 {
                self.delay = value
            }
            if let value = dict["Level"] as? String {
                self.level = value
            }
        }
    }
    public var liveStreamFlvDelayConfig: DescribeLiveStreamDelayConfigResponseBody.LiveStreamFlvDelayConfig?

    public var liveStreamHlsDelayConfig: DescribeLiveStreamDelayConfigResponseBody.LiveStreamHlsDelayConfig?

    public var liveStreamRtmpDelayConfig: DescribeLiveStreamDelayConfigResponseBody.LiveStreamRtmpDelayConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamFlvDelayConfig?.validate()
        try self.liveStreamHlsDelayConfig?.validate()
        try self.liveStreamRtmpDelayConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamFlvDelayConfig != nil {
            map["LiveStreamFlvDelayConfig"] = self.liveStreamFlvDelayConfig?.toMap()
        }
        if self.liveStreamHlsDelayConfig != nil {
            map["LiveStreamHlsDelayConfig"] = self.liveStreamHlsDelayConfig?.toMap()
        }
        if self.liveStreamRtmpDelayConfig != nil {
            map["LiveStreamRtmpDelayConfig"] = self.liveStreamRtmpDelayConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveStreamFlvDelayConfig"] as? [String: Any?] {
            var model = DescribeLiveStreamDelayConfigResponseBody.LiveStreamFlvDelayConfig()
            model.fromMap(value)
            self.liveStreamFlvDelayConfig = model
        }
        if let value = dict["LiveStreamHlsDelayConfig"] as? [String: Any?] {
            var model = DescribeLiveStreamDelayConfigResponseBody.LiveStreamHlsDelayConfig()
            model.fromMap(value)
            self.liveStreamHlsDelayConfig = model
        }
        if let value = dict["LiveStreamRtmpDelayConfig"] as? [String: Any?] {
            var model = DescribeLiveStreamDelayConfigResponseBody.LiveStreamRtmpDelayConfig()
            model.fromMap(value)
            self.liveStreamRtmpDelayConfig = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamDelayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamDelayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamDelayConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamDetailFrameRateAndBitRateDataRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody : Tea.TeaModel {
    public class FrameRateAndBitRateInfos : Tea.TeaModel {
        public var audioBitRate: Double?

        public var audioFrameRate: Double?

        public var bitRate: Double?

        public var streamUrl: String?

        public var time: String?

        public var videoBitRate: Double?

        public var videoFrameRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioBitRate != nil {
                map["AudioBitRate"] = self.audioBitRate!
            }
            if self.audioFrameRate != nil {
                map["AudioFrameRate"] = self.audioFrameRate!
            }
            if self.bitRate != nil {
                map["BitRate"] = self.bitRate!
            }
            if self.streamUrl != nil {
                map["StreamUrl"] = self.streamUrl!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.videoBitRate != nil {
                map["VideoBitRate"] = self.videoBitRate!
            }
            if self.videoFrameRate != nil {
                map["VideoFrameRate"] = self.videoFrameRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AudioBitRate"] as? Double {
                self.audioBitRate = value
            }
            if let value = dict["AudioFrameRate"] as? Double {
                self.audioFrameRate = value
            }
            if let value = dict["BitRate"] as? Double {
                self.bitRate = value
            }
            if let value = dict["StreamUrl"] as? String {
                self.streamUrl = value
            }
            if let value = dict["Time"] as? String {
                self.time = value
            }
            if let value = dict["VideoBitRate"] as? Double {
                self.videoBitRate = value
            }
            if let value = dict["VideoFrameRate"] as? Double {
                self.videoFrameRate = value
            }
        }
    }
    public var frameRateAndBitRateInfos: [DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.frameRateAndBitRateInfos != nil {
            var tmp : [Any] = []
            for k in self.frameRateAndBitRateInfos! {
                tmp.append(k.toMap())
            }
            map["FrameRateAndBitRateInfos"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FrameRateAndBitRateInfos"] as? [Any?] {
            var tmp : [DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody.FrameRateAndBitRateInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.frameRateAndBitRateInfos = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamDetailFrameRateAndBitRateDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamHistoryUserNumRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamHistoryUserNumResponseBody : Tea.TeaModel {
    public class LiveStreamUserNumInfos : Tea.TeaModel {
        public class LiveStreamUserNumInfo : Tea.TeaModel {
            public var streamTime: String?

            public var userNum: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.streamTime != nil {
                    map["StreamTime"] = self.streamTime!
                }
                if self.userNum != nil {
                    map["UserNum"] = self.userNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["StreamTime"] as? String {
                    self.streamTime = value
                }
                if let value = dict["UserNum"] as? String {
                    self.userNum = value
                }
            }
        }
        public var liveStreamUserNumInfo: [DescribeLiveStreamHistoryUserNumResponseBody.LiveStreamUserNumInfos.LiveStreamUserNumInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamUserNumInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamUserNumInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamUserNumInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveStreamUserNumInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamHistoryUserNumResponseBody.LiveStreamUserNumInfos.LiveStreamUserNumInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamHistoryUserNumResponseBody.LiveStreamUserNumInfos.LiveStreamUserNumInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveStreamUserNumInfo = tmp
            }
        }
    }
    public var liveStreamUserNumInfos: DescribeLiveStreamHistoryUserNumResponseBody.LiveStreamUserNumInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamUserNumInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamUserNumInfos != nil {
            map["LiveStreamUserNumInfos"] = self.liveStreamUserNumInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveStreamUserNumInfos"] as? [String: Any?] {
            var model = DescribeLiveStreamHistoryUserNumResponseBody.LiveStreamUserNumInfos()
            model.fromMap(value)
            self.liveStreamUserNumInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamHistoryUserNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamHistoryUserNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamHistoryUserNumResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamMergeRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var protocol_: String?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamMergeResponseBody : Tea.TeaModel {
    public class LiveStreamMergeList : Tea.TeaModel {
        public class LiveStreamMerge : Tea.TeaModel {
            public var appName: String?

            public var appUsing: String?

            public var domainName: String?

            public var endTime: String?

            public var extraInAppStreams: String?

            public var inAppName1: String?

            public var inAppName2: String?

            public var inStreamName1: String?

            public var inStreamName2: String?

            public var liveMerger: String?

            public var mergeParameters: String?

            public var protocol_: String?

            public var startTime: String?

            public var streamName: String?

            public var streamUsing: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.appUsing != nil {
                    map["AppUsing"] = self.appUsing!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.extraInAppStreams != nil {
                    map["ExtraInAppStreams"] = self.extraInAppStreams!
                }
                if self.inAppName1 != nil {
                    map["InAppName1"] = self.inAppName1!
                }
                if self.inAppName2 != nil {
                    map["InAppName2"] = self.inAppName2!
                }
                if self.inStreamName1 != nil {
                    map["InStreamName1"] = self.inStreamName1!
                }
                if self.inStreamName2 != nil {
                    map["InStreamName2"] = self.inStreamName2!
                }
                if self.liveMerger != nil {
                    map["LiveMerger"] = self.liveMerger!
                }
                if self.mergeParameters != nil {
                    map["MergeParameters"] = self.mergeParameters!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.streamUsing != nil {
                    map["StreamUsing"] = self.streamUsing!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["AppUsing"] as? String {
                    self.appUsing = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["ExtraInAppStreams"] as? String {
                    self.extraInAppStreams = value
                }
                if let value = dict["InAppName1"] as? String {
                    self.inAppName1 = value
                }
                if let value = dict["InAppName2"] as? String {
                    self.inAppName2 = value
                }
                if let value = dict["InStreamName1"] as? String {
                    self.inStreamName1 = value
                }
                if let value = dict["InStreamName2"] as? String {
                    self.inStreamName2 = value
                }
                if let value = dict["LiveMerger"] as? String {
                    self.liveMerger = value
                }
                if let value = dict["MergeParameters"] as? String {
                    self.mergeParameters = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["StreamUsing"] as? String {
                    self.streamUsing = value
                }
            }
        }
        public var liveStreamMerge: [DescribeLiveStreamMergeResponseBody.LiveStreamMergeList.LiveStreamMerge]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamMerge != nil {
                var tmp : [Any] = []
                for k in self.liveStreamMerge! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamMerge"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveStreamMerge"] as? [Any?] {
                var tmp : [DescribeLiveStreamMergeResponseBody.LiveStreamMergeList.LiveStreamMerge] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamMergeResponseBody.LiveStreamMergeList.LiveStreamMerge()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveStreamMerge = tmp
            }
        }
    }
    public var liveStreamMergeList: DescribeLiveStreamMergeResponseBody.LiveStreamMergeList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamMergeList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamMergeList != nil {
            map["LiveStreamMergeList"] = self.liveStreamMergeList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveStreamMergeList"] as? [String: Any?] {
            var model = DescribeLiveStreamMergeResponseBody.LiveStreamMergeList()
            model.fromMap(value)
            self.liveStreamMergeList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamMergeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamMergeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamMergeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamMetricDetailDataRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var nextPageToken: String?

    public var ownerId: Int64?

    public var protocol_: String?

    public var regionId: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["NextPageToken"] as? String {
            self.nextPageToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamMetricDetailDataResponseBody : Tea.TeaModel {
    public class StreamDetailData : Tea.TeaModel {
        public class StreamData : Tea.TeaModel {
            public var appName: String?

            public var bps: Double?

            public var count: Int64?

            public var flvBps: Double?

            public var flvCount: Int64?

            public var flvTraffic: Int64?

            public var hlsBps: Double?

            public var hlsCount: Int64?

            public var hlsTraffic: Int64?

            public var newConns: String?

            public var p2pBps: Double?

            public var p2pCount: Int64?

            public var p2pTraffic: Int64?

            public var rtmpBps: Double?

            public var rtmpCount: Int64?

            public var rtmpTraffic: Int64?

            public var rtsBps: Double?

            public var rtsCount: Int64?

            public var rtsTraffic: Int64?

            public var streamName: String?

            public var timeStamp: String?

            public var traffic: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.bps != nil {
                    map["Bps"] = self.bps!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.flvBps != nil {
                    map["FlvBps"] = self.flvBps!
                }
                if self.flvCount != nil {
                    map["FlvCount"] = self.flvCount!
                }
                if self.flvTraffic != nil {
                    map["FlvTraffic"] = self.flvTraffic!
                }
                if self.hlsBps != nil {
                    map["HlsBps"] = self.hlsBps!
                }
                if self.hlsCount != nil {
                    map["HlsCount"] = self.hlsCount!
                }
                if self.hlsTraffic != nil {
                    map["HlsTraffic"] = self.hlsTraffic!
                }
                if self.newConns != nil {
                    map["NewConns"] = self.newConns!
                }
                if self.p2pBps != nil {
                    map["P2pBps"] = self.p2pBps!
                }
                if self.p2pCount != nil {
                    map["P2pCount"] = self.p2pCount!
                }
                if self.p2pTraffic != nil {
                    map["P2pTraffic"] = self.p2pTraffic!
                }
                if self.rtmpBps != nil {
                    map["RtmpBps"] = self.rtmpBps!
                }
                if self.rtmpCount != nil {
                    map["RtmpCount"] = self.rtmpCount!
                }
                if self.rtmpTraffic != nil {
                    map["RtmpTraffic"] = self.rtmpTraffic!
                }
                if self.rtsBps != nil {
                    map["RtsBps"] = self.rtsBps!
                }
                if self.rtsCount != nil {
                    map["RtsCount"] = self.rtsCount!
                }
                if self.rtsTraffic != nil {
                    map["RtsTraffic"] = self.rtsTraffic!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.traffic != nil {
                    map["Traffic"] = self.traffic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["Bps"] as? Double {
                    self.bps = value
                }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["FlvBps"] as? Double {
                    self.flvBps = value
                }
                if let value = dict["FlvCount"] as? Int64 {
                    self.flvCount = value
                }
                if let value = dict["FlvTraffic"] as? Int64 {
                    self.flvTraffic = value
                }
                if let value = dict["HlsBps"] as? Double {
                    self.hlsBps = value
                }
                if let value = dict["HlsCount"] as? Int64 {
                    self.hlsCount = value
                }
                if let value = dict["HlsTraffic"] as? Int64 {
                    self.hlsTraffic = value
                }
                if let value = dict["NewConns"] as? String {
                    self.newConns = value
                }
                if let value = dict["P2pBps"] as? Double {
                    self.p2pBps = value
                }
                if let value = dict["P2pCount"] as? Int64 {
                    self.p2pCount = value
                }
                if let value = dict["P2pTraffic"] as? Int64 {
                    self.p2pTraffic = value
                }
                if let value = dict["RtmpBps"] as? Double {
                    self.rtmpBps = value
                }
                if let value = dict["RtmpCount"] as? Int64 {
                    self.rtmpCount = value
                }
                if let value = dict["RtmpTraffic"] as? Int64 {
                    self.rtmpTraffic = value
                }
                if let value = dict["RtsBps"] as? Double {
                    self.rtsBps = value
                }
                if let value = dict["RtsCount"] as? Int64 {
                    self.rtsCount = value
                }
                if let value = dict["RtsTraffic"] as? Int64 {
                    self.rtsTraffic = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["Traffic"] as? Int64 {
                    self.traffic = value
                }
            }
        }
        public var streamData: [DescribeLiveStreamMetricDetailDataResponseBody.StreamDetailData.StreamData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamData != nil {
                var tmp : [Any] = []
                for k in self.streamData! {
                    tmp.append(k.toMap())
                }
                map["StreamData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StreamData"] as? [Any?] {
                var tmp : [DescribeLiveStreamMetricDetailDataResponseBody.StreamDetailData.StreamData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamMetricDetailDataResponseBody.StreamDetailData.StreamData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.streamData = tmp
            }
        }
    }
    public var domainName: String?

    public var endTime: String?

    public var nextPageToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var startTime: String?

    public var streamDetailData: DescribeLiveStreamMetricDetailDataResponseBody.StreamDetailData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamDetailData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamDetailData != nil {
            map["StreamDetailData"] = self.streamDetailData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["NextPageToken"] as? String {
            self.nextPageToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamDetailData"] as? [String: Any?] {
            var model = DescribeLiveStreamMetricDetailDataResponseBody.StreamDetailData()
            model.fromMap(value)
            self.streamDetailData = model
        }
    }
}

public class DescribeLiveStreamMetricDetailDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamMetricDetailDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamMetricDetailDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamMonitorListRequest : Tea.TeaModel {
    public var monitorId: String?

    public var orderRule: Int32?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.orderRule != nil {
            map["OrderRule"] = self.orderRule!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorId"] as? String {
            self.monitorId = value
        }
        if let value = dict["OrderRule"] as? Int32 {
            self.orderRule = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
    }
}

public class DescribeLiveStreamMonitorListResponseBody : Tea.TeaModel {
    public class LiveStreamMonitorList : Tea.TeaModel {
        public class InputList : Tea.TeaModel {
            public class LayoutConfig : Tea.TeaModel {
                public var fillMode: String?

                public var positionNormalized: [Double]?

                public var positionRefer: String?

                public var sizeNormalized: [Double]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fillMode != nil {
                        map["FillMode"] = self.fillMode!
                    }
                    if self.positionNormalized != nil {
                        map["PositionNormalized"] = self.positionNormalized!
                    }
                    if self.positionRefer != nil {
                        map["PositionRefer"] = self.positionRefer!
                    }
                    if self.sizeNormalized != nil {
                        map["SizeNormalized"] = self.sizeNormalized!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FillMode"] as? String {
                        self.fillMode = value
                    }
                    if let value = dict["PositionNormalized"] as? [Double] {
                        self.positionNormalized = value
                    }
                    if let value = dict["PositionRefer"] as? String {
                        self.positionRefer = value
                    }
                    if let value = dict["SizeNormalized"] as? [Double] {
                        self.sizeNormalized = value
                    }
                }
            }
            public class PlayConfig : Tea.TeaModel {
                public var volumeRate: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.volumeRate != nil {
                        map["VolumeRate"] = self.volumeRate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VolumeRate"] as? Double {
                        self.volumeRate = value
                    }
                }
            }
            public var index: Int32?

            public var inputUrl: String?

            public var layoutConfig: DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList.LayoutConfig?

            public var layoutId: Int32?

            public var playConfig: DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList.PlayConfig?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.layoutConfig?.validate()
                try self.playConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.inputUrl != nil {
                    map["InputUrl"] = self.inputUrl!
                }
                if self.layoutConfig != nil {
                    map["LayoutConfig"] = self.layoutConfig?.toMap()
                }
                if self.layoutId != nil {
                    map["LayoutId"] = self.layoutId!
                }
                if self.playConfig != nil {
                    map["PlayConfig"] = self.playConfig?.toMap()
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Index"] as? Int32 {
                    self.index = value
                }
                if let value = dict["InputUrl"] as? String {
                    self.inputUrl = value
                }
                if let value = dict["LayoutConfig"] as? [String: Any?] {
                    var model = DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList.LayoutConfig()
                    model.fromMap(value)
                    self.layoutConfig = model
                }
                if let value = dict["LayoutId"] as? Int32 {
                    self.layoutId = value
                }
                if let value = dict["PlayConfig"] as? [String: Any?] {
                    var model = DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList.PlayConfig()
                    model.fromMap(value)
                    self.playConfig = model
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
            }
        }
        public class OutputUrls : Tea.TeaModel {
            public var flvUrl: String?

            public var rtmpUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.flvUrl != nil {
                    map["FlvUrl"] = self.flvUrl!
                }
                if self.rtmpUrl != nil {
                    map["RtmpUrl"] = self.rtmpUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FlvUrl"] as? String {
                    self.flvUrl = value
                }
                if let value = dict["RtmpUrl"] as? String {
                    self.rtmpUrl = value
                }
            }
        }
        public var audioFrom: Int32?

        public var callbackUrl: String?

        public var dingTalkWebHookUrl: String?

        public var domain: String?

        public var inputList: [DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList]?

        public var monitorConfig: String?

        public var monitorId: String?

        public var monitorName: String?

        public var outputTemplate: String?

        public var outputUrls: DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.OutputUrls?

        public var region: String?

        public var startTime: String?

        public var status: Int32?

        public var stopTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.outputUrls?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioFrom != nil {
                map["AudioFrom"] = self.audioFrom!
            }
            if self.callbackUrl != nil {
                map["CallbackUrl"] = self.callbackUrl!
            }
            if self.dingTalkWebHookUrl != nil {
                map["DingTalkWebHookUrl"] = self.dingTalkWebHookUrl!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.inputList != nil {
                var tmp : [Any] = []
                for k in self.inputList! {
                    tmp.append(k.toMap())
                }
                map["InputList"] = tmp
            }
            if self.monitorConfig != nil {
                map["MonitorConfig"] = self.monitorConfig!
            }
            if self.monitorId != nil {
                map["MonitorId"] = self.monitorId!
            }
            if self.monitorName != nil {
                map["MonitorName"] = self.monitorName!
            }
            if self.outputTemplate != nil {
                map["OutputTemplate"] = self.outputTemplate!
            }
            if self.outputUrls != nil {
                map["OutputUrls"] = self.outputUrls?.toMap()
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopTime != nil {
                map["StopTime"] = self.stopTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AudioFrom"] as? Int32 {
                self.audioFrom = value
            }
            if let value = dict["CallbackUrl"] as? String {
                self.callbackUrl = value
            }
            if let value = dict["DingTalkWebHookUrl"] as? String {
                self.dingTalkWebHookUrl = value
            }
            if let value = dict["Domain"] as? String {
                self.domain = value
            }
            if let value = dict["InputList"] as? [Any?] {
                var tmp : [DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.InputList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.inputList = tmp
            }
            if let value = dict["MonitorConfig"] as? String {
                self.monitorConfig = value
            }
            if let value = dict["MonitorId"] as? String {
                self.monitorId = value
            }
            if let value = dict["MonitorName"] as? String {
                self.monitorName = value
            }
            if let value = dict["OutputTemplate"] as? String {
                self.outputTemplate = value
            }
            if let value = dict["OutputUrls"] as? [String: Any?] {
                var model = DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList.OutputUrls()
                model.fromMap(value)
                self.outputUrls = model
            }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
            if let value = dict["StopTime"] as? String {
                self.stopTime = value
            }
        }
    }
    public var liveStreamMonitorList: [DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamMonitorList != nil {
            var tmp : [Any] = []
            for k in self.liveStreamMonitorList! {
                tmp.append(k.toMap())
            }
            map["LiveStreamMonitorList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveStreamMonitorList"] as? [Any?] {
            var tmp : [DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveStreamMonitorListResponseBody.LiveStreamMonitorList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.liveStreamMonitorList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeLiveStreamMonitorListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamMonitorListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamMonitorListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamPreloadTasksRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var playUrl: String?

    public var regionId: String?

    public var startTime: String?

    public var status: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.playUrl != nil {
            map["PlayUrl"] = self.playUrl!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PlayUrl"] as? String {
            self.playUrl = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DescribeLiveStreamPreloadTasksResponseBody : Tea.TeaModel {
    public class PreloadTasks : Tea.TeaModel {
        public class PreloadTask : Tea.TeaModel {
            public var area: String?

            public var createTime: String?

            public var description_: String?

            public var domainName: String?

            public var playUrl: String?

            public var preloadedEndTime: String?

            public var preloadedStartTime: String?

            public var process: String?

            public var status: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area != nil {
                    map["Area"] = self.area!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.playUrl != nil {
                    map["PlayUrl"] = self.playUrl!
                }
                if self.preloadedEndTime != nil {
                    map["PreloadedEndTime"] = self.preloadedEndTime!
                }
                if self.preloadedStartTime != nil {
                    map["PreloadedStartTime"] = self.preloadedStartTime!
                }
                if self.process != nil {
                    map["Process"] = self.process!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Area"] as? String {
                    self.area = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["PlayUrl"] as? String {
                    self.playUrl = value
                }
                if let value = dict["PreloadedEndTime"] as? String {
                    self.preloadedEndTime = value
                }
                if let value = dict["PreloadedStartTime"] as? String {
                    self.preloadedStartTime = value
                }
                if let value = dict["Process"] as? String {
                    self.process = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
            }
        }
        public var preloadTask: [DescribeLiveStreamPreloadTasksResponseBody.PreloadTasks.PreloadTask]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preloadTask != nil {
                var tmp : [Any] = []
                for k in self.preloadTask! {
                    tmp.append(k.toMap())
                }
                map["PreloadTask"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PreloadTask"] as? [Any?] {
                var tmp : [DescribeLiveStreamPreloadTasksResponseBody.PreloadTasks.PreloadTask] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamPreloadTasksResponseBody.PreloadTasks.PreloadTask()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.preloadTask = tmp
            }
        }
    }
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var preloadTasks: DescribeLiveStreamPreloadTasksResponseBody.PreloadTasks?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.preloadTasks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.preloadTasks != nil {
            map["PreloadTasks"] = self.preloadTasks?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PreloadTasks"] as? [String: Any?] {
            var model = DescribeLiveStreamPreloadTasksResponseBody.PreloadTasks()
            model.fromMap(value)
            self.preloadTasks = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveStreamPreloadTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamPreloadTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamPreloadTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamPushMetricDetailDataRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var nextPageToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["NextPageToken"] as? String {
            self.nextPageToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamPushMetricDetailDataResponseBody : Tea.TeaModel {
    public class StreamDetailData : Tea.TeaModel {
        public class StreamData : Tea.TeaModel {
            public var appName: String?

            public var reqBps: Double?

            public var reqTraffic: Int64?

            public var streamName: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.reqBps != nil {
                    map["ReqBps"] = self.reqBps!
                }
                if self.reqTraffic != nil {
                    map["ReqTraffic"] = self.reqTraffic!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["ReqBps"] as? Double {
                    self.reqBps = value
                }
                if let value = dict["ReqTraffic"] as? Int64 {
                    self.reqTraffic = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var streamData: [DescribeLiveStreamPushMetricDetailDataResponseBody.StreamDetailData.StreamData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamData != nil {
                var tmp : [Any] = []
                for k in self.streamData! {
                    tmp.append(k.toMap())
                }
                map["StreamData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StreamData"] as? [Any?] {
                var tmp : [DescribeLiveStreamPushMetricDetailDataResponseBody.StreamDetailData.StreamData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamPushMetricDetailDataResponseBody.StreamDetailData.StreamData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.streamData = tmp
            }
        }
    }
    public var domainName: String?

    public var endTime: String?

    public var nextPageToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var startTime: String?

    public var streamDetailData: DescribeLiveStreamPushMetricDetailDataResponseBody.StreamDetailData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamDetailData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamDetailData != nil {
            map["StreamDetailData"] = self.streamDetailData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["NextPageToken"] as? String {
            self.nextPageToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamDetailData"] as? [String: Any?] {
            var model = DescribeLiveStreamPushMetricDetailDataResponseBody.StreamDetailData()
            model.fromMap(value)
            self.streamDetailData = model
        }
    }
}

public class DescribeLiveStreamPushMetricDetailDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamPushMetricDetailDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamPushMetricDetailDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamRecordContentRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamRecordContentResponseBody : Tea.TeaModel {
    public class RecordContentInfoList : Tea.TeaModel {
        public class RecordContentInfo : Tea.TeaModel {
            public var duration: Double?

            public var endTime: String?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var ossObjectPrefix: String?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.ossObjectPrefix != nil {
                    map["OssObjectPrefix"] = self.ossObjectPrefix!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Duration"] as? Double {
                    self.duration = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["OssBucket"] as? String {
                    self.ossBucket = value
                }
                if let value = dict["OssEndpoint"] as? String {
                    self.ossEndpoint = value
                }
                if let value = dict["OssObjectPrefix"] as? String {
                    self.ossObjectPrefix = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
            }
        }
        public var recordContentInfo: [DescribeLiveStreamRecordContentResponseBody.RecordContentInfoList.RecordContentInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordContentInfo != nil {
                var tmp : [Any] = []
                for k in self.recordContentInfo! {
                    tmp.append(k.toMap())
                }
                map["RecordContentInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RecordContentInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamRecordContentResponseBody.RecordContentInfoList.RecordContentInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamRecordContentResponseBody.RecordContentInfoList.RecordContentInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.recordContentInfo = tmp
            }
        }
    }
    public var recordContentInfoList: DescribeLiveStreamRecordContentResponseBody.RecordContentInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordContentInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordContentInfoList != nil {
            map["RecordContentInfoList"] = self.recordContentInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordContentInfoList"] as? [String: Any?] {
            var model = DescribeLiveStreamRecordContentResponseBody.RecordContentInfoList()
            model.fromMap(value)
            self.recordContentInfoList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamRecordContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamRecordContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamRecordContentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamRecordIndexFileRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var recordId: String?

    public var securityToken: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recordId != nil {
            map["RecordId"] = self.recordId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RecordId"] as? String {
            self.recordId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamRecordIndexFileResponseBody : Tea.TeaModel {
    public class RecordIndexInfo : Tea.TeaModel {
        public var appName: String?

        public var createTime: String?

        public var domainName: String?

        public var duration: Double?

        public var endTime: String?

        public var format: String?

        public var height: Int32?

        public var ossBucket: String?

        public var ossEndpoint: String?

        public var ossObject: String?

        public var recordId: String?

        public var recordUrl: String?

        public var startTime: String?

        public var streamName: String?

        public var width: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossEndpoint != nil {
                map["OssEndpoint"] = self.ossEndpoint!
            }
            if self.ossObject != nil {
                map["OssObject"] = self.ossObject!
            }
            if self.recordId != nil {
                map["RecordId"] = self.recordId!
            }
            if self.recordUrl != nil {
                map["RecordUrl"] = self.recordUrl!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["Duration"] as? Double {
                self.duration = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["Format"] as? String {
                self.format = value
            }
            if let value = dict["Height"] as? Int32 {
                self.height = value
            }
            if let value = dict["OssBucket"] as? String {
                self.ossBucket = value
            }
            if let value = dict["OssEndpoint"] as? String {
                self.ossEndpoint = value
            }
            if let value = dict["OssObject"] as? String {
                self.ossObject = value
            }
            if let value = dict["RecordId"] as? String {
                self.recordId = value
            }
            if let value = dict["RecordUrl"] as? String {
                self.recordUrl = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
            if let value = dict["Width"] as? Int32 {
                self.width = value
            }
        }
    }
    public var recordIndexInfo: DescribeLiveStreamRecordIndexFileResponseBody.RecordIndexInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordIndexInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordIndexInfo != nil {
            map["RecordIndexInfo"] = self.recordIndexInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RecordIndexInfo"] as? [String: Any?] {
            var model = DescribeLiveStreamRecordIndexFileResponseBody.RecordIndexInfo()
            model.fromMap(value)
            self.recordIndexInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamRecordIndexFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamRecordIndexFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamRecordIndexFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamRecordIndexFilesRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var order: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamRecordIndexFilesResponseBody : Tea.TeaModel {
    public class RecordIndexInfoList : Tea.TeaModel {
        public class RecordIndexInfo : Tea.TeaModel {
            public var appName: String?

            public var createTime: String?

            public var domainName: String?

            public var duration: Double?

            public var endTime: String?

            public var format: String?

            public var height: Int32?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var ossObject: String?

            public var recordId: String?

            public var recordUrl: String?

            public var startTime: String?

            public var streamName: String?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.ossObject != nil {
                    map["OssObject"] = self.ossObject!
                }
                if self.recordId != nil {
                    map["RecordId"] = self.recordId!
                }
                if self.recordUrl != nil {
                    map["RecordUrl"] = self.recordUrl!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Duration"] as? Double {
                    self.duration = value
                }
                if let value = dict["EndTime"] as? String {
                    self.endTime = value
                }
                if let value = dict["Format"] as? String {
                    self.format = value
                }
                if let value = dict["Height"] as? Int32 {
                    self.height = value
                }
                if let value = dict["OssBucket"] as? String {
                    self.ossBucket = value
                }
                if let value = dict["OssEndpoint"] as? String {
                    self.ossEndpoint = value
                }
                if let value = dict["OssObject"] as? String {
                    self.ossObject = value
                }
                if let value = dict["RecordId"] as? String {
                    self.recordId = value
                }
                if let value = dict["RecordUrl"] as? String {
                    self.recordUrl = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["Width"] as? Int32 {
                    self.width = value
                }
            }
        }
        public var recordIndexInfo: [DescribeLiveStreamRecordIndexFilesResponseBody.RecordIndexInfoList.RecordIndexInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordIndexInfo != nil {
                var tmp : [Any] = []
                for k in self.recordIndexInfo! {
                    tmp.append(k.toMap())
                }
                map["RecordIndexInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RecordIndexInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamRecordIndexFilesResponseBody.RecordIndexInfoList.RecordIndexInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamRecordIndexFilesResponseBody.RecordIndexInfoList.RecordIndexInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.recordIndexInfo = tmp
            }
        }
    }
    public var order: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var recordIndexInfoList: DescribeLiveStreamRecordIndexFilesResponseBody.RecordIndexInfoList?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.recordIndexInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.recordIndexInfoList != nil {
            map["RecordIndexInfoList"] = self.recordIndexInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RecordIndexInfoList"] as? [String: Any?] {
            var model = DescribeLiveStreamRecordIndexFilesResponseBody.RecordIndexInfoList()
            model.fromMap(value)
            self.recordIndexInfoList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveStreamRecordIndexFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamRecordIndexFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamRecordIndexFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamSnapshotInfoRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var limit: Int32?

    public var order: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Limit"] as? Int32 {
            self.limit = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamSnapshotInfoResponseBody : Tea.TeaModel {
    public class LiveStreamSnapshotInfoList : Tea.TeaModel {
        public class LiveStreamSnapshotInfo : Tea.TeaModel {
            public var createTime: String?

            public var createTimestamp: Int64?

            public var isOverlay: Bool?

            public var ossBucket: String?

            public var ossEndpoint: String?

            public var ossObject: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createTimestamp != nil {
                    map["CreateTimestamp"] = self.createTimestamp!
                }
                if self.isOverlay != nil {
                    map["IsOverlay"] = self.isOverlay!
                }
                if self.ossBucket != nil {
                    map["OssBucket"] = self.ossBucket!
                }
                if self.ossEndpoint != nil {
                    map["OssEndpoint"] = self.ossEndpoint!
                }
                if self.ossObject != nil {
                    map["OssObject"] = self.ossObject!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateTimestamp"] as? Int64 {
                    self.createTimestamp = value
                }
                if let value = dict["IsOverlay"] as? Bool {
                    self.isOverlay = value
                }
                if let value = dict["OssBucket"] as? String {
                    self.ossBucket = value
                }
                if let value = dict["OssEndpoint"] as? String {
                    self.ossEndpoint = value
                }
                if let value = dict["OssObject"] as? String {
                    self.ossObject = value
                }
            }
        }
        public var liveStreamSnapshotInfo: [DescribeLiveStreamSnapshotInfoResponseBody.LiveStreamSnapshotInfoList.LiveStreamSnapshotInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamSnapshotInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamSnapshotInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamSnapshotInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveStreamSnapshotInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamSnapshotInfoResponseBody.LiveStreamSnapshotInfoList.LiveStreamSnapshotInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamSnapshotInfoResponseBody.LiveStreamSnapshotInfoList.LiveStreamSnapshotInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveStreamSnapshotInfo = tmp
            }
        }
    }
    public var liveStreamSnapshotInfoList: DescribeLiveStreamSnapshotInfoResponseBody.LiveStreamSnapshotInfoList?

    public var nextStartTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamSnapshotInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamSnapshotInfoList != nil {
            map["LiveStreamSnapshotInfoList"] = self.liveStreamSnapshotInfoList?.toMap()
        }
        if self.nextStartTime != nil {
            map["NextStartTime"] = self.nextStartTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveStreamSnapshotInfoList"] as? [String: Any?] {
            var model = DescribeLiveStreamSnapshotInfoResponseBody.LiveStreamSnapshotInfoList()
            model.fromMap(value)
            self.liveStreamSnapshotInfoList = model
        }
        if let value = dict["NextStartTime"] as? String {
            self.nextStartTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamSnapshotInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamSnapshotInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamSnapshotInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamStateRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamStateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var streamState: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamState != nil {
            map["StreamState"] = self.streamState!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamState"] as? String {
            self.streamState = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeLiveStreamStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamStateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamTranscodeInfoRequest : Tea.TeaModel {
    public var appName: String?

    public var domainTranscodeName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainTranscodeName != nil {
            map["DomainTranscodeName"] = self.domainTranscodeName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainTranscodeName"] as? String {
            self.domainTranscodeName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveStreamTranscodeInfoResponseBody : Tea.TeaModel {
    public class DomainTranscodeList : Tea.TeaModel {
        public class DomainTranscodeInfo : Tea.TeaModel {
            public class CustomTranscodeParameters : Tea.TeaModel {
                public var audioBitrate: Int32?

                public var audioChannelNum: Int32?

                public var audioCodec: String?

                public var audioProfile: String?

                public var audioRate: Int32?

                public var bframes: String?

                public var bitrateWithSource: [String: Any]?

                public var deInterlaced: Bool?

                public var extWithSource: [String: Any]?

                public var FPS: Int32?

                public var fpsWithSource: [String: Any]?

                public var gop: String?

                public var height: Int32?

                public var resWithSource: [String: Any]?

                public var rtsFlag: String?

                public var templateType: String?

                public var videoBitrate: Int32?

                public var videoProfile: String?

                public var width: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioBitrate != nil {
                        map["AudioBitrate"] = self.audioBitrate!
                    }
                    if self.audioChannelNum != nil {
                        map["AudioChannelNum"] = self.audioChannelNum!
                    }
                    if self.audioCodec != nil {
                        map["AudioCodec"] = self.audioCodec!
                    }
                    if self.audioProfile != nil {
                        map["AudioProfile"] = self.audioProfile!
                    }
                    if self.audioRate != nil {
                        map["AudioRate"] = self.audioRate!
                    }
                    if self.bframes != nil {
                        map["Bframes"] = self.bframes!
                    }
                    if self.bitrateWithSource != nil {
                        map["BitrateWithSource"] = self.bitrateWithSource!
                    }
                    if self.deInterlaced != nil {
                        map["DeInterlaced"] = self.deInterlaced!
                    }
                    if self.extWithSource != nil {
                        map["ExtWithSource"] = self.extWithSource!
                    }
                    if self.FPS != nil {
                        map["FPS"] = self.FPS!
                    }
                    if self.fpsWithSource != nil {
                        map["FpsWithSource"] = self.fpsWithSource!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.resWithSource != nil {
                        map["ResWithSource"] = self.resWithSource!
                    }
                    if self.rtsFlag != nil {
                        map["RtsFlag"] = self.rtsFlag!
                    }
                    if self.templateType != nil {
                        map["TemplateType"] = self.templateType!
                    }
                    if self.videoBitrate != nil {
                        map["VideoBitrate"] = self.videoBitrate!
                    }
                    if self.videoProfile != nil {
                        map["VideoProfile"] = self.videoProfile!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AudioBitrate"] as? Int32 {
                        self.audioBitrate = value
                    }
                    if let value = dict["AudioChannelNum"] as? Int32 {
                        self.audioChannelNum = value
                    }
                    if let value = dict["AudioCodec"] as? String {
                        self.audioCodec = value
                    }
                    if let value = dict["AudioProfile"] as? String {
                        self.audioProfile = value
                    }
                    if let value = dict["AudioRate"] as? Int32 {
                        self.audioRate = value
                    }
                    if let value = dict["Bframes"] as? String {
                        self.bframes = value
                    }
                    if let value = dict["BitrateWithSource"] as? [String: Any] {
                        self.bitrateWithSource = value
                    }
                    if let value = dict["DeInterlaced"] as? Bool {
                        self.deInterlaced = value
                    }
                    if let value = dict["ExtWithSource"] as? [String: Any] {
                        self.extWithSource = value
                    }
                    if let value = dict["FPS"] as? Int32 {
                        self.FPS = value
                    }
                    if let value = dict["FpsWithSource"] as? [String: Any] {
                        self.fpsWithSource = value
                    }
                    if let value = dict["Gop"] as? String {
                        self.gop = value
                    }
                    if let value = dict["Height"] as? Int32 {
                        self.height = value
                    }
                    if let value = dict["ResWithSource"] as? [String: Any] {
                        self.resWithSource = value
                    }
                    if let value = dict["RtsFlag"] as? String {
                        self.rtsFlag = value
                    }
                    if let value = dict["TemplateType"] as? String {
                        self.templateType = value
                    }
                    if let value = dict["VideoBitrate"] as? Int32 {
                        self.videoBitrate = value
                    }
                    if let value = dict["VideoProfile"] as? String {
                        self.videoProfile = value
                    }
                    if let value = dict["Width"] as? Int32 {
                        self.width = value
                    }
                }
            }
            public class EncryptParameters : Tea.TeaModel {
                public var encryptType: String?

                public var kmsKeyExpireInterval: String?

                public var kmsKeyID: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.encryptType != nil {
                        map["EncryptType"] = self.encryptType!
                    }
                    if self.kmsKeyExpireInterval != nil {
                        map["KmsKeyExpireInterval"] = self.kmsKeyExpireInterval!
                    }
                    if self.kmsKeyID != nil {
                        map["KmsKeyID"] = self.kmsKeyID!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EncryptType"] as? String {
                        self.encryptType = value
                    }
                    if let value = dict["KmsKeyExpireInterval"] as? String {
                        self.kmsKeyExpireInterval = value
                    }
                    if let value = dict["KmsKeyID"] as? String {
                        self.kmsKeyID = value
                    }
                }
            }
            public var customTranscodeParameters: DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo.CustomTranscodeParameters?

            public var encryptParameters: DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo.EncryptParameters?

            public var isLazy: Bool?

            public var transcodeApp: String?

            public var transcodeName: String?

            public var transcodeTemplate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.customTranscodeParameters?.validate()
                try self.encryptParameters?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customTranscodeParameters != nil {
                    map["CustomTranscodeParameters"] = self.customTranscodeParameters?.toMap()
                }
                if self.encryptParameters != nil {
                    map["EncryptParameters"] = self.encryptParameters?.toMap()
                }
                if self.isLazy != nil {
                    map["IsLazy"] = self.isLazy!
                }
                if self.transcodeApp != nil {
                    map["TranscodeApp"] = self.transcodeApp!
                }
                if self.transcodeName != nil {
                    map["TranscodeName"] = self.transcodeName!
                }
                if self.transcodeTemplate != nil {
                    map["TranscodeTemplate"] = self.transcodeTemplate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CustomTranscodeParameters"] as? [String: Any?] {
                    var model = DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo.CustomTranscodeParameters()
                    model.fromMap(value)
                    self.customTranscodeParameters = model
                }
                if let value = dict["EncryptParameters"] as? [String: Any?] {
                    var model = DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo.EncryptParameters()
                    model.fromMap(value)
                    self.encryptParameters = model
                }
                if let value = dict["IsLazy"] as? Bool {
                    self.isLazy = value
                }
                if let value = dict["TranscodeApp"] as? String {
                    self.transcodeApp = value
                }
                if let value = dict["TranscodeName"] as? String {
                    self.transcodeName = value
                }
                if let value = dict["TranscodeTemplate"] as? String {
                    self.transcodeTemplate = value
                }
            }
        }
        public var domainTranscodeInfo: [DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainTranscodeInfo != nil {
                var tmp : [Any] = []
                for k in self.domainTranscodeInfo! {
                    tmp.append(k.toMap())
                }
                map["DomainTranscodeInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainTranscodeInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList.DomainTranscodeInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainTranscodeInfo = tmp
            }
        }
    }
    public var domainTranscodeList: DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainTranscodeList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainTranscodeList != nil {
            map["DomainTranscodeList"] = self.domainTranscodeList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainTranscodeList"] as? [String: Any?] {
            var model = DescribeLiveStreamTranscodeInfoResponseBody.DomainTranscodeList()
            model.fromMap(value)
            self.domainTranscodeList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamTranscodeInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamTranscodeInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamTranscodeInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamTranscodeMetricDataRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var nextPageToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["NextPageToken"] as? String {
            self.nextPageToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamTranscodeMetricDataResponseBody : Tea.TeaModel {
    public class StreamDetailData : Tea.TeaModel {
        public class StreamData : Tea.TeaModel {
            public var appName: String?

            public var duration: Int64?

            public var fps: String?

            public var region: String?

            public var resolution: String?

            public var streamName: String?

            public var timeStamp: String?

            public var transcodeType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.resolution != nil {
                    map["Resolution"] = self.resolution!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.transcodeType != nil {
                    map["TranscodeType"] = self.transcodeType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["Duration"] as? Int64 {
                    self.duration = value
                }
                if let value = dict["Fps"] as? String {
                    self.fps = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["Resolution"] as? String {
                    self.resolution = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
                if let value = dict["TranscodeType"] as? String {
                    self.transcodeType = value
                }
            }
        }
        public var streamData: [DescribeLiveStreamTranscodeMetricDataResponseBody.StreamDetailData.StreamData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamData != nil {
                var tmp : [Any] = []
                for k in self.streamData! {
                    tmp.append(k.toMap())
                }
                map["StreamData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StreamData"] as? [Any?] {
                var tmp : [DescribeLiveStreamTranscodeMetricDataResponseBody.StreamDetailData.StreamData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamTranscodeMetricDataResponseBody.StreamDetailData.StreamData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.streamData = tmp
            }
        }
    }
    public var domainName: String?

    public var endTime: String?

    public var nextPageToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var startTime: String?

    public var streamDetailData: DescribeLiveStreamTranscodeMetricDataResponseBody.StreamDetailData?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamDetailData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamDetailData != nil {
            map["StreamDetailData"] = self.streamDetailData?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["NextPageToken"] as? String {
            self.nextPageToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamDetailData"] as? [String: Any?] {
            var model = DescribeLiveStreamTranscodeMetricDataResponseBody.StreamDetailData()
            model.fromMap(value)
            self.streamDetailData = model
        }
    }
}

public class DescribeLiveStreamTranscodeMetricDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamTranscodeMetricDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamTranscodeMetricDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamTranscodeStreamNumRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var splitType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.splitType != nil {
            map["SplitType"] = self.splitType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SplitType"] as? String {
            self.splitType = value
        }
    }
}

public class DescribeLiveStreamTranscodeStreamNumResponseBody : Tea.TeaModel {
    public class TranscodeStreamCountDetails : Tea.TeaModel {
        public var count: Int32?

        public var template: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.template != nil {
                map["Template"] = self.template!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Count"] as? Int32 {
                self.count = value
            }
            if let value = dict["Template"] as? String {
                self.template = value
            }
        }
    }
    public var lazyTranscodedNumber: Int64?

    public var requestId: String?

    public var total: Int64?

    public var transcodeStreamCountDetails: [DescribeLiveStreamTranscodeStreamNumResponseBody.TranscodeStreamCountDetails]?

    public var transcodedNumber: Int64?

    public var untranscodeNumber: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lazyTranscodedNumber != nil {
            map["LazyTranscodedNumber"] = self.lazyTranscodedNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.transcodeStreamCountDetails != nil {
            var tmp : [Any] = []
            for k in self.transcodeStreamCountDetails! {
                tmp.append(k.toMap())
            }
            map["TranscodeStreamCountDetails"] = tmp
        }
        if self.transcodedNumber != nil {
            map["TranscodedNumber"] = self.transcodedNumber!
        }
        if self.untranscodeNumber != nil {
            map["UntranscodeNumber"] = self.untranscodeNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LazyTranscodedNumber"] as? Int64 {
            self.lazyTranscodedNumber = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int64 {
            self.total = value
        }
        if let value = dict["TranscodeStreamCountDetails"] as? [Any?] {
            var tmp : [DescribeLiveStreamTranscodeStreamNumResponseBody.TranscodeStreamCountDetails] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveStreamTranscodeStreamNumResponseBody.TranscodeStreamCountDetails()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.transcodeStreamCountDetails = tmp
        }
        if let value = dict["TranscodedNumber"] as? Int64 {
            self.transcodedNumber = value
        }
        if let value = dict["UntranscodeNumber"] as? Int64 {
            self.untranscodeNumber = value
        }
    }
}

public class DescribeLiveStreamTranscodeStreamNumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamTranscodeStreamNumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamTranscodeStreamNumResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamWatermarkRulesRequest : Tea.TeaModel {
    public var domain: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveStreamWatermarkRulesResponseBody : Tea.TeaModel {
    public class RuleInfoList : Tea.TeaModel {
        public class RuleInfo : Tea.TeaModel {
            public var app: String?

            public var description_: String?

            public var domain: String?

            public var name: String?

            public var ruleId: String?

            public var stream: String?

            public var templateId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.app != nil {
                    map["App"] = self.app!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.stream != nil {
                    map["Stream"] = self.stream!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["App"] as? String {
                    self.app = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RuleId"] as? String {
                    self.ruleId = value
                }
                if let value = dict["Stream"] as? String {
                    self.stream = value
                }
                if let value = dict["TemplateId"] as? String {
                    self.templateId = value
                }
            }
        }
        public var ruleInfo: [DescribeLiveStreamWatermarkRulesResponseBody.RuleInfoList.RuleInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleInfo != nil {
                var tmp : [Any] = []
                for k in self.ruleInfo! {
                    tmp.append(k.toMap())
                }
                map["RuleInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RuleInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamWatermarkRulesResponseBody.RuleInfoList.RuleInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamWatermarkRulesResponseBody.RuleInfoList.RuleInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ruleInfo = tmp
            }
        }
    }
    public var requestId: String?

    public var ruleInfoList: DescribeLiveStreamWatermarkRulesResponseBody.RuleInfoList?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ruleInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleInfoList != nil {
            map["RuleInfoList"] = self.ruleInfoList?.toMap()
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RuleInfoList"] as? [String: Any?] {
            var model = DescribeLiveStreamWatermarkRulesResponseBody.RuleInfoList()
            model.fromMap(value)
            self.ruleInfoList = model
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeLiveStreamWatermarkRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamWatermarkRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamWatermarkRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamWatermarksRequest : Tea.TeaModel {
    public var domain: String?

    public var keyWord: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.keyWord != nil {
            map["KeyWord"] = self.keyWord!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["KeyWord"] as? String {
            self.keyWord = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveStreamWatermarksResponseBody : Tea.TeaModel {
    public class WatermarkList : Tea.TeaModel {
        public class Watermark : Tea.TeaModel {
            public var description_: String?

            public var height: Int32?

            public var name: String?

            public var offsetCorner: String?

            public var pictureUrl: String?

            public var refHeight: Int32?

            public var refWidth: Int32?

            public var ruleCount: Int32?

            public var templateId: String?

            public var transparency: Int32?

            public var type: Int32?

            public var XOffset: Double?

            public var YOffset: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.offsetCorner != nil {
                    map["OffsetCorner"] = self.offsetCorner!
                }
                if self.pictureUrl != nil {
                    map["PictureUrl"] = self.pictureUrl!
                }
                if self.refHeight != nil {
                    map["RefHeight"] = self.refHeight!
                }
                if self.refWidth != nil {
                    map["RefWidth"] = self.refWidth!
                }
                if self.ruleCount != nil {
                    map["RuleCount"] = self.ruleCount!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.transparency != nil {
                    map["Transparency"] = self.transparency!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.XOffset != nil {
                    map["XOffset"] = self.XOffset!
                }
                if self.YOffset != nil {
                    map["YOffset"] = self.YOffset!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Height"] as? Int32 {
                    self.height = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["OffsetCorner"] as? String {
                    self.offsetCorner = value
                }
                if let value = dict["PictureUrl"] as? String {
                    self.pictureUrl = value
                }
                if let value = dict["RefHeight"] as? Int32 {
                    self.refHeight = value
                }
                if let value = dict["RefWidth"] as? Int32 {
                    self.refWidth = value
                }
                if let value = dict["RuleCount"] as? Int32 {
                    self.ruleCount = value
                }
                if let value = dict["TemplateId"] as? String {
                    self.templateId = value
                }
                if let value = dict["Transparency"] as? Int32 {
                    self.transparency = value
                }
                if let value = dict["Type"] as? Int32 {
                    self.type = value
                }
                if let value = dict["XOffset"] as? Double {
                    self.XOffset = value
                }
                if let value = dict["YOffset"] as? Double {
                    self.YOffset = value
                }
            }
        }
        public var watermark: [DescribeLiveStreamWatermarksResponseBody.WatermarkList.Watermark]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.watermark != nil {
                var tmp : [Any] = []
                for k in self.watermark! {
                    tmp.append(k.toMap())
                }
                map["Watermark"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Watermark"] as? [Any?] {
                var tmp : [DescribeLiveStreamWatermarksResponseBody.WatermarkList.Watermark] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamWatermarksResponseBody.WatermarkList.Watermark()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.watermark = tmp
            }
        }
    }
    public var requestId: String?

    public var total: Int32?

    public var watermarkList: DescribeLiveStreamWatermarksResponseBody.WatermarkList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.watermarkList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.watermarkList != nil {
            map["WatermarkList"] = self.watermarkList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
        if let value = dict["WatermarkList"] as? [String: Any?] {
            var model = DescribeLiveStreamWatermarksResponseBody.WatermarkList()
            model.fromMap(value)
            self.watermarkList = model
        }
    }
}

public class DescribeLiveStreamWatermarksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamWatermarksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamWatermarksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamsBlockListRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class DescribeLiveStreamsBlockListResponseBody : Tea.TeaModel {
    public class StreamUrls : Tea.TeaModel {
        public var streamUrl: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamUrl != nil {
                map["StreamUrl"] = self.streamUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StreamUrl"] as? [String] {
                self.streamUrl = value
            }
        }
    }
    public var domainName: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var streamUrls: DescribeLiveStreamsBlockListResponseBody.StreamUrls?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamUrls?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamUrls != nil {
            map["StreamUrls"] = self.streamUrls?.toMap()
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamUrls"] as? [String: Any?] {
            var model = DescribeLiveStreamsBlockListResponseBody.StreamUrls()
            model.fromMap(value)
            self.streamUrls = model
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveStreamsBlockListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsBlockListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamsBlockListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamsControlHistoryRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveStreamsControlHistoryResponseBody : Tea.TeaModel {
    public class ControlInfo : Tea.TeaModel {
        public class LiveStreamControlInfo : Tea.TeaModel {
            public var action: String?

            public var clientIP: String?

            public var streamName: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.clientIP != nil {
                    map["ClientIP"] = self.clientIP!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Action"] as? String {
                    self.action = value
                }
                if let value = dict["ClientIP"] as? String {
                    self.clientIP = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["TimeStamp"] as? String {
                    self.timeStamp = value
                }
            }
        }
        public var liveStreamControlInfo: [DescribeLiveStreamsControlHistoryResponseBody.ControlInfo.LiveStreamControlInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamControlInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamControlInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamControlInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveStreamControlInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamsControlHistoryResponseBody.ControlInfo.LiveStreamControlInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamsControlHistoryResponseBody.ControlInfo.LiveStreamControlInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveStreamControlInfo = tmp
            }
        }
    }
    public var controlInfo: DescribeLiveStreamsControlHistoryResponseBody.ControlInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.controlInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.controlInfo != nil {
            map["ControlInfo"] = self.controlInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ControlInfo"] as? [String: Any?] {
            var model = DescribeLiveStreamsControlHistoryResponseBody.ControlInfo()
            model.fromMap(value)
            self.controlInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamsControlHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsControlHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamsControlHistoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamsNotifyRecordsRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: String?

    public var status: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveStreamsNotifyRecordsResponseBody : Tea.TeaModel {
    public class NotifyRecordsInfo : Tea.TeaModel {
        public class LiveStreamNotifyRecordsInfo : Tea.TeaModel {
            public var appName: String?

            public var description_: String?

            public var domainName: String?

            public var notifyContent: String?

            public var notifyHeader: String?

            public var notifyResponse: String?

            public var notifyResult: String?

            public var notifyTime: String?

            public var notifyType: String?

            public var notifyUrl: String?

            public var streamName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.notifyContent != nil {
                    map["NotifyContent"] = self.notifyContent!
                }
                if self.notifyHeader != nil {
                    map["NotifyHeader"] = self.notifyHeader!
                }
                if self.notifyResponse != nil {
                    map["NotifyResponse"] = self.notifyResponse!
                }
                if self.notifyResult != nil {
                    map["NotifyResult"] = self.notifyResult!
                }
                if self.notifyTime != nil {
                    map["NotifyTime"] = self.notifyTime!
                }
                if self.notifyType != nil {
                    map["NotifyType"] = self.notifyType!
                }
                if self.notifyUrl != nil {
                    map["NotifyUrl"] = self.notifyUrl!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["NotifyContent"] as? String {
                    self.notifyContent = value
                }
                if let value = dict["NotifyHeader"] as? String {
                    self.notifyHeader = value
                }
                if let value = dict["NotifyResponse"] as? String {
                    self.notifyResponse = value
                }
                if let value = dict["NotifyResult"] as? String {
                    self.notifyResult = value
                }
                if let value = dict["NotifyTime"] as? String {
                    self.notifyTime = value
                }
                if let value = dict["NotifyType"] as? String {
                    self.notifyType = value
                }
                if let value = dict["NotifyUrl"] as? String {
                    self.notifyUrl = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
            }
        }
        public var liveStreamNotifyRecordsInfo: [DescribeLiveStreamsNotifyRecordsResponseBody.NotifyRecordsInfo.LiveStreamNotifyRecordsInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamNotifyRecordsInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamNotifyRecordsInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamNotifyRecordsInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveStreamNotifyRecordsInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamsNotifyRecordsResponseBody.NotifyRecordsInfo.LiveStreamNotifyRecordsInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamsNotifyRecordsResponseBody.NotifyRecordsInfo.LiveStreamNotifyRecordsInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveStreamNotifyRecordsInfo = tmp
            }
        }
    }
    public var notifyRecordsInfo: DescribeLiveStreamsNotifyRecordsResponseBody.NotifyRecordsInfo?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.notifyRecordsInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.notifyRecordsInfo != nil {
            map["NotifyRecordsInfo"] = self.notifyRecordsInfo?.toMap()
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NotifyRecordsInfo"] as? [String: Any?] {
            var model = DescribeLiveStreamsNotifyRecordsResponseBody.NotifyRecordsInfo()
            model.fromMap(value)
            self.notifyRecordsInfo = model
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveStreamsNotifyRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsNotifyRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamsNotifyRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamsNotifyUrlConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveStreamsNotifyUrlConfigResponseBody : Tea.TeaModel {
    public class LiveStreamsNotifyConfig : Tea.TeaModel {
        public var domainName: String?

        public var exceptionNotifyUrl: String?

        public var notifyAuthKey: String?

        public var notifyReqAuth: String?

        public var notifyUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.exceptionNotifyUrl != nil {
                map["ExceptionNotifyUrl"] = self.exceptionNotifyUrl!
            }
            if self.notifyAuthKey != nil {
                map["NotifyAuthKey"] = self.notifyAuthKey!
            }
            if self.notifyReqAuth != nil {
                map["NotifyReqAuth"] = self.notifyReqAuth!
            }
            if self.notifyUrl != nil {
                map["NotifyUrl"] = self.notifyUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["ExceptionNotifyUrl"] as? String {
                self.exceptionNotifyUrl = value
            }
            if let value = dict["NotifyAuthKey"] as? String {
                self.notifyAuthKey = value
            }
            if let value = dict["NotifyReqAuth"] as? String {
                self.notifyReqAuth = value
            }
            if let value = dict["NotifyUrl"] as? String {
                self.notifyUrl = value
            }
        }
    }
    public var liveStreamsNotifyConfig: DescribeLiveStreamsNotifyUrlConfigResponseBody.LiveStreamsNotifyConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.liveStreamsNotifyConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveStreamsNotifyConfig != nil {
            map["LiveStreamsNotifyConfig"] = self.liveStreamsNotifyConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveStreamsNotifyConfig"] as? [String: Any?] {
            var model = DescribeLiveStreamsNotifyUrlConfigResponseBody.LiveStreamsNotifyConfig()
            model.fromMap(value)
            self.liveStreamsNotifyConfig = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveStreamsNotifyUrlConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsNotifyUrlConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamsNotifyUrlConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamsOnlineListRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var onlyStream: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var queryType: String?

    public var regionId: String?

    public var streamName: String?

    public var streamType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.onlyStream != nil {
            map["OnlyStream"] = self.onlyStream!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryType != nil {
            map["QueryType"] = self.queryType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OnlyStream"] as? String {
            self.onlyStream = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["QueryType"] as? String {
            self.queryType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["StreamType"] as? String {
            self.streamType = value
        }
    }
}

public class DescribeLiveStreamsOnlineListResponseBody : Tea.TeaModel {
    public class OnlineInfo : Tea.TeaModel {
        public class LiveStreamOnlineInfo : Tea.TeaModel {
            public var appName: String?

            public var audioCodecId: Int32?

            public var audioDataRate: Int32?

            public var clientIp: String?

            public var domainName: String?

            public var frameRate: Int32?

            public var height: Int32?

            public var publishDomain: String?

            public var publishTime: String?

            public var publishType: String?

            public var publishUrl: String?

            public var serverIp: String?

            public var streamName: String?

            public var transcoded: String?

            public var videoCodecId: Int32?

            public var videoDataRate: Int32?

            public var width: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.audioCodecId != nil {
                    map["AudioCodecId"] = self.audioCodecId!
                }
                if self.audioDataRate != nil {
                    map["AudioDataRate"] = self.audioDataRate!
                }
                if self.clientIp != nil {
                    map["ClientIp"] = self.clientIp!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.frameRate != nil {
                    map["FrameRate"] = self.frameRate!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.publishDomain != nil {
                    map["PublishDomain"] = self.publishDomain!
                }
                if self.publishTime != nil {
                    map["PublishTime"] = self.publishTime!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.publishUrl != nil {
                    map["PublishUrl"] = self.publishUrl!
                }
                if self.serverIp != nil {
                    map["ServerIp"] = self.serverIp!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.transcoded != nil {
                    map["Transcoded"] = self.transcoded!
                }
                if self.videoCodecId != nil {
                    map["VideoCodecId"] = self.videoCodecId!
                }
                if self.videoDataRate != nil {
                    map["VideoDataRate"] = self.videoDataRate!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["AudioCodecId"] as? Int32 {
                    self.audioCodecId = value
                }
                if let value = dict["AudioDataRate"] as? Int32 {
                    self.audioDataRate = value
                }
                if let value = dict["ClientIp"] as? String {
                    self.clientIp = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["FrameRate"] as? Int32 {
                    self.frameRate = value
                }
                if let value = dict["Height"] as? Int32 {
                    self.height = value
                }
                if let value = dict["PublishDomain"] as? String {
                    self.publishDomain = value
                }
                if let value = dict["PublishTime"] as? String {
                    self.publishTime = value
                }
                if let value = dict["PublishType"] as? String {
                    self.publishType = value
                }
                if let value = dict["PublishUrl"] as? String {
                    self.publishUrl = value
                }
                if let value = dict["ServerIp"] as? String {
                    self.serverIp = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["Transcoded"] as? String {
                    self.transcoded = value
                }
                if let value = dict["VideoCodecId"] as? Int32 {
                    self.videoCodecId = value
                }
                if let value = dict["VideoDataRate"] as? Int32 {
                    self.videoDataRate = value
                }
                if let value = dict["Width"] as? Int32 {
                    self.width = value
                }
            }
        }
        public var liveStreamOnlineInfo: [DescribeLiveStreamsOnlineListResponseBody.OnlineInfo.LiveStreamOnlineInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamOnlineInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamOnlineInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamOnlineInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveStreamOnlineInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamsOnlineListResponseBody.OnlineInfo.LiveStreamOnlineInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamsOnlineListResponseBody.OnlineInfo.LiveStreamOnlineInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveStreamOnlineInfo = tmp
            }
        }
    }
    public var onlineInfo: DescribeLiveStreamsOnlineListResponseBody.OnlineInfo?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.onlineInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onlineInfo != nil {
            map["OnlineInfo"] = self.onlineInfo?.toMap()
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OnlineInfo"] as? [String: Any?] {
            var model = DescribeLiveStreamsOnlineListResponseBody.OnlineInfo()
            model.fromMap(value)
            self.onlineInfo = model
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveStreamsOnlineListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsOnlineListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamsOnlineListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamsPublishListRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var orderBy: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var queryType: String?

    public var regionId: String?

    public var startTime: String?

    public var streamName: String?

    public var streamType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryType != nil {
            map["QueryType"] = self.queryType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.streamType != nil {
            map["StreamType"] = self.streamType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["QueryType"] as? String {
            self.queryType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["StreamType"] as? String {
            self.streamType = value
        }
    }
}

public class DescribeLiveStreamsPublishListResponseBody : Tea.TeaModel {
    public class PublishInfo : Tea.TeaModel {
        public class LiveStreamPublishInfo : Tea.TeaModel {
            public var aliInnerErrorFlags: String?

            public var appName: String?

            public var clientAddr: String?

            public var domainName: String?

            public var edgeNodeAddr: String?

            public var publishDomain: String?

            public var publishTime: String?

            public var publishType: String?

            public var publishUrl: String?

            public var stopTime: String?

            public var streamName: String?

            public var streamUrl: String?

            public var transcodeId: String?

            public var transcoded: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliInnerErrorFlags != nil {
                    map["AliInnerErrorFlags"] = self.aliInnerErrorFlags!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.clientAddr != nil {
                    map["ClientAddr"] = self.clientAddr!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.edgeNodeAddr != nil {
                    map["EdgeNodeAddr"] = self.edgeNodeAddr!
                }
                if self.publishDomain != nil {
                    map["PublishDomain"] = self.publishDomain!
                }
                if self.publishTime != nil {
                    map["PublishTime"] = self.publishTime!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.publishUrl != nil {
                    map["PublishUrl"] = self.publishUrl!
                }
                if self.stopTime != nil {
                    map["StopTime"] = self.stopTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                if self.transcodeId != nil {
                    map["TranscodeId"] = self.transcodeId!
                }
                if self.transcoded != nil {
                    map["Transcoded"] = self.transcoded!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AliInnerErrorFlags"] as? String {
                    self.aliInnerErrorFlags = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["ClientAddr"] as? String {
                    self.clientAddr = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["EdgeNodeAddr"] as? String {
                    self.edgeNodeAddr = value
                }
                if let value = dict["PublishDomain"] as? String {
                    self.publishDomain = value
                }
                if let value = dict["PublishTime"] as? String {
                    self.publishTime = value
                }
                if let value = dict["PublishType"] as? String {
                    self.publishType = value
                }
                if let value = dict["PublishUrl"] as? String {
                    self.publishUrl = value
                }
                if let value = dict["StopTime"] as? String {
                    self.stopTime = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["StreamUrl"] as? String {
                    self.streamUrl = value
                }
                if let value = dict["TranscodeId"] as? String {
                    self.transcodeId = value
                }
                if let value = dict["Transcoded"] as? String {
                    self.transcoded = value
                }
            }
        }
        public var liveStreamPublishInfo: [DescribeLiveStreamsPublishListResponseBody.PublishInfo.LiveStreamPublishInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.liveStreamPublishInfo != nil {
                var tmp : [Any] = []
                for k in self.liveStreamPublishInfo! {
                    tmp.append(k.toMap())
                }
                map["LiveStreamPublishInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LiveStreamPublishInfo"] as? [Any?] {
                var tmp : [DescribeLiveStreamsPublishListResponseBody.PublishInfo.LiveStreamPublishInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamsPublishListResponseBody.PublishInfo.LiveStreamPublishInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.liveStreamPublishInfo = tmp
            }
        }
    }
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var publishInfo: DescribeLiveStreamsPublishListResponseBody.PublishInfo?

    public var requestId: String?

    public var totalNum: Int32?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.publishInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.publishInfo != nil {
            map["PublishInfo"] = self.publishInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PublishInfo"] as? [String: Any?] {
            var model = DescribeLiveStreamsPublishListResponseBody.PublishInfo()
            model.fromMap(value)
            self.publishInfo = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int32 {
            self.totalNum = value
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeLiveStreamsPublishListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsPublishListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamsPublishListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveStreamsTotalCountRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var typ: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.typ != nil {
            map["Typ"] = self.typ!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Typ"] as? String {
            self.typ = value
        }
    }
}

public class DescribeLiveStreamsTotalCountResponseBody : Tea.TeaModel {
    public class StreamCountList : Tea.TeaModel {
        public class StreamCountInfos : Tea.TeaModel {
            public var count: Int32?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Count"] as? Int32 {
                    self.count = value
                }
                if let value = dict["Timestamp"] as? String {
                    self.timestamp = value
                }
            }
        }
        public var streamCountInfos: [DescribeLiveStreamsTotalCountResponseBody.StreamCountList.StreamCountInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamCountInfos != nil {
                var tmp : [Any] = []
                for k in self.streamCountInfos! {
                    tmp.append(k.toMap())
                }
                map["StreamCountInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StreamCountInfos"] as? [Any?] {
                var tmp : [DescribeLiveStreamsTotalCountResponseBody.StreamCountList.StreamCountInfos] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveStreamsTotalCountResponseBody.StreamCountList.StreamCountInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.streamCountInfos = tmp
            }
        }
    }
    public var requestId: String?

    public var streamCountList: DescribeLiveStreamsTotalCountResponseBody.StreamCountList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamCountList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamCountList != nil {
            map["StreamCountList"] = self.streamCountList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamCountList"] as? [String: Any?] {
            var model = DescribeLiveStreamsTotalCountResponseBody.StreamCountList()
            model.fromMap(value)
            self.streamCountList = model
        }
    }
}

public class DescribeLiveStreamsTotalCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveStreamsTotalCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveStreamsTotalCountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [DescribeLiveTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeLiveTagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveTagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeLiveTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var resourceId: String?

        public var tag: [DescribeLiveTagResourcesResponseBody.TagResources.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["Tag"] as? [Any?] {
                var tmp : [DescribeLiveTagResourcesResponseBody.TagResources.Tag] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveTagResourcesResponseBody.TagResources.Tag()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tag = tmp
            }
        }
    }
    public var requestId: String?

    public var tagResources: [DescribeLiveTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [Any?] {
            var tmp : [DescribeLiveTagResourcesResponseBody.TagResources] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveTagResourcesResponseBody.TagResources()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tagResources = tmp
        }
    }
}

public class DescribeLiveTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveTopDomainsByFlowRequest : Tea.TeaModel {
    public var endTime: String?

    public var limit: Int64?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Limit"] as? Int64 {
            self.limit = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveTopDomainsByFlowResponseBody : Tea.TeaModel {
    public class TopDomains : Tea.TeaModel {
        public class TopDomain : Tea.TeaModel {
            public var domainName: String?

            public var maxBps: Int64?

            public var maxBpsTime: String?

            public var rank: Int64?

            public var totalAccess: Int64?

            public var totalTraffic: String?

            public var trafficPercent: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.maxBps != nil {
                    map["MaxBps"] = self.maxBps!
                }
                if self.maxBpsTime != nil {
                    map["MaxBpsTime"] = self.maxBpsTime!
                }
                if self.rank != nil {
                    map["Rank"] = self.rank!
                }
                if self.totalAccess != nil {
                    map["TotalAccess"] = self.totalAccess!
                }
                if self.totalTraffic != nil {
                    map["TotalTraffic"] = self.totalTraffic!
                }
                if self.trafficPercent != nil {
                    map["TrafficPercent"] = self.trafficPercent!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["MaxBps"] as? Int64 {
                    self.maxBps = value
                }
                if let value = dict["MaxBpsTime"] as? String {
                    self.maxBpsTime = value
                }
                if let value = dict["Rank"] as? Int64 {
                    self.rank = value
                }
                if let value = dict["TotalAccess"] as? Int64 {
                    self.totalAccess = value
                }
                if let value = dict["TotalTraffic"] as? String {
                    self.totalTraffic = value
                }
                if let value = dict["TrafficPercent"] as? String {
                    self.trafficPercent = value
                }
            }
        }
        public var topDomain: [DescribeLiveTopDomainsByFlowResponseBody.TopDomains.TopDomain]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.topDomain != nil {
                var tmp : [Any] = []
                for k in self.topDomain! {
                    tmp.append(k.toMap())
                }
                map["TopDomain"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TopDomain"] as? [Any?] {
                var tmp : [DescribeLiveTopDomainsByFlowResponseBody.TopDomains.TopDomain] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveTopDomainsByFlowResponseBody.TopDomains.TopDomain()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.topDomain = tmp
            }
        }
    }
    public var domainCount: Int64?

    public var domainOnlineCount: Int64?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var topDomains: DescribeLiveTopDomainsByFlowResponseBody.TopDomains?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.topDomains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainCount != nil {
            map["DomainCount"] = self.domainCount!
        }
        if self.domainOnlineCount != nil {
            map["DomainOnlineCount"] = self.domainOnlineCount!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.topDomains != nil {
            map["TopDomains"] = self.topDomains?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainCount"] as? Int64 {
            self.domainCount = value
        }
        if let value = dict["DomainOnlineCount"] as? Int64 {
            self.domainOnlineCount = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TopDomains"] as? [String: Any?] {
            var model = DescribeLiveTopDomainsByFlowResponseBody.TopDomains()
            model.fromMap(value)
            self.topDomains = model
        }
    }
}

public class DescribeLiveTopDomainsByFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveTopDomainsByFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveTopDomainsByFlowResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveTrafficDomainLogRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveTrafficDomainLogResponseBody : Tea.TeaModel {
    public class DomainLogDetails : Tea.TeaModel {
        public class DomainLogDetail : Tea.TeaModel {
            public class LogInfos : Tea.TeaModel {
                public class LogInfoDetail : Tea.TeaModel {
                    public var endTime: String?

                    public var logName: String?

                    public var logPath: String?

                    public var logSize: Int64?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.logName != nil {
                            map["LogName"] = self.logName!
                        }
                        if self.logPath != nil {
                            map["LogPath"] = self.logPath!
                        }
                        if self.logSize != nil {
                            map["LogSize"] = self.logSize!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["LogName"] as? String {
                            self.logName = value
                        }
                        if let value = dict["LogPath"] as? String {
                            self.logPath = value
                        }
                        if let value = dict["LogSize"] as? Int64 {
                            self.logSize = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                    }
                }
                public var logInfoDetail: [DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logInfoDetail != nil {
                        var tmp : [Any] = []
                        for k in self.logInfoDetail! {
                            tmp.append(k.toMap())
                        }
                        map["LogInfoDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LogInfoDetail"] as? [Any?] {
                        var tmp : [DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.logInfoDetail = tmp
                    }
                }
            }
            public class PageInfos : Tea.TeaModel {
                public var pageIndex: Int64?

                public var pageSize: Int64?

                public var total: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pageIndex != nil {
                        map["PageIndex"] = self.pageIndex!
                    }
                    if self.pageSize != nil {
                        map["PageSize"] = self.pageSize!
                    }
                    if self.total != nil {
                        map["Total"] = self.total!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PageIndex"] as? Int64 {
                        self.pageIndex = value
                    }
                    if let value = dict["PageSize"] as? Int64 {
                        self.pageSize = value
                    }
                    if let value = dict["Total"] as? Int64 {
                        self.total = value
                    }
                }
            }
            public var logCount: Int64?

            public var logInfos: DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos?

            public var pageInfos: DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.logInfos?.validate()
                try self.pageInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.logInfos != nil {
                    map["LogInfos"] = self.logInfos?.toMap()
                }
                if self.pageInfos != nil {
                    map["PageInfos"] = self.pageInfos?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LogCount"] as? Int64 {
                    self.logCount = value
                }
                if let value = dict["LogInfos"] as? [String: Any?] {
                    var model = DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos()
                    model.fromMap(value)
                    self.logInfos = model
                }
                if let value = dict["PageInfos"] as? [String: Any?] {
                    var model = DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos()
                    model.fromMap(value)
                    self.pageInfos = model
                }
            }
        }
        public var domainLogDetail: [DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLogDetail != nil {
                var tmp : [Any] = []
                for k in self.domainLogDetail! {
                    tmp.append(k.toMap())
                }
                map["DomainLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainLogDetail"] as? [Any?] {
                var tmp : [DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails.DomainLogDetail()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainLogDetail = tmp
            }
        }
    }
    public var domainLogDetails: DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails?

    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogDetails != nil {
            map["DomainLogDetails"] = self.domainLogDetails?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainLogDetails"] as? [String: Any?] {
            var model = DescribeLiveTrafficDomainLogResponseBody.DomainLogDetails()
            model.fromMap(value)
            self.domainLogDetails = model
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveTrafficDomainLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveTrafficDomainLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveTrafficDomainLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveUpVideoAudioInfoRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
    }
}

public class DescribeLiveUpVideoAudioInfoResponseBody : Tea.TeaModel {
    public class UpItems : Tea.TeaModel {
        public class PublishItem : Tea.TeaModel {
            public class AacHeaders : Tea.TeaModel {
                public class AacHeaders : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var aacHeaders: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AacHeaders.AacHeaders]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.aacHeaders != nil {
                        var tmp : [Any] = []
                        for k in self.aacHeaders! {
                            tmp.append(k.toMap())
                        }
                        map["AacHeaders"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AacHeaders"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AacHeaders.AacHeaders] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AacHeaders.AacHeaders()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.aacHeaders = tmp
                    }
                }
            }
            public class AudioBitRate : Tea.TeaModel {
                public class AudioBitRate : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var audioBitRate: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioBitRate.AudioBitRate]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioBitRate != nil {
                        var tmp : [Any] = []
                        for k in self.audioBitRate! {
                            tmp.append(k.toMap())
                        }
                        map["AudioBitRate"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AudioBitRate"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioBitRate.AudioBitRate] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioBitRate.AudioBitRate()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.audioBitRate = tmp
                    }
                }
            }
            public class AudioFrames : Tea.TeaModel {
                public class AudioFrames : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var audioFrames: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioFrames.AudioFrames]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioFrames != nil {
                        var tmp : [Any] = []
                        for k in self.audioFrames! {
                            tmp.append(k.toMap())
                        }
                        map["AudioFrames"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AudioFrames"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioFrames.AudioFrames] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioFrames.AudioFrames()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.audioFrames = tmp
                    }
                }
            }
            public class AudioInterval : Tea.TeaModel {
                public class AudioInterval : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var audioInterval: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioInterval.AudioInterval]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioInterval != nil {
                        var tmp : [Any] = []
                        for k in self.audioInterval! {
                            tmp.append(k.toMap())
                        }
                        map["AudioInterval"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AudioInterval"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioInterval.AudioInterval] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioInterval.AudioInterval()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.audioInterval = tmp
                    }
                }
            }
            public class AudioStamps : Tea.TeaModel {
                public class AudioStamps : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var audioStamps: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioStamps.AudioStamps]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStamps != nil {
                        var tmp : [Any] = []
                        for k in self.audioStamps! {
                            tmp.append(k.toMap())
                        }
                        map["AudioStamps"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AudioStamps"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioStamps.AudioStamps] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioStamps.AudioStamps()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.audioStamps = tmp
                    }
                }
            }
            public class AvcHeaders : Tea.TeaModel {
                public class AvcHeaders : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var avcHeaders: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AvcHeaders.AvcHeaders]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avcHeaders != nil {
                        var tmp : [Any] = []
                        for k in self.avcHeaders! {
                            tmp.append(k.toMap())
                        }
                        map["AvcHeaders"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AvcHeaders"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AvcHeaders.AvcHeaders] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AvcHeaders.AvcHeaders()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.avcHeaders = tmp
                    }
                }
            }
            public class ErrorFlags : Tea.TeaModel {
                public class ErrorFlags : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var errorFlags: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.ErrorFlags.ErrorFlags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorFlags != nil {
                        var tmp : [Any] = []
                        for k in self.errorFlags! {
                            tmp.append(k.toMap())
                        }
                        map["ErrorFlags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ErrorFlags"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.ErrorFlags.ErrorFlags] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.ErrorFlags.ErrorFlags()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.errorFlags = tmp
                    }
                }
            }
            public class VideoAndAudioStamp : Tea.TeaModel {
                public class VAStamp : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var vAStamp: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoAndAudioStamp.VAStamp]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vAStamp != nil {
                        var tmp : [Any] = []
                        for k in self.vAStamp! {
                            tmp.append(k.toMap())
                        }
                        map["V_AStamp"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["V_AStamp"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoAndAudioStamp.VAStamp] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoAndAudioStamp.VAStamp()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.vAStamp = tmp
                    }
                }
            }
            public class VideoBitRate : Tea.TeaModel {
                public class VideoBitRate : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var videoBitRate: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoBitRate.VideoBitRate]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoBitRate != nil {
                        var tmp : [Any] = []
                        for k in self.videoBitRate! {
                            tmp.append(k.toMap())
                        }
                        map["VideoBitRate"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VideoBitRate"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoBitRate.VideoBitRate] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoBitRate.VideoBitRate()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.videoBitRate = tmp
                    }
                }
            }
            public class VideoFrames : Tea.TeaModel {
                public class VideoFrames : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var videoFrames: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoFrames.VideoFrames]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoFrames != nil {
                        var tmp : [Any] = []
                        for k in self.videoFrames! {
                            tmp.append(k.toMap())
                        }
                        map["VideoFrames"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VideoFrames"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoFrames.VideoFrames] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoFrames.VideoFrames()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.videoFrames = tmp
                    }
                }
            }
            public class VideoInterval : Tea.TeaModel {
                public class VideoInterval : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var videoInterval: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoInterval.VideoInterval]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoInterval != nil {
                        var tmp : [Any] = []
                        for k in self.videoInterval! {
                            tmp.append(k.toMap())
                        }
                        map["VideoInterval"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VideoInterval"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoInterval.VideoInterval] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoInterval.VideoInterval()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.videoInterval = tmp
                    }
                }
            }
            public class VideoStamps : Tea.TeaModel {
                public class VideoStamps : Tea.TeaModel {
                    public var time: Int64?

                    public var value: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.time != nil {
                            map["Time"] = self.time!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Time"] as? Int64 {
                            self.time = value
                        }
                        if let value = dict["Value"] as? Int32 {
                            self.value = value
                        }
                    }
                }
                public var videoStamps: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoStamps.VideoStamps]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoStamps != nil {
                        var tmp : [Any] = []
                        for k in self.videoStamps! {
                            tmp.append(k.toMap())
                        }
                        map["VideoStamps"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["VideoStamps"] as? [Any?] {
                        var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoStamps.VideoStamps] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoStamps.VideoStamps()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.videoStamps = tmp
                    }
                }
            }
            public var aacHeaders: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AacHeaders?

            public var appName: String?

            public var audioBitRate: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioBitRate?

            public var audioFrames: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioFrames?

            public var audioInterval: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioInterval?

            public var audioStamps: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioStamps?

            public var avcHeaders: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AvcHeaders?

            public var codecInfo: String?

            public var domainName: String?

            public var errorFlags: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.ErrorFlags?

            public var publishInterval: String?

            public var publishIp: String?

            public var publishStatus: String?

            public var publishTime: String?

            public var stopTime: String?

            public var streamName: String?

            public var uniqueId: String?

            public var videoAndAudioStamp: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoAndAudioStamp?

            public var videoBitRate: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoBitRate?

            public var videoFrames: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoFrames?

            public var videoInterval: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoInterval?

            public var videoStamps: DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoStamps?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.aacHeaders?.validate()
                try self.audioBitRate?.validate()
                try self.audioFrames?.validate()
                try self.audioInterval?.validate()
                try self.audioStamps?.validate()
                try self.avcHeaders?.validate()
                try self.errorFlags?.validate()
                try self.videoAndAudioStamp?.validate()
                try self.videoBitRate?.validate()
                try self.videoFrames?.validate()
                try self.videoInterval?.validate()
                try self.videoStamps?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aacHeaders != nil {
                    map["AacHeaders"] = self.aacHeaders?.toMap()
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.audioBitRate != nil {
                    map["AudioBitRate"] = self.audioBitRate?.toMap()
                }
                if self.audioFrames != nil {
                    map["AudioFrames"] = self.audioFrames?.toMap()
                }
                if self.audioInterval != nil {
                    map["AudioInterval"] = self.audioInterval?.toMap()
                }
                if self.audioStamps != nil {
                    map["AudioStamps"] = self.audioStamps?.toMap()
                }
                if self.avcHeaders != nil {
                    map["AvcHeaders"] = self.avcHeaders?.toMap()
                }
                if self.codecInfo != nil {
                    map["CodecInfo"] = self.codecInfo!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.errorFlags != nil {
                    map["ErrorFlags"] = self.errorFlags?.toMap()
                }
                if self.publishInterval != nil {
                    map["PublishInterval"] = self.publishInterval!
                }
                if self.publishIp != nil {
                    map["PublishIp"] = self.publishIp!
                }
                if self.publishStatus != nil {
                    map["PublishStatus"] = self.publishStatus!
                }
                if self.publishTime != nil {
                    map["PublishTime"] = self.publishTime!
                }
                if self.stopTime != nil {
                    map["StopTime"] = self.stopTime!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.uniqueId != nil {
                    map["UniqueId"] = self.uniqueId!
                }
                if self.videoAndAudioStamp != nil {
                    map["VideoAndAudioStamp"] = self.videoAndAudioStamp?.toMap()
                }
                if self.videoBitRate != nil {
                    map["VideoBitRate"] = self.videoBitRate?.toMap()
                }
                if self.videoFrames != nil {
                    map["VideoFrames"] = self.videoFrames?.toMap()
                }
                if self.videoInterval != nil {
                    map["VideoInterval"] = self.videoInterval?.toMap()
                }
                if self.videoStamps != nil {
                    map["VideoStamps"] = self.videoStamps?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AacHeaders"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AacHeaders()
                    model.fromMap(value)
                    self.aacHeaders = model
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["AudioBitRate"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioBitRate()
                    model.fromMap(value)
                    self.audioBitRate = model
                }
                if let value = dict["AudioFrames"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioFrames()
                    model.fromMap(value)
                    self.audioFrames = model
                }
                if let value = dict["AudioInterval"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioInterval()
                    model.fromMap(value)
                    self.audioInterval = model
                }
                if let value = dict["AudioStamps"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AudioStamps()
                    model.fromMap(value)
                    self.audioStamps = model
                }
                if let value = dict["AvcHeaders"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.AvcHeaders()
                    model.fromMap(value)
                    self.avcHeaders = model
                }
                if let value = dict["CodecInfo"] as? String {
                    self.codecInfo = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["ErrorFlags"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.ErrorFlags()
                    model.fromMap(value)
                    self.errorFlags = model
                }
                if let value = dict["PublishInterval"] as? String {
                    self.publishInterval = value
                }
                if let value = dict["PublishIp"] as? String {
                    self.publishIp = value
                }
                if let value = dict["PublishStatus"] as? String {
                    self.publishStatus = value
                }
                if let value = dict["PublishTime"] as? String {
                    self.publishTime = value
                }
                if let value = dict["StopTime"] as? String {
                    self.stopTime = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["UniqueId"] as? String {
                    self.uniqueId = value
                }
                if let value = dict["VideoAndAudioStamp"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoAndAudioStamp()
                    model.fromMap(value)
                    self.videoAndAudioStamp = model
                }
                if let value = dict["VideoBitRate"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoBitRate()
                    model.fromMap(value)
                    self.videoBitRate = model
                }
                if let value = dict["VideoFrames"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoFrames()
                    model.fromMap(value)
                    self.videoFrames = model
                }
                if let value = dict["VideoInterval"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoInterval()
                    model.fromMap(value)
                    self.videoInterval = model
                }
                if let value = dict["VideoStamps"] as? [String: Any?] {
                    var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem.VideoStamps()
                    model.fromMap(value)
                    self.videoStamps = model
                }
            }
        }
        public var publishItem: [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.publishItem != nil {
                var tmp : [Any] = []
                for k in self.publishItem! {
                    tmp.append(k.toMap())
                }
                map["PublishItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PublishItem"] as? [Any?] {
                var tmp : [DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems.PublishItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.publishItem = tmp
            }
        }
    }
    public var requestId: String?

    public var upItems: DescribeLiveUpVideoAudioInfoResponseBody.UpItems?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.upItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.upItems != nil {
            map["UpItems"] = self.upItems?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UpItems"] as? [String: Any?] {
            var model = DescribeLiveUpVideoAudioInfoResponseBody.UpItems()
            model.fromMap(value)
            self.upItems = model
        }
    }
}

public class DescribeLiveUpVideoAudioInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveUpVideoAudioInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveUpVideoAudioInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveUserBillPredictionRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveUserBillPredictionResponseBody : Tea.TeaModel {
    public class BillPredictionData : Tea.TeaModel {
        public class BillPredictionDataItem : Tea.TeaModel {
            public var area: String?

            public var timeStp: String?

            public var value: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.area != nil {
                    map["Area"] = self.area!
                }
                if self.timeStp != nil {
                    map["TimeStp"] = self.timeStp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Area"] as? String {
                    self.area = value
                }
                if let value = dict["TimeStp"] as? String {
                    self.timeStp = value
                }
                if let value = dict["Value"] as? Double {
                    self.value = value
                }
            }
        }
        public var billPredictionDataItem: [DescribeLiveUserBillPredictionResponseBody.BillPredictionData.BillPredictionDataItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.billPredictionDataItem != nil {
                var tmp : [Any] = []
                for k in self.billPredictionDataItem! {
                    tmp.append(k.toMap())
                }
                map["BillPredictionDataItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BillPredictionDataItem"] as? [Any?] {
                var tmp : [DescribeLiveUserBillPredictionResponseBody.BillPredictionData.BillPredictionDataItem] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveUserBillPredictionResponseBody.BillPredictionData.BillPredictionDataItem()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.billPredictionDataItem = tmp
            }
        }
    }
    public var billPredictionData: DescribeLiveUserBillPredictionResponseBody.BillPredictionData?

    public var billType: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.billPredictionData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.billPredictionData != nil {
            map["BillPredictionData"] = self.billPredictionData?.toMap()
        }
        if self.billType != nil {
            map["BillType"] = self.billType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BillPredictionData"] as? [String: Any?] {
            var model = DescribeLiveUserBillPredictionResponseBody.BillPredictionData()
            model.fromMap(value)
            self.billPredictionData = model
        }
        if let value = dict["BillType"] as? String {
            self.billType = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveUserBillPredictionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveUserBillPredictionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveUserBillPredictionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveUserDomainsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var domainName: String?

    public var domainSearchType: String?

    public var domainStatus: String?

    public var liveDomainType: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionName: String?

    public var resourceGroupId: String?

    public var securityToken: String?

    public var tag: [DescribeLiveUserDomainsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSearchType != nil {
            map["DomainSearchType"] = self.domainSearchType!
        }
        if self.domainStatus != nil {
            map["DomainStatus"] = self.domainStatus!
        }
        if self.liveDomainType != nil {
            map["LiveDomainType"] = self.liveDomainType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionName != nil {
            map["RegionName"] = self.regionName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainSearchType"] as? String {
            self.domainSearchType = value
        }
        if let value = dict["DomainStatus"] as? String {
            self.domainStatus = value
        }
        if let value = dict["LiveDomainType"] as? String {
            self.liveDomainType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionName"] as? String {
            self.regionName = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeLiveUserDomainsRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveUserDomainsRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeLiveUserDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class PageData : Tea.TeaModel {
            public var cname: String?

            public var description_: String?

            public var domainName: String?

            public var gmtCreated: String?

            public var gmtModified: String?

            public var liveDomainStatus: String?

            public var liveDomainType: String?

            public var regionName: String?

            public var resourceGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cname != nil {
                    map["Cname"] = self.cname!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.gmtCreated != nil {
                    map["GmtCreated"] = self.gmtCreated!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.liveDomainStatus != nil {
                    map["LiveDomainStatus"] = self.liveDomainStatus!
                }
                if self.liveDomainType != nil {
                    map["LiveDomainType"] = self.liveDomainType!
                }
                if self.regionName != nil {
                    map["RegionName"] = self.regionName!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cname"] as? String {
                    self.cname = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["GmtCreated"] as? String {
                    self.gmtCreated = value
                }
                if let value = dict["GmtModified"] as? String {
                    self.gmtModified = value
                }
                if let value = dict["LiveDomainStatus"] as? String {
                    self.liveDomainStatus = value
                }
                if let value = dict["LiveDomainType"] as? String {
                    self.liveDomainType = value
                }
                if let value = dict["RegionName"] as? String {
                    self.regionName = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
            }
        }
        public var pageData: [DescribeLiveUserDomainsResponseBody.Domains.PageData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageData != nil {
                var tmp : [Any] = []
                for k in self.pageData! {
                    tmp.append(k.toMap())
                }
                map["PageData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageData"] as? [Any?] {
                var tmp : [DescribeLiveUserDomainsResponseBody.Domains.PageData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveUserDomainsResponseBody.Domains.PageData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.pageData = tmp
            }
        }
    }
    public var domains: DescribeLiveUserDomainsResponseBody.Domains?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domains?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            map["Domains"] = self.domains?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domains"] as? [String: Any?] {
            var model = DescribeLiveUserDomainsResponseBody.Domains()
            model.fromMap(value)
            self.domains = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeLiveUserDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveUserDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveUserDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveUserStreamMetricDataRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var protocol_: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeLiveUserStreamMetricDataResponseBody : Tea.TeaModel {
    public class StreamDetailData : Tea.TeaModel {
        public var appName: String?

        public var bps: Double?

        public var count: Int64?

        public var flvBps: Double?

        public var flvCount: Int64?

        public var flvTraffic: Double?

        public var hlsBps: Double?

        public var hlsCount: Int64?

        public var hlsTraffic: Double?

        public var newConns: Int64?

        public var p2pBps: Double?

        public var p2pCount: Int64?

        public var p2pTraffic: Double?

        public var rtmpBps: Double?

        public var rtmpCount: Int64?

        public var rtmpTraffic: Double?

        public var rtsBps: Double?

        public var rtsCount: Int64?

        public var rtsTraffic: Double?

        public var streamName: String?

        public var timeStamp: String?

        public var traffic: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.bps != nil {
                map["Bps"] = self.bps!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.flvBps != nil {
                map["FlvBps"] = self.flvBps!
            }
            if self.flvCount != nil {
                map["FlvCount"] = self.flvCount!
            }
            if self.flvTraffic != nil {
                map["FlvTraffic"] = self.flvTraffic!
            }
            if self.hlsBps != nil {
                map["HlsBps"] = self.hlsBps!
            }
            if self.hlsCount != nil {
                map["HlsCount"] = self.hlsCount!
            }
            if self.hlsTraffic != nil {
                map["HlsTraffic"] = self.hlsTraffic!
            }
            if self.newConns != nil {
                map["NewConns"] = self.newConns!
            }
            if self.p2pBps != nil {
                map["P2pBps"] = self.p2pBps!
            }
            if self.p2pCount != nil {
                map["P2pCount"] = self.p2pCount!
            }
            if self.p2pTraffic != nil {
                map["P2pTraffic"] = self.p2pTraffic!
            }
            if self.rtmpBps != nil {
                map["RtmpBps"] = self.rtmpBps!
            }
            if self.rtmpCount != nil {
                map["RtmpCount"] = self.rtmpCount!
            }
            if self.rtmpTraffic != nil {
                map["RtmpTraffic"] = self.rtmpTraffic!
            }
            if self.rtsBps != nil {
                map["RtsBps"] = self.rtsBps!
            }
            if self.rtsCount != nil {
                map["RtsCount"] = self.rtsCount!
            }
            if self.rtsTraffic != nil {
                map["RtsTraffic"] = self.rtsTraffic!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            if self.traffic != nil {
                map["Traffic"] = self.traffic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["Bps"] as? Double {
                self.bps = value
            }
            if let value = dict["Count"] as? Int64 {
                self.count = value
            }
            if let value = dict["FlvBps"] as? Double {
                self.flvBps = value
            }
            if let value = dict["FlvCount"] as? Int64 {
                self.flvCount = value
            }
            if let value = dict["FlvTraffic"] as? Double {
                self.flvTraffic = value
            }
            if let value = dict["HlsBps"] as? Double {
                self.hlsBps = value
            }
            if let value = dict["HlsCount"] as? Int64 {
                self.hlsCount = value
            }
            if let value = dict["HlsTraffic"] as? Double {
                self.hlsTraffic = value
            }
            if let value = dict["NewConns"] as? Int64 {
                self.newConns = value
            }
            if let value = dict["P2pBps"] as? Double {
                self.p2pBps = value
            }
            if let value = dict["P2pCount"] as? Int64 {
                self.p2pCount = value
            }
            if let value = dict["P2pTraffic"] as? Double {
                self.p2pTraffic = value
            }
            if let value = dict["RtmpBps"] as? Double {
                self.rtmpBps = value
            }
            if let value = dict["RtmpCount"] as? Int64 {
                self.rtmpCount = value
            }
            if let value = dict["RtmpTraffic"] as? Double {
                self.rtmpTraffic = value
            }
            if let value = dict["RtsBps"] as? Double {
                self.rtsBps = value
            }
            if let value = dict["RtsCount"] as? Int64 {
                self.rtsCount = value
            }
            if let value = dict["RtsTraffic"] as? Double {
                self.rtsTraffic = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
            if let value = dict["TimeStamp"] as? String {
                self.timeStamp = value
            }
            if let value = dict["Traffic"] as? Double {
                self.traffic = value
            }
        }
    }
    public var domainName: String?

    public var endTime: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var startTime: String?

    public var streamDetailData: [DescribeLiveUserStreamMetricDataResponseBody.StreamDetailData]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamDetailData != nil {
            var tmp : [Any] = []
            for k in self.streamDetailData! {
                tmp.append(k.toMap())
            }
            map["StreamDetailData"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamDetailData"] as? [Any?] {
            var tmp : [DescribeLiveUserStreamMetricDataResponseBody.StreamDetailData] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveUserStreamMetricDataResponseBody.StreamDetailData()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.streamDetailData = tmp
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeLiveUserStreamMetricDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveUserStreamMetricDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveUserStreamMetricDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveUserTagsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveUserTagsResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? [String] {
                self.value = value
            }
        }
    }
    public var requestId: String?

    public var tags: [DescribeLiveUserTagsResponseBody.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [DescribeLiveUserTagsResponseBody.Tags] = []
            for v in value {
                if v != nil {
                    var model = DescribeLiveUserTagsResponseBody.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class DescribeLiveUserTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveUserTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveUserTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveUserTrafficLogRequest : Tea.TeaModel {
    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeLiveUserTrafficLogResponseBody : Tea.TeaModel {
    public class DomainLogDetails : Tea.TeaModel {
        public class DomainLogDetail : Tea.TeaModel {
            public class LogInfos : Tea.TeaModel {
                public class LogInfoDetail : Tea.TeaModel {
                    public var endTime: String?

                    public var logName: String?

                    public var logPath: String?

                    public var logSize: Int64?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.logName != nil {
                            map["LogName"] = self.logName!
                        }
                        if self.logPath != nil {
                            map["LogPath"] = self.logPath!
                        }
                        if self.logSize != nil {
                            map["LogSize"] = self.logSize!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["EndTime"] as? String {
                            self.endTime = value
                        }
                        if let value = dict["LogName"] as? String {
                            self.logName = value
                        }
                        if let value = dict["LogPath"] as? String {
                            self.logPath = value
                        }
                        if let value = dict["LogSize"] as? Int64 {
                            self.logSize = value
                        }
                        if let value = dict["StartTime"] as? String {
                            self.startTime = value
                        }
                    }
                }
                public var logInfoDetail: [DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.logInfoDetail != nil {
                        var tmp : [Any] = []
                        for k in self.logInfoDetail! {
                            tmp.append(k.toMap())
                        }
                        map["LogInfoDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["LogInfoDetail"] as? [Any?] {
                        var tmp : [DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos.LogInfoDetail()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.logInfoDetail = tmp
                    }
                }
            }
            public class PageInfos : Tea.TeaModel {
                public var pageIndex: Int64?

                public var pageSize: Int64?

                public var total: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pageIndex != nil {
                        map["PageIndex"] = self.pageIndex!
                    }
                    if self.pageSize != nil {
                        map["PageSize"] = self.pageSize!
                    }
                    if self.total != nil {
                        map["Total"] = self.total!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PageIndex"] as? Int64 {
                        self.pageIndex = value
                    }
                    if let value = dict["PageSize"] as? Int64 {
                        self.pageSize = value
                    }
                    if let value = dict["Total"] as? Int64 {
                        self.total = value
                    }
                }
            }
            public var logCount: Int64?

            public var logInfos: DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos?

            public var pageInfos: DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.logInfos?.validate()
                try self.pageInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.logInfos != nil {
                    map["LogInfos"] = self.logInfos?.toMap()
                }
                if self.pageInfos != nil {
                    map["PageInfos"] = self.pageInfos?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LogCount"] as? Int64 {
                    self.logCount = value
                }
                if let value = dict["LogInfos"] as? [String: Any?] {
                    var model = DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail.LogInfos()
                    model.fromMap(value)
                    self.logInfos = model
                }
                if let value = dict["PageInfos"] as? [String: Any?] {
                    var model = DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail.PageInfos()
                    model.fromMap(value)
                    self.pageInfos = model
                }
            }
        }
        public var domainLogDetail: [DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainLogDetail != nil {
                var tmp : [Any] = []
                for k in self.domainLogDetail! {
                    tmp.append(k.toMap())
                }
                map["DomainLogDetail"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainLogDetail"] as? [Any?] {
                var tmp : [DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLiveUserTrafficLogResponseBody.DomainLogDetails.DomainLogDetail()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domainLogDetail = tmp
            }
        }
    }
    public var domainLogDetails: DescribeLiveUserTrafficLogResponseBody.DomainLogDetails?

    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainLogDetails?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainLogDetails != nil {
            map["DomainLogDetails"] = self.domainLogDetails?.toMap()
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainLogDetails"] as? [String: Any?] {
            var model = DescribeLiveUserTrafficLogResponseBody.DomainLogDetails()
            model.fromMap(value)
            self.domainLogDetails = model
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveUserTrafficLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveUserTrafficLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveUserTrafficLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLiveVerifyContentRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeLiveVerifyContentResponseBody : Tea.TeaModel {
    public var content: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLiveVerifyContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLiveVerifyContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLiveVerifyContentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeMeterLiveBypassDurationRequest : Tea.TeaModel {
    public var appId: String?

    public var endTime: String?

    public var interval: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Interval"] as? String {
            self.interval = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeMeterLiveBypassDurationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var audioDuration: Int64?

        public var singleAudio: Int64?

        public var singleVideo: Int64?

        public var timestamp: String?

        public var totalDuration: Int64?

        public var v1080Duration: Int64?

        public var v480Duration: Int64?

        public var v720Duration: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioDuration != nil {
                map["AudioDuration"] = self.audioDuration!
            }
            if self.singleAudio != nil {
                map["Single_Audio"] = self.singleAudio!
            }
            if self.singleVideo != nil {
                map["Single_Video"] = self.singleVideo!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalDuration != nil {
                map["TotalDuration"] = self.totalDuration!
            }
            if self.v1080Duration != nil {
                map["V1080Duration"] = self.v1080Duration!
            }
            if self.v480Duration != nil {
                map["V480Duration"] = self.v480Duration!
            }
            if self.v720Duration != nil {
                map["V720Duration"] = self.v720Duration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AudioDuration"] as? Int64 {
                self.audioDuration = value
            }
            if let value = dict["Single_Audio"] as? Int64 {
                self.singleAudio = value
            }
            if let value = dict["Single_Video"] as? Int64 {
                self.singleVideo = value
            }
            if let value = dict["Timestamp"] as? String {
                self.timestamp = value
            }
            if let value = dict["TotalDuration"] as? Int64 {
                self.totalDuration = value
            }
            if let value = dict["V1080Duration"] as? Int64 {
                self.v1080Duration = value
            }
            if let value = dict["V480Duration"] as? Int64 {
                self.v480Duration = value
            }
            if let value = dict["V720Duration"] as? Int64 {
                self.v720Duration = value
            }
        }
    }
    public var audioSummaryDuration: Int64?

    public var data: [DescribeMeterLiveBypassDurationResponseBody.Data]?

    public var requestId: String?

    public var singleAudioSummaryDuration: Int64?

    public var singleVideoSummaryDuration: Int64?

    public var totalSummaryDuration: Int64?

    public var v1080SummaryDuration: Int64?

    public var v480SummaryDuration: Int64?

    public var v720SummaryDuration: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioSummaryDuration != nil {
            map["AudioSummaryDuration"] = self.audioSummaryDuration!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.singleAudioSummaryDuration != nil {
            map["SingleAudioSummaryDuration"] = self.singleAudioSummaryDuration!
        }
        if self.singleVideoSummaryDuration != nil {
            map["SingleVideoSummaryDuration"] = self.singleVideoSummaryDuration!
        }
        if self.totalSummaryDuration != nil {
            map["TotalSummaryDuration"] = self.totalSummaryDuration!
        }
        if self.v1080SummaryDuration != nil {
            map["V1080SummaryDuration"] = self.v1080SummaryDuration!
        }
        if self.v480SummaryDuration != nil {
            map["V480SummaryDuration"] = self.v480SummaryDuration!
        }
        if self.v720SummaryDuration != nil {
            map["V720SummaryDuration"] = self.v720SummaryDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AudioSummaryDuration"] as? Int64 {
            self.audioSummaryDuration = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeMeterLiveBypassDurationResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeMeterLiveBypassDurationResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SingleAudioSummaryDuration"] as? Int64 {
            self.singleAudioSummaryDuration = value
        }
        if let value = dict["SingleVideoSummaryDuration"] as? Int64 {
            self.singleVideoSummaryDuration = value
        }
        if let value = dict["TotalSummaryDuration"] as? Int64 {
            self.totalSummaryDuration = value
        }
        if let value = dict["V1080SummaryDuration"] as? Int64 {
            self.v1080SummaryDuration = value
        }
        if let value = dict["V480SummaryDuration"] as? Int64 {
            self.v480SummaryDuration = value
        }
        if let value = dict["V720SummaryDuration"] as? Int64 {
            self.v720SummaryDuration = value
        }
    }
}

public class DescribeMeterLiveBypassDurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMeterLiveBypassDurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeMeterLiveBypassDurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeMixStreamListRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var mixStreamId: String?

    public var ownerId: Int64?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["MixStreamId"] as? String {
            self.mixStreamId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeMixStreamListResponseBody : Tea.TeaModel {
    public class MixStreamList : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var inputStreamNumber: Int32?

        public var layoutId: String?

        public var mixStreamTemplate: String?

        public var mixstreamId: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.inputStreamNumber != nil {
                map["InputStreamNumber"] = self.inputStreamNumber!
            }
            if self.layoutId != nil {
                map["LayoutId"] = self.layoutId!
            }
            if self.mixStreamTemplate != nil {
                map["MixStreamTemplate"] = self.mixStreamTemplate!
            }
            if self.mixstreamId != nil {
                map["MixstreamId"] = self.mixstreamId!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["GmtCreate"] as? String {
                self.gmtCreate = value
            }
            if let value = dict["GmtModified"] as? String {
                self.gmtModified = value
            }
            if let value = dict["InputStreamNumber"] as? Int32 {
                self.inputStreamNumber = value
            }
            if let value = dict["LayoutId"] as? String {
                self.layoutId = value
            }
            if let value = dict["MixStreamTemplate"] as? String {
                self.mixStreamTemplate = value
            }
            if let value = dict["MixstreamId"] as? String {
                self.mixstreamId = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
        }
    }
    public var mixStreamList: [DescribeMixStreamListResponseBody.MixStreamList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixStreamList != nil {
            var tmp : [Any] = []
            for k in self.mixStreamList! {
                tmp.append(k.toMap())
            }
            map["MixStreamList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MixStreamList"] as? [Any?] {
            var tmp : [DescribeMixStreamListResponseBody.MixStreamList] = []
            for v in value {
                if v != nil {
                    var model = DescribeMixStreamListResponseBody.MixStreamList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.mixStreamList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeMixStreamListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMixStreamListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeMixStreamListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameCostRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? [String] {
            self.domainNameList = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameCostShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? String {
            self.domainNameListShrink = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameCostResponseBody : Tea.TeaModel {
    public class FirstFrameCostData : Tea.TeaModel {
        public var connected: String?

        public var finishGetStreamInfo: String?

        public var firstFrameComplete: String?

        public var firstPacket: String?

        public var initialized: String?

        public var timeStamp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connected != nil {
                map["Connected"] = self.connected!
            }
            if self.finishGetStreamInfo != nil {
                map["FinishGetStreamInfo"] = self.finishGetStreamInfo!
            }
            if self.firstFrameComplete != nil {
                map["FirstFrameComplete"] = self.firstFrameComplete!
            }
            if self.firstPacket != nil {
                map["FirstPacket"] = self.firstPacket!
            }
            if self.initialized != nil {
                map["Initialized"] = self.initialized!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Connected"] as? String {
                self.connected = value
            }
            if let value = dict["FinishGetStreamInfo"] as? String {
                self.finishGetStreamInfo = value
            }
            if let value = dict["FirstFrameComplete"] as? String {
                self.firstFrameComplete = value
            }
            if let value = dict["FirstPacket"] as? String {
                self.firstPacket = value
            }
            if let value = dict["Initialized"] as? String {
                self.initialized = value
            }
            if let value = dict["TimeStamp"] as? String {
                self.timeStamp = value
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var firstFrameCostData: [DescribeRTSNativeSDKFirstFrameCostResponseBody.FirstFrameCostData]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.firstFrameCostData != nil {
            var tmp : [Any] = []
            for k in self.firstFrameCostData! {
                tmp.append(k.toMap())
            }
            map["FirstFrameCostData"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FirstFrameCostData"] as? [Any?] {
            var tmp : [DescribeRTSNativeSDKFirstFrameCostResponseBody.FirstFrameCostData] = []
            for v in value {
                if v != nil {
                    var model = DescribeRTSNativeSDKFirstFrameCostResponseBody.FirstFrameCostData()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.firstFrameCostData = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameCostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKFirstFrameCostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRTSNativeSDKFirstFrameCostResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameDelayRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? [String] {
            self.domainNameList = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameDelayShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? String {
            self.domainNameListShrink = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameDelayResponseBody : Tea.TeaModel {
    public class FrameDelayData : Tea.TeaModel {
        public var frameDelay: String?

        public var timeStamp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.frameDelay != nil {
                map["FrameDelay"] = self.frameDelay!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FrameDelay"] as? String {
                self.frameDelay = value
            }
            if let value = dict["TimeStamp"] as? String {
                self.timeStamp = value
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var frameDelayData: [DescribeRTSNativeSDKFirstFrameDelayResponseBody.FrameDelayData]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.frameDelayData != nil {
            var tmp : [Any] = []
            for k in self.frameDelayData! {
                tmp.append(k.toMap())
            }
            map["FrameDelayData"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FrameDelayData"] as? [Any?] {
            var tmp : [DescribeRTSNativeSDKFirstFrameDelayResponseBody.FrameDelayData] = []
            for v in value {
                if v != nil {
                    var model = DescribeRTSNativeSDKFirstFrameDelayResponseBody.FrameDelayData()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.frameDelayData = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKFirstFrameDelayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKFirstFrameDelayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRTSNativeSDKFirstFrameDelayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKPlayFailStatusRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? [String] {
            self.domainNameList = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKPlayFailStatusShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? String {
            self.domainNameListShrink = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKPlayFailStatusResponseBody : Tea.TeaModel {
    public class PlayFailStatus : Tea.TeaModel {
        public var timeStamp: String?

        public var v20001: String?

        public var v20002: String?

        public var v20011: String?

        public var v20012: String?

        public var v20013: String?

        public var v20052: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            if self.v20001 != nil {
                map["V20001"] = self.v20001!
            }
            if self.v20002 != nil {
                map["V20002"] = self.v20002!
            }
            if self.v20011 != nil {
                map["V20011"] = self.v20011!
            }
            if self.v20012 != nil {
                map["V20012"] = self.v20012!
            }
            if self.v20013 != nil {
                map["V20013"] = self.v20013!
            }
            if self.v20052 != nil {
                map["V20052"] = self.v20052!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TimeStamp"] as? String {
                self.timeStamp = value
            }
            if let value = dict["V20001"] as? String {
                self.v20001 = value
            }
            if let value = dict["V20002"] as? String {
                self.v20002 = value
            }
            if let value = dict["V20011"] as? String {
                self.v20011 = value
            }
            if let value = dict["V20012"] as? String {
                self.v20012 = value
            }
            if let value = dict["V20013"] as? String {
                self.v20013 = value
            }
            if let value = dict["V20052"] as? String {
                self.v20052 = value
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var playFailStatus: [DescribeRTSNativeSDKPlayFailStatusResponseBody.PlayFailStatus]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.playFailStatus != nil {
            var tmp : [Any] = []
            for k in self.playFailStatus! {
                tmp.append(k.toMap())
            }
            map["PlayFailStatus"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PlayFailStatus"] as? [Any?] {
            var tmp : [DescribeRTSNativeSDKPlayFailStatusResponseBody.PlayFailStatus] = []
            for v in value {
                if v != nil {
                    var model = DescribeRTSNativeSDKPlayFailStatusResponseBody.PlayFailStatus()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.playFailStatus = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKPlayFailStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKPlayFailStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRTSNativeSDKPlayFailStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKPlayTimeRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? [String] {
            self.domainNameList = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKPlayTimeShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? String {
            self.domainNameListShrink = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKPlayTimeResponseBody : Tea.TeaModel {
    public class PlayTimeData : Tea.TeaModel {
        public var playTime: String?

        public var stallTime: String?

        public var timeStamp: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.playTime != nil {
                map["PlayTime"] = self.playTime!
            }
            if self.stallTime != nil {
                map["StallTime"] = self.stallTime!
            }
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PlayTime"] as? String {
                self.playTime = value
            }
            if let value = dict["StallTime"] as? String {
                self.stallTime = value
            }
            if let value = dict["TimeStamp"] as? String {
                self.timeStamp = value
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var playTimeData: [DescribeRTSNativeSDKPlayTimeResponseBody.PlayTimeData]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.playTimeData != nil {
            var tmp : [Any] = []
            for k in self.playTimeData! {
                tmp.append(k.toMap())
            }
            map["PlayTimeData"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PlayTimeData"] as? [Any?] {
            var tmp : [DescribeRTSNativeSDKPlayTimeResponseBody.PlayTimeData] = []
            for v in value {
                if v != nil {
                    var model = DescribeRTSNativeSDKPlayTimeResponseBody.PlayTimeData()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.playTimeData = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKPlayTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKPlayTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRTSNativeSDKPlayTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRTSNativeSDKVvDataRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameList: [String]?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameList != nil {
            map["DomainNameList"] = self.domainNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? [String] {
            self.domainNameList = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKVvDataShrinkRequest : Tea.TeaModel {
    public var dataInterval: String?

    public var domainNameListShrink: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.domainNameListShrink != nil {
            map["DomainNameList"] = self.domainNameListShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["DomainNameList"] as? String {
            self.domainNameListShrink = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeRTSNativeSDKVvDataResponseBody : Tea.TeaModel {
    public class VvData : Tea.TeaModel {
        public var timeStamp: String?

        public var vvSuccess: String?

        public var vvTotal: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.timeStamp != nil {
                map["TimeStamp"] = self.timeStamp!
            }
            if self.vvSuccess != nil {
                map["VvSuccess"] = self.vvSuccess!
            }
            if self.vvTotal != nil {
                map["VvTotal"] = self.vvTotal!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TimeStamp"] as? String {
                self.timeStamp = value
            }
            if let value = dict["VvSuccess"] as? String {
                self.vvSuccess = value
            }
            if let value = dict["VvTotal"] as? String {
                self.vvTotal = value
            }
        }
    }
    public var dataInterval: String?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public var vvData: [DescribeRTSNativeSDKVvDataResponseBody.VvData]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataInterval != nil {
            map["DataInterval"] = self.dataInterval!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.vvData != nil {
            var tmp : [Any] = []
            for k in self.vvData! {
                tmp.append(k.toMap())
            }
            map["VvData"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataInterval"] as? String {
            self.dataInterval = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["VvData"] as? [Any?] {
            var tmp : [DescribeRTSNativeSDKVvDataResponseBody.VvData] = []
            for v in value {
                if v != nil {
                    var model = DescribeRTSNativeSDKVvDataResponseBody.VvData()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.vvData = tmp
        }
    }
}

public class DescribeRTSNativeSDKVvDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRTSNativeSDKVvDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRTSNativeSDKVvDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRtcCloudRecordingFilesRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class DescribeRtcCloudRecordingFilesResponseBody : Tea.TeaModel {
    public class TaskInfo : Tea.TeaModel {
        public class RecordFileList : Tea.TeaModel {
            public class VodMediaList : Tea.TeaModel {
                public var mediaIds: [String]?

                public var mergedIds: [String]?

                public var stream: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mediaIds != nil {
                        map["MediaIds"] = self.mediaIds!
                    }
                    if self.mergedIds != nil {
                        map["MergedIds"] = self.mergedIds!
                    }
                    if self.stream != nil {
                        map["Stream"] = self.stream!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MediaIds"] as? [String] {
                        self.mediaIds = value
                    }
                    if let value = dict["MergedIds"] as? [String] {
                        self.mergedIds = value
                    }
                    if let value = dict["Stream"] as? String {
                        self.stream = value
                    }
                }
            }
            public var hlsFileList: [String]?

            public var mp3FileList: [String]?

            public var mp4FileList: [String]?

            public var vodMediaList: [DescribeRtcCloudRecordingFilesResponseBody.TaskInfo.RecordFileList.VodMediaList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hlsFileList != nil {
                    map["HlsFileList"] = self.hlsFileList!
                }
                if self.mp3FileList != nil {
                    map["Mp3FileList"] = self.mp3FileList!
                }
                if self.mp4FileList != nil {
                    map["Mp4FileList"] = self.mp4FileList!
                }
                if self.vodMediaList != nil {
                    var tmp : [Any] = []
                    for k in self.vodMediaList! {
                        tmp.append(k.toMap())
                    }
                    map["VodMediaList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["HlsFileList"] as? [String] {
                    self.hlsFileList = value
                }
                if let value = dict["Mp3FileList"] as? [String] {
                    self.mp3FileList = value
                }
                if let value = dict["Mp4FileList"] as? [String] {
                    self.mp4FileList = value
                }
                if let value = dict["VodMediaList"] as? [Any?] {
                    var tmp : [DescribeRtcCloudRecordingFilesResponseBody.TaskInfo.RecordFileList.VodMediaList] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeRtcCloudRecordingFilesResponseBody.TaskInfo.RecordFileList.VodMediaList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.vodMediaList = tmp
                }
            }
        }
        public var recordFileList: DescribeRtcCloudRecordingFilesResponseBody.TaskInfo.RecordFileList?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.recordFileList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recordFileList != nil {
                map["RecordFileList"] = self.recordFileList?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RecordFileList"] as? [String: Any?] {
                var model = DescribeRtcCloudRecordingFilesResponseBody.TaskInfo.RecordFileList()
                model.fromMap(value)
                self.recordFileList = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var requestId: String?

    public var taskInfo: DescribeRtcCloudRecordingFilesResponseBody.TaskInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskInfo != nil {
            map["TaskInfo"] = self.taskInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskInfo"] as? [String: Any?] {
            var model = DescribeRtcCloudRecordingFilesResponseBody.TaskInfo()
            model.fromMap(value)
            self.taskInfo = model
        }
    }
}

public class DescribeRtcCloudRecordingFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRtcCloudRecordingFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRtcCloudRecordingFilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRtcMPUEventSubRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DescribeRtcMPUEventSubResponseBody : Tea.TeaModel {
    public class SubInfo : Tea.TeaModel {
        public var appId: String?

        public var callbackUrl: String?

        public var channelIds: String?

        public var createTime: String?

        public var subId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.callbackUrl != nil {
                map["CallbackUrl"] = self.callbackUrl!
            }
            if self.channelIds != nil {
                map["ChannelIds"] = self.channelIds!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.subId != nil {
                map["SubId"] = self.subId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["CallbackUrl"] as? String {
                self.callbackUrl = value
            }
            if let value = dict["ChannelIds"] as? String {
                self.channelIds = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["SubId"] as? String {
                self.subId = value
            }
        }
    }
    public var requestId: String?

    public var subInfo: DescribeRtcMPUEventSubResponseBody.SubInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.subInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subInfo != nil {
            map["SubInfo"] = self.subInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SubInfo"] as? [String: Any?] {
            var model = DescribeRtcMPUEventSubResponseBody.SubInfo()
            model.fromMap(value)
            self.subInfo = model
        }
    }
}

public class DescribeRtcMPUEventSubResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRtcMPUEventSubResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRtcMPUEventSubResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeShowListRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeShowListResponseBody : Tea.TeaModel {
    public class ShowListInfo : Tea.TeaModel {
        public class ShowList : Tea.TeaModel {
            public class Show : Tea.TeaModel {
                public class ResourceInfo : Tea.TeaModel {
                    public var liveInputType: Int32?

                    public var resourceId: String?

                    public var resourceType: String?

                    public var resourceUrl: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.liveInputType != nil {
                            map["LiveInputType"] = self.liveInputType!
                        }
                        if self.resourceId != nil {
                            map["ResourceId"] = self.resourceId!
                        }
                        if self.resourceType != nil {
                            map["ResourceType"] = self.resourceType!
                        }
                        if self.resourceUrl != nil {
                            map["ResourceUrl"] = self.resourceUrl!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LiveInputType"] as? Int32 {
                            self.liveInputType = value
                        }
                        if let value = dict["ResourceId"] as? String {
                            self.resourceId = value
                        }
                        if let value = dict["ResourceType"] as? String {
                            self.resourceType = value
                        }
                        if let value = dict["ResourceUrl"] as? String {
                            self.resourceUrl = value
                        }
                    }
                }
                public var duration: Int64?

                public var repeatTimes: Int32?

                public var resourceInfo: DescribeShowListResponseBody.ShowListInfo.ShowList.Show.ResourceInfo?

                public var showId: String?

                public var showName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.resourceInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.repeatTimes != nil {
                        map["RepeatTimes"] = self.repeatTimes!
                    }
                    if self.resourceInfo != nil {
                        map["ResourceInfo"] = self.resourceInfo?.toMap()
                    }
                    if self.showId != nil {
                        map["ShowId"] = self.showId!
                    }
                    if self.showName != nil {
                        map["ShowName"] = self.showName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Duration"] as? Int64 {
                        self.duration = value
                    }
                    if let value = dict["RepeatTimes"] as? Int32 {
                        self.repeatTimes = value
                    }
                    if let value = dict["ResourceInfo"] as? [String: Any?] {
                        var model = DescribeShowListResponseBody.ShowListInfo.ShowList.Show.ResourceInfo()
                        model.fromMap(value)
                        self.resourceInfo = model
                    }
                    if let value = dict["ShowId"] as? String {
                        self.showId = value
                    }
                    if let value = dict["ShowName"] as? String {
                        self.showName = value
                    }
                }
            }
            public var show: [DescribeShowListResponseBody.ShowListInfo.ShowList.Show]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.show != nil {
                    var tmp : [Any] = []
                    for k in self.show! {
                        tmp.append(k.toMap())
                    }
                    map["Show"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Show"] as? [Any?] {
                    var tmp : [DescribeShowListResponseBody.ShowListInfo.ShowList.Show] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeShowListResponseBody.ShowListInfo.ShowList.Show()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.show = tmp
                }
            }
        }
        public var background: String?

        public var currentShowId: String?

        public var highPriorityShowId: String?

        public var highPriorityShowStartTime: String?

        public var showList: DescribeShowListResponseBody.ShowListInfo.ShowList?

        public var showListRepeatTimes: Int32?

        public var totalShowListRepeatTimes: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.showList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.background != nil {
                map["Background"] = self.background!
            }
            if self.currentShowId != nil {
                map["CurrentShowId"] = self.currentShowId!
            }
            if self.highPriorityShowId != nil {
                map["HighPriorityShowId"] = self.highPriorityShowId!
            }
            if self.highPriorityShowStartTime != nil {
                map["HighPriorityShowStartTime"] = self.highPriorityShowStartTime!
            }
            if self.showList != nil {
                map["ShowList"] = self.showList?.toMap()
            }
            if self.showListRepeatTimes != nil {
                map["ShowListRepeatTimes"] = self.showListRepeatTimes!
            }
            if self.totalShowListRepeatTimes != nil {
                map["TotalShowListRepeatTimes"] = self.totalShowListRepeatTimes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Background"] as? String {
                self.background = value
            }
            if let value = dict["CurrentShowId"] as? String {
                self.currentShowId = value
            }
            if let value = dict["HighPriorityShowId"] as? String {
                self.highPriorityShowId = value
            }
            if let value = dict["HighPriorityShowStartTime"] as? String {
                self.highPriorityShowStartTime = value
            }
            if let value = dict["ShowList"] as? [String: Any?] {
                var model = DescribeShowListResponseBody.ShowListInfo.ShowList()
                model.fromMap(value)
                self.showList = model
            }
            if let value = dict["ShowListRepeatTimes"] as? Int32 {
                self.showListRepeatTimes = value
            }
            if let value = dict["TotalShowListRepeatTimes"] as? Int32 {
                self.totalShowListRepeatTimes = value
            }
        }
    }
    public var requestId: String?

    public var showList: String?

    public var showListInfo: DescribeShowListResponseBody.ShowListInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.showListInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.showList != nil {
            map["ShowList"] = self.showList!
        }
        if self.showListInfo != nil {
            map["ShowListInfo"] = self.showListInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ShowList"] as? String {
            self.showList = value
        }
        if let value = dict["ShowListInfo"] as? [String: Any?] {
            var model = DescribeShowListResponseBody.ShowListInfo()
            model.fromMap(value)
            self.showListInfo = model
        }
    }
}

public class DescribeShowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeShowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeShowListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeStreamLocationBlockRequest : Tea.TeaModel {
    public var appName: String?

    public var blockType: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.blockType != nil {
            map["BlockType"] = self.blockType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["BlockType"] as? String {
            self.blockType = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class DescribeStreamLocationBlockResponseBody : Tea.TeaModel {
    public class StreamBlockList : Tea.TeaModel {
        public class StreamBlock : Tea.TeaModel {
            public var appName: String?

            public var blockType: String?

            public var domainName: String?

            public var locationList: String?

            public var releaseTime: String?

            public var status: Int32?

            public var streamName: String?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.blockType != nil {
                    map["BlockType"] = self.blockType!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.locationList != nil {
                    map["LocationList"] = self.locationList!
                }
                if self.releaseTime != nil {
                    map["ReleaseTime"] = self.releaseTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.streamName != nil {
                    map["StreamName"] = self.streamName!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["BlockType"] as? String {
                    self.blockType = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["LocationList"] as? String {
                    self.locationList = value
                }
                if let value = dict["ReleaseTime"] as? String {
                    self.releaseTime = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["StreamName"] as? String {
                    self.streamName = value
                }
                if let value = dict["UpdateTime"] as? String {
                    self.updateTime = value
                }
            }
        }
        public var streamBlock: [DescribeStreamLocationBlockResponseBody.StreamBlockList.StreamBlock]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.streamBlock != nil {
                var tmp : [Any] = []
                for k in self.streamBlock! {
                    tmp.append(k.toMap())
                }
                map["StreamBlock"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["StreamBlock"] as? [Any?] {
                var tmp : [DescribeStreamLocationBlockResponseBody.StreamBlockList.StreamBlock] = []
                for v in value {
                    if v != nil {
                        var model = DescribeStreamLocationBlockResponseBody.StreamBlockList.StreamBlock()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.streamBlock = tmp
            }
        }
    }
    public var count: Int32?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var streamBlockList: DescribeStreamLocationBlockResponseBody.StreamBlockList?

    public var totalPage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamBlockList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamBlockList != nil {
            map["StreamBlockList"] = self.streamBlockList?.toMap()
        }
        if self.totalPage != nil {
            map["TotalPage"] = self.totalPage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int32 {
            self.count = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamBlockList"] as? [String: Any?] {
            var model = DescribeStreamLocationBlockResponseBody.StreamBlockList()
            model.fromMap(value)
            self.streamBlockList = model
        }
        if let value = dict["TotalPage"] as? Int32 {
            self.totalPage = value
        }
    }
}

public class DescribeStreamLocationBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStreamLocationBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeStreamLocationBlockResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeStudioLayoutsRequest : Tea.TeaModel {
    public var casterId: String?

    public var layoutId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeStudioLayoutsResponseBody : Tea.TeaModel {
    public class StudioLayouts : Tea.TeaModel {
        public class BgImageConfig : Tea.TeaModel {
            public var id: String?

            public var imageUrl: String?

            public var locationId: String?

            public var materialId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.locationId != nil {
                    map["LocationId"] = self.locationId!
                }
                if self.materialId != nil {
                    map["MaterialId"] = self.materialId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["ImageUrl"] as? String {
                    self.imageUrl = value
                }
                if let value = dict["LocationId"] as? String {
                    self.locationId = value
                }
                if let value = dict["MaterialId"] as? String {
                    self.materialId = value
                }
            }
        }
        public class CommonConfig : Tea.TeaModel {
            public var channelId: String?

            public var videoResourceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.videoResourceId != nil {
                    map["VideoResourceId"] = self.videoResourceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChannelId"] as? String {
                    self.channelId = value
                }
                if let value = dict["VideoResourceId"] as? String {
                    self.videoResourceId = value
                }
            }
        }
        public class LayerOrderConfigList : Tea.TeaModel {
            public var id: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class MediaInputConfigList : Tea.TeaModel {
            public var channelId: String?

            public var fillMode: String?

            public var heightNormalized: Double?

            public var id: String?

            public var imageMaterialId: String?

            public var index: Int32?

            public var positionNormalized: [Double]?

            public var positionRefer: String?

            public var videoResourceId: String?

            public var widthNormalized: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.fillMode != nil {
                    map["FillMode"] = self.fillMode!
                }
                if self.heightNormalized != nil {
                    map["HeightNormalized"] = self.heightNormalized!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.imageMaterialId != nil {
                    map["ImageMaterialId"] = self.imageMaterialId!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.positionNormalized != nil {
                    map["PositionNormalized"] = self.positionNormalized!
                }
                if self.positionRefer != nil {
                    map["PositionRefer"] = self.positionRefer!
                }
                if self.videoResourceId != nil {
                    map["VideoResourceId"] = self.videoResourceId!
                }
                if self.widthNormalized != nil {
                    map["WidthNormalized"] = self.widthNormalized!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChannelId"] as? String {
                    self.channelId = value
                }
                if let value = dict["FillMode"] as? String {
                    self.fillMode = value
                }
                if let value = dict["HeightNormalized"] as? Double {
                    self.heightNormalized = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["ImageMaterialId"] as? String {
                    self.imageMaterialId = value
                }
                if let value = dict["Index"] as? Int32 {
                    self.index = value
                }
                if let value = dict["PositionNormalized"] as? [Double] {
                    self.positionNormalized = value
                }
                if let value = dict["PositionRefer"] as? String {
                    self.positionRefer = value
                }
                if let value = dict["VideoResourceId"] as? String {
                    self.videoResourceId = value
                }
                if let value = dict["WidthNormalized"] as? Double {
                    self.widthNormalized = value
                }
            }
        }
        public class ScreenInputConfigList : Tea.TeaModel {
            public class AudioConfig : Tea.TeaModel {
                public var validChannel: String?

                public var volumeRate: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.validChannel != nil {
                        map["ValidChannel"] = self.validChannel!
                    }
                    if self.volumeRate != nil {
                        map["VolumeRate"] = self.volumeRate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ValidChannel"] as? String {
                        self.validChannel = value
                    }
                    if let value = dict["VolumeRate"] as? Double {
                        self.volumeRate = value
                    }
                }
            }
            public var audioConfig: DescribeStudioLayoutsResponseBody.StudioLayouts.ScreenInputConfigList.AudioConfig?

            public var channelId: String?

            public var color: String?

            public var heightNormalized: Double?

            public var id: String?

            public var index: Int32?

            public var onlyAudio: Bool?

            public var portraitType: Int32?

            public var positionX: String?

            public var positionY: String?

            public var videoResourceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioConfig != nil {
                    map["AudioConfig"] = self.audioConfig?.toMap()
                }
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.color != nil {
                    map["Color"] = self.color!
                }
                if self.heightNormalized != nil {
                    map["HeightNormalized"] = self.heightNormalized!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.onlyAudio != nil {
                    map["OnlyAudio"] = self.onlyAudio!
                }
                if self.portraitType != nil {
                    map["PortraitType"] = self.portraitType!
                }
                if self.positionX != nil {
                    map["PositionX"] = self.positionX!
                }
                if self.positionY != nil {
                    map["PositionY"] = self.positionY!
                }
                if self.videoResourceId != nil {
                    map["VideoResourceId"] = self.videoResourceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AudioConfig"] as? [String: Any?] {
                    var model = DescribeStudioLayoutsResponseBody.StudioLayouts.ScreenInputConfigList.AudioConfig()
                    model.fromMap(value)
                    self.audioConfig = model
                }
                if let value = dict["ChannelId"] as? String {
                    self.channelId = value
                }
                if let value = dict["Color"] as? String {
                    self.color = value
                }
                if let value = dict["HeightNormalized"] as? Double {
                    self.heightNormalized = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Index"] as? Int32 {
                    self.index = value
                }
                if let value = dict["OnlyAudio"] as? Bool {
                    self.onlyAudio = value
                }
                if let value = dict["PortraitType"] as? Int32 {
                    self.portraitType = value
                }
                if let value = dict["PositionX"] as? String {
                    self.positionX = value
                }
                if let value = dict["PositionY"] as? String {
                    self.positionY = value
                }
                if let value = dict["VideoResourceId"] as? String {
                    self.videoResourceId = value
                }
            }
        }
        public var bgImageConfig: DescribeStudioLayoutsResponseBody.StudioLayouts.BgImageConfig?

        public var commonConfig: DescribeStudioLayoutsResponseBody.StudioLayouts.CommonConfig?

        public var layerOrderConfigList: [DescribeStudioLayoutsResponseBody.StudioLayouts.LayerOrderConfigList]?

        public var layoutId: String?

        public var layoutName: String?

        public var layoutType: String?

        public var mediaInputConfigList: [DescribeStudioLayoutsResponseBody.StudioLayouts.MediaInputConfigList]?

        public var screenInputConfigList: [DescribeStudioLayoutsResponseBody.StudioLayouts.ScreenInputConfigList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bgImageConfig?.validate()
            try self.commonConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bgImageConfig != nil {
                map["BgImageConfig"] = self.bgImageConfig?.toMap()
            }
            if self.commonConfig != nil {
                map["CommonConfig"] = self.commonConfig?.toMap()
            }
            if self.layerOrderConfigList != nil {
                var tmp : [Any] = []
                for k in self.layerOrderConfigList! {
                    tmp.append(k.toMap())
                }
                map["LayerOrderConfigList"] = tmp
            }
            if self.layoutId != nil {
                map["LayoutId"] = self.layoutId!
            }
            if self.layoutName != nil {
                map["LayoutName"] = self.layoutName!
            }
            if self.layoutType != nil {
                map["LayoutType"] = self.layoutType!
            }
            if self.mediaInputConfigList != nil {
                var tmp : [Any] = []
                for k in self.mediaInputConfigList! {
                    tmp.append(k.toMap())
                }
                map["MediaInputConfigList"] = tmp
            }
            if self.screenInputConfigList != nil {
                var tmp : [Any] = []
                for k in self.screenInputConfigList! {
                    tmp.append(k.toMap())
                }
                map["ScreenInputConfigList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BgImageConfig"] as? [String: Any?] {
                var model = DescribeStudioLayoutsResponseBody.StudioLayouts.BgImageConfig()
                model.fromMap(value)
                self.bgImageConfig = model
            }
            if let value = dict["CommonConfig"] as? [String: Any?] {
                var model = DescribeStudioLayoutsResponseBody.StudioLayouts.CommonConfig()
                model.fromMap(value)
                self.commonConfig = model
            }
            if let value = dict["LayerOrderConfigList"] as? [Any?] {
                var tmp : [DescribeStudioLayoutsResponseBody.StudioLayouts.LayerOrderConfigList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeStudioLayoutsResponseBody.StudioLayouts.LayerOrderConfigList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.layerOrderConfigList = tmp
            }
            if let value = dict["LayoutId"] as? String {
                self.layoutId = value
            }
            if let value = dict["LayoutName"] as? String {
                self.layoutName = value
            }
            if let value = dict["LayoutType"] as? String {
                self.layoutType = value
            }
            if let value = dict["MediaInputConfigList"] as? [Any?] {
                var tmp : [DescribeStudioLayoutsResponseBody.StudioLayouts.MediaInputConfigList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeStudioLayoutsResponseBody.StudioLayouts.MediaInputConfigList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.mediaInputConfigList = tmp
            }
            if let value = dict["ScreenInputConfigList"] as? [Any?] {
                var tmp : [DescribeStudioLayoutsResponseBody.StudioLayouts.ScreenInputConfigList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeStudioLayoutsResponseBody.StudioLayouts.ScreenInputConfigList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.screenInputConfigList = tmp
            }
        }
    }
    public var requestId: String?

    public var studioLayouts: [DescribeStudioLayoutsResponseBody.StudioLayouts]?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.studioLayouts != nil {
            var tmp : [Any] = []
            for k in self.studioLayouts! {
                tmp.append(k.toMap())
            }
            map["StudioLayouts"] = tmp
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StudioLayouts"] as? [Any?] {
            var tmp : [DescribeStudioLayoutsResponseBody.StudioLayouts] = []
            for v in value {
                if v != nil {
                    var model = DescribeStudioLayoutsResponseBody.StudioLayouts()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.studioLayouts = tmp
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class DescribeStudioLayoutsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStudioLayoutsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeStudioLayoutsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeToutiaoLivePlayRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
    }
}

public class DescribeToutiaoLivePlayResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var app: String?

        public var bandwidth: Double?

        public var cdnName: String?

        public var domain: String?

        public var playNum: Int64?

        public var streamName: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.cdnName != nil {
                map["CdnName"] = self.cdnName!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.playNum != nil {
                map["PlayNum"] = self.playNum!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["App"] as? String {
                self.app = value
            }
            if let value = dict["Bandwidth"] as? Double {
                self.bandwidth = value
            }
            if let value = dict["CdnName"] as? String {
                self.cdnName = value
            }
            if let value = dict["Domain"] as? String {
                self.domain = value
            }
            if let value = dict["PlayNum"] as? Int64 {
                self.playNum = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var content: [DescribeToutiaoLivePlayResponseBody.Content]?

    public var description_: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["Content"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? [Any?] {
            var tmp : [DescribeToutiaoLivePlayResponseBody.Content] = []
            for v in value {
                if v != nil {
                    var model = DescribeToutiaoLivePlayResponseBody.Content()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.content = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeToutiaoLivePlayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeToutiaoLivePlayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeToutiaoLivePlayResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeToutiaoLivePublishRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
    }
}

public class DescribeToutiaoLivePublishResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public var app: String?

        public var bitrate: Double?

        public var bwDiff: Double?

        public var cdnName: String?

        public var domain: String?

        public var flr: Double?

        public var fps: Double?

        public var streamName: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.app != nil {
                map["App"] = self.app!
            }
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.bwDiff != nil {
                map["BwDiff"] = self.bwDiff!
            }
            if self.cdnName != nil {
                map["CdnName"] = self.cdnName!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.flr != nil {
                map["Flr"] = self.flr!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["App"] as? String {
                self.app = value
            }
            if let value = dict["Bitrate"] as? Double {
                self.bitrate = value
            }
            if let value = dict["BwDiff"] as? Double {
                self.bwDiff = value
            }
            if let value = dict["CdnName"] as? String {
                self.cdnName = value
            }
            if let value = dict["Domain"] as? String {
                self.domain = value
            }
            if let value = dict["Flr"] as? Double {
                self.flr = value
            }
            if let value = dict["Fps"] as? Double {
                self.fps = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var content: [DescribeToutiaoLivePublishResponseBody.Content]?

    public var description_: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            var tmp : [Any] = []
            for k in self.content! {
                tmp.append(k.toMap())
            }
            map["Content"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? [Any?] {
            var tmp : [DescribeToutiaoLivePublishResponseBody.Content] = []
            for v in value {
                if v != nil {
                    var model = DescribeToutiaoLivePublishResponseBody.Content()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.content = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeToutiaoLivePublishResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeToutiaoLivePublishResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeToutiaoLivePublishResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeUidOnlineStreamsRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeUidOnlineStreamsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appName: String?

        public var domainName: String?

        public var streamName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
        }
    }
    public var data: [DescribeUidOnlineStreamsResponseBody.Data]?

    public var requestId: String?

    public var totalNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalNum != nil {
            map["TotalNum"] = self.totalNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeUidOnlineStreamsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeUidOnlineStreamsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalNum"] as? Int64 {
            self.totalNum = value
        }
    }
}

public class DescribeUidOnlineStreamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUidOnlineStreamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeUidOnlineStreamsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeUpBpsPeakDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainSwitch: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSwitch != nil {
            map["DomainSwitch"] = self.domainSwitch!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainSwitch"] as? String {
            self.domainSwitch = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeUpBpsPeakDataResponseBody : Tea.TeaModel {
    public class DescribeUpPeakTraffics : Tea.TeaModel {
        public class DescribeUpPeakTraffic : Tea.TeaModel {
            public var bandWidth: String?

            public var peakTime: String?

            public var queryTime: String?

            public var statName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidth != nil {
                    map["BandWidth"] = self.bandWidth!
                }
                if self.peakTime != nil {
                    map["PeakTime"] = self.peakTime!
                }
                if self.queryTime != nil {
                    map["QueryTime"] = self.queryTime!
                }
                if self.statName != nil {
                    map["StatName"] = self.statName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BandWidth"] as? String {
                    self.bandWidth = value
                }
                if let value = dict["PeakTime"] as? String {
                    self.peakTime = value
                }
                if let value = dict["QueryTime"] as? String {
                    self.queryTime = value
                }
                if let value = dict["StatName"] as? String {
                    self.statName = value
                }
            }
        }
        public var describeUpPeakTraffic: [DescribeUpBpsPeakDataResponseBody.DescribeUpPeakTraffics.DescribeUpPeakTraffic]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.describeUpPeakTraffic != nil {
                var tmp : [Any] = []
                for k in self.describeUpPeakTraffic! {
                    tmp.append(k.toMap())
                }
                map["DescribeUpPeakTraffic"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DescribeUpPeakTraffic"] as? [Any?] {
                var tmp : [DescribeUpBpsPeakDataResponseBody.DescribeUpPeakTraffics.DescribeUpPeakTraffic] = []
                for v in value {
                    if v != nil {
                        var model = DescribeUpBpsPeakDataResponseBody.DescribeUpPeakTraffics.DescribeUpPeakTraffic()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.describeUpPeakTraffic = tmp
            }
        }
    }
    public var describeUpPeakTraffics: DescribeUpBpsPeakDataResponseBody.DescribeUpPeakTraffics?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.describeUpPeakTraffics?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describeUpPeakTraffics != nil {
            map["DescribeUpPeakTraffics"] = self.describeUpPeakTraffics?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DescribeUpPeakTraffics"] as? [String: Any?] {
            var model = DescribeUpBpsPeakDataResponseBody.DescribeUpPeakTraffics()
            model.fromMap(value)
            self.describeUpPeakTraffics = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeUpBpsPeakDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpBpsPeakDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeUpBpsPeakDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeUpBpsPeakOfLineRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainSwitch: String?

    public var endTime: String?

    public var line: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSwitch != nil {
            map["DomainSwitch"] = self.domainSwitch!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.line != nil {
            map["Line"] = self.line!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainSwitch"] as? String {
            self.domainSwitch = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Line"] as? String {
            self.line = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeUpBpsPeakOfLineResponseBody : Tea.TeaModel {
    public class DescribeUpBpsPeakOfLines : Tea.TeaModel {
        public class DescribeUpBpsPeakOfLine : Tea.TeaModel {
            public var bandWidth: Double?

            public var peakTime: String?

            public var queryTime: String?

            public var statName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidth != nil {
                    map["BandWidth"] = self.bandWidth!
                }
                if self.peakTime != nil {
                    map["PeakTime"] = self.peakTime!
                }
                if self.queryTime != nil {
                    map["QueryTime"] = self.queryTime!
                }
                if self.statName != nil {
                    map["StatName"] = self.statName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BandWidth"] as? Double {
                    self.bandWidth = value
                }
                if let value = dict["PeakTime"] as? String {
                    self.peakTime = value
                }
                if let value = dict["QueryTime"] as? String {
                    self.queryTime = value
                }
                if let value = dict["StatName"] as? String {
                    self.statName = value
                }
            }
        }
        public var describeUpBpsPeakOfLine: [DescribeUpBpsPeakOfLineResponseBody.DescribeUpBpsPeakOfLines.DescribeUpBpsPeakOfLine]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.describeUpBpsPeakOfLine != nil {
                var tmp : [Any] = []
                for k in self.describeUpBpsPeakOfLine! {
                    tmp.append(k.toMap())
                }
                map["DescribeUpBpsPeakOfLine"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DescribeUpBpsPeakOfLine"] as? [Any?] {
                var tmp : [DescribeUpBpsPeakOfLineResponseBody.DescribeUpBpsPeakOfLines.DescribeUpBpsPeakOfLine] = []
                for v in value {
                    if v != nil {
                        var model = DescribeUpBpsPeakOfLineResponseBody.DescribeUpBpsPeakOfLines.DescribeUpBpsPeakOfLine()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.describeUpBpsPeakOfLine = tmp
            }
        }
    }
    public var describeUpBpsPeakOfLines: DescribeUpBpsPeakOfLineResponseBody.DescribeUpBpsPeakOfLines?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.describeUpBpsPeakOfLines?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describeUpBpsPeakOfLines != nil {
            map["DescribeUpBpsPeakOfLines"] = self.describeUpBpsPeakOfLines?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DescribeUpBpsPeakOfLines"] as? [String: Any?] {
            var model = DescribeUpBpsPeakOfLineResponseBody.DescribeUpBpsPeakOfLines()
            model.fromMap(value)
            self.describeUpBpsPeakOfLines = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeUpBpsPeakOfLineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpBpsPeakOfLineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeUpBpsPeakOfLineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeUpPeakPublishStreamDataRequest : Tea.TeaModel {
    public var domainName: String?

    public var domainSwitch: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.domainSwitch != nil {
            map["DomainSwitch"] = self.domainSwitch!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DomainSwitch"] as? String {
            self.domainSwitch = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeUpPeakPublishStreamDataResponseBody : Tea.TeaModel {
    public class DescribeUpPeakPublishStreamDatas : Tea.TeaModel {
        public class DescribeUpPeakPublishStreamData : Tea.TeaModel {
            public var bandWidth: String?

            public var peakTime: String?

            public var publishStreamNum: Int32?

            public var queryTime: String?

            public var statName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandWidth != nil {
                    map["BandWidth"] = self.bandWidth!
                }
                if self.peakTime != nil {
                    map["PeakTime"] = self.peakTime!
                }
                if self.publishStreamNum != nil {
                    map["PublishStreamNum"] = self.publishStreamNum!
                }
                if self.queryTime != nil {
                    map["QueryTime"] = self.queryTime!
                }
                if self.statName != nil {
                    map["StatName"] = self.statName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BandWidth"] as? String {
                    self.bandWidth = value
                }
                if let value = dict["PeakTime"] as? String {
                    self.peakTime = value
                }
                if let value = dict["PublishStreamNum"] as? Int32 {
                    self.publishStreamNum = value
                }
                if let value = dict["QueryTime"] as? String {
                    self.queryTime = value
                }
                if let value = dict["StatName"] as? String {
                    self.statName = value
                }
            }
        }
        public var describeUpPeakPublishStreamData: [DescribeUpPeakPublishStreamDataResponseBody.DescribeUpPeakPublishStreamDatas.DescribeUpPeakPublishStreamData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.describeUpPeakPublishStreamData != nil {
                var tmp : [Any] = []
                for k in self.describeUpPeakPublishStreamData! {
                    tmp.append(k.toMap())
                }
                map["DescribeUpPeakPublishStreamData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DescribeUpPeakPublishStreamData"] as? [Any?] {
                var tmp : [DescribeUpPeakPublishStreamDataResponseBody.DescribeUpPeakPublishStreamDatas.DescribeUpPeakPublishStreamData] = []
                for v in value {
                    if v != nil {
                        var model = DescribeUpPeakPublishStreamDataResponseBody.DescribeUpPeakPublishStreamDatas.DescribeUpPeakPublishStreamData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.describeUpPeakPublishStreamData = tmp
            }
        }
    }
    public var describeUpPeakPublishStreamDatas: DescribeUpPeakPublishStreamDataResponseBody.DescribeUpPeakPublishStreamDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.describeUpPeakPublishStreamDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.describeUpPeakPublishStreamDatas != nil {
            map["DescribeUpPeakPublishStreamDatas"] = self.describeUpPeakPublishStreamDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DescribeUpPeakPublishStreamDatas"] as? [String: Any?] {
            var model = DescribeUpPeakPublishStreamDataResponseBody.DescribeUpPeakPublishStreamDatas()
            model.fromMap(value)
            self.describeUpPeakPublishStreamDatas = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeUpPeakPublishStreamDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUpPeakPublishStreamDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeUpPeakPublishStreamDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DisableLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DynamicUpdateWaterMarkStreamRuleRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var stream: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class DynamicUpdateWaterMarkStreamRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DynamicUpdateWaterMarkStreamRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DynamicUpdateWaterMarkStreamRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DynamicUpdateWaterMarkStreamRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EditPlaylistRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programConfig: String?

    public var programId: String?

    public var programItems: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programConfig != nil {
            map["ProgramConfig"] = self.programConfig!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.programItems != nil {
            map["ProgramItems"] = self.programItems!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProgramConfig"] as? String {
            self.programConfig = value
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["ProgramItems"] as? String {
            self.programItems = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class EditPlaylistResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class FailedItems : Tea.TeaModel {
            public var itemId: String?

            public var itemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ItemId"] as? String {
                    self.itemId = value
                }
                if let value = dict["ItemName"] as? String {
                    self.itemName = value
                }
            }
        }
        public class SuccessItems : Tea.TeaModel {
            public var itemId: String?

            public var itemName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.itemId != nil {
                    map["ItemId"] = self.itemId!
                }
                if self.itemName != nil {
                    map["ItemName"] = self.itemName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ItemId"] as? String {
                    self.itemId = value
                }
                if let value = dict["ItemName"] as? String {
                    self.itemName = value
                }
            }
        }
        public var failedItems: [EditPlaylistResponseBody.Items.FailedItems]?

        public var successItems: [EditPlaylistResponseBody.Items.SuccessItems]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.failedItems != nil {
                var tmp : [Any] = []
                for k in self.failedItems! {
                    tmp.append(k.toMap())
                }
                map["FailedItems"] = tmp
            }
            if self.successItems != nil {
                var tmp : [Any] = []
                for k in self.successItems! {
                    tmp.append(k.toMap())
                }
                map["SuccessItems"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FailedItems"] as? [Any?] {
                var tmp : [EditPlaylistResponseBody.Items.FailedItems] = []
                for v in value {
                    if v != nil {
                        var model = EditPlaylistResponseBody.Items.FailedItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.failedItems = tmp
            }
            if let value = dict["SuccessItems"] as? [Any?] {
                var tmp : [EditPlaylistResponseBody.Items.SuccessItems] = []
                for v in value {
                    if v != nil {
                        var model = EditPlaylistResponseBody.Items.SuccessItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.successItems = tmp
            }
        }
    }
    public var casterId: String?

    public var items: EditPlaylistResponseBody.Items?

    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = EditPlaylistResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EditPlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EditPlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EditPlaylistResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EditShowAndReplaceRequest : Tea.TeaModel {
    public var casterId: String?

    public var endTime: Double?

    public var ownerId: Int64?

    public var regionId: String?

    public var showId: String?

    public var startTime: Double?

    public var storageInfo: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.storageInfo != nil {
            map["StorageInfo"] = self.storageInfo!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["EndTime"] as? Double {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowId"] as? String {
            self.showId = value
        }
        if let value = dict["StartTime"] as? Double {
            self.startTime = value
        }
        if let value = dict["StorageInfo"] as? String {
            self.storageInfo = value
        }
        if let value = dict["UserData"] as? String {
            self.userData = value
        }
    }
}

public class EditShowAndReplaceResponseBody : Tea.TeaModel {
    public var jobInfo: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobInfo != nil {
            map["JobInfo"] = self.jobInfo!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobInfo"] as? String {
            self.jobInfo = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EditShowAndReplaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EditShowAndReplaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EditShowAndReplaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EffectCasterUrgentRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
    }
}

public class EffectCasterUrgentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EffectCasterUrgentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EffectCasterUrgentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EffectCasterUrgentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EffectCasterVideoResourceRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
    }
}

public class EffectCasterVideoResourceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EffectCasterVideoResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EffectCasterVideoResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EffectCasterVideoResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class EnableLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ForbidLiveStreamRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var liveStreamType: String?

    public var oneshot: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resumeTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.liveStreamType != nil {
            map["LiveStreamType"] = self.liveStreamType!
        }
        if self.oneshot != nil {
            map["Oneshot"] = self.oneshot!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resumeTime != nil {
            map["ResumeTime"] = self.resumeTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["LiveStreamType"] as? String {
            self.liveStreamType = value
        }
        if let value = dict["Oneshot"] as? String {
            self.oneshot = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResumeTime"] as? String {
            self.resumeTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class ForbidLiveStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ForbidLiveStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ForbidLiveStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ForbidLiveStreamResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAllCustomTemplatesRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GetAllCustomTemplatesResponseBody : Tea.TeaModel {
    public var customTemplates: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplates != nil {
            map["CustomTemplates"] = self.customTemplates!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomTemplates"] as? String {
            self.customTemplates = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetAllCustomTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAllCustomTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAllCustomTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCustomTemplateRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
    }
}

public class GetCustomTemplateResponseBody : Tea.TeaModel {
    public var customTemplate: String?

    public var requestId: String?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customTemplate != nil {
            map["CustomTemplate"] = self.customTemplate!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomTemplate"] as? String {
            self.customTemplate = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
    }
}

public class GetCustomTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCustomTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCustomTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetEdgeTranscodeJobRequest : Tea.TeaModel {
    public var clusterId: String?

    public var jobId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class GetEdgeTranscodeJobResponseBody : Tea.TeaModel {
    public class Job : Tea.TeaModel {
        public var createTime: String?

        public var jobId: String?

        public var lastStartAt: String?

        public var lastStopAt: String?

        public var name: String?

        public var status: String?

        public var streamInput: String?

        public var streamOutput: String?

        public var templateId: String?

        public var templateName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.lastStartAt != nil {
                map["LastStartAt"] = self.lastStartAt!
            }
            if self.lastStopAt != nil {
                map["LastStopAt"] = self.lastStopAt!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.streamInput != nil {
                map["StreamInput"] = self.streamInput!
            }
            if self.streamOutput != nil {
                map["StreamOutput"] = self.streamOutput!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["JobId"] as? String {
                self.jobId = value
            }
            if let value = dict["LastStartAt"] as? String {
                self.lastStartAt = value
            }
            if let value = dict["LastStopAt"] as? String {
                self.lastStopAt = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["StreamInput"] as? String {
                self.streamInput = value
            }
            if let value = dict["StreamOutput"] as? String {
                self.streamOutput = value
            }
            if let value = dict["TemplateId"] as? String {
                self.templateId = value
            }
            if let value = dict["TemplateName"] as? String {
                self.templateName = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var job: GetEdgeTranscodeJobResponseBody.Job?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.job?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.job != nil {
            map["Job"] = self.job?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Job"] as? [String: Any?] {
            var model = GetEdgeTranscodeJobResponseBody.Job()
            model.fromMap(value)
            self.job = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetEdgeTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEdgeTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetEdgeTranscodeJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetEdgeTranscodeTemplateRequest : Tea.TeaModel {
    public var clusterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class GetEdgeTranscodeTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var bitrate: String?

        public var codec: String?

        public var createTime: String?

        public var fps: String?

        public var gop: String?

        public var name: String?

        public var resolution: String?

        public var templateId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.codec != nil {
                map["Codec"] = self.codec!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.gop != nil {
                map["Gop"] = self.gop!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.resolution != nil {
                map["Resolution"] = self.resolution!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Bitrate"] as? String {
                self.bitrate = value
            }
            if let value = dict["Codec"] as? String {
                self.codec = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["Fps"] as? String {
                self.fps = value
            }
            if let value = dict["Gop"] as? String {
                self.gop = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Resolution"] as? String {
                self.resolution = value
            }
            if let value = dict["TemplateId"] as? String {
                self.templateId = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var requestId: String?

    public var template: GetEdgeTranscodeTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Template"] as? [String: Any?] {
            var model = GetEdgeTranscodeTemplateResponseBody.Template()
            model.fromMap(value)
            self.template = model
        }
    }
}

public class GetEdgeTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEdgeTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetEdgeTranscodeTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetEditingJobInfoRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var showId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowId"] as? String {
            self.showId = value
        }
    }
}

public class GetEditingJobInfoResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var editingTasksInfo: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.editingTasksInfo != nil {
            map["EditingTasksInfo"] = self.editingTasksInfo!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["EditingTasksInfo"] as? String {
            self.editingTasksInfo = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetEditingJobInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEditingJobInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetEditingJobInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMessageAppRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class GetMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var appConfig: [String: String]?

        public var appId: String?

        public var appName: String?

        public var createTime: Int64?

        public var extension_: [String: String]?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appConfig != nil {
                map["AppConfig"] = self.appConfig!
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppConfig"] as? [String: String] {
                self.appConfig = value
            }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Extension"] as? [String: String] {
                self.extension_ = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var result: GetMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = GetMessageAppResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class GetMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMessageAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class GetMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: Int64?

        public var creatorId: String?

        public var extension_: [String: Any]?

        public var groupId: String?

        public var isMuteAll: Bool?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.isMuteAll != nil {
                map["IsMuteAll"] = self.isMuteAll!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CreatorId"] as? String {
                self.creatorId = value
            }
            if let value = dict["Extension"] as? [String: Any] {
                self.extension_ = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["IsMuteAll"] as? Bool {
                self.isMuteAll = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var result: GetMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = GetMessageGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class GetMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetMessageTokenRequest : Tea.TeaModel {
    public var appId: String?

    public var deviceId: String?

    public var deviceType: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.deviceType != nil {
            map["DeviceType"] = self.deviceType!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DeviceId"] as? String {
            self.deviceId = value
        }
        if let value = dict["DeviceType"] as? String {
            self.deviceType = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GetMessageTokenResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessToken: String?

        public var accessTokenExpiredTime: Int64?

        public var refreshToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessToken != nil {
                map["AccessToken"] = self.accessToken!
            }
            if self.accessTokenExpiredTime != nil {
                map["AccessTokenExpiredTime"] = self.accessTokenExpiredTime!
            }
            if self.refreshToken != nil {
                map["RefreshToken"] = self.refreshToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessToken"] as? String {
                self.accessToken = value
            }
            if let value = dict["AccessTokenExpiredTime"] as? Int64 {
                self.accessTokenExpiredTime = value
            }
            if let value = dict["RefreshToken"] as? String {
                self.refreshToken = value
            }
        }
    }
    public var requestId: String?

    public var result: GetMessageTokenResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = GetMessageTokenResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class GetMessageTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMessageTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetMessageTokenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTranscodeTaskStatusRequest : Tea.TeaModel {
    public var app: String?

    public var pushDomain: String?

    public var securityToken: String?

    public var streamName: String?

    public var transcodingTemplate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.pushDomain != nil {
            map["PushDomain"] = self.pushDomain!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.transcodingTemplate != nil {
            map["TranscodingTemplate"] = self.transcodingTemplate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["PushDomain"] as? String {
            self.pushDomain = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["TranscodingTemplate"] as? String {
            self.transcodingTemplate = value
        }
    }
}

public class GetTranscodeTaskStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetTranscodeTaskStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTranscodeTaskStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTranscodeTaskStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class HotLiveRtcStreamRequest : Tea.TeaModel {
    public var appName: String?

    public var audioMsid: String?

    public var connectionTimeout: String?

    public var domainName: String?

    public var mediaTimeout: String?

    public var ownerId: Int64?

    public var regionCode: String?

    public var regionId: String?

    public var streamName: String?

    public var videoMsid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.audioMsid != nil {
            map["AudioMsid"] = self.audioMsid!
        }
        if self.connectionTimeout != nil {
            map["ConnectionTimeout"] = self.connectionTimeout!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.mediaTimeout != nil {
            map["MediaTimeout"] = self.mediaTimeout!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionCode != nil {
            map["RegionCode"] = self.regionCode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.videoMsid != nil {
            map["VideoMsid"] = self.videoMsid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AudioMsid"] as? String {
            self.audioMsid = value
        }
        if let value = dict["ConnectionTimeout"] as? String {
            self.connectionTimeout = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["MediaTimeout"] as? String {
            self.mediaTimeout = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionCode"] as? String {
            self.regionCode = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["VideoMsid"] as? String {
            self.videoMsid = value
        }
    }
}

public class HotLiveRtcStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class HotLiveRtcStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: HotLiveRtcStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = HotLiveRtcStreamResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InitializeAutoShowListTaskRequest : Tea.TeaModel {
    public var callBackUrl: String?

    public var casterConfig: String?

    public var domainName: String?

    public var endTime: Int64?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceIds: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callBackUrl != nil {
            map["CallBackUrl"] = self.callBackUrl!
        }
        if self.casterConfig != nil {
            map["CasterConfig"] = self.casterConfig!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallBackUrl"] as? String {
            self.callBackUrl = value
        }
        if let value = dict["CasterConfig"] as? String {
            self.casterConfig = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceIds"] as? String {
            self.resourceIds = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class InitializeAutoShowListTaskResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public var streamList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamList != nil {
            map["StreamList"] = self.streamList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamList"] as? String {
            self.streamList = value
        }
    }
}

public class InitializeAutoShowListTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitializeAutoShowListTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InitializeAutoShowListTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class JoinMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastStatistics: Bool?

    public var broadCastType: Int32?

    public var groupId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastStatistics != nil {
            map["BroadCastStatistics"] = self.broadCastStatistics!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BroadCastStatistics"] as? Bool {
            self.broadCastStatistics = value
        }
        if let value = dict["BroadCastType"] as? Int32 {
            self.broadCastType = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class JoinMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var requestId: String?

    public var result: JoinMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = JoinMessageGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class JoinMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = JoinMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class KickLiveMessageGroupUserRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var kickoffUser: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.kickoffUser != nil {
            map["KickoffUser"] = self.kickoffUser!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["KickoffUser"] as? String {
            self.kickoffUser = value
        }
    }
}

public class KickLiveMessageGroupUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class KickLiveMessageGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: KickLiveMessageGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = KickLiveMessageGroupUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class LeaveMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastStatistics: Bool?

    public var broadCastType: Int32?

    public var groupId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastStatistics != nil {
            map["BroadCastStatistics"] = self.broadCastStatistics!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BroadCastStatistics"] as? Bool {
            self.broadCastStatistics = value
        }
        if let value = dict["BroadCastType"] as? Int32 {
            self.broadCastType = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class LeaveMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var requestId: String?

    public var result: LeaveMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = LeaveMessageGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class LeaveMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LeaveMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = LeaveMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEdgeTranscodeJobRequest : Tea.TeaModel {
    public var clusterId: String?

    public var keyword: String?

    public var ownerId: Int64?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var sortBy: String?

    public var status: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Status"] as? Int32 {
            self.status = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class ListEdgeTranscodeJobResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Job : Tea.TeaModel {
            public var createTime: String?

            public var jobId: String?

            public var lastStartAt: String?

            public var lastStopAt: String?

            public var name: String?

            public var status: String?

            public var streamInput: String?

            public var streamOutput: String?

            public var templateId: String?

            public var templateName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.lastStartAt != nil {
                    map["LastStartAt"] = self.lastStartAt!
                }
                if self.lastStopAt != nil {
                    map["LastStopAt"] = self.lastStopAt!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.streamInput != nil {
                    map["StreamInput"] = self.streamInput!
                }
                if self.streamOutput != nil {
                    map["StreamOutput"] = self.streamOutput!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["JobId"] as? String {
                    self.jobId = value
                }
                if let value = dict["LastStartAt"] as? String {
                    self.lastStartAt = value
                }
                if let value = dict["LastStopAt"] as? String {
                    self.lastStopAt = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
                if let value = dict["StreamInput"] as? String {
                    self.streamInput = value
                }
                if let value = dict["StreamOutput"] as? String {
                    self.streamOutput = value
                }
                if let value = dict["TemplateId"] as? String {
                    self.templateId = value
                }
                if let value = dict["TemplateName"] as? String {
                    self.templateName = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var job: [ListEdgeTranscodeJobResponseBody.JobList.Job]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.job != nil {
                var tmp : [Any] = []
                for k in self.job! {
                    tmp.append(k.toMap())
                }
                map["Job"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Job"] as? [Any?] {
                var tmp : [ListEdgeTranscodeJobResponseBody.JobList.Job] = []
                for v in value {
                    if v != nil {
                        var model = ListEdgeTranscodeJobResponseBody.JobList.Job()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.job = tmp
            }
        }
    }
    public var jobList: ListEdgeTranscodeJobResponseBody.JobList?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            map["JobList"] = self.jobList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobList"] as? [String: Any?] {
            var model = ListEdgeTranscodeJobResponseBody.JobList()
            model.fromMap(value)
            self.jobList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListEdgeTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEdgeTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEdgeTranscodeJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEdgeTranscodeTemplateRequest : Tea.TeaModel {
    public var clusterId: String?

    public var keyword: String?

    public var ownerId: Int64?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var sortBy: String?

    public var type: String?

    public var videoCodec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sortBy != nil {
            map["SortBy"] = self.sortBy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.videoCodec != nil {
            map["VideoCodec"] = self.videoCodec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SortBy"] as? String {
            self.sortBy = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["VideoCodec"] as? String {
            self.videoCodec = value
        }
    }
}

public class ListEdgeTranscodeTemplateResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var bitrate: String?

            public var codec: String?

            public var createTime: String?

            public var fps: String?

            public var gop: String?

            public var name: String?

            public var resolution: String?

            public var templateId: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.resolution != nil {
                    map["Resolution"] = self.resolution!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Bitrate"] as? String {
                    self.bitrate = value
                }
                if let value = dict["Codec"] as? String {
                    self.codec = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["Fps"] as? String {
                    self.fps = value
                }
                if let value = dict["Gop"] as? String {
                    self.gop = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Resolution"] as? String {
                    self.resolution = value
                }
                if let value = dict["TemplateId"] as? String {
                    self.templateId = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var template: [ListEdgeTranscodeTemplateResponseBody.TemplateList.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Template"] as? [Any?] {
                var tmp : [ListEdgeTranscodeTemplateResponseBody.TemplateList.Template] = []
                for v in value {
                    if v != nil {
                        var model = ListEdgeTranscodeTemplateResponseBody.TemplateList.Template()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.template = tmp
            }
        }
    }
    public var requestId: String?

    public var templateList: ListEdgeTranscodeTemplateResponseBody.TemplateList?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateList != nil {
            map["TemplateList"] = self.templateList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TemplateList"] as? [String: Any?] {
            var model = ListEdgeTranscodeTemplateResponseBody.TemplateList()
            model.fromMap(value)
            self.templateList = model
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListEdgeTranscodeTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEdgeTranscodeTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEdgeTranscodeTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEventSubRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListEventSubResponseBody : Tea.TeaModel {
    public class Subscribers : Tea.TeaModel {
        public var callbackUrl: String?

        public var channelId: String?

        public var createTime: String?

        public var events: [String]?

        public var modifyTime: String?

        public var roles: Int32?

        public var subId: String?

        public var users: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callbackUrl != nil {
                map["CallbackUrl"] = self.callbackUrl!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.events != nil {
                map["Events"] = self.events!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.roles != nil {
                map["Roles"] = self.roles!
            }
            if self.subId != nil {
                map["SubId"] = self.subId!
            }
            if self.users != nil {
                map["Users"] = self.users!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CallbackUrl"] as? String {
                self.callbackUrl = value
            }
            if let value = dict["ChannelId"] as? String {
                self.channelId = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["Events"] as? [String] {
                self.events = value
            }
            if let value = dict["ModifyTime"] as? String {
                self.modifyTime = value
            }
            if let value = dict["Roles"] as? Int32 {
                self.roles = value
            }
            if let value = dict["SubId"] as? String {
                self.subId = value
            }
            if let value = dict["Users"] as? [String] {
                self.users = value
            }
        }
    }
    public var requestId: String?

    public var subscribers: [ListEventSubResponseBody.Subscribers]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.subscribers != nil {
            var tmp : [Any] = []
            for k in self.subscribers! {
                tmp.append(k.toMap())
            }
            map["Subscribers"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Subscribers"] as? [Any?] {
            var tmp : [ListEventSubResponseBody.Subscribers] = []
            for v in value {
                if v != nil {
                    var model = ListEventSubResponseBody.Subscribers()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.subscribers = tmp
        }
    }
}

public class ListEventSubResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventSubResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEventSubResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEventSubEventRequest : Tea.TeaModel {
    public var appId: String?

    public var endTime: Int64?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var startTime: Int64?

    public var subscribeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.subscribeId != nil {
            map["SubscribeId"] = self.subscribeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["PageNo"] as? Int64 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["SubscribeId"] as? String {
            self.subscribeId = value
        }
    }
}

public class ListEventSubEventResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public var appId: String?

        public var code: Int32?

        public var cost: Int32?

        public var data: String?

        public var messageId: String?

        public var subId: String?

        public var time: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.cost != nil {
                map["Cost"] = self.cost!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.messageId != nil {
                map["MessageId"] = self.messageId!
            }
            if self.subId != nil {
                map["SubId"] = self.subId!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Code"] as? Int32 {
                self.code = value
            }
            if let value = dict["Cost"] as? Int32 {
                self.cost = value
            }
            if let value = dict["Data"] as? String {
                self.data = value
            }
            if let value = dict["MessageId"] as? String {
                self.messageId = value
            }
            if let value = dict["SubId"] as? String {
                self.subId = value
            }
            if let value = dict["Time"] as? String {
                self.time = value
            }
            if let value = dict["Url"] as? String {
                self.url = value
            }
        }
    }
    public var count: Int64?

    public var hasMore: Bool?

    public var logs: [ListEventSubEventResponseBody.Logs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.hasMore != nil {
            map["HasMore"] = self.hasMore!
        }
        if self.logs != nil {
            var tmp : [Any] = []
            for k in self.logs! {
                tmp.append(k.toMap())
            }
            map["Logs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int64 {
            self.count = value
        }
        if let value = dict["HasMore"] as? Bool {
            self.hasMore = value
        }
        if let value = dict["Logs"] as? [Any?] {
            var tmp : [ListEventSubEventResponseBody.Logs] = []
            for v in value {
                if v != nil {
                    var model = ListEventSubEventResponseBody.Logs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.logs = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListEventSubEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEventSubEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEventSubEventResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveDelayConfigRequest : Tea.TeaModel {
    public var domain: String?

    public var ownerId: Int64?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListLiveDelayConfigResponseBody : Tea.TeaModel {
    public class DelayConfigList : Tea.TeaModel {
        public class DelayConfig : Tea.TeaModel {
            public var app: String?

            public var delayTime: String?

            public var domain: String?

            public var stream: String?

            public var taskTriggerMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.app != nil {
                    map["App"] = self.app!
                }
                if self.delayTime != nil {
                    map["DelayTime"] = self.delayTime!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.stream != nil {
                    map["Stream"] = self.stream!
                }
                if self.taskTriggerMode != nil {
                    map["TaskTriggerMode"] = self.taskTriggerMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["App"] as? String {
                    self.app = value
                }
                if let value = dict["DelayTime"] as? String {
                    self.delayTime = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["Stream"] as? String {
                    self.stream = value
                }
                if let value = dict["TaskTriggerMode"] as? String {
                    self.taskTriggerMode = value
                }
            }
        }
        public var delayConfig: [ListLiveDelayConfigResponseBody.DelayConfigList.DelayConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.delayConfig != nil {
                var tmp : [Any] = []
                for k in self.delayConfig! {
                    tmp.append(k.toMap())
                }
                map["DelayConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DelayConfig"] as? [Any?] {
                var tmp : [ListLiveDelayConfigResponseBody.DelayConfigList.DelayConfig] = []
                for v in value {
                    if v != nil {
                        var model = ListLiveDelayConfigResponseBody.DelayConfigList.DelayConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.delayConfig = tmp
            }
        }
    }
    public var delayConfigList: ListLiveDelayConfigResponseBody.DelayConfigList?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.delayConfigList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.delayConfigList != nil {
            map["DelayConfigList"] = self.delayConfigList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DelayConfigList"] as? [String: Any?] {
            var model = ListLiveDelayConfigResponseBody.DelayConfigList()
            model.fromMap(value)
            self.delayConfigList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class ListLiveDelayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveDelayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveDelayConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveMessageAppsRequest : Tea.TeaModel {
    public var dataCenter: String?

    public var nextPageToken: Int64?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["NextPageToken"] as? Int64 {
            self.nextPageToken = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
    }
}

public class ListLiveMessageAppsResponseBody : Tea.TeaModel {
    public class AppList : Tea.TeaModel {
        public var appId: String?

        public var appKey: String?

        public var appName: String?

        public var appSign: String?

        public var createTime: Int64?

        public var dataCenter: String?

        public var disable: String?

        public var modifyTime: Int64?

        public var msgLifeCycle: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appKey != nil {
                map["AppKey"] = self.appKey!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.appSign != nil {
                map["AppSign"] = self.appSign!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.dataCenter != nil {
                map["DataCenter"] = self.dataCenter!
            }
            if self.disable != nil {
                map["Disable"] = self.disable!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.msgLifeCycle != nil {
                map["MsgLifeCycle"] = self.msgLifeCycle!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppKey"] as? String {
                self.appKey = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["AppSign"] as? String {
                self.appSign = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DataCenter"] as? String {
                self.dataCenter = value
            }
            if let value = dict["Disable"] as? String {
                self.disable = value
            }
            if let value = dict["ModifyTime"] as? Int64 {
                self.modifyTime = value
            }
            if let value = dict["MsgLifeCycle"] as? Int32 {
                self.msgLifeCycle = value
            }
        }
    }
    public var appList: [ListLiveMessageAppsResponseBody.AppList]?

    public var hasMore: Bool?

    public var nextPageToken: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appList != nil {
            var tmp : [Any] = []
            for k in self.appList! {
                tmp.append(k.toMap())
            }
            map["AppList"] = tmp
        }
        if self.hasMore != nil {
            map["HasMore"] = self.hasMore!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppList"] as? [Any?] {
            var tmp : [ListLiveMessageAppsResponseBody.AppList] = []
            for v in value {
                if v != nil {
                    var model = ListLiveMessageAppsResponseBody.AppList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.appList = tmp
        }
        if let value = dict["HasMore"] as? Bool {
            self.hasMore = value
        }
        if let value = dict["NextPageToken"] as? Int64 {
            self.nextPageToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListLiveMessageAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveMessageAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveMessageAppsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveMessageGroupByPageRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupStatus: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupStatus != nil {
            map["GroupStatus"] = self.groupStatus!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupStatus"] as? Int32 {
            self.groupStatus = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
    }
}

public class ListLiveMessageGroupByPageResponseBody : Tea.TeaModel {
    public class GroupList : Tea.TeaModel {
        public var adminList: [String]?

        public var createtime: Int64?

        public var creatorId: String?

        public var delete: Bool?

        public var groupId: String?

        public var groupInfo: String?

        public var groupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adminList != nil {
                map["AdminList"] = self.adminList!
            }
            if self.createtime != nil {
                map["Createtime"] = self.createtime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.delete != nil {
                map["Delete"] = self.delete!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupInfo != nil {
                map["GroupInfo"] = self.groupInfo!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdminList"] as? [String] {
                self.adminList = value
            }
            if let value = dict["Createtime"] as? Int64 {
                self.createtime = value
            }
            if let value = dict["CreatorId"] as? String {
                self.creatorId = value
            }
            if let value = dict["Delete"] as? Bool {
                self.delete = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["GroupInfo"] as? String {
                self.groupInfo = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
        }
    }
    public var groupList: [ListLiveMessageGroupByPageResponseBody.GroupList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupList != nil {
            var tmp : [Any] = []
            for k in self.groupList! {
                tmp.append(k.toMap())
            }
            map["GroupList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupList"] as? [Any?] {
            var tmp : [ListLiveMessageGroupByPageResponseBody.GroupList] = []
            for v in value {
                if v != nil {
                    var model = ListLiveMessageGroupByPageResponseBody.GroupList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.groupList = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListLiveMessageGroupByPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveMessageGroupByPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveMessageGroupByPageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveMessageGroupMessagesRequest : Tea.TeaModel {
    public var appId: String?

    public var beginTime: Int64?

    public var dataCenter: String?

    public var endTime: Int64?

    public var groupId: String?

    public var msgType: Int64?

    public var nextPageToken: Int64?

    public var pageSize: Int32?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.msgType != nil {
            map["MsgType"] = self.msgType!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BeginTime"] as? Int64 {
            self.beginTime = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["MsgType"] as? Int64 {
            self.msgType = value
        }
        if let value = dict["NextPageToken"] as? Int64 {
            self.nextPageToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
    }
}

public class ListLiveMessageGroupMessagesResponseBody : Tea.TeaModel {
    public class MessageList : Tea.TeaModel {
        public class Sender : Tea.TeaModel {
            public var userId: String?

            public var userInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userInfo != nil {
                    map["UserInfo"] = self.userInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["UserInfo"] as? String {
                    self.userInfo = value
                }
            }
        }
        public var body: String?

        public var msgTid: String?

        public var msgType: Int64?

        public var sender: ListLiveMessageGroupMessagesResponseBody.MessageList.Sender?

        public var seqNumber: Int64?

        public var timestamp: Int64?

        public var totalMessages: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sender?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.body != nil {
                map["Body"] = self.body!
            }
            if self.msgTid != nil {
                map["MsgTid"] = self.msgTid!
            }
            if self.msgType != nil {
                map["MsgType"] = self.msgType!
            }
            if self.sender != nil {
                map["Sender"] = self.sender?.toMap()
            }
            if self.seqNumber != nil {
                map["SeqNumber"] = self.seqNumber!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.totalMessages != nil {
                map["TotalMessages"] = self.totalMessages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Body"] as? String {
                self.body = value
            }
            if let value = dict["MsgTid"] as? String {
                self.msgTid = value
            }
            if let value = dict["MsgType"] as? Int64 {
                self.msgType = value
            }
            if let value = dict["Sender"] as? [String: Any?] {
                var model = ListLiveMessageGroupMessagesResponseBody.MessageList.Sender()
                model.fromMap(value)
                self.sender = model
            }
            if let value = dict["SeqNumber"] as? Int64 {
                self.seqNumber = value
            }
            if let value = dict["Timestamp"] as? Int64 {
                self.timestamp = value
            }
            if let value = dict["TotalMessages"] as? Int64 {
                self.totalMessages = value
            }
        }
    }
    public var groupId: String?

    public var hasmore: Bool?

    public var messageList: [ListLiveMessageGroupMessagesResponseBody.MessageList]?

    public var nextPageToken: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.hasmore != nil {
            map["Hasmore"] = self.hasmore!
        }
        if self.messageList != nil {
            var tmp : [Any] = []
            for k in self.messageList! {
                tmp.append(k.toMap())
            }
            map["MessageList"] = tmp
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["Hasmore"] as? Bool {
            self.hasmore = value
        }
        if let value = dict["MessageList"] as? [Any?] {
            var tmp : [ListLiveMessageGroupMessagesResponseBody.MessageList] = []
            for v in value {
                if v != nil {
                    var model = ListLiveMessageGroupMessagesResponseBody.MessageList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.messageList = tmp
        }
        if let value = dict["NextPageToken"] as? Int64 {
            self.nextPageToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListLiveMessageGroupMessagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveMessageGroupMessagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveMessageGroupMessagesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveMessageGroupUsersRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var nextPageToken: Int64?

    public var pageSize: Int32?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["NextPageToken"] as? Int64 {
            self.nextPageToken = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
    }
}

public class ListLiveMessageGroupUsersResponseBody : Tea.TeaModel {
    public class UserList : Tea.TeaModel {
        public var userId: String?

        public var userInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userInfo != nil {
                map["UserInfo"] = self.userInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
            if let value = dict["UserInfo"] as? String {
                self.userInfo = value
            }
        }
    }
    public var groupId: String?

    public var hasmore: Bool?

    public var nextPageToken: Int64?

    public var requestId: String?

    public var userList: [ListLiveMessageGroupUsersResponseBody.UserList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.hasmore != nil {
            map["Hasmore"] = self.hasmore!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userList != nil {
            var tmp : [Any] = []
            for k in self.userList! {
                tmp.append(k.toMap())
            }
            map["UserList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["Hasmore"] as? Bool {
            self.hasmore = value
        }
        if let value = dict["NextPageToken"] as? Int64 {
            self.nextPageToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UserList"] as? [Any?] {
            var tmp : [ListLiveMessageGroupUsersResponseBody.UserList] = []
            for v in value {
                if v != nil {
                    var model = ListLiveMessageGroupUsersResponseBody.UserList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.userList = tmp
        }
    }
}

public class ListLiveMessageGroupUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveMessageGroupUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveMessageGroupUsersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveMessageGroupsRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupStatus: Int32?

    public var nextPageToken: Int64?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupStatus != nil {
            map["GroupStatus"] = self.groupStatus!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupStatus"] as? Int32 {
            self.groupStatus = value
        }
        if let value = dict["NextPageToken"] as? Int64 {
            self.nextPageToken = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
    }
}

public class ListLiveMessageGroupsResponseBody : Tea.TeaModel {
    public class GroupList : Tea.TeaModel {
        public var adminList: [String]?

        public var createtime: Int64?

        public var creatorId: String?

        public var delete: Bool?

        public var groupId: String?

        public var groupInfo: String?

        public var groupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adminList != nil {
                map["AdminList"] = self.adminList!
            }
            if self.createtime != nil {
                map["Createtime"] = self.createtime!
            }
            if self.creatorId != nil {
                map["CreatorId"] = self.creatorId!
            }
            if self.delete != nil {
                map["Delete"] = self.delete!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupInfo != nil {
                map["GroupInfo"] = self.groupInfo!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdminList"] as? [String] {
                self.adminList = value
            }
            if let value = dict["Createtime"] as? Int64 {
                self.createtime = value
            }
            if let value = dict["CreatorId"] as? String {
                self.creatorId = value
            }
            if let value = dict["Delete"] as? Bool {
                self.delete = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["GroupInfo"] as? String {
                self.groupInfo = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
        }
    }
    public var groupList: [ListLiveMessageGroupsResponseBody.GroupList]?

    public var hasmore: Bool?

    public var nextpageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupList != nil {
            var tmp : [Any] = []
            for k in self.groupList! {
                tmp.append(k.toMap())
            }
            map["GroupList"] = tmp
        }
        if self.hasmore != nil {
            map["Hasmore"] = self.hasmore!
        }
        if self.nextpageToken != nil {
            map["NextpageToken"] = self.nextpageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupList"] as? [Any?] {
            var tmp : [ListLiveMessageGroupsResponseBody.GroupList] = []
            for v in value {
                if v != nil {
                    var model = ListLiveMessageGroupsResponseBody.GroupList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.groupList = tmp
        }
        if let value = dict["Hasmore"] as? Bool {
            self.hasmore = value
        }
        if let value = dict["NextpageToken"] as? String {
            self.nextpageToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListLiveMessageGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveMessageGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveMessageGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var liveOpenapiReserve: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveOpenapiReserve != nil {
            map["LiveOpenapiReserve"] = self.liveOpenapiReserve!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveOpenapiReserve"] as? String {
            self.liveOpenapiReserve = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class RealtimeLogDeliveryInfo : Tea.TeaModel {
            public var dmId: Int32?

            public var domainName: String?

            public var logstore: String?

            public var project: String?

            public var region: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dmId != nil {
                    map["DmId"] = self.dmId!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.logstore != nil {
                    map["Logstore"] = self.logstore!
                }
                if self.project != nil {
                    map["Project"] = self.project!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DmId"] as? Int32 {
                    self.dmId = value
                }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Logstore"] as? String {
                    self.logstore = value
                }
                if let value = dict["Project"] as? String {
                    self.project = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var realtimeLogDeliveryInfo: [ListLiveRealtimeLogDeliveryResponseBody.Content.RealtimeLogDeliveryInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.realtimeLogDeliveryInfo != nil {
                var tmp : [Any] = []
                for k in self.realtimeLogDeliveryInfo! {
                    tmp.append(k.toMap())
                }
                map["RealtimeLogDeliveryInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RealtimeLogDeliveryInfo"] as? [Any?] {
                var tmp : [ListLiveRealtimeLogDeliveryResponseBody.Content.RealtimeLogDeliveryInfo] = []
                for v in value {
                    if v != nil {
                        var model = ListLiveRealtimeLogDeliveryResponseBody.Content.RealtimeLogDeliveryInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.realtimeLogDeliveryInfo = tmp
            }
        }
    }
    public var content: ListLiveRealtimeLogDeliveryResponseBody.Content?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? [String: Any?] {
            var model = ListLiveRealtimeLogDeliveryResponseBody.Content()
            model.fromMap(value)
            self.content = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveRealtimeLogDeliveryDomainsRequest : Tea.TeaModel {
    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Logstore"] as? String {
            self.logstore = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Project"] as? String {
            self.project = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListLiveRealtimeLogDeliveryDomainsResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class Domains : Tea.TeaModel {
            public var domainName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DomainName"] as? String {
                    self.domainName = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var domains: [ListLiveRealtimeLogDeliveryDomainsResponseBody.Content.Domains]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domains != nil {
                var tmp : [Any] = []
                for k in self.domains! {
                    tmp.append(k.toMap())
                }
                map["Domains"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Domains"] as? [Any?] {
                var tmp : [ListLiveRealtimeLogDeliveryDomainsResponseBody.Content.Domains] = []
                for v in value {
                    if v != nil {
                        var model = ListLiveRealtimeLogDeliveryDomainsResponseBody.Content.Domains()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.domains = tmp
            }
        }
    }
    public var content: ListLiveRealtimeLogDeliveryDomainsResponseBody.Content?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? [String: Any?] {
            var model = ListLiveRealtimeLogDeliveryDomainsResponseBody.Content()
            model.fromMap(value)
            self.content = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListLiveRealtimeLogDeliveryDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRealtimeLogDeliveryDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveRealtimeLogDeliveryDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveRealtimeLogDeliveryInfosRequest : Tea.TeaModel {
    public var liveOpenapiReserve: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.liveOpenapiReserve != nil {
            map["LiveOpenapiReserve"] = self.liveOpenapiReserve!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LiveOpenapiReserve"] as? String {
            self.liveOpenapiReserve = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListLiveRealtimeLogDeliveryInfosResponseBody : Tea.TeaModel {
    public class Content : Tea.TeaModel {
        public class RealtimeLogDeliveryInfos : Tea.TeaModel {
            public var logstore: String?

            public var project: String?

            public var region: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.logstore != nil {
                    map["Logstore"] = self.logstore!
                }
                if self.project != nil {
                    map["Project"] = self.project!
                }
                if self.region != nil {
                    map["Region"] = self.region!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Logstore"] as? String {
                    self.logstore = value
                }
                if let value = dict["Project"] as? String {
                    self.project = value
                }
                if let value = dict["Region"] as? String {
                    self.region = value
                }
            }
        }
        public var realtimeLogDeliveryInfos: [ListLiveRealtimeLogDeliveryInfosResponseBody.Content.RealtimeLogDeliveryInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.realtimeLogDeliveryInfos != nil {
                var tmp : [Any] = []
                for k in self.realtimeLogDeliveryInfos! {
                    tmp.append(k.toMap())
                }
                map["RealtimeLogDeliveryInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RealtimeLogDeliveryInfos"] as? [Any?] {
                var tmp : [ListLiveRealtimeLogDeliveryInfosResponseBody.Content.RealtimeLogDeliveryInfos] = []
                for v in value {
                    if v != nil {
                        var model = ListLiveRealtimeLogDeliveryInfosResponseBody.Content.RealtimeLogDeliveryInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.realtimeLogDeliveryInfos = tmp
            }
        }
    }
    public var content: ListLiveRealtimeLogDeliveryInfosResponseBody.Content?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.content?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? [String: Any?] {
            var model = ListLiveRealtimeLogDeliveryInfosResponseBody.Content()
            model.fromMap(value)
            self.content = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListLiveRealtimeLogDeliveryInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveRealtimeLogDeliveryInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveRealtimeLogDeliveryInfosResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLiveTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var nextToken: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListLiveTagResourcesRequest.Tag]?

    public var tagOwnerBid: String?

    public var tagOwnerUid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagOwnerBid != nil {
            map["TagOwnerBid"] = self.tagOwnerBid!
        }
        if self.tagOwnerUid != nil {
            map["TagOwnerUid"] = self.tagOwnerUid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListLiveTagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListLiveTagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["TagOwnerBid"] as? String {
            self.tagOwnerBid = value
        }
        if let value = dict["TagOwnerUid"] as? String {
            self.tagOwnerUid = value
        }
    }
}

public class ListLiveTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [ListLiveTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [ListLiveTagResourcesResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = ListLiveTagResourcesResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListLiveTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = ListLiveTagResourcesResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class ListLiveTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLiveTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLiveTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMessageRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
        if let value = dict["Type"] as? Int32 {
            self.type = value
        }
    }
}

public class ListMessageResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class MessageList : Tea.TeaModel {
            public var data: String?

            public var groupId: String?

            public var messageId: String?

            public var senderId: String?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                if self.senderId != nil {
                    map["SenderId"] = self.senderId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Data"] as? String {
                    self.data = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["MessageId"] as? String {
                    self.messageId = value
                }
                if let value = dict["SenderId"] as? String {
                    self.senderId = value
                }
                if let value = dict["Type"] as? Int32 {
                    self.type = value
                }
            }
        }
        public var hasMore: Bool?

        public var messageList: [ListMessageResponseBody.Result.MessageList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.messageList != nil {
                var tmp : [Any] = []
                for k in self.messageList! {
                    tmp.append(k.toMap())
                }
                map["MessageList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HasMore"] as? Bool {
                self.hasMore = value
            }
            if let value = dict["MessageList"] as? [Any?] {
                var tmp : [ListMessageResponseBody.Result.MessageList] = []
                for v in value {
                    if v != nil {
                        var model = ListMessageResponseBody.Result.MessageList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.messageList = tmp
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListMessageResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListMessageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMessageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMessageAppRequest : Tea.TeaModel {
    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
    }
}

public class ListMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AppList : Tea.TeaModel {
            public var appConfig: [String: String]?

            public var appId: String?

            public var appName: String?

            public var createTime: Int64?

            public var extension_: [String: String]?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appConfig != nil {
                    map["AppConfig"] = self.appConfig!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppConfig"] as? [String: String] {
                    self.appConfig = value
                }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Extension"] as? [String: String] {
                    self.extension_ = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
            }
        }
        public var appList: [ListMessageAppResponseBody.Result.AppList]?

        public var hasMore: Bool?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appList != nil {
                var tmp : [Any] = []
                for k in self.appList! {
                    tmp.append(k.toMap())
                }
                map["AppList"] = tmp
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppList"] as? [Any?] {
                var tmp : [ListMessageAppResponseBody.Result.AppList] = []
                for v in value {
                    if v != nil {
                        var model = ListMessageAppResponseBody.Result.AppList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.appList = tmp
            }
            if let value = dict["HasMore"] as? Bool {
                self.hasMore = value
            }
            if let value = dict["Total"] as? Int32 {
                self.total = value
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListMessageAppResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMessageAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class ListMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class GroupList : Tea.TeaModel {
            public var appId: String?

            public var createTime: Int64?

            public var creatorId: String?

            public var extension_: [String: String]?

            public var groupId: String?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creatorId != nil {
                    map["CreatorId"] = self.creatorId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["CreatorId"] as? String {
                    self.creatorId = value
                }
                if let value = dict["Extension"] as? [String: String] {
                    self.extension_ = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
            }
        }
        public var groupList: [ListMessageGroupResponseBody.Result.GroupList]?

        public var hasMore: Bool?

        public var total: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupList != nil {
                var tmp : [Any] = []
                for k in self.groupList! {
                    tmp.append(k.toMap())
                }
                map["GroupList"] = tmp
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupList"] as? [Any?] {
                var tmp : [ListMessageGroupResponseBody.Result.GroupList] = []
                for v in value {
                    if v != nil {
                        var model = ListMessageGroupResponseBody.Result.GroupList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.groupList = tmp
            }
            if let value = dict["HasMore"] as? Bool {
                self.hasMore = value
            }
            if let value = dict["Total"] as? Int32 {
                self.total = value
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListMessageGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMessageGroupUserRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
    }
}

public class ListMessageGroupUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class UserList : Tea.TeaModel {
            public var joinTime: Int64?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.joinTime != nil {
                    map["JoinTime"] = self.joinTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["JoinTime"] as? Int64 {
                    self.joinTime = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var hasMore: Bool?

        public var total: Int32?

        public var userList: [ListMessageGroupUserResponseBody.Result.UserList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            if self.userList != nil {
                var tmp : [Any] = []
                for k in self.userList! {
                    tmp.append(k.toMap())
                }
                map["UserList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HasMore"] as? Bool {
                self.hasMore = value
            }
            if let value = dict["Total"] as? Int32 {
                self.total = value
            }
            if let value = dict["UserList"] as? [Any?] {
                var tmp : [ListMessageGroupUserResponseBody.Result.UserList] = []
                for v in value {
                    if v != nil {
                        var model = ListMessageGroupUserResponseBody.Result.UserList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.userList = tmp
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageGroupUserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListMessageGroupUserResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListMessageGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMessageGroupUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMessageGroupUserByIdRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var userIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["UserIdList"] as? [String] {
            self.userIdList = value
        }
    }
}

public class ListMessageGroupUserByIdShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var userIdListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.userIdListShrink != nil {
            map["UserIdList"] = self.userIdListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["UserIdList"] as? String {
            self.userIdListShrink = value
        }
    }
}

public class ListMessageGroupUserByIdResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class UserList : Tea.TeaModel {
            public var isMute: Bool?

            public var muteBy: [String]?

            public var userAvatar: String?

            public var userExtension: String?

            public var userId: String?

            public var userNick: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isMute != nil {
                    map["IsMute"] = self.isMute!
                }
                if self.muteBy != nil {
                    map["MuteBy"] = self.muteBy!
                }
                if self.userAvatar != nil {
                    map["UserAvatar"] = self.userAvatar!
                }
                if self.userExtension != nil {
                    map["UserExtension"] = self.userExtension!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userNick != nil {
                    map["UserNick"] = self.userNick!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IsMute"] as? Bool {
                    self.isMute = value
                }
                if let value = dict["MuteBy"] as? [String] {
                    self.muteBy = value
                }
                if let value = dict["UserAvatar"] as? String {
                    self.userAvatar = value
                }
                if let value = dict["UserExtension"] as? String {
                    self.userExtension = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["UserNick"] as? String {
                    self.userNick = value
                }
            }
        }
        public var hasMore: Bool?

        public var total: Int32?

        public var userList: [ListMessageGroupUserByIdResponseBody.Result.UserList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            if self.userList != nil {
                var tmp : [Any] = []
                for k in self.userList! {
                    tmp.append(k.toMap())
                }
                map["UserList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HasMore"] as? Bool {
                self.hasMore = value
            }
            if let value = dict["Total"] as? Int32 {
                self.total = value
            }
            if let value = dict["UserList"] as? [Any?] {
                var tmp : [ListMessageGroupUserByIdResponseBody.Result.UserList] = []
                for v in value {
                    if v != nil {
                        var model = ListMessageGroupUserByIdResponseBody.Result.UserList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.userList = tmp
            }
        }
    }
    public var requestId: String?

    public var result: ListMessageGroupUserByIdResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListMessageGroupUserByIdResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListMessageGroupUserByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMessageGroupUserByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMessageGroupUserByIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListMuteGroupUserRequest : Tea.TeaModel {
    public var appId: String?

    public var groupId: String?

    public var operatorUserId: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListMuteGroupUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class UserList : Tea.TeaModel {
            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var hasMore: Bool?

        public var total: Int32?

        public var userList: [ListMuteGroupUserResponseBody.Result.UserList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            if self.userList != nil {
                var tmp : [Any] = []
                for k in self.userList! {
                    tmp.append(k.toMap())
                }
                map["UserList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HasMore"] as? Bool {
                self.hasMore = value
            }
            if let value = dict["Total"] as? Int32 {
                self.total = value
            }
            if let value = dict["UserList"] as? [Any?] {
                var tmp : [ListMuteGroupUserResponseBody.Result.UserList] = []
                for v in value {
                    if v != nil {
                        var model = ListMuteGroupUserResponseBody.Result.UserList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.userList = tmp
            }
        }
    }
    public var requestId: String?

    public var result: ListMuteGroupUserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListMuteGroupUserResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListMuteGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMuteGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListMuteGroupUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPlaylistRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var page: Int32?

    public var pageSize: Int32?

    public var programId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Page"] as? Int32 {
            self.page = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListPlaylistResponseBody : Tea.TeaModel {
    public class ProgramList : Tea.TeaModel {
        public var casterId: String?

        public var domainName: String?

        public var programId: String?

        public var programName: String?

        public var repeatNumber: Int32?

        public var status: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.casterId != nil {
                map["CasterId"] = self.casterId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.programId != nil {
                map["ProgramId"] = self.programId!
            }
            if self.programName != nil {
                map["ProgramName"] = self.programName!
            }
            if self.repeatNumber != nil {
                map["RepeatNumber"] = self.repeatNumber!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CasterId"] as? String {
                self.casterId = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["ProgramId"] as? String {
                self.programId = value
            }
            if let value = dict["ProgramName"] as? String {
                self.programName = value
            }
            if let value = dict["RepeatNumber"] as? Int32 {
                self.repeatNumber = value
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
        }
    }
    public var programList: [ListPlaylistResponseBody.ProgramList]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programList != nil {
            var tmp : [Any] = []
            for k in self.programList! {
                tmp.append(k.toMap())
            }
            map["ProgramList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProgramList"] as? [Any?] {
            var tmp : [ListPlaylistResponseBody.ProgramList] = []
            for v in value {
                if v != nil {
                    var model = ListPlaylistResponseBody.ProgramList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.programList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class ListPlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPlaylistResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPlaylistItemsRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public var programItemIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.programItemIds != nil {
            map["ProgramItemIds"] = self.programItemIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["ProgramItemIds"] as? String {
            self.programItemIds = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListPlaylistItemsResponseBody : Tea.TeaModel {
    public class ProgramItems : Tea.TeaModel {
        public var index: Int32?

        public var programId: String?

        public var programItemId: String?

        public var programItemName: String?

        public var resourceType: String?

        public var resourceValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.index != nil {
                map["Index"] = self.index!
            }
            if self.programId != nil {
                map["ProgramId"] = self.programId!
            }
            if self.programItemId != nil {
                map["ProgramItemId"] = self.programItemId!
            }
            if self.programItemName != nil {
                map["ProgramItemName"] = self.programItemName!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.resourceValue != nil {
                map["ResourceValue"] = self.resourceValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Index"] as? Int32 {
                self.index = value
            }
            if let value = dict["ProgramId"] as? String {
                self.programId = value
            }
            if let value = dict["ProgramItemId"] as? String {
                self.programItemId = value
            }
            if let value = dict["ProgramItemName"] as? String {
                self.programItemName = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["ResourceValue"] as? String {
                self.resourceValue = value
            }
        }
    }
    public var programItems: [ListPlaylistItemsResponseBody.ProgramItems]?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programItems != nil {
            var tmp : [Any] = []
            for k in self.programItems! {
                tmp.append(k.toMap())
            }
            map["ProgramItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProgramItems"] as? [Any?] {
            var tmp : [ListPlaylistItemsResponseBody.ProgramItems] = []
            for v in value {
                if v != nil {
                    var model = ListPlaylistItemsResponseBody.ProgramItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.programItems = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class ListPlaylistItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPlaylistItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPlaylistItemsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRTCLiveRoomsRequest : Tea.TeaModel {
    public var appId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListRTCLiveRoomsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var rooms: [String]?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rooms != nil {
            map["Rooms"] = self.rooms!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Rooms"] as? [String] {
            self.rooms = value
        }
        if let value = dict["Total"] as? Int32 {
            self.total = value
        }
    }
}

public class ListRTCLiveRoomsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRTCLiveRoomsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRTCLiveRoomsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRtcMPUEventSubRecordRequest : Tea.TeaModel {
    public var appId: String?

    public var endTime: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var subId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.subId != nil {
            map["SubId"] = self.subId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNo"] as? Int32 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["SubId"] as? String {
            self.subId = value
        }
    }
}

public class ListRtcMPUEventSubRecordResponseBody : Tea.TeaModel {
    public class Logs : Tea.TeaModel {
        public var appId: String?

        public var callbackUrl: String?

        public var cost: Int64?

        public var data: String?

        public var HTTPCode: String?

        public var msgId: String?

        public var subId: String?

        public var time: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.callbackUrl != nil {
                map["CallbackUrl"] = self.callbackUrl!
            }
            if self.cost != nil {
                map["Cost"] = self.cost!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.HTTPCode != nil {
                map["HTTPCode"] = self.HTTPCode!
            }
            if self.msgId != nil {
                map["MsgId"] = self.msgId!
            }
            if self.subId != nil {
                map["SubId"] = self.subId!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["CallbackUrl"] as? String {
                self.callbackUrl = value
            }
            if let value = dict["Cost"] as? Int64 {
                self.cost = value
            }
            if let value = dict["Data"] as? String {
                self.data = value
            }
            if let value = dict["HTTPCode"] as? String {
                self.HTTPCode = value
            }
            if let value = dict["MsgId"] as? String {
                self.msgId = value
            }
            if let value = dict["SubId"] as? String {
                self.subId = value
            }
            if let value = dict["Time"] as? String {
                self.time = value
            }
        }
    }
    public var count: Int64?

    public var hasMore: Bool?

    public var logs: [ListRtcMPUEventSubRecordResponseBody.Logs]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.hasMore != nil {
            map["HasMore"] = self.hasMore!
        }
        if self.logs != nil {
            var tmp : [Any] = []
            for k in self.logs! {
                tmp.append(k.toMap())
            }
            map["Logs"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Count"] as? Int64 {
            self.count = value
        }
        if let value = dict["HasMore"] as? Bool {
            self.hasMore = value
        }
        if let value = dict["Logs"] as? [Any?] {
            var tmp : [ListRtcMPUEventSubRecordResponseBody.Logs] = []
            for v in value {
                if v != nil {
                    var model = ListRtcMPUEventSubRecordResponseBody.Logs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.logs = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListRtcMPUEventSubRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRtcMPUEventSubRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRtcMPUEventSubRecordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRtcMPUTaskDetailRequest : Tea.TeaModel {
    public var appId: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["PageNo"] as? Int64 {
            self.pageNo = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class ListRtcMPUTaskDetailResponseBody : Tea.TeaModel {
    public class MPUTasks : Tea.TeaModel {
        public class MultiStreamURL : Tea.TeaModel {
            public var isAliCdn: Bool?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isAliCdn != nil {
                    map["IsAliCdn"] = self.isAliCdn!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IsAliCdn"] as? Bool {
                    self.isAliCdn = value
                }
                if let value = dict["URL"] as? String {
                    self.URL = value
                }
            }
        }
        public class SeiParams : Tea.TeaModel {
            public class LayoutVolume : Tea.TeaModel {
                public var followIdr: String?

                public var interval: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.followIdr != nil {
                        map["FollowIdr"] = self.followIdr!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FollowIdr"] as? String {
                        self.followIdr = value
                    }
                    if let value = dict["Interval"] as? String {
                        self.interval = value
                    }
                }
            }
            public class PassThrough : Tea.TeaModel {
                public var followIdr: String?

                public var interval: String?

                public var payloadContent: String?

                public var payloadContentKey: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.followIdr != nil {
                        map["FollowIdr"] = self.followIdr!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.payloadContent != nil {
                        map["PayloadContent"] = self.payloadContent!
                    }
                    if self.payloadContentKey != nil {
                        map["PayloadContentKey"] = self.payloadContentKey!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["FollowIdr"] as? String {
                        self.followIdr = value
                    }
                    if let value = dict["Interval"] as? String {
                        self.interval = value
                    }
                    if let value = dict["PayloadContent"] as? String {
                        self.payloadContent = value
                    }
                    if let value = dict["PayloadContentKey"] as? String {
                        self.payloadContentKey = value
                    }
                }
            }
            public var layoutVolume: ListRtcMPUTaskDetailResponseBody.MPUTasks.SeiParams.LayoutVolume?

            public var passThrough: ListRtcMPUTaskDetailResponseBody.MPUTasks.SeiParams.PassThrough?

            public var payloadType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.layoutVolume?.validate()
                try self.passThrough?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.layoutVolume != nil {
                    map["LayoutVolume"] = self.layoutVolume?.toMap()
                }
                if self.passThrough != nil {
                    map["PassThrough"] = self.passThrough?.toMap()
                }
                if self.payloadType != nil {
                    map["PayloadType"] = self.payloadType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LayoutVolume"] as? [String: Any?] {
                    var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.SeiParams.LayoutVolume()
                    model.fromMap(value)
                    self.layoutVolume = model
                }
                if let value = dict["PassThrough"] as? [String: Any?] {
                    var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.SeiParams.PassThrough()
                    model.fromMap(value)
                    self.passThrough = model
                }
                if let value = dict["PayloadType"] as? String {
                    self.payloadType = value
                }
            }
        }
        public class SingleSubParams : Tea.TeaModel {
            public var sourceType: String?

            public var streamType: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["StreamType"] as? String {
                    self.streamType = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public class TranscodeParams : Tea.TeaModel {
            public class Background : Tea.TeaModel {
                public var renderMode: String?

                public var URL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.renderMode != nil {
                        map["RenderMode"] = self.renderMode!
                    }
                    if self.URL != nil {
                        map["URL"] = self.URL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RenderMode"] as? String {
                        self.renderMode = value
                    }
                    if let value = dict["URL"] as? String {
                        self.URL = value
                    }
                }
            }
            public class EncodeParams : Tea.TeaModel {
                public var audioBitrate: String?

                public var audioChannels: String?

                public var audioOnly: String?

                public var audioSampleRate: String?

                public var enhancedParam: String?

                public var videoBitrate: String?

                public var videoCodec: String?

                public var videoFramerate: String?

                public var videoGop: String?

                public var videoHeight: String?

                public var videoWidth: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioBitrate != nil {
                        map["AudioBitrate"] = self.audioBitrate!
                    }
                    if self.audioChannels != nil {
                        map["AudioChannels"] = self.audioChannels!
                    }
                    if self.audioOnly != nil {
                        map["AudioOnly"] = self.audioOnly!
                    }
                    if self.audioSampleRate != nil {
                        map["AudioSampleRate"] = self.audioSampleRate!
                    }
                    if self.enhancedParam != nil {
                        map["EnhancedParam"] = self.enhancedParam!
                    }
                    if self.videoBitrate != nil {
                        map["VideoBitrate"] = self.videoBitrate!
                    }
                    if self.videoCodec != nil {
                        map["VideoCodec"] = self.videoCodec!
                    }
                    if self.videoFramerate != nil {
                        map["VideoFramerate"] = self.videoFramerate!
                    }
                    if self.videoGop != nil {
                        map["VideoGop"] = self.videoGop!
                    }
                    if self.videoHeight != nil {
                        map["VideoHeight"] = self.videoHeight!
                    }
                    if self.videoWidth != nil {
                        map["VideoWidth"] = self.videoWidth!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AudioBitrate"] as? String {
                        self.audioBitrate = value
                    }
                    if let value = dict["AudioChannels"] as? String {
                        self.audioChannels = value
                    }
                    if let value = dict["AudioOnly"] as? String {
                        self.audioOnly = value
                    }
                    if let value = dict["AudioSampleRate"] as? String {
                        self.audioSampleRate = value
                    }
                    if let value = dict["EnhancedParam"] as? String {
                        self.enhancedParam = value
                    }
                    if let value = dict["VideoBitrate"] as? String {
                        self.videoBitrate = value
                    }
                    if let value = dict["VideoCodec"] as? String {
                        self.videoCodec = value
                    }
                    if let value = dict["VideoFramerate"] as? String {
                        self.videoFramerate = value
                    }
                    if let value = dict["VideoGop"] as? String {
                        self.videoGop = value
                    }
                    if let value = dict["VideoHeight"] as? String {
                        self.videoHeight = value
                    }
                    if let value = dict["VideoWidth"] as? String {
                        self.videoWidth = value
                    }
                }
            }
            public class Layout : Tea.TeaModel {
                public class UserPanes : Tea.TeaModel {
                    public class UserInfo : Tea.TeaModel {
                        public var channelId: String?

                        public var sourceType: String?

                        public var userId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.channelId != nil {
                                map["ChannelId"] = self.channelId!
                            }
                            if self.sourceType != nil {
                                map["SourceType"] = self.sourceType!
                            }
                            if self.userId != nil {
                                map["UserId"] = self.userId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["ChannelId"] as? String {
                                self.channelId = value
                            }
                            if let value = dict["SourceType"] as? String {
                                self.sourceType = value
                            }
                            if let value = dict["UserId"] as? String {
                                self.userId = value
                            }
                        }
                    }
                    public var backgroundImageUrl: String?

                    public var height: String?

                    public var renderMode: String?

                    public var userInfo: ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.Layout.UserPanes.UserInfo?

                    public var width: String?

                    public var x: String?

                    public var y: String?

                    public var ZOrder: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.userInfo?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.backgroundImageUrl != nil {
                            map["BackgroundImageUrl"] = self.backgroundImageUrl!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.renderMode != nil {
                            map["RenderMode"] = self.renderMode!
                        }
                        if self.userInfo != nil {
                            map["UserInfo"] = self.userInfo?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        if self.x != nil {
                            map["X"] = self.x!
                        }
                        if self.y != nil {
                            map["Y"] = self.y!
                        }
                        if self.ZOrder != nil {
                            map["ZOrder"] = self.ZOrder!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["BackgroundImageUrl"] as? String {
                            self.backgroundImageUrl = value
                        }
                        if let value = dict["Height"] as? String {
                            self.height = value
                        }
                        if let value = dict["RenderMode"] as? String {
                            self.renderMode = value
                        }
                        if let value = dict["UserInfo"] as? [String: Any?] {
                            var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.Layout.UserPanes.UserInfo()
                            model.fromMap(value)
                            self.userInfo = model
                        }
                        if let value = dict["Width"] as? String {
                            self.width = value
                        }
                        if let value = dict["X"] as? String {
                            self.x = value
                        }
                        if let value = dict["Y"] as? String {
                            self.y = value
                        }
                        if let value = dict["ZOrder"] as? String {
                            self.ZOrder = value
                        }
                    }
                }
                public var userPanes: [ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.Layout.UserPanes]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.userPanes != nil {
                        var tmp : [Any] = []
                        for k in self.userPanes! {
                            tmp.append(k.toMap())
                        }
                        map["UserPanes"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["UserPanes"] as? [Any?] {
                        var tmp : [ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.Layout.UserPanes] = []
                        for v in value {
                            if v != nil {
                                var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.Layout.UserPanes()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.userPanes = tmp
                    }
                }
            }
            public class UserInfos : Tea.TeaModel {
                public var channelId: String?

                public var sourceType: String?

                public var streamType: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.sourceType != nil {
                        map["SourceType"] = self.sourceType!
                    }
                    if self.streamType != nil {
                        map["StreamType"] = self.streamType!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ChannelId"] as? String {
                        self.channelId = value
                    }
                    if let value = dict["SourceType"] as? String {
                        self.sourceType = value
                    }
                    if let value = dict["StreamType"] as? String {
                        self.streamType = value
                    }
                    if let value = dict["UserId"] as? String {
                        self.userId = value
                    }
                }
            }
            public var background: ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.Background?

            public var encodeParams: ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.EncodeParams?

            public var layout: ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.Layout?

            public var userInfos: [ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.UserInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.background?.validate()
                try self.encodeParams?.validate()
                try self.layout?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.background != nil {
                    map["Background"] = self.background?.toMap()
                }
                if self.encodeParams != nil {
                    map["EncodeParams"] = self.encodeParams?.toMap()
                }
                if self.layout != nil {
                    map["Layout"] = self.layout?.toMap()
                }
                if self.userInfos != nil {
                    var tmp : [Any] = []
                    for k in self.userInfos! {
                        tmp.append(k.toMap())
                    }
                    map["UserInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Background"] as? [String: Any?] {
                    var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.Background()
                    model.fromMap(value)
                    self.background = model
                }
                if let value = dict["EncodeParams"] as? [String: Any?] {
                    var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.EncodeParams()
                    model.fromMap(value)
                    self.encodeParams = model
                }
                if let value = dict["Layout"] as? [String: Any?] {
                    var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.Layout()
                    model.fromMap(value)
                    self.layout = model
                }
                if let value = dict["UserInfos"] as? [Any?] {
                    var tmp : [ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.UserInfos] = []
                    for v in value {
                        if v != nil {
                            var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams.UserInfos()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.userInfos = tmp
                }
            }
        }
        public var appId: String?

        public var channelId: String?

        public var maxIdleTime: String?

        public var mixMode: String?

        public var multiStreamURL: [ListRtcMPUTaskDetailResponseBody.MPUTasks.MultiStreamURL]?

        public var region: String?

        public var seiParams: ListRtcMPUTaskDetailResponseBody.MPUTasks.SeiParams?

        public var singleSubParams: ListRtcMPUTaskDetailResponseBody.MPUTasks.SingleSubParams?

        public var streamURL: String?

        public var taskId: String?

        public var transcodeParams: ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.seiParams?.validate()
            try self.singleSubParams?.validate()
            try self.transcodeParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.maxIdleTime != nil {
                map["MaxIdleTime"] = self.maxIdleTime!
            }
            if self.mixMode != nil {
                map["MixMode"] = self.mixMode!
            }
            if self.multiStreamURL != nil {
                var tmp : [Any] = []
                for k in self.multiStreamURL! {
                    tmp.append(k.toMap())
                }
                map["MultiStreamURL"] = tmp
            }
            if self.region != nil {
                map["Region"] = self.region!
            }
            if self.seiParams != nil {
                map["SeiParams"] = self.seiParams?.toMap()
            }
            if self.singleSubParams != nil {
                map["SingleSubParams"] = self.singleSubParams?.toMap()
            }
            if self.streamURL != nil {
                map["StreamURL"] = self.streamURL!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.transcodeParams != nil {
                map["TranscodeParams"] = self.transcodeParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["ChannelId"] as? String {
                self.channelId = value
            }
            if let value = dict["MaxIdleTime"] as? String {
                self.maxIdleTime = value
            }
            if let value = dict["MixMode"] as? String {
                self.mixMode = value
            }
            if let value = dict["MultiStreamURL"] as? [Any?] {
                var tmp : [ListRtcMPUTaskDetailResponseBody.MPUTasks.MultiStreamURL] = []
                for v in value {
                    if v != nil {
                        var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.MultiStreamURL()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.multiStreamURL = tmp
            }
            if let value = dict["Region"] as? String {
                self.region = value
            }
            if let value = dict["SeiParams"] as? [String: Any?] {
                var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.SeiParams()
                model.fromMap(value)
                self.seiParams = model
            }
            if let value = dict["SingleSubParams"] as? [String: Any?] {
                var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.SingleSubParams()
                model.fromMap(value)
                self.singleSubParams = model
            }
            if let value = dict["StreamURL"] as? String {
                self.streamURL = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TranscodeParams"] as? [String: Any?] {
                var model = ListRtcMPUTaskDetailResponseBody.MPUTasks.TranscodeParams()
                model.fromMap(value)
                self.transcodeParams = model
            }
        }
    }
    public var MPUTasks: [ListRtcMPUTaskDetailResponseBody.MPUTasks]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.MPUTasks != nil {
            var tmp : [Any] = []
            for k in self.MPUTasks! {
                tmp.append(k.toMap())
            }
            map["MPUTasks"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MPUTasks"] as? [Any?] {
            var tmp : [ListRtcMPUTaskDetailResponseBody.MPUTasks] = []
            for v in value {
                if v != nil {
                    var model = ListRtcMPUTaskDetailResponseBody.MPUTasks()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.MPUTasks = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListRtcMPUTaskDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRtcMPUTaskDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRtcMPUTaskDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class LiveUpstreamQosDataRequest : Tea.TeaModel {
    public var cdnDomains: [String]?

    public var cdnIsps: [String]?

    public var cdnProvinces: [String]?

    public var endTime: String?

    public var kwaiSidcs: [String]?

    public var kwaiTsc: [Int32]?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var startTime: String?

    public var upstreamDomains: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdnDomains != nil {
            map["CdnDomains"] = self.cdnDomains!
        }
        if self.cdnIsps != nil {
            map["CdnIsps"] = self.cdnIsps!
        }
        if self.cdnProvinces != nil {
            map["CdnProvinces"] = self.cdnProvinces!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.kwaiSidcs != nil {
            map["KwaiSidcs"] = self.kwaiSidcs!
        }
        if self.kwaiTsc != nil {
            map["KwaiTsc"] = self.kwaiTsc!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.upstreamDomains != nil {
            map["UpstreamDomains"] = self.upstreamDomains!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CdnDomains"] as? [String] {
            self.cdnDomains = value
        }
        if let value = dict["CdnIsps"] as? [String] {
            self.cdnIsps = value
        }
        if let value = dict["CdnProvinces"] as? [String] {
            self.cdnProvinces = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["KwaiSidcs"] as? [String] {
            self.kwaiSidcs = value
        }
        if let value = dict["KwaiTsc"] as? [Int32] {
            self.kwaiTsc = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["UpstreamDomains"] as? [String] {
            self.upstreamDomains = value
        }
    }
}

public class LiveUpstreamQosDataShrinkRequest : Tea.TeaModel {
    public var cdnDomainsShrink: String?

    public var cdnIspsShrink: String?

    public var cdnProvincesShrink: String?

    public var endTime: String?

    public var kwaiSidcsShrink: String?

    public var kwaiTscShrink: String?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var startTime: String?

    public var upstreamDomainsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cdnDomainsShrink != nil {
            map["CdnDomains"] = self.cdnDomainsShrink!
        }
        if self.cdnIspsShrink != nil {
            map["CdnIsps"] = self.cdnIspsShrink!
        }
        if self.cdnProvincesShrink != nil {
            map["CdnProvinces"] = self.cdnProvincesShrink!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.kwaiSidcsShrink != nil {
            map["KwaiSidcs"] = self.kwaiSidcsShrink!
        }
        if self.kwaiTscShrink != nil {
            map["KwaiTsc"] = self.kwaiTscShrink!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.upstreamDomainsShrink != nil {
            map["UpstreamDomains"] = self.upstreamDomainsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CdnDomains"] as? String {
            self.cdnDomainsShrink = value
        }
        if let value = dict["CdnIsps"] as? String {
            self.cdnIspsShrink = value
        }
        if let value = dict["CdnProvinces"] as? String {
            self.cdnProvincesShrink = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["KwaiSidcs"] as? String {
            self.kwaiSidcsShrink = value
        }
        if let value = dict["KwaiTsc"] as? String {
            self.kwaiTscShrink = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["UpstreamDomains"] as? String {
            self.upstreamDomainsShrink = value
        }
    }
}

public class LiveUpstreamQosDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DetailData : Tea.TeaModel {
            public var connectDur: Int64?

            public var connectFailedCount: Int64?

            public var count: Int64?

            public var firstDataDur: Int64?

            public var firstDataFailedCount: Int64?

            public var firstFrameDur: Int64?

            public var firstFrameSuccessCount: Int64?

            public var statusCode2Xx: Int64?

            public var statusCode3Xx: Int64?

            public var statusCode4Xx: Int64?

            public var statusCode5Xx: Int64?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectDur != nil {
                    map["ConnectDur"] = self.connectDur!
                }
                if self.connectFailedCount != nil {
                    map["ConnectFailedCount"] = self.connectFailedCount!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.firstDataDur != nil {
                    map["FirstDataDur"] = self.firstDataDur!
                }
                if self.firstDataFailedCount != nil {
                    map["FirstDataFailedCount"] = self.firstDataFailedCount!
                }
                if self.firstFrameDur != nil {
                    map["FirstFrameDur"] = self.firstFrameDur!
                }
                if self.firstFrameSuccessCount != nil {
                    map["FirstFrameSuccessCount"] = self.firstFrameSuccessCount!
                }
                if self.statusCode2Xx != nil {
                    map["StatusCode2Xx"] = self.statusCode2Xx!
                }
                if self.statusCode3Xx != nil {
                    map["StatusCode3Xx"] = self.statusCode3Xx!
                }
                if self.statusCode4Xx != nil {
                    map["StatusCode4Xx"] = self.statusCode4Xx!
                }
                if self.statusCode5Xx != nil {
                    map["StatusCode5Xx"] = self.statusCode5Xx!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConnectDur"] as? Int64 {
                    self.connectDur = value
                }
                if let value = dict["ConnectFailedCount"] as? Int64 {
                    self.connectFailedCount = value
                }
                if let value = dict["Count"] as? Int64 {
                    self.count = value
                }
                if let value = dict["FirstDataDur"] as? Int64 {
                    self.firstDataDur = value
                }
                if let value = dict["FirstDataFailedCount"] as? Int64 {
                    self.firstDataFailedCount = value
                }
                if let value = dict["FirstFrameDur"] as? Int64 {
                    self.firstFrameDur = value
                }
                if let value = dict["FirstFrameSuccessCount"] as? Int64 {
                    self.firstFrameSuccessCount = value
                }
                if let value = dict["StatusCode2Xx"] as? Int64 {
                    self.statusCode2Xx = value
                }
                if let value = dict["StatusCode3Xx"] as? Int64 {
                    self.statusCode3Xx = value
                }
                if let value = dict["StatusCode4Xx"] as? Int64 {
                    self.statusCode4Xx = value
                }
                if let value = dict["StatusCode5Xx"] as? Int64 {
                    self.statusCode5Xx = value
                }
                if let value = dict["Timestamp"] as? String {
                    self.timestamp = value
                }
            }
        }
        public var cdnDomain: String?

        public var cdnIsp: String?

        public var cdnOcid: String?

        public var cdnProvince: String?

        public var detailData: [LiveUpstreamQosDataResponseBody.Data.DetailData]?

        public var kwaiSidc: String?

        public var kwaiTsc: Int64?

        public var upstreamDomain: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cdnDomain != nil {
                map["CdnDomain"] = self.cdnDomain!
            }
            if self.cdnIsp != nil {
                map["CdnIsp"] = self.cdnIsp!
            }
            if self.cdnOcid != nil {
                map["CdnOcid"] = self.cdnOcid!
            }
            if self.cdnProvince != nil {
                map["CdnProvince"] = self.cdnProvince!
            }
            if self.detailData != nil {
                var tmp : [Any] = []
                for k in self.detailData! {
                    tmp.append(k.toMap())
                }
                map["DetailData"] = tmp
            }
            if self.kwaiSidc != nil {
                map["KwaiSidc"] = self.kwaiSidc!
            }
            if self.kwaiTsc != nil {
                map["KwaiTsc"] = self.kwaiTsc!
            }
            if self.upstreamDomain != nil {
                map["UpstreamDomain"] = self.upstreamDomain!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CdnDomain"] as? String {
                self.cdnDomain = value
            }
            if let value = dict["CdnIsp"] as? String {
                self.cdnIsp = value
            }
            if let value = dict["CdnOcid"] as? String {
                self.cdnOcid = value
            }
            if let value = dict["CdnProvince"] as? String {
                self.cdnProvince = value
            }
            if let value = dict["DetailData"] as? [Any?] {
                var tmp : [LiveUpstreamQosDataResponseBody.Data.DetailData] = []
                for v in value {
                    if v != nil {
                        var model = LiveUpstreamQosDataResponseBody.Data.DetailData()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.detailData = tmp
            }
            if let value = dict["KwaiSidc"] as? String {
                self.kwaiSidc = value
            }
            if let value = dict["KwaiTsc"] as? Int64 {
                self.kwaiTsc = value
            }
            if let value = dict["UpstreamDomain"] as? String {
                self.upstreamDomain = value
            }
        }
    }
    public var data: [LiveUpstreamQosDataResponseBody.Data]?

    public var endTime: String?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [LiveUpstreamQosDataResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = LiveUpstreamQosDataResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class LiveUpstreamQosDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LiveUpstreamQosDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = LiveUpstreamQosDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MiguLivePullToPushStartRequest : Tea.TeaModel {
    public var domainName: String?

    public var miguData: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.miguData != nil {
            map["MiguData"] = self.miguData!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["MiguData"] as? String {
            self.miguData = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class MiguLivePullToPushStartResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["code"] as? String {
            self.code = value
        }
        if let value = dict["message"] as? String {
            self.message = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["timestamp"] as? String {
            self.timestamp = value
        }
    }
}

public class MiguLivePullToPushStartResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MiguLivePullToPushStartResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MiguLivePullToPushStartResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MiguLivePullToPushStatusRequest : Tea.TeaModel {
    public var domainName: String?

    public var miguData: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.miguData != nil {
            map["MiguData"] = self.miguData!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["MiguData"] as? String {
            self.miguData = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class MiguLivePullToPushStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
        }
    }
    public var code: String?

    public var data: MiguLivePullToPushStatusResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.data != nil {
            map["data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["code"] as? String {
            self.code = value
        }
        if let value = dict["data"] as? [String: Any?] {
            var model = MiguLivePullToPushStatusResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["message"] as? String {
            self.message = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["timestamp"] as? String {
            self.timestamp = value
        }
    }
}

public class MiguLivePullToPushStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MiguLivePullToPushStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MiguLivePullToPushStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCasterComponentRequest : Tea.TeaModel {
    public var captionLayerContent: String?

    public var casterId: String?

    public var componentId: String?

    public var componentLayer: String?

    public var componentName: String?

    public var componentType: String?

    public var effect: String?

    public var imageLayerContent: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var textLayerContent: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.captionLayerContent != nil {
            map["CaptionLayerContent"] = self.captionLayerContent!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.componentLayer != nil {
            map["ComponentLayer"] = self.componentLayer!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.componentType != nil {
            map["ComponentType"] = self.componentType!
        }
        if self.effect != nil {
            map["Effect"] = self.effect!
        }
        if self.imageLayerContent != nil {
            map["ImageLayerContent"] = self.imageLayerContent!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.textLayerContent != nil {
            map["TextLayerContent"] = self.textLayerContent!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CaptionLayerContent"] as? String {
            self.captionLayerContent = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ComponentId"] as? String {
            self.componentId = value
        }
        if let value = dict["ComponentLayer"] as? String {
            self.componentLayer = value
        }
        if let value = dict["ComponentName"] as? String {
            self.componentName = value
        }
        if let value = dict["ComponentType"] as? String {
            self.componentType = value
        }
        if let value = dict["Effect"] as? String {
            self.effect = value
        }
        if let value = dict["ImageLayerContent"] as? String {
            self.imageLayerContent = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TextLayerContent"] as? String {
            self.textLayerContent = value
        }
    }
}

public class ModifyCasterComponentResponseBody : Tea.TeaModel {
    public var componentId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComponentId"] as? String {
            self.componentId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCasterComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCasterComponentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCasterEpisodeRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: [String]?

    public var endTime: String?

    public var episodeId: String?

    public var episodeName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var startTime: String?

    public var switchType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.episodeName != nil {
            map["EpisodeName"] = self.episodeName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.switchType != nil {
            map["SwitchType"] = self.switchType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ComponentId"] as? [String] {
            self.componentId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["EpisodeId"] as? String {
            self.episodeId = value
        }
        if let value = dict["EpisodeName"] as? String {
            self.episodeName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["SwitchType"] as? String {
            self.switchType = value
        }
    }
}

public class ModifyCasterEpisodeResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var episodeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episodeId != nil {
            map["EpisodeId"] = self.episodeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["EpisodeId"] as? String {
            self.episodeId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCasterEpisodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterEpisodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCasterEpisodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCasterLayoutRequest : Tea.TeaModel {
    public class AudioLayer : Tea.TeaModel {
        public var fixedDelayDuration: Int32?

        public var validChannel: String?

        public var volumeRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.validChannel != nil {
                map["ValidChannel"] = self.validChannel!
            }
            if self.volumeRate != nil {
                map["VolumeRate"] = self.volumeRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FixedDelayDuration"] as? Int32 {
                self.fixedDelayDuration = value
            }
            if let value = dict["ValidChannel"] as? String {
                self.validChannel = value
            }
            if let value = dict["VolumeRate"] as? Double {
                self.volumeRate = value
            }
        }
    }
    public class VideoLayer : Tea.TeaModel {
        public var fillMode: String?

        public var fixedDelayDuration: Int32?

        public var heightNormalized: Double?

        public var positionNormalized: [Double]?

        public var positionRefer: String?

        public var widthNormalized: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fillMode != nil {
                map["FillMode"] = self.fillMode!
            }
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.heightNormalized != nil {
                map["HeightNormalized"] = self.heightNormalized!
            }
            if self.positionNormalized != nil {
                map["PositionNormalized"] = self.positionNormalized!
            }
            if self.positionRefer != nil {
                map["PositionRefer"] = self.positionRefer!
            }
            if self.widthNormalized != nil {
                map["WidthNormalized"] = self.widthNormalized!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FillMode"] as? String {
                self.fillMode = value
            }
            if let value = dict["FixedDelayDuration"] as? Int32 {
                self.fixedDelayDuration = value
            }
            if let value = dict["HeightNormalized"] as? Double {
                self.heightNormalized = value
            }
            if let value = dict["PositionNormalized"] as? [Double] {
                self.positionNormalized = value
            }
            if let value = dict["PositionRefer"] as? String {
                self.positionRefer = value
            }
            if let value = dict["WidthNormalized"] as? Double {
                self.widthNormalized = value
            }
        }
    }
    public var audioLayer: [ModifyCasterLayoutRequest.AudioLayer]?

    public var blendList: [String]?

    public var casterId: String?

    public var layoutId: String?

    public var mixList: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var videoLayer: [ModifyCasterLayoutRequest.VideoLayer]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioLayer != nil {
            var tmp : [Any] = []
            for k in self.audioLayer! {
                tmp.append(k.toMap())
            }
            map["AudioLayer"] = tmp
        }
        if self.blendList != nil {
            map["BlendList"] = self.blendList!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.mixList != nil {
            map["MixList"] = self.mixList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.videoLayer != nil {
            var tmp : [Any] = []
            for k in self.videoLayer! {
                tmp.append(k.toMap())
            }
            map["VideoLayer"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AudioLayer"] as? [Any?] {
            var tmp : [ModifyCasterLayoutRequest.AudioLayer] = []
            for v in value {
                if v != nil {
                    var model = ModifyCasterLayoutRequest.AudioLayer()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.audioLayer = tmp
        }
        if let value = dict["BlendList"] as? [String] {
            self.blendList = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["MixList"] as? [String] {
            self.mixList = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VideoLayer"] as? [Any?] {
            var tmp : [ModifyCasterLayoutRequest.VideoLayer] = []
            for v in value {
                if v != nil {
                    var model = ModifyCasterLayoutRequest.VideoLayer()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.videoLayer = tmp
        }
    }
}

public class ModifyCasterLayoutResponseBody : Tea.TeaModel {
    public var layoutId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCasterLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCasterLayoutResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCasterProgramRequest : Tea.TeaModel {
    public class Episode : Tea.TeaModel {
        public var componentId: [String]?

        public var endTime: String?

        public var episodeId: String?

        public var episodeName: String?

        public var episodeType: String?

        public var resourceId: String?

        public var startTime: String?

        public var switchType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentId != nil {
                map["ComponentId"] = self.componentId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.episodeId != nil {
                map["EpisodeId"] = self.episodeId!
            }
            if self.episodeName != nil {
                map["EpisodeName"] = self.episodeName!
            }
            if self.episodeType != nil {
                map["EpisodeType"] = self.episodeType!
            }
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.switchType != nil {
                map["SwitchType"] = self.switchType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComponentId"] as? [String] {
                self.componentId = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["EpisodeId"] as? String {
                self.episodeId = value
            }
            if let value = dict["EpisodeName"] as? String {
                self.episodeName = value
            }
            if let value = dict["EpisodeType"] as? String {
                self.episodeType = value
            }
            if let value = dict["ResourceId"] as? String {
                self.resourceId = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["SwitchType"] as? String {
                self.switchType = value
            }
        }
    }
    public var casterId: String?

    public var episode: [ModifyCasterProgramRequest.Episode]?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.episode != nil {
            var tmp : [Any] = []
            for k in self.episode! {
                tmp.append(k.toMap())
            }
            map["Episode"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["Episode"] as? [Any?] {
            var tmp : [ModifyCasterProgramRequest.Episode] = []
            for v in value {
                if v != nil {
                    var model = ModifyCasterProgramRequest.Episode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.episode = tmp
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyCasterProgramResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCasterProgramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterProgramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCasterProgramResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCasterVideoResourceRequest : Tea.TeaModel {
    public var beginOffset: Int32?

    public var casterId: String?

    public var endOffset: Int32?

    public var imageId: String?

    public var imageUrl: String?

    public var liveStreamUrl: String?

    public var materialId: String?

    public var ownerId: Int64?

    public var ptsCallbackInterval: Int32?

    public var regionId: String?

    public var repeatNum: Int32?

    public var resourceId: String?

    public var resourceName: String?

    public var vodUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginOffset != nil {
            map["BeginOffset"] = self.beginOffset!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.endOffset != nil {
            map["EndOffset"] = self.endOffset!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.liveStreamUrl != nil {
            map["LiveStreamUrl"] = self.liveStreamUrl!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ptsCallbackInterval != nil {
            map["PtsCallbackInterval"] = self.ptsCallbackInterval!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatNum != nil {
            map["RepeatNum"] = self.repeatNum!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceName != nil {
            map["ResourceName"] = self.resourceName!
        }
        if self.vodUrl != nil {
            map["VodUrl"] = self.vodUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BeginOffset"] as? Int32 {
            self.beginOffset = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["EndOffset"] as? Int32 {
            self.endOffset = value
        }
        if let value = dict["ImageId"] as? String {
            self.imageId = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["LiveStreamUrl"] as? String {
            self.liveStreamUrl = value
        }
        if let value = dict["MaterialId"] as? String {
            self.materialId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PtsCallbackInterval"] as? Int32 {
            self.ptsCallbackInterval = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatNum"] as? Int32 {
            self.repeatNum = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceName"] as? String {
            self.resourceName = value
        }
        if let value = dict["VodUrl"] as? String {
            self.vodUrl = value
        }
    }
}

public class ModifyCasterVideoResourceResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
    }
}

public class ModifyCasterVideoResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCasterVideoResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCasterVideoResourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLiveAIStudioRequest : Tea.TeaModel {
    public class MattingLayout : Tea.TeaModel {
        public var heightNormalized: Double?

        public var positionX: Double?

        public var positionY: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.heightNormalized != nil {
                map["HeightNormalized"] = self.heightNormalized!
            }
            if self.positionX != nil {
                map["PositionX"] = self.positionX!
            }
            if self.positionY != nil {
                map["PositionY"] = self.positionY!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HeightNormalized"] as? Double {
                self.heightNormalized = value
            }
            if let value = dict["PositionX"] as? Double {
                self.positionX = value
            }
            if let value = dict["PositionY"] as? Double {
                self.positionY = value
            }
        }
    }
    public class MediaLayout : Tea.TeaModel {
        public var heightNormalized: Double?

        public var positionX: Double?

        public var positionY: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.heightNormalized != nil {
                map["HeightNormalized"] = self.heightNormalized!
            }
            if self.positionX != nil {
                map["PositionX"] = self.positionX!
            }
            if self.positionY != nil {
                map["PositionY"] = self.positionY!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HeightNormalized"] as? Double {
                self.heightNormalized = value
            }
            if let value = dict["PositionX"] as? Double {
                self.positionX = value
            }
            if let value = dict["PositionY"] as? Double {
                self.positionY = value
            }
        }
    }
    public var backgroundResourceId: String?

    public var backgroundResourceUrl: String?

    public var backgroundType: String?

    public var description_: String?

    public var height: Int32?

    public var mattingLayout: ModifyLiveAIStudioRequest.MattingLayout?

    public var mattingType: String?

    public var mediaLayout: ModifyLiveAIStudioRequest.MediaLayout?

    public var mediaResourceId: String?

    public var mediaResourceUrl: String?

    public var mediaType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var studioName: String?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mattingLayout?.validate()
        try self.mediaLayout?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundResourceId != nil {
            map["BackgroundResourceId"] = self.backgroundResourceId!
        }
        if self.backgroundResourceUrl != nil {
            map["BackgroundResourceUrl"] = self.backgroundResourceUrl!
        }
        if self.backgroundType != nil {
            map["BackgroundType"] = self.backgroundType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.mattingLayout != nil {
            map["MattingLayout"] = self.mattingLayout?.toMap()
        }
        if self.mattingType != nil {
            map["MattingType"] = self.mattingType!
        }
        if self.mediaLayout != nil {
            map["MediaLayout"] = self.mediaLayout?.toMap()
        }
        if self.mediaResourceId != nil {
            map["MediaResourceId"] = self.mediaResourceId!
        }
        if self.mediaResourceUrl != nil {
            map["MediaResourceUrl"] = self.mediaResourceUrl!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.studioName != nil {
            map["StudioName"] = self.studioName!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackgroundResourceId"] as? String {
            self.backgroundResourceId = value
        }
        if let value = dict["BackgroundResourceUrl"] as? String {
            self.backgroundResourceUrl = value
        }
        if let value = dict["BackgroundType"] as? String {
            self.backgroundType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["MattingLayout"] as? [String: Any?] {
            var model = ModifyLiveAIStudioRequest.MattingLayout()
            model.fromMap(value)
            self.mattingLayout = model
        }
        if let value = dict["MattingType"] as? String {
            self.mattingType = value
        }
        if let value = dict["MediaLayout"] as? [String: Any?] {
            var model = ModifyLiveAIStudioRequest.MediaLayout()
            model.fromMap(value)
            self.mediaLayout = model
        }
        if let value = dict["MediaResourceId"] as? String {
            self.mediaResourceId = value
        }
        if let value = dict["MediaResourceUrl"] as? String {
            self.mediaResourceUrl = value
        }
        if let value = dict["MediaType"] as? String {
            self.mediaType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StudioName"] as? String {
            self.studioName = value
        }
        if let value = dict["Width"] as? Int32 {
            self.width = value
        }
    }
}

public class ModifyLiveAIStudioShrinkRequest : Tea.TeaModel {
    public var backgroundResourceId: String?

    public var backgroundResourceUrl: String?

    public var backgroundType: String?

    public var description_: String?

    public var height: Int32?

    public var mattingLayoutShrink: String?

    public var mattingType: String?

    public var mediaLayoutShrink: String?

    public var mediaResourceId: String?

    public var mediaResourceUrl: String?

    public var mediaType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var studioName: String?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backgroundResourceId != nil {
            map["BackgroundResourceId"] = self.backgroundResourceId!
        }
        if self.backgroundResourceUrl != nil {
            map["BackgroundResourceUrl"] = self.backgroundResourceUrl!
        }
        if self.backgroundType != nil {
            map["BackgroundType"] = self.backgroundType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.mattingLayoutShrink != nil {
            map["MattingLayout"] = self.mattingLayoutShrink!
        }
        if self.mattingType != nil {
            map["MattingType"] = self.mattingType!
        }
        if self.mediaLayoutShrink != nil {
            map["MediaLayout"] = self.mediaLayoutShrink!
        }
        if self.mediaResourceId != nil {
            map["MediaResourceId"] = self.mediaResourceId!
        }
        if self.mediaResourceUrl != nil {
            map["MediaResourceUrl"] = self.mediaResourceUrl!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.studioName != nil {
            map["StudioName"] = self.studioName!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackgroundResourceId"] as? String {
            self.backgroundResourceId = value
        }
        if let value = dict["BackgroundResourceUrl"] as? String {
            self.backgroundResourceUrl = value
        }
        if let value = dict["BackgroundType"] as? String {
            self.backgroundType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["MattingLayout"] as? String {
            self.mattingLayoutShrink = value
        }
        if let value = dict["MattingType"] as? String {
            self.mattingType = value
        }
        if let value = dict["MediaLayout"] as? String {
            self.mediaLayoutShrink = value
        }
        if let value = dict["MediaResourceId"] as? String {
            self.mediaResourceId = value
        }
        if let value = dict["MediaResourceUrl"] as? String {
            self.mediaResourceUrl = value
        }
        if let value = dict["MediaType"] as? String {
            self.mediaType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StudioName"] as? String {
            self.studioName = value
        }
        if let value = dict["Width"] as? Int32 {
            self.width = value
        }
    }
}

public class ModifyLiveAIStudioResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLiveAIStudioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveAIStudioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLiveAIStudioResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLiveDomainSchdmByPropertyRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var property: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.property != nil {
            map["Property"] = self.property!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Property"] as? String {
            self.property = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyLiveDomainSchdmByPropertyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLiveDomainSchdmByPropertyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveDomainSchdmByPropertyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLiveDomainSchdmByPropertyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLiveMessageAppAuditRequest : Tea.TeaModel {
    public var appId: String?

    public var auditType: Int32?

    public var auditUrl: String?

    public var dataCenter: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.auditType != nil {
            map["AuditType"] = self.auditType!
        }
        if self.auditUrl != nil {
            map["AuditUrl"] = self.auditUrl!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AuditType"] as? Int32 {
            self.auditType = value
        }
        if let value = dict["AuditUrl"] as? String {
            self.auditUrl = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
    }
}

public class ModifyLiveMessageAppAuditResponseBody : Tea.TeaModel {
    public var appId: String?

    public var appSign: String?

    public var auditNeedAuthentication: Bool?

    public var auditType: Int32?

    public var auditUrl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appSign != nil {
            map["AppSign"] = self.appSign!
        }
        if self.auditNeedAuthentication != nil {
            map["AuditNeedAuthentication"] = self.auditNeedAuthentication!
        }
        if self.auditType != nil {
            map["AuditType"] = self.auditType!
        }
        if self.auditUrl != nil {
            map["AuditUrl"] = self.auditUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppSign"] as? String {
            self.appSign = value
        }
        if let value = dict["AuditNeedAuthentication"] as? Bool {
            self.auditNeedAuthentication = value
        }
        if let value = dict["AuditType"] as? Int32 {
            self.auditType = value
        }
        if let value = dict["AuditUrl"] as? String {
            self.auditUrl = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLiveMessageAppAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveMessageAppAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLiveMessageAppAuditResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLiveMessageAppCallbackRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var eventCallbackUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.eventCallbackUrl != nil {
            map["EventCallbackUrl"] = self.eventCallbackUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["EventCallbackUrl"] as? String {
            self.eventCallbackUrl = value
        }
    }
}

public class ModifyLiveMessageAppCallbackResponseBody : Tea.TeaModel {
    public var appId: String?

    public var appSign: String?

    public var eventCallbackNeedAuthentication: Bool?

    public var eventCallbackUrl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appSign != nil {
            map["AppSign"] = self.appSign!
        }
        if self.eventCallbackNeedAuthentication != nil {
            map["EventCallbackNeedAuthentication"] = self.eventCallbackNeedAuthentication!
        }
        if self.eventCallbackUrl != nil {
            map["EventCallbackUrl"] = self.eventCallbackUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppSign"] as? String {
            self.appSign = value
        }
        if let value = dict["EventCallbackNeedAuthentication"] as? Bool {
            self.eventCallbackNeedAuthentication = value
        }
        if let value = dict["EventCallbackUrl"] as? String {
            self.eventCallbackUrl = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLiveMessageAppCallbackResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveMessageAppCallbackResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLiveMessageAppCallbackResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLiveMessageAppDisableRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var disable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.disable != nil {
            map["Disable"] = self.disable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["Disable"] as? Bool {
            self.disable = value
        }
    }
}

public class ModifyLiveMessageAppDisableResponseBody : Tea.TeaModel {
    public var appId: String?

    public var appSign: String?

    public var disable: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appSign != nil {
            map["AppSign"] = self.appSign!
        }
        if self.disable != nil {
            map["Disable"] = self.disable!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppSign"] as? String {
            self.appSign = value
        }
        if let value = dict["Disable"] as? Bool {
            self.disable = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLiveMessageAppDisableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveMessageAppDisableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLiveMessageAppDisableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLiveMessageGroupRequest : Tea.TeaModel {
    public var adminList: [String]?

    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var groupInfo: String?

    public var modifyAdmin: Bool?

    public var modifyInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminList != nil {
            map["AdminList"] = self.adminList!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupInfo != nil {
            map["GroupInfo"] = self.groupInfo!
        }
        if self.modifyAdmin != nil {
            map["ModifyAdmin"] = self.modifyAdmin!
        }
        if self.modifyInfo != nil {
            map["ModifyInfo"] = self.modifyInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdminList"] as? [String] {
            self.adminList = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupInfo"] as? String {
            self.groupInfo = value
        }
        if let value = dict["ModifyAdmin"] as? Bool {
            self.modifyAdmin = value
        }
        if let value = dict["ModifyInfo"] as? Bool {
            self.modifyInfo = value
        }
    }
}

public class ModifyLiveMessageGroupShrinkRequest : Tea.TeaModel {
    public var adminListShrink: String?

    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var groupInfo: String?

    public var modifyAdmin: Bool?

    public var modifyInfo: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminListShrink != nil {
            map["AdminList"] = self.adminListShrink!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupInfo != nil {
            map["GroupInfo"] = self.groupInfo!
        }
        if self.modifyAdmin != nil {
            map["ModifyAdmin"] = self.modifyAdmin!
        }
        if self.modifyInfo != nil {
            map["ModifyInfo"] = self.modifyInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdminList"] as? String {
            self.adminListShrink = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupInfo"] as? String {
            self.groupInfo = value
        }
        if let value = dict["ModifyAdmin"] as? Bool {
            self.modifyAdmin = value
        }
        if let value = dict["ModifyInfo"] as? Bool {
            self.modifyInfo = value
        }
    }
}

public class ModifyLiveMessageGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLiveMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLiveMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLiveMessageGroupBandRequest : Tea.TeaModel {
    public var appId: String?

    public var bannedAll: Bool?

    public var bannnedUsers: [String]?

    public var dataCenter: String?

    public var exceptUsers: [String]?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bannedAll != nil {
            map["BannedAll"] = self.bannedAll!
        }
        if self.bannnedUsers != nil {
            map["BannnedUsers"] = self.bannnedUsers!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.exceptUsers != nil {
            map["ExceptUsers"] = self.exceptUsers!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BannedAll"] as? Bool {
            self.bannedAll = value
        }
        if let value = dict["BannnedUsers"] as? [String] {
            self.bannnedUsers = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["ExceptUsers"] as? [String] {
            self.exceptUsers = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class ModifyLiveMessageGroupBandShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var bannedAll: Bool?

    public var bannnedUsersShrink: String?

    public var dataCenter: String?

    public var exceptUsersShrink: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.bannedAll != nil {
            map["BannedAll"] = self.bannedAll!
        }
        if self.bannnedUsersShrink != nil {
            map["BannnedUsers"] = self.bannnedUsersShrink!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.exceptUsersShrink != nil {
            map["ExceptUsers"] = self.exceptUsersShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BannedAll"] as? Bool {
            self.bannedAll = value
        }
        if let value = dict["BannnedUsers"] as? String {
            self.bannnedUsersShrink = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["ExceptUsers"] as? String {
            self.exceptUsersShrink = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class ModifyLiveMessageGroupBandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLiveMessageGroupBandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveMessageGroupBandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLiveMessageGroupBandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLiveMessageUserInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var userId: String?

    public var userMetaInfo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.userMetaInfo != nil {
            map["UserMetaInfo"] = self.userMetaInfo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
        if let value = dict["UserMetaInfo"] as? String {
            self.userMetaInfo = value
        }
    }
}

public class ModifyLiveMessageUserInfoResponseBody : Tea.TeaModel {
    public class FailList : Tea.TeaModel {
        public var code: Int32?

        public var groupId: String?

        public var reason: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Code"] as? Int32 {
                self.code = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["Reason"] as? String {
                self.reason = value
            }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public class SuccessList : Tea.TeaModel {
        public var groupId: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var failList: [ModifyLiveMessageUserInfoResponseBody.FailList]?

    public var requestId: String?

    public var successList: [ModifyLiveMessageUserInfoResponseBody.SuccessList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failList != nil {
            var tmp : [Any] = []
            for k in self.failList! {
                tmp.append(k.toMap())
            }
            map["FailList"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successList != nil {
            var tmp : [Any] = []
            for k in self.successList! {
                tmp.append(k.toMap())
            }
            map["SuccessList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailList"] as? [Any?] {
            var tmp : [ModifyLiveMessageUserInfoResponseBody.FailList] = []
            for v in value {
                if v != nil {
                    var model = ModifyLiveMessageUserInfoResponseBody.FailList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.failList = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessList"] as? [Any?] {
            var tmp : [ModifyLiveMessageUserInfoResponseBody.SuccessList] = []
            for v in value {
                if v != nil {
                    var model = ModifyLiveMessageUserInfoResponseBody.SuccessList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.successList = tmp
        }
    }
}

public class ModifyLiveMessageUserInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveMessageUserInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLiveMessageUserInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLiveRealtimeLogDeliveryRequest : Tea.TeaModel {
    public var domainName: String?

    public var logstore: String?

    public var ownerId: Int64?

    public var project: String?

    public var region: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.logstore != nil {
            map["Logstore"] = self.logstore!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Logstore"] as? String {
            self.logstore = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Project"] as? String {
            self.project = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyLiveRealtimeLogDeliveryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLiveRealtimeLogDeliveryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLiveRealtimeLogDeliveryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLiveRealtimeLogDeliveryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyShowListRequest : Tea.TeaModel {
    public var casterId: String?

    public var highPriorityShowId: String?

    public var highPriorityShowStartTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var repeatTimes: Int32?

    public var showId: String?

    public var spot: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.highPriorityShowId != nil {
            map["HighPriorityShowId"] = self.highPriorityShowId!
        }
        if self.highPriorityShowStartTime != nil {
            map["HighPriorityShowStartTime"] = self.highPriorityShowStartTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatTimes != nil {
            map["RepeatTimes"] = self.repeatTimes!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.spot != nil {
            map["Spot"] = self.spot!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["HighPriorityShowId"] as? String {
            self.highPriorityShowId = value
        }
        if let value = dict["HighPriorityShowStartTime"] as? String {
            self.highPriorityShowStartTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatTimes"] as? Int32 {
            self.repeatTimes = value
        }
        if let value = dict["ShowId"] as? String {
            self.showId = value
        }
        if let value = dict["Spot"] as? Int32 {
            self.spot = value
        }
    }
}

public class ModifyShowListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyShowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyShowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyShowListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyStudioLayoutRequest : Tea.TeaModel {
    public var bgImageConfig: String?

    public var casterId: String?

    public var commonConfig: String?

    public var layerOrderConfigList: String?

    public var layoutId: String?

    public var layoutName: String?

    public var mediaInputConfigList: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var screenInputConfigList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgImageConfig != nil {
            map["BgImageConfig"] = self.bgImageConfig!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.commonConfig != nil {
            map["CommonConfig"] = self.commonConfig!
        }
        if self.layerOrderConfigList != nil {
            map["LayerOrderConfigList"] = self.layerOrderConfigList!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.layoutName != nil {
            map["LayoutName"] = self.layoutName!
        }
        if self.mediaInputConfigList != nil {
            map["MediaInputConfigList"] = self.mediaInputConfigList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.screenInputConfigList != nil {
            map["ScreenInputConfigList"] = self.screenInputConfigList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgImageConfig"] as? String {
            self.bgImageConfig = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["CommonConfig"] as? String {
            self.commonConfig = value
        }
        if let value = dict["LayerOrderConfigList"] as? String {
            self.layerOrderConfigList = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["LayoutName"] as? String {
            self.layoutName = value
        }
        if let value = dict["MediaInputConfigList"] as? String {
            self.mediaInputConfigList = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ScreenInputConfigList"] as? String {
            self.screenInputConfigList = value
        }
    }
}

public class ModifyStudioLayoutResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyStudioLayoutResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStudioLayoutResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyStudioLayoutResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MuteAllGroupUserRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastType: Int32?

    public var groupId: String?

    public var operatorUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BroadCastType"] as? Int32 {
            self.broadCastType = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
    }
}

public class MuteAllGroupUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var requestId: String?

    public var result: MuteAllGroupUserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = MuteAllGroupUserResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class MuteAllGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MuteAllGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MuteAllGroupUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MuteGroupUserRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastType: Int32?

    public var groupId: String?

    public var muteTime: Int32?

    public var muteUserList: [String]?

    public var operatorUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.muteTime != nil {
            map["MuteTime"] = self.muteTime!
        }
        if self.muteUserList != nil {
            map["MuteUserList"] = self.muteUserList!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BroadCastType"] as? Int32 {
            self.broadCastType = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["MuteTime"] as? Int32 {
            self.muteTime = value
        }
        if let value = dict["MuteUserList"] as? [String] {
            self.muteUserList = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
    }
}

public class MuteGroupUserShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastType: Int32?

    public var groupId: String?

    public var muteTime: Int32?

    public var muteUserListShrink: String?

    public var operatorUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.muteTime != nil {
            map["MuteTime"] = self.muteTime!
        }
        if self.muteUserListShrink != nil {
            map["MuteUserList"] = self.muteUserListShrink!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BroadCastType"] as? Int32 {
            self.broadCastType = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["MuteTime"] as? Int32 {
            self.muteTime = value
        }
        if let value = dict["MuteUserList"] as? String {
            self.muteUserListShrink = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
    }
}

public class MuteGroupUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var requestId: String?

    public var result: MuteGroupUserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = MuteGroupUserResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class MuteGroupUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MuteGroupUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MuteGroupUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OpenLiveShiftRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var duration: Int32?

    public var ignoreTranscode: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public var vision: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.ignoreTranscode != nil {
            map["IgnoreTranscode"] = self.ignoreTranscode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.vision != nil {
            map["Vision"] = self.vision!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Duration"] as? Int32 {
            self.duration = value
        }
        if let value = dict["IgnoreTranscode"] as? Bool {
            self.ignoreTranscode = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["Vision"] as? Int32 {
            self.vision = value
        }
    }
}

public class OpenLiveShiftResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class OpenLiveShiftResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenLiveShiftResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OpenLiveShiftResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PlayChoosenShowRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var showId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowId"] as? String {
            self.showId = value
        }
    }
}

public class PlayChoosenShowResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var showId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ShowId"] as? String {
            self.showId = value
        }
    }
}

public class PlayChoosenShowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PlayChoosenShowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PlayChoosenShowResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PublishLiveStagingConfigToProductionRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["FunctionName"] as? String {
            self.functionName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class PublishLiveStagingConfigToProductionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class PublishLiveStagingConfigToProductionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishLiveStagingConfigToProductionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PublishLiveStagingConfigToProductionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PutRecordStorageLifeCycleRequest : Tea.TeaModel {
    public var streamIds: [String]?

    public var tag: String?

    public var unixTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.streamIds != nil {
            map["StreamIds"] = self.streamIds!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.unixTimestamp != nil {
            map["UnixTimestamp"] = self.unixTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["StreamIds"] as? [String] {
            self.streamIds = value
        }
        if let value = dict["Tag"] as? String {
            self.tag = value
        }
        if let value = dict["UnixTimestamp"] as? Int64 {
            self.unixTimestamp = value
        }
    }
}

public class PutRecordStorageLifeCycleShrinkRequest : Tea.TeaModel {
    public var streamIdsShrink: String?

    public var tag: String?

    public var unixTimestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.streamIdsShrink != nil {
            map["StreamIds"] = self.streamIdsShrink!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        if self.unixTimestamp != nil {
            map["UnixTimestamp"] = self.unixTimestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["StreamIds"] as? String {
            self.streamIdsShrink = value
        }
        if let value = dict["Tag"] as? String {
            self.tag = value
        }
        if let value = dict["UnixTimestamp"] as? Int64 {
            self.unixTimestamp = value
        }
    }
}

public class PutRecordStorageLifeCycleResponseBody : Tea.TeaModel {
    public var code: Int32?

    public var msg: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.msg != nil {
            map["Msg"] = self.msg!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Msg"] as? String {
            self.msg = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class PutRecordStorageLifeCycleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PutRecordStorageLifeCycleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PutRecordStorageLifeCycleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryLiveDomainMultiStreamListRequest : Tea.TeaModel {
    public var domain: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int32?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class QueryLiveDomainMultiStreamListResponseBody : Tea.TeaModel {
    public class OnlineStreams : Tea.TeaModel {
        public class ChangeLogs : Tea.TeaModel {
            public var changeReason: String?

            public var changeTime: String?

            public var masterUpstream: String?

            public var upstreamIp: String?

            public var upstreamSequence: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.changeReason != nil {
                    map["ChangeReason"] = self.changeReason!
                }
                if self.changeTime != nil {
                    map["ChangeTime"] = self.changeTime!
                }
                if self.masterUpstream != nil {
                    map["MasterUpstream"] = self.masterUpstream!
                }
                if self.upstreamIp != nil {
                    map["UpstreamIp"] = self.upstreamIp!
                }
                if self.upstreamSequence != nil {
                    map["UpstreamSequence"] = self.upstreamSequence!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChangeReason"] as? String {
                    self.changeReason = value
                }
                if let value = dict["ChangeTime"] as? String {
                    self.changeTime = value
                }
                if let value = dict["MasterUpstream"] as? String {
                    self.masterUpstream = value
                }
                if let value = dict["UpstreamIp"] as? String {
                    self.upstreamIp = value
                }
                if let value = dict["UpstreamSequence"] as? String {
                    self.upstreamSequence = value
                }
            }
        }
        public class UpstreamList : Tea.TeaModel {
            public var masterFlag: Bool?

            public var upstreamIp: String?

            public var upstreamSequence: String?

            public var upstreamTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.masterFlag != nil {
                    map["MasterFlag"] = self.masterFlag!
                }
                if self.upstreamIp != nil {
                    map["UpstreamIp"] = self.upstreamIp!
                }
                if self.upstreamSequence != nil {
                    map["UpstreamSequence"] = self.upstreamSequence!
                }
                if self.upstreamTime != nil {
                    map["UpstreamTime"] = self.upstreamTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MasterFlag"] as? Bool {
                    self.masterFlag = value
                }
                if let value = dict["UpstreamIp"] as? String {
                    self.upstreamIp = value
                }
                if let value = dict["UpstreamSequence"] as? String {
                    self.upstreamSequence = value
                }
                if let value = dict["UpstreamTime"] as? String {
                    self.upstreamTime = value
                }
            }
        }
        public var appName: String?

        public var changeLogs: [QueryLiveDomainMultiStreamListResponseBody.OnlineStreams.ChangeLogs]?

        public var domain: String?

        public var optimalMode: String?

        public var streamName: String?

        public var upstreamList: [QueryLiveDomainMultiStreamListResponseBody.OnlineStreams.UpstreamList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.changeLogs != nil {
                var tmp : [Any] = []
                for k in self.changeLogs! {
                    tmp.append(k.toMap())
                }
                map["ChangeLogs"] = tmp
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.optimalMode != nil {
                map["OptimalMode"] = self.optimalMode!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.upstreamList != nil {
                var tmp : [Any] = []
                for k in self.upstreamList! {
                    tmp.append(k.toMap())
                }
                map["UpstreamList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["ChangeLogs"] as? [Any?] {
                var tmp : [QueryLiveDomainMultiStreamListResponseBody.OnlineStreams.ChangeLogs] = []
                for v in value {
                    if v != nil {
                        var model = QueryLiveDomainMultiStreamListResponseBody.OnlineStreams.ChangeLogs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.changeLogs = tmp
            }
            if let value = dict["Domain"] as? String {
                self.domain = value
            }
            if let value = dict["OptimalMode"] as? String {
                self.optimalMode = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
            if let value = dict["UpstreamList"] as? [Any?] {
                var tmp : [QueryLiveDomainMultiStreamListResponseBody.OnlineStreams.UpstreamList] = []
                for v in value {
                    if v != nil {
                        var model = QueryLiveDomainMultiStreamListResponseBody.OnlineStreams.UpstreamList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.upstreamList = tmp
            }
        }
    }
    public var onlineStreams: [QueryLiveDomainMultiStreamListResponseBody.OnlineStreams]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.onlineStreams != nil {
            var tmp : [Any] = []
            for k in self.onlineStreams! {
                tmp.append(k.toMap())
            }
            map["OnlineStreams"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OnlineStreams"] as? [Any?] {
            var tmp : [QueryLiveDomainMultiStreamListResponseBody.OnlineStreams] = []
            for v in value {
                if v != nil {
                    var model = QueryLiveDomainMultiStreamListResponseBody.OnlineStreams()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.onlineStreams = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class QueryLiveDomainMultiStreamListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryLiveDomainMultiStreamListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryLiveDomainMultiStreamListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryMessageAppRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var pageNum: Int32?

    public var pageSize: Int32?

    public var sortType: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.pageNum != nil {
            map["PageNum"] = self.pageNum!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortType != nil {
            map["SortType"] = self.sortType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["PageNum"] as? Int32 {
            self.pageNum = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["SortType"] as? Int32 {
            self.sortType = value
        }
    }
}

public class QueryMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AppList : Tea.TeaModel {
            public var appConfig: [String: String]?

            public var appId: String?

            public var appName: String?

            public var createTime: Int64?

            public var extension_: [String: String]?

            public var status: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appConfig != nil {
                    map["AppConfig"] = self.appConfig!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppConfig"] as? [String: String] {
                    self.appConfig = value
                }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Extension"] as? [String: String] {
                    self.extension_ = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
            }
        }
        public var appList: [QueryMessageAppResponseBody.Result.AppList]?

        public var hasMore: Bool?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appList != nil {
                var tmp : [Any] = []
                for k in self.appList! {
                    tmp.append(k.toMap())
                }
                map["AppList"] = tmp
            }
            if self.hasMore != nil {
                map["HasMore"] = self.hasMore!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppList"] as? [Any?] {
                var tmp : [QueryMessageAppResponseBody.Result.AppList] = []
                for v in value {
                    if v != nil {
                        var model = QueryMessageAppResponseBody.Result.AppList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.appList = tmp
            }
            if let value = dict["HasMore"] as? Bool {
                self.hasMore = value
            }
            if let value = dict["TotalCount"] as? Int32 {
                self.totalCount = value
            }
        }
    }
    public var requestId: String?

    public var result: [QueryMessageAppResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [QueryMessageAppResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = QueryMessageAppResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class QueryMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryMessageAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryRtcAsrTasksRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class QueryRtcAsrTasksResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var retCode: Int64?

    public var tasks: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        if self.tasks != nil {
            map["Tasks"] = self.tasks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetCode"] as? Int64 {
            self.retCode = value
        }
        if let value = dict["Tasks"] as? [String: Any] {
            self.tasks = value
        }
    }
}

public class QueryRtcAsrTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryRtcAsrTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryRtcAsrTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QuerySnapshotCallbackAuthRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class QuerySnapshotCallbackAuthResponseBody : Tea.TeaModel {
    public var callbackAuthKey: String?

    public var callbackReqAuth: String?

    public var domainName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackAuthKey != nil {
            map["CallbackAuthKey"] = self.callbackAuthKey!
        }
        if self.callbackReqAuth != nil {
            map["CallbackReqAuth"] = self.callbackReqAuth!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallbackAuthKey"] as? String {
            self.callbackAuthKey = value
        }
        if let value = dict["CallbackReqAuth"] as? String {
            self.callbackReqAuth = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class QuerySnapshotCallbackAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySnapshotCallbackAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QuerySnapshotCallbackAuthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RealTimeRecordCommandRequest : Tea.TeaModel {
    public var appName: String?

    public var command: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class RealTimeRecordCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RealTimeRecordCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RealTimeRecordCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RealTimeRecordCommandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RecoverLiveMessageDeletedGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class RecoverLiveMessageDeletedGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RecoverLiveMessageDeletedGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverLiveMessageDeletedGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RecoverLiveMessageDeletedGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveLiveMessageGroupBandRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var unbannedUsers: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.unbannedUsers != nil {
            map["UnbannedUsers"] = self.unbannedUsers!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["UnbannedUsers"] as? [String] {
            self.unbannedUsers = value
        }
    }
}

public class RemoveLiveMessageGroupBandShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public var unbannedUsersShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.unbannedUsersShrink != nil {
            map["UnbannedUsers"] = self.unbannedUsersShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["UnbannedUsers"] as? String {
            self.unbannedUsersShrink = value
        }
    }
}

public class RemoveLiveMessageGroupBandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveLiveMessageGroupBandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveLiveMessageGroupBandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveLiveMessageGroupBandResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveShowFromShowListRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var showId: String?

    public var isBatchMode: Bool?

    public var showIdList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.isBatchMode != nil {
            map["isBatchMode"] = self.isBatchMode!
        }
        if self.showIdList != nil {
            map["showIdList"] = self.showIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowId"] as? String {
            self.showId = value
        }
        if let value = dict["isBatchMode"] as? Bool {
            self.isBatchMode = value
        }
        if let value = dict["showIdList"] as? [String] {
            self.showIdList = value
        }
    }
}

public class RemoveShowFromShowListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var showId: String?

    public var failedList: String?

    public var successfulShowIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.showId != nil {
            map["ShowId"] = self.showId!
        }
        if self.failedList != nil {
            map["failedList"] = self.failedList!
        }
        if self.successfulShowIds != nil {
            map["successfulShowIds"] = self.successfulShowIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ShowId"] as? String {
            self.showId = value
        }
        if let value = dict["failedList"] as? String {
            self.failedList = value
        }
        if let value = dict["successfulShowIds"] as? String {
            self.successfulShowIds = value
        }
    }
}

public class RemoveShowFromShowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveShowFromShowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveShowFromShowListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveTerminalsRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var terminalIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.terminalIds != nil {
            map["TerminalIds"] = self.terminalIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["TerminalIds"] as? [String] {
            self.terminalIds = value
        }
    }
}

public class RemoveTerminalsResponseBody : Tea.TeaModel {
    public class Terminals : Tea.TeaModel {
        public var code: Int32?

        public var id: String?

        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Code"] as? Int32 {
                self.code = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
        }
    }
    public var requestId: String?

    public var terminals: [RemoveTerminalsResponseBody.Terminals]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.terminals != nil {
            var tmp : [Any] = []
            for k in self.terminals! {
                tmp.append(k.toMap())
            }
            map["Terminals"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Terminals"] as? [Any?] {
            var tmp : [RemoveTerminalsResponseBody.Terminals] = []
            for v in value {
                if v != nil {
                    var model = RemoveTerminalsResponseBody.Terminals()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.terminals = tmp
        }
    }
}

public class RemoveTerminalsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTerminalsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveTerminalsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartCasterRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class RestartCasterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RestartCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartCasterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartLivePullToPushRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class RestartLivePullToPushResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class RestartLivePullToPushResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartLivePullToPushResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartLivePullToPushResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartTranscodeTaskRequest : Tea.TeaModel {
    public var app: String?

    public var pushDomain: String?

    public var securityToken: String?

    public var streamName: String?

    public var transcodingTemplate: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.pushDomain != nil {
            map["PushDomain"] = self.pushDomain!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.transcodingTemplate != nil {
            map["TranscodingTemplate"] = self.transcodingTemplate!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["PushDomain"] as? String {
            self.pushDomain = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["TranscodingTemplate"] as? String {
            self.transcodingTemplate = value
        }
    }
}

public class RestartTranscodeTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RestartTranscodeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartTranscodeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartTranscodeTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResumeLiveStreamRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var liveStreamType: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.liveStreamType != nil {
            map["LiveStreamType"] = self.liveStreamType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["LiveStreamType"] as? String {
            self.liveStreamType = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class ResumeLiveStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResumeLiveStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeLiveStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResumeLiveStreamResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RollbackLiveStagingConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var functionName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["FunctionName"] as? String {
            self.functionName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class RollbackLiveStagingConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RollbackLiveStagingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackLiveStagingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RollbackLiveStagingConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SendLikeRequest : Tea.TeaModel {
    public var appId: String?

    public var broadCastType: Int32?

    public var count: String?

    public var groupId: String?

    public var operatorUserId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.broadCastType != nil {
            map["BroadCastType"] = self.broadCastType!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BroadCastType"] as? Int32 {
            self.broadCastType = value
        }
        if let value = dict["Count"] as? String {
            self.count = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
    }
}

public class SendLikeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var likeCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.likeCount != nil {
                map["LikeCount"] = self.likeCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LikeCount"] as? Int32 {
                self.likeCount = value
            }
        }
    }
    public var requestId: String?

    public var result: SendLikeResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = SendLikeResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class SendLikeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLikeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SendLikeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SendLiveMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var body: String?

    public var dataCenter: String?

    public var groupId: String?

    public var msgTid: String?

    public var msgType: Int64?

    public var noCache: Bool?

    public var noStorage: Bool?

    public var senderId: String?

    public var senderMetaInfo: String?

    public var staticsIncrease: Int64?

    public var weight: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.body != nil {
            map["Body"] = self.body!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.msgTid != nil {
            map["MsgTid"] = self.msgTid!
        }
        if self.msgType != nil {
            map["MsgType"] = self.msgType!
        }
        if self.noCache != nil {
            map["NoCache"] = self.noCache!
        }
        if self.noStorage != nil {
            map["NoStorage"] = self.noStorage!
        }
        if self.senderId != nil {
            map["SenderId"] = self.senderId!
        }
        if self.senderMetaInfo != nil {
            map["SenderMetaInfo"] = self.senderMetaInfo!
        }
        if self.staticsIncrease != nil {
            map["StaticsIncrease"] = self.staticsIncrease!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Body"] as? String {
            self.body = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["MsgTid"] as? String {
            self.msgTid = value
        }
        if let value = dict["MsgType"] as? Int64 {
            self.msgType = value
        }
        if let value = dict["NoCache"] as? Bool {
            self.noCache = value
        }
        if let value = dict["NoStorage"] as? Bool {
            self.noStorage = value
        }
        if let value = dict["SenderId"] as? String {
            self.senderId = value
        }
        if let value = dict["SenderMetaInfo"] as? String {
            self.senderMetaInfo = value
        }
        if let value = dict["StaticsIncrease"] as? Int64 {
            self.staticsIncrease = value
        }
        if let value = dict["Weight"] as? Int64 {
            self.weight = value
        }
    }
}

public class SendLiveMessageGroupResponseBody : Tea.TeaModel {
    public var msgTid: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.msgTid != nil {
            map["MsgTid"] = self.msgTid!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MsgTid"] as? String {
            self.msgTid = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SendLiveMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SendLiveMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SendLiveMessageUserRequest : Tea.TeaModel {
    public var appId: String?

    public var body: String?

    public var dataCenter: String?

    public var highReliability: Bool?

    public var msgTid: String?

    public var msgType: Int64?

    public var receiverId: String?

    public var senderId: String?

    public var senderInfo: String?

    public var storage: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.body != nil {
            map["Body"] = self.body!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.highReliability != nil {
            map["HighReliability"] = self.highReliability!
        }
        if self.msgTid != nil {
            map["MsgTid"] = self.msgTid!
        }
        if self.msgType != nil {
            map["MsgType"] = self.msgType!
        }
        if self.receiverId != nil {
            map["ReceiverId"] = self.receiverId!
        }
        if self.senderId != nil {
            map["SenderId"] = self.senderId!
        }
        if self.senderInfo != nil {
            map["SenderInfo"] = self.senderInfo!
        }
        if self.storage != nil {
            map["Storage"] = self.storage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Body"] as? String {
            self.body = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["HighReliability"] as? Bool {
            self.highReliability = value
        }
        if let value = dict["MsgTid"] as? String {
            self.msgTid = value
        }
        if let value = dict["MsgType"] as? Int64 {
            self.msgType = value
        }
        if let value = dict["ReceiverId"] as? String {
            self.receiverId = value
        }
        if let value = dict["SenderId"] as? String {
            self.senderId = value
        }
        if let value = dict["SenderInfo"] as? String {
            self.senderInfo = value
        }
        if let value = dict["Storage"] as? Bool {
            self.storage = value
        }
    }
}

public class SendLiveMessageUserResponseBody : Tea.TeaModel {
    public var msgTid: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.msgTid != nil {
            map["MsgTid"] = self.msgTid!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MsgTid"] as? String {
            self.msgTid = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SendLiveMessageUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendLiveMessageUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SendLiveMessageUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SendMessageToGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var groupId: String?

    public var operatorUserId: String?

    public var skipAudit: Bool?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        if self.skipAudit != nil {
            map["SkipAudit"] = self.skipAudit!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
        if let value = dict["SkipAudit"] as? Bool {
            self.skipAudit = value
        }
        if let value = dict["Type"] as? Int32 {
            self.type = value
        }
    }
}

public class SendMessageToGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var messageId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.messageId != nil {
                map["MessageId"] = self.messageId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MessageId"] as? String {
                self.messageId = value
            }
        }
    }
    public var requestId: String?

    public var result: SendMessageToGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = SendMessageToGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class SendMessageToGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendMessageToGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SendMessageToGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SendMessageToGroupUsersRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var groupId: String?

    public var operatorUserId: String?

    public var receiverIdList: [String]?

    public var skipAudit: Bool?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        if self.receiverIdList != nil {
            map["ReceiverIdList"] = self.receiverIdList!
        }
        if self.skipAudit != nil {
            map["SkipAudit"] = self.skipAudit!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
        if let value = dict["ReceiverIdList"] as? [String] {
            self.receiverIdList = value
        }
        if let value = dict["SkipAudit"] as? Bool {
            self.skipAudit = value
        }
        if let value = dict["Type"] as? Int32 {
            self.type = value
        }
    }
}

public class SendMessageToGroupUsersShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var data: String?

    public var groupId: String?

    public var operatorUserId: String?

    public var receiverIdListShrink: String?

    public var skipAudit: Bool?

    public var type: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.operatorUserId != nil {
            map["OperatorUserId"] = self.operatorUserId!
        }
        if self.receiverIdListShrink != nil {
            map["ReceiverIdList"] = self.receiverIdListShrink!
        }
        if self.skipAudit != nil {
            map["SkipAudit"] = self.skipAudit!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["OperatorUserId"] as? String {
            self.operatorUserId = value
        }
        if let value = dict["ReceiverIdList"] as? String {
            self.receiverIdListShrink = value
        }
        if let value = dict["SkipAudit"] as? Bool {
            self.skipAudit = value
        }
        if let value = dict["Type"] as? Int32 {
            self.type = value
        }
    }
}

public class SendMessageToGroupUsersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var messageId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.messageId != nil {
                map["MessageId"] = self.messageId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MessageId"] as? String {
                self.messageId = value
            }
        }
    }
    public var requestId: String?

    public var result: SendMessageToGroupUsersResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = SendMessageToGroupUsersResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class SendMessageToGroupUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendMessageToGroupUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SendMessageToGroupUsersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetCasterChannelRequest : Tea.TeaModel {
    public var casterId: String?

    public var channelId: String?

    public var faceBeauty: String?

    public var ownerId: Int64?

    public var playStatus: Int32?

    public var regionId: String?

    public var resourceId: String?

    public var seekOffset: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.faceBeauty != nil {
            map["FaceBeauty"] = self.faceBeauty!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.playStatus != nil {
            map["PlayStatus"] = self.playStatus!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.seekOffset != nil {
            map["SeekOffset"] = self.seekOffset!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["FaceBeauty"] as? String {
            self.faceBeauty = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PlayStatus"] as? Int32 {
            self.playStatus = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["SeekOffset"] as? Int32 {
            self.seekOffset = value
        }
    }
}

public class SetCasterChannelResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetCasterChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCasterChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetCasterChannelResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetCasterConfigRequest : Tea.TeaModel {
    public var autoSwitchUrgentConfig: String?

    public var autoSwitchUrgentOn: Bool?

    public var callbackUrl: String?

    public var casterId: String?

    public var casterName: String?

    public var channelEnable: Int32?

    public var delay: Double?

    public var domainName: String?

    public var ownerId: Int64?

    public var programEffect: Int32?

    public var programName: String?

    public var recordConfig: String?

    public var regionId: String?

    public var sideOutputUrl: String?

    public var sideOutputUrlList: String?

    public var syncGroupsConfig: String?

    public var transcodeConfig: String?

    public var urgentImageId: String?

    public var urgentImageUrl: String?

    public var urgentLiveStreamUrl: String?

    public var urgentMaterialId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSwitchUrgentConfig != nil {
            map["AutoSwitchUrgentConfig"] = self.autoSwitchUrgentConfig!
        }
        if self.autoSwitchUrgentOn != nil {
            map["AutoSwitchUrgentOn"] = self.autoSwitchUrgentOn!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.casterName != nil {
            map["CasterName"] = self.casterName!
        }
        if self.channelEnable != nil {
            map["ChannelEnable"] = self.channelEnable!
        }
        if self.delay != nil {
            map["Delay"] = self.delay!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programEffect != nil {
            map["ProgramEffect"] = self.programEffect!
        }
        if self.programName != nil {
            map["ProgramName"] = self.programName!
        }
        if self.recordConfig != nil {
            map["RecordConfig"] = self.recordConfig!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sideOutputUrl != nil {
            map["SideOutputUrl"] = self.sideOutputUrl!
        }
        if self.sideOutputUrlList != nil {
            map["SideOutputUrlList"] = self.sideOutputUrlList!
        }
        if self.syncGroupsConfig != nil {
            map["SyncGroupsConfig"] = self.syncGroupsConfig!
        }
        if self.transcodeConfig != nil {
            map["TranscodeConfig"] = self.transcodeConfig!
        }
        if self.urgentImageId != nil {
            map["UrgentImageId"] = self.urgentImageId!
        }
        if self.urgentImageUrl != nil {
            map["UrgentImageUrl"] = self.urgentImageUrl!
        }
        if self.urgentLiveStreamUrl != nil {
            map["UrgentLiveStreamUrl"] = self.urgentLiveStreamUrl!
        }
        if self.urgentMaterialId != nil {
            map["UrgentMaterialId"] = self.urgentMaterialId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoSwitchUrgentConfig"] as? String {
            self.autoSwitchUrgentConfig = value
        }
        if let value = dict["AutoSwitchUrgentOn"] as? Bool {
            self.autoSwitchUrgentOn = value
        }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["CasterName"] as? String {
            self.casterName = value
        }
        if let value = dict["ChannelEnable"] as? Int32 {
            self.channelEnable = value
        }
        if let value = dict["Delay"] as? Double {
            self.delay = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProgramEffect"] as? Int32 {
            self.programEffect = value
        }
        if let value = dict["ProgramName"] as? String {
            self.programName = value
        }
        if let value = dict["RecordConfig"] as? String {
            self.recordConfig = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SideOutputUrl"] as? String {
            self.sideOutputUrl = value
        }
        if let value = dict["SideOutputUrlList"] as? String {
            self.sideOutputUrlList = value
        }
        if let value = dict["SyncGroupsConfig"] as? String {
            self.syncGroupsConfig = value
        }
        if let value = dict["TranscodeConfig"] as? String {
            self.transcodeConfig = value
        }
        if let value = dict["UrgentImageId"] as? String {
            self.urgentImageId = value
        }
        if let value = dict["UrgentImageUrl"] as? String {
            self.urgentImageUrl = value
        }
        if let value = dict["UrgentLiveStreamUrl"] as? String {
            self.urgentLiveStreamUrl = value
        }
        if let value = dict["UrgentMaterialId"] as? String {
            self.urgentMaterialId = value
        }
    }
}

public class SetCasterConfigResponseBody : Tea.TeaModel {
    public var casterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetCasterConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCasterConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetCasterConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetCasterSceneConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: [String]?

    public var layoutId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ComponentId"] as? [String] {
            self.componentId = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
    }
}

public class SetCasterSceneConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetCasterSceneConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetCasterSceneConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetCasterSceneConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveDomainCertificateRequest : Tea.TeaModel {
    public var certName: String?

    public var certType: String?

    public var domainName: String?

    public var forceSet: String?

    public var ownerId: Int64?

    public var SSLPri: String?

    public var SSLProtocol: String?

    public var SSLPub: String?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.certType != nil {
            map["CertType"] = self.certType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.forceSet != nil {
            map["ForceSet"] = self.forceSet!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.SSLPri != nil {
            map["SSLPri"] = self.SSLPri!
        }
        if self.SSLProtocol != nil {
            map["SSLProtocol"] = self.SSLProtocol!
        }
        if self.SSLPub != nil {
            map["SSLPub"] = self.SSLPub!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertName"] as? String {
            self.certName = value
        }
        if let value = dict["CertType"] as? String {
            self.certType = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["ForceSet"] as? String {
            self.forceSet = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SSLPri"] as? String {
            self.SSLPri = value
        }
        if let value = dict["SSLProtocol"] as? String {
            self.SSLProtocol = value
        }
        if let value = dict["SSLPub"] as? String {
            self.SSLPub = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class SetLiveDomainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveDomainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveDomainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveDomainCertificateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveDomainMultiStreamConfigRequest : Tea.TeaModel {
    public var domain: String?

    public var ownerId: Int64?

    public var switch_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.switch_ != nil {
            map["Switch"] = self.switch_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Switch"] as? String {
            self.switch_ = value
        }
    }
}

public class SetLiveDomainMultiStreamConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveDomainMultiStreamConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveDomainMultiStreamConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveDomainMultiStreamConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveDomainMultiStreamMasterRequest : Tea.TeaModel {
    public var appName: String?

    public var domain: String?

    public var ownerId: Int64?

    public var streamName: String?

    public var upstreamSequence: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.upstreamSequence != nil {
            map["UpstreamSequence"] = self.upstreamSequence!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["UpstreamSequence"] as? String {
            self.upstreamSequence = value
        }
    }
}

public class SetLiveDomainMultiStreamMasterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveDomainMultiStreamMasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveDomainMultiStreamMasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveDomainMultiStreamMasterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveDomainMultiStreamOptimalModeRequest : Tea.TeaModel {
    public var appName: String?

    public var domain: String?

    public var optimalMode: String?

    public var ownerId: Int64?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.optimalMode != nil {
            map["OptimalMode"] = self.optimalMode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OptimalMode"] as? String {
            self.optimalMode = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class SetLiveDomainMultiStreamOptimalModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveDomainMultiStreamOptimalModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveDomainMultiStreamOptimalModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveDomainMultiStreamOptimalModeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveDomainStagingConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var functions: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.functions != nil {
            map["Functions"] = self.functions!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Functions"] as? String {
            self.functions = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class SetLiveDomainStagingConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveDomainStagingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveDomainStagingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveDomainStagingConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveEdgeTransferRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var httpDns: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public var targetDomainList: String?

    public var transferArgs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.httpDns != nil {
            map["HttpDns"] = self.httpDns!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.targetDomainList != nil {
            map["TargetDomainList"] = self.targetDomainList!
        }
        if self.transferArgs != nil {
            map["TransferArgs"] = self.transferArgs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["HttpDns"] as? String {
            self.httpDns = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["TargetDomainList"] as? String {
            self.targetDomainList = value
        }
        if let value = dict["TransferArgs"] as? String {
            self.transferArgs = value
        }
    }
}

public class SetLiveEdgeTransferResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveEdgeTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveEdgeTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveEdgeTransferResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveLazyPullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var pullAppName: String?

    public var pullDomainName: String?

    public var pullProtocol: String?

    public var regionId: String?

    public var transcodeLazy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pullAppName != nil {
            map["PullAppName"] = self.pullAppName!
        }
        if self.pullDomainName != nil {
            map["PullDomainName"] = self.pullDomainName!
        }
        if self.pullProtocol != nil {
            map["PullProtocol"] = self.pullProtocol!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.transcodeLazy != nil {
            map["TranscodeLazy"] = self.transcodeLazy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PullAppName"] as? String {
            self.pullAppName = value
        }
        if let value = dict["PullDomainName"] as? String {
            self.pullDomainName = value
        }
        if let value = dict["PullProtocol"] as? String {
            self.pullProtocol = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TranscodeLazy"] as? String {
            self.transcodeLazy = value
        }
    }
}

public class SetLiveLazyPullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveLazyPullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveLazyPullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveLazyPullStreamInfoConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveMpuTaskSeiRequest : Tea.TeaModel {
    public var appId: String?

    public var customSei: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.customSei != nil {
            map["CustomSei"] = self.customSei!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CustomSei"] as? String {
            self.customSei = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class SetLiveMpuTaskSeiResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveMpuTaskSeiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveMpuTaskSeiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveMpuTaskSeiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveStreamBlockRequest : Tea.TeaModel {
    public var appName: String?

    public var blockType: String?

    public var domainName: String?

    public var locationList: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var releaseTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.blockType != nil {
            map["BlockType"] = self.blockType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.locationList != nil {
            map["LocationList"] = self.locationList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseTime != nil {
            map["ReleaseTime"] = self.releaseTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["BlockType"] as? String {
            self.blockType = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["LocationList"] as? String {
            self.locationList = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReleaseTime"] as? String {
            self.releaseTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class SetLiveStreamBlockResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class SetLiveStreamBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveStreamBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveStreamBlockResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveStreamDelayConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var flvDelay: Int32?

    public var flvLevel: String?

    public var hlsDelay: Int32?

    public var hlsLevel: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var rtmpDelay: Int32?

    public var rtmpLevel: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.flvDelay != nil {
            map["FlvDelay"] = self.flvDelay!
        }
        if self.flvLevel != nil {
            map["FlvLevel"] = self.flvLevel!
        }
        if self.hlsDelay != nil {
            map["HlsDelay"] = self.hlsDelay!
        }
        if self.hlsLevel != nil {
            map["HlsLevel"] = self.hlsLevel!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rtmpDelay != nil {
            map["RtmpDelay"] = self.rtmpDelay!
        }
        if self.rtmpLevel != nil {
            map["RtmpLevel"] = self.rtmpLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["FlvDelay"] as? Int32 {
            self.flvDelay = value
        }
        if let value = dict["FlvLevel"] as? String {
            self.flvLevel = value
        }
        if let value = dict["HlsDelay"] as? Int32 {
            self.hlsDelay = value
        }
        if let value = dict["HlsLevel"] as? String {
            self.hlsLevel = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RtmpDelay"] as? Int32 {
            self.rtmpDelay = value
        }
        if let value = dict["RtmpLevel"] as? String {
            self.rtmpLevel = value
        }
    }
}

public class SetLiveStreamDelayConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveStreamDelayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveStreamDelayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveStreamDelayConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveStreamPreloadTasksRequest : Tea.TeaModel {
    public var area: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var playUrl: String?

    public var preloadedEndTime: String?

    public var preloadedStartTime: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.area != nil {
            map["Area"] = self.area!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.playUrl != nil {
            map["PlayUrl"] = self.playUrl!
        }
        if self.preloadedEndTime != nil {
            map["PreloadedEndTime"] = self.preloadedEndTime!
        }
        if self.preloadedStartTime != nil {
            map["PreloadedStartTime"] = self.preloadedStartTime!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Area"] as? String {
            self.area = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PlayUrl"] as? String {
            self.playUrl = value
        }
        if let value = dict["PreloadedEndTime"] as? String {
            self.preloadedEndTime = value
        }
        if let value = dict["PreloadedStartTime"] as? String {
            self.preloadedStartTime = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class SetLiveStreamPreloadTasksResponseBody : Tea.TeaModel {
    public class PreloadTasksMessages : Tea.TeaModel {
        public class PreloadTasksMessage : Tea.TeaModel {
            public var description_: String?

            public var playUrl: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.playUrl != nil {
                    map["PlayUrl"] = self.playUrl!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["PlayUrl"] as? String {
                    self.playUrl = value
                }
                if let value = dict["TaskId"] as? String {
                    self.taskId = value
                }
            }
        }
        public var preloadTasksMessage: [SetLiveStreamPreloadTasksResponseBody.PreloadTasksMessages.PreloadTasksMessage]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preloadTasksMessage != nil {
                var tmp : [Any] = []
                for k in self.preloadTasksMessage! {
                    tmp.append(k.toMap())
                }
                map["PreloadTasksMessage"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PreloadTasksMessage"] as? [Any?] {
                var tmp : [SetLiveStreamPreloadTasksResponseBody.PreloadTasksMessages.PreloadTasksMessage] = []
                for v in value {
                    if v != nil {
                        var model = SetLiveStreamPreloadTasksResponseBody.PreloadTasksMessages.PreloadTasksMessage()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.preloadTasksMessage = tmp
            }
        }
    }
    public var failedURL: Int32?

    public var preloadTasksMessages: SetLiveStreamPreloadTasksResponseBody.PreloadTasksMessages?

    public var requestId: String?

    public var status: String?

    public var successURL: Int32?

    public var totalURL: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.preloadTasksMessages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failedURL != nil {
            map["FailedURL"] = self.failedURL!
        }
        if self.preloadTasksMessages != nil {
            map["PreloadTasksMessages"] = self.preloadTasksMessages?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.successURL != nil {
            map["SuccessURL"] = self.successURL!
        }
        if self.totalURL != nil {
            map["TotalURL"] = self.totalURL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailedURL"] as? Int32 {
            self.failedURL = value
        }
        if let value = dict["PreloadTasksMessages"] as? [String: Any?] {
            var model = SetLiveStreamPreloadTasksResponseBody.PreloadTasksMessages()
            model.fromMap(value)
            self.preloadTasksMessages = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["SuccessURL"] as? Int32 {
            self.successURL = value
        }
        if let value = dict["TotalURL"] as? Int32 {
            self.totalURL = value
        }
    }
}

public class SetLiveStreamPreloadTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveStreamPreloadTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveStreamPreloadTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetLiveStreamsNotifyUrlConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var exceptionNotifyUrl: String?

    public var notifyAuthKey: String?

    public var notifyReqAuth: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public var switchNotifyUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.exceptionNotifyUrl != nil {
            map["ExceptionNotifyUrl"] = self.exceptionNotifyUrl!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.switchNotifyUrl != nil {
            map["SwitchNotifyUrl"] = self.switchNotifyUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["ExceptionNotifyUrl"] as? String {
            self.exceptionNotifyUrl = value
        }
        if let value = dict["NotifyAuthKey"] as? String {
            self.notifyAuthKey = value
        }
        if let value = dict["NotifyReqAuth"] as? String {
            self.notifyReqAuth = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SwitchNotifyUrl"] as? String {
            self.switchNotifyUrl = value
        }
    }
}

public class SetLiveStreamsNotifyUrlConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetLiveStreamsNotifyUrlConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetLiveStreamsNotifyUrlConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetLiveStreamsNotifyUrlConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetShowListBackgroundRequest : Tea.TeaModel {
    public var casterId: String?

    public var materialId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceType: String?

    public var resourceUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.materialId != nil {
            map["MaterialId"] = self.materialId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.resourceUrl != nil {
            map["ResourceUrl"] = self.resourceUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["MaterialId"] as? String {
            self.materialId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["ResourceUrl"] as? String {
            self.resourceUrl = value
        }
    }
}

public class SetShowListBackgroundResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetShowListBackgroundResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetShowListBackgroundResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetShowListBackgroundResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetSnapshotCallbackAuthRequest : Tea.TeaModel {
    public var callbackAuthKey: String?

    public var callbackReqAuth: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackAuthKey != nil {
            map["CallbackAuthKey"] = self.callbackAuthKey!
        }
        if self.callbackReqAuth != nil {
            map["CallbackReqAuth"] = self.callbackReqAuth!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallbackAuthKey"] as? String {
            self.callbackAuthKey = value
        }
        if let value = dict["CallbackReqAuth"] as? String {
            self.callbackReqAuth = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class SetSnapshotCallbackAuthResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetSnapshotCallbackAuthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetSnapshotCallbackAuthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetSnapshotCallbackAuthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartCasterRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StartCasterResponseBody : Tea.TeaModel {
    public class PgmSceneInfos : Tea.TeaModel {
        public class SceneInfo : Tea.TeaModel {
            public class StreamInfos : Tea.TeaModel {
                public class StreamInfo : Tea.TeaModel {
                    public var outputStreamUrl: String?

                    public var transcodeConfig: String?

                    public var videoFormat: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outputStreamUrl != nil {
                            map["OutputStreamUrl"] = self.outputStreamUrl!
                        }
                        if self.transcodeConfig != nil {
                            map["TranscodeConfig"] = self.transcodeConfig!
                        }
                        if self.videoFormat != nil {
                            map["VideoFormat"] = self.videoFormat!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["OutputStreamUrl"] as? String {
                            self.outputStreamUrl = value
                        }
                        if let value = dict["TranscodeConfig"] as? String {
                            self.transcodeConfig = value
                        }
                        if let value = dict["VideoFormat"] as? String {
                            self.videoFormat = value
                        }
                    }
                }
                public var streamInfo: [StartCasterResponseBody.PgmSceneInfos.SceneInfo.StreamInfos.StreamInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.streamInfo != nil {
                        var tmp : [Any] = []
                        for k in self.streamInfo! {
                            tmp.append(k.toMap())
                        }
                        map["StreamInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["StreamInfo"] as? [Any?] {
                        var tmp : [StartCasterResponseBody.PgmSceneInfos.SceneInfo.StreamInfos.StreamInfo] = []
                        for v in value {
                            if v != nil {
                                var model = StartCasterResponseBody.PgmSceneInfos.SceneInfo.StreamInfos.StreamInfo()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.streamInfo = tmp
                    }
                }
            }
            public var sceneId: String?

            public var streamInfos: StartCasterResponseBody.PgmSceneInfos.SceneInfo.StreamInfos?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.streamInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.streamInfos != nil {
                    map["StreamInfos"] = self.streamInfos?.toMap()
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SceneId"] as? String {
                    self.sceneId = value
                }
                if let value = dict["StreamInfos"] as? [String: Any?] {
                    var model = StartCasterResponseBody.PgmSceneInfos.SceneInfo.StreamInfos()
                    model.fromMap(value)
                    self.streamInfos = model
                }
                if let value = dict["StreamUrl"] as? String {
                    self.streamUrl = value
                }
            }
        }
        public var sceneInfo: [StartCasterResponseBody.PgmSceneInfos.SceneInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sceneInfo != nil {
                var tmp : [Any] = []
                for k in self.sceneInfo! {
                    tmp.append(k.toMap())
                }
                map["SceneInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SceneInfo"] as? [Any?] {
                var tmp : [StartCasterResponseBody.PgmSceneInfos.SceneInfo] = []
                for v in value {
                    if v != nil {
                        var model = StartCasterResponseBody.PgmSceneInfos.SceneInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sceneInfo = tmp
            }
        }
    }
    public class PvwSceneInfos : Tea.TeaModel {
        public class SceneInfo : Tea.TeaModel {
            public var sceneId: String?

            public var streamUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sceneId != nil {
                    map["SceneId"] = self.sceneId!
                }
                if self.streamUrl != nil {
                    map["StreamUrl"] = self.streamUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SceneId"] as? String {
                    self.sceneId = value
                }
                if let value = dict["StreamUrl"] as? String {
                    self.streamUrl = value
                }
            }
        }
        public var sceneInfo: [StartCasterResponseBody.PvwSceneInfos.SceneInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sceneInfo != nil {
                var tmp : [Any] = []
                for k in self.sceneInfo! {
                    tmp.append(k.toMap())
                }
                map["SceneInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SceneInfo"] as? [Any?] {
                var tmp : [StartCasterResponseBody.PvwSceneInfos.SceneInfo] = []
                for v in value {
                    if v != nil {
                        var model = StartCasterResponseBody.PvwSceneInfos.SceneInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sceneInfo = tmp
            }
        }
    }
    public var pgmSceneInfos: StartCasterResponseBody.PgmSceneInfos?

    public var pvwSceneInfos: StartCasterResponseBody.PvwSceneInfos?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pgmSceneInfos?.validate()
        try self.pvwSceneInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pgmSceneInfos != nil {
            map["PgmSceneInfos"] = self.pgmSceneInfos?.toMap()
        }
        if self.pvwSceneInfos != nil {
            map["PvwSceneInfos"] = self.pvwSceneInfos?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PgmSceneInfos"] as? [String: Any?] {
            var model = StartCasterResponseBody.PgmSceneInfos()
            model.fromMap(value)
            self.pgmSceneInfos = model
        }
        if let value = dict["PvwSceneInfos"] as? [String: Any?] {
            var model = StartCasterResponseBody.PvwSceneInfos()
            model.fromMap(value)
            self.pvwSceneInfos = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartCasterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartCasterSceneRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
    }
}

public class StartCasterSceneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var streamUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamUrl != nil {
            map["StreamUrl"] = self.streamUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamUrl"] as? String {
            self.streamUrl = value
        }
    }
}

public class StartCasterSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartCasterSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartCasterSceneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartEdgeTranscodeJobRequest : Tea.TeaModel {
    public var clusterId: String?

    public var jobId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StartEdgeTranscodeJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartEdgeTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartEdgeTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartEdgeTranscodeJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartLiveDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class StartLiveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartLiveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartLiveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartLiveDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartLiveMPUTaskRequest : Tea.TeaModel {
    public class MultiStreamURL : Tea.TeaModel {
        public var isAliCdn: Bool?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isAliCdn != nil {
                map["IsAliCdn"] = self.isAliCdn!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IsAliCdn"] as? Bool {
                self.isAliCdn = value
            }
            if let value = dict["URL"] as? String {
                self.URL = value
            }
        }
    }
    public class SeiParams : Tea.TeaModel {
        public class LayoutVolume : Tea.TeaModel {
            public var followIdr: String?

            public var interval: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.followIdr != nil {
                    map["FollowIdr"] = self.followIdr!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FollowIdr"] as? String {
                    self.followIdr = value
                }
                if let value = dict["Interval"] as? String {
                    self.interval = value
                }
            }
        }
        public class PassThrough : Tea.TeaModel {
            public var followIdr: String?

            public var interval: String?

            public var payloadContent: String?

            public var payloadContentKey: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.followIdr != nil {
                    map["FollowIdr"] = self.followIdr!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.payloadContent != nil {
                    map["PayloadContent"] = self.payloadContent!
                }
                if self.payloadContentKey != nil {
                    map["PayloadContentKey"] = self.payloadContentKey!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FollowIdr"] as? String {
                    self.followIdr = value
                }
                if let value = dict["Interval"] as? String {
                    self.interval = value
                }
                if let value = dict["PayloadContent"] as? String {
                    self.payloadContent = value
                }
                if let value = dict["PayloadContentKey"] as? String {
                    self.payloadContentKey = value
                }
            }
        }
        public var layoutVolume: StartLiveMPUTaskRequest.SeiParams.LayoutVolume?

        public var passThrough: StartLiveMPUTaskRequest.SeiParams.PassThrough?

        public var payloadType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.layoutVolume?.validate()
            try self.passThrough?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.layoutVolume != nil {
                map["LayoutVolume"] = self.layoutVolume?.toMap()
            }
            if self.passThrough != nil {
                map["PassThrough"] = self.passThrough?.toMap()
            }
            if self.payloadType != nil {
                map["PayloadType"] = self.payloadType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LayoutVolume"] as? [String: Any?] {
                var model = StartLiveMPUTaskRequest.SeiParams.LayoutVolume()
                model.fromMap(value)
                self.layoutVolume = model
            }
            if let value = dict["PassThrough"] as? [String: Any?] {
                var model = StartLiveMPUTaskRequest.SeiParams.PassThrough()
                model.fromMap(value)
                self.passThrough = model
            }
            if let value = dict["PayloadType"] as? String {
                self.payloadType = value
            }
        }
    }
    public class SingleSubParams : Tea.TeaModel {
        public var sourceType: String?

        public var streamType: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.streamType != nil {
                map["StreamType"] = self.streamType!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["StreamType"] as? String {
                self.streamType = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public class TranscodeParams : Tea.TeaModel {
        public class Background : Tea.TeaModel {
            public var renderMode: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.renderMode != nil {
                    map["RenderMode"] = self.renderMode!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RenderMode"] as? String {
                    self.renderMode = value
                }
                if let value = dict["URL"] as? String {
                    self.URL = value
                }
            }
        }
        public class EncodeParams : Tea.TeaModel {
            public var audioBitrate: String?

            public var audioChannels: String?

            public var audioOnly: String?

            public var audioSampleRate: String?

            public var enhancedParam: String?

            public var videoBitrate: String?

            public var videoCodec: String?

            public var videoFramerate: String?

            public var videoGop: String?

            public var videoHeight: String?

            public var videoWidth: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioBitrate != nil {
                    map["AudioBitrate"] = self.audioBitrate!
                }
                if self.audioChannels != nil {
                    map["AudioChannels"] = self.audioChannels!
                }
                if self.audioOnly != nil {
                    map["AudioOnly"] = self.audioOnly!
                }
                if self.audioSampleRate != nil {
                    map["AudioSampleRate"] = self.audioSampleRate!
                }
                if self.enhancedParam != nil {
                    map["EnhancedParam"] = self.enhancedParam!
                }
                if self.videoBitrate != nil {
                    map["VideoBitrate"] = self.videoBitrate!
                }
                if self.videoCodec != nil {
                    map["VideoCodec"] = self.videoCodec!
                }
                if self.videoFramerate != nil {
                    map["VideoFramerate"] = self.videoFramerate!
                }
                if self.videoGop != nil {
                    map["VideoGop"] = self.videoGop!
                }
                if self.videoHeight != nil {
                    map["VideoHeight"] = self.videoHeight!
                }
                if self.videoWidth != nil {
                    map["VideoWidth"] = self.videoWidth!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AudioBitrate"] as? String {
                    self.audioBitrate = value
                }
                if let value = dict["AudioChannels"] as? String {
                    self.audioChannels = value
                }
                if let value = dict["AudioOnly"] as? String {
                    self.audioOnly = value
                }
                if let value = dict["AudioSampleRate"] as? String {
                    self.audioSampleRate = value
                }
                if let value = dict["EnhancedParam"] as? String {
                    self.enhancedParam = value
                }
                if let value = dict["VideoBitrate"] as? String {
                    self.videoBitrate = value
                }
                if let value = dict["VideoCodec"] as? String {
                    self.videoCodec = value
                }
                if let value = dict["VideoFramerate"] as? String {
                    self.videoFramerate = value
                }
                if let value = dict["VideoGop"] as? String {
                    self.videoGop = value
                }
                if let value = dict["VideoHeight"] as? String {
                    self.videoHeight = value
                }
                if let value = dict["VideoWidth"] as? String {
                    self.videoWidth = value
                }
            }
        }
        public class Layout : Tea.TeaModel {
            public class UserPanes : Tea.TeaModel {
                public class UserInfo : Tea.TeaModel {
                    public var channelId: String?

                    public var sourceType: String?

                    public var userId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channelId != nil {
                            map["ChannelId"] = self.channelId!
                        }
                        if self.sourceType != nil {
                            map["SourceType"] = self.sourceType!
                        }
                        if self.userId != nil {
                            map["UserId"] = self.userId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ChannelId"] as? String {
                            self.channelId = value
                        }
                        if let value = dict["SourceType"] as? String {
                            self.sourceType = value
                        }
                        if let value = dict["UserId"] as? String {
                            self.userId = value
                        }
                    }
                }
                public var backgroundImageUrl: String?

                public var height: String?

                public var renderMode: String?

                public var userInfo: StartLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes.UserInfo?

                public var width: String?

                public var x: String?

                public var y: String?

                public var ZOrder: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.userInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.backgroundImageUrl != nil {
                        map["BackgroundImageUrl"] = self.backgroundImageUrl!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.renderMode != nil {
                        map["RenderMode"] = self.renderMode!
                    }
                    if self.userInfo != nil {
                        map["UserInfo"] = self.userInfo?.toMap()
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    if self.x != nil {
                        map["X"] = self.x!
                    }
                    if self.y != nil {
                        map["Y"] = self.y!
                    }
                    if self.ZOrder != nil {
                        map["ZOrder"] = self.ZOrder!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BackgroundImageUrl"] as? String {
                        self.backgroundImageUrl = value
                    }
                    if let value = dict["Height"] as? String {
                        self.height = value
                    }
                    if let value = dict["RenderMode"] as? String {
                        self.renderMode = value
                    }
                    if let value = dict["UserInfo"] as? [String: Any?] {
                        var model = StartLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes.UserInfo()
                        model.fromMap(value)
                        self.userInfo = model
                    }
                    if let value = dict["Width"] as? String {
                        self.width = value
                    }
                    if let value = dict["X"] as? String {
                        self.x = value
                    }
                    if let value = dict["Y"] as? String {
                        self.y = value
                    }
                    if let value = dict["ZOrder"] as? String {
                        self.ZOrder = value
                    }
                }
            }
            public var userPanes: [StartLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userPanes != nil {
                    var tmp : [Any] = []
                    for k in self.userPanes! {
                        tmp.append(k.toMap())
                    }
                    map["UserPanes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["UserPanes"] as? [Any?] {
                    var tmp : [StartLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes] = []
                    for v in value {
                        if v != nil {
                            var model = StartLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.userPanes = tmp
                }
            }
        }
        public class UserInfos : Tea.TeaModel {
            public var channelId: String?

            public var sourceType: String?

            public var streamType: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChannelId"] as? String {
                    self.channelId = value
                }
                if let value = dict["SourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["StreamType"] as? String {
                    self.streamType = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var background: StartLiveMPUTaskRequest.TranscodeParams.Background?

        public var encodeParams: StartLiveMPUTaskRequest.TranscodeParams.EncodeParams?

        public var layout: StartLiveMPUTaskRequest.TranscodeParams.Layout?

        public var userInfos: [StartLiveMPUTaskRequest.TranscodeParams.UserInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.background?.validate()
            try self.encodeParams?.validate()
            try self.layout?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.background != nil {
                map["Background"] = self.background?.toMap()
            }
            if self.encodeParams != nil {
                map["EncodeParams"] = self.encodeParams?.toMap()
            }
            if self.layout != nil {
                map["Layout"] = self.layout?.toMap()
            }
            if self.userInfos != nil {
                var tmp : [Any] = []
                for k in self.userInfos! {
                    tmp.append(k.toMap())
                }
                map["UserInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Background"] as? [String: Any?] {
                var model = StartLiveMPUTaskRequest.TranscodeParams.Background()
                model.fromMap(value)
                self.background = model
            }
            if let value = dict["EncodeParams"] as? [String: Any?] {
                var model = StartLiveMPUTaskRequest.TranscodeParams.EncodeParams()
                model.fromMap(value)
                self.encodeParams = model
            }
            if let value = dict["Layout"] as? [String: Any?] {
                var model = StartLiveMPUTaskRequest.TranscodeParams.Layout()
                model.fromMap(value)
                self.layout = model
            }
            if let value = dict["UserInfos"] as? [Any?] {
                var tmp : [StartLiveMPUTaskRequest.TranscodeParams.UserInfos] = []
                for v in value {
                    if v != nil {
                        var model = StartLiveMPUTaskRequest.TranscodeParams.UserInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.userInfos = tmp
            }
        }
    }
    public var appId: String?

    public var channelId: String?

    public var maxIdleTime: String?

    public var mixMode: String?

    public var multiStreamURL: [StartLiveMPUTaskRequest.MultiStreamURL]?

    public var region: String?

    public var seiParams: StartLiveMPUTaskRequest.SeiParams?

    public var singleSubParams: StartLiveMPUTaskRequest.SingleSubParams?

    public var streamURL: String?

    public var taskId: String?

    public var transcodeParams: StartLiveMPUTaskRequest.TranscodeParams?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.seiParams?.validate()
        try self.singleSubParams?.validate()
        try self.transcodeParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.maxIdleTime != nil {
            map["MaxIdleTime"] = self.maxIdleTime!
        }
        if self.mixMode != nil {
            map["MixMode"] = self.mixMode!
        }
        if self.multiStreamURL != nil {
            var tmp : [Any] = []
            for k in self.multiStreamURL! {
                tmp.append(k.toMap())
            }
            map["MultiStreamURL"] = tmp
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.seiParams != nil {
            map["SeiParams"] = self.seiParams?.toMap()
        }
        if self.singleSubParams != nil {
            map["SingleSubParams"] = self.singleSubParams?.toMap()
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.transcodeParams != nil {
            map["TranscodeParams"] = self.transcodeParams?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["MaxIdleTime"] as? String {
            self.maxIdleTime = value
        }
        if let value = dict["MixMode"] as? String {
            self.mixMode = value
        }
        if let value = dict["MultiStreamURL"] as? [Any?] {
            var tmp : [StartLiveMPUTaskRequest.MultiStreamURL] = []
            for v in value {
                if v != nil {
                    var model = StartLiveMPUTaskRequest.MultiStreamURL()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.multiStreamURL = tmp
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["SeiParams"] as? [String: Any?] {
            var model = StartLiveMPUTaskRequest.SeiParams()
            model.fromMap(value)
            self.seiParams = model
        }
        if let value = dict["SingleSubParams"] as? [String: Any?] {
            var model = StartLiveMPUTaskRequest.SingleSubParams()
            model.fromMap(value)
            self.singleSubParams = model
        }
        if let value = dict["StreamURL"] as? String {
            self.streamURL = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TranscodeParams"] as? [String: Any?] {
            var model = StartLiveMPUTaskRequest.TranscodeParams()
            model.fromMap(value)
            self.transcodeParams = model
        }
    }
}

public class StartLiveMPUTaskShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var maxIdleTime: String?

    public var mixMode: String?

    public var multiStreamURLShrink: String?

    public var region: String?

    public var seiParamsShrink: String?

    public var singleSubParamsShrink: String?

    public var streamURL: String?

    public var taskId: String?

    public var transcodeParamsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.maxIdleTime != nil {
            map["MaxIdleTime"] = self.maxIdleTime!
        }
        if self.mixMode != nil {
            map["MixMode"] = self.mixMode!
        }
        if self.multiStreamURLShrink != nil {
            map["MultiStreamURL"] = self.multiStreamURLShrink!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.seiParamsShrink != nil {
            map["SeiParams"] = self.seiParamsShrink!
        }
        if self.singleSubParamsShrink != nil {
            map["SingleSubParams"] = self.singleSubParamsShrink!
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.transcodeParamsShrink != nil {
            map["TranscodeParams"] = self.transcodeParamsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["MaxIdleTime"] as? String {
            self.maxIdleTime = value
        }
        if let value = dict["MixMode"] as? String {
            self.mixMode = value
        }
        if let value = dict["MultiStreamURL"] as? String {
            self.multiStreamURLShrink = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["SeiParams"] as? String {
            self.seiParamsShrink = value
        }
        if let value = dict["SingleSubParams"] as? String {
            self.singleSubParamsShrink = value
        }
        if let value = dict["StreamURL"] as? String {
            self.streamURL = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TranscodeParams"] as? String {
            self.transcodeParamsShrink = value
        }
    }
}

public class StartLiveMPUTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartLiveMPUTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartLiveMPUTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartLiveMPUTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartLiveStreamMonitorRequest : Tea.TeaModel {
    public var monitorId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorId"] as? String {
            self.monitorId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StartLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartLiveStreamMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartPlaylistRequest : Tea.TeaModel {
    public var offset: Int32?

    public var ownerId: Int64?

    public var programId: String?

    public var regionId: String?

    public var resumeMode: String?

    public var startItemId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resumeMode != nil {
            map["ResumeMode"] = self.resumeMode!
        }
        if self.startItemId != nil {
            map["StartItemId"] = self.startItemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Offset"] as? Int32 {
            self.offset = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResumeMode"] as? String {
            self.resumeMode = value
        }
        if let value = dict["StartItemId"] as? String {
            self.startItemId = value
        }
    }
}

public class StartPlaylistResponseBody : Tea.TeaModel {
    public class StreamInfo : Tea.TeaModel {
        public class Streams : Tea.TeaModel {
            public class Stream : Tea.TeaModel {
                public var pullFlvUrl: String?

                public var pullM3U8Url: String?

                public var pullRtmpUrl: String?

                public var quality: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pullFlvUrl != nil {
                        map["PullFlvUrl"] = self.pullFlvUrl!
                    }
                    if self.pullM3U8Url != nil {
                        map["PullM3U8Url"] = self.pullM3U8Url!
                    }
                    if self.pullRtmpUrl != nil {
                        map["PullRtmpUrl"] = self.pullRtmpUrl!
                    }
                    if self.quality != nil {
                        map["Quality"] = self.quality!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["PullFlvUrl"] as? String {
                        self.pullFlvUrl = value
                    }
                    if let value = dict["PullM3U8Url"] as? String {
                        self.pullM3U8Url = value
                    }
                    if let value = dict["PullRtmpUrl"] as? String {
                        self.pullRtmpUrl = value
                    }
                    if let value = dict["Quality"] as? String {
                        self.quality = value
                    }
                }
            }
            public var stream: [StartPlaylistResponseBody.StreamInfo.Streams.Stream]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.stream != nil {
                    var tmp : [Any] = []
                    for k in self.stream! {
                        tmp.append(k.toMap())
                    }
                    map["Stream"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Stream"] as? [Any?] {
                    var tmp : [StartPlaylistResponseBody.StreamInfo.Streams.Stream] = []
                    for v in value {
                        if v != nil {
                            var model = StartPlaylistResponseBody.StreamInfo.Streams.Stream()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.stream = tmp
                }
            }
        }
        public var appName: String?

        public var domainName: String?

        public var streamName: String?

        public var streams: StartPlaylistResponseBody.StreamInfo.Streams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.streams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.streamName != nil {
                map["StreamName"] = self.streamName!
            }
            if self.streams != nil {
                map["Streams"] = self.streams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
            if let value = dict["StreamName"] as? String {
                self.streamName = value
            }
            if let value = dict["Streams"] as? [String: Any?] {
                var model = StartPlaylistResponseBody.StreamInfo.Streams()
                model.fromMap(value)
                self.streams = model
            }
        }
    }
    public var programId: String?

    public var requestId: String?

    public var streamInfo: StartPlaylistResponseBody.StreamInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.streamInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.streamInfo != nil {
            map["StreamInfo"] = self.streamInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StreamInfo"] as? [String: Any?] {
            var model = StartPlaylistResponseBody.StreamInfo()
            model.fromMap(value)
            self.streamInfo = model
        }
    }
}

public class StartPlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartPlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartPlaylistResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartRtcCloudRecordingRequest : Tea.TeaModel {
    public class MixLayoutParams : Tea.TeaModel {
        public class MixBackground : Tea.TeaModel {
            public var renderMode: Int32?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.renderMode != nil {
                    map["RenderMode"] = self.renderMode!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RenderMode"] as? Int32 {
                    self.renderMode = value
                }
                if let value = dict["Url"] as? String {
                    self.url = value
                }
            }
        }
        public class UserPanes : Tea.TeaModel {
            public class SubBackground : Tea.TeaModel {
                public var renderMode: Int32?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.renderMode != nil {
                        map["RenderMode"] = self.renderMode!
                    }
                    if self.url != nil {
                        map["Url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RenderMode"] as? Int32 {
                        self.renderMode = value
                    }
                    if let value = dict["Url"] as? String {
                        self.url = value
                    }
                }
            }
            public var height: String?

            public var sourceType: Int32?

            public var subBackground: StartRtcCloudRecordingRequest.MixLayoutParams.UserPanes.SubBackground?

            public var userId: String?

            public var width: String?

            public var x: String?

            public var y: String?

            public var ZOrder: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.subBackground?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.subBackground != nil {
                    map["SubBackground"] = self.subBackground?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                if self.x != nil {
                    map["X"] = self.x!
                }
                if self.y != nil {
                    map["Y"] = self.y!
                }
                if self.ZOrder != nil {
                    map["ZOrder"] = self.ZOrder!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Height"] as? String {
                    self.height = value
                }
                if let value = dict["SourceType"] as? Int32 {
                    self.sourceType = value
                }
                if let value = dict["SubBackground"] as? [String: Any?] {
                    var model = StartRtcCloudRecordingRequest.MixLayoutParams.UserPanes.SubBackground()
                    model.fromMap(value)
                    self.subBackground = model
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["Width"] as? String {
                    self.width = value
                }
                if let value = dict["X"] as? String {
                    self.x = value
                }
                if let value = dict["Y"] as? String {
                    self.y = value
                }
                if let value = dict["ZOrder"] as? Int32 {
                    self.ZOrder = value
                }
            }
        }
        public var mixBackground: StartRtcCloudRecordingRequest.MixLayoutParams.MixBackground?

        public var userPanes: [StartRtcCloudRecordingRequest.MixLayoutParams.UserPanes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mixBackground?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mixBackground != nil {
                map["MixBackground"] = self.mixBackground?.toMap()
            }
            if self.userPanes != nil {
                var tmp : [Any] = []
                for k in self.userPanes! {
                    tmp.append(k.toMap())
                }
                map["UserPanes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MixBackground"] as? [String: Any?] {
                var model = StartRtcCloudRecordingRequest.MixLayoutParams.MixBackground()
                model.fromMap(value)
                self.mixBackground = model
            }
            if let value = dict["UserPanes"] as? [Any?] {
                var tmp : [StartRtcCloudRecordingRequest.MixLayoutParams.UserPanes] = []
                for v in value {
                    if v != nil {
                        var model = StartRtcCloudRecordingRequest.MixLayoutParams.UserPanes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.userPanes = tmp
            }
        }
    }
    public class MixTranscodeParams : Tea.TeaModel {
        public var audioBitrate: Int64?

        public var audioChannels: Int32?

        public var audioSampleRate: Int64?

        public var frameFillType: Int32?

        public var videoBitrate: Int32?

        public var videoCodec: String?

        public var videoFramerate: Int32?

        public var videoGop: Int32?

        public var videoHeight: Int32?

        public var videoWidth: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioBitrate != nil {
                map["AudioBitrate"] = self.audioBitrate!
            }
            if self.audioChannels != nil {
                map["AudioChannels"] = self.audioChannels!
            }
            if self.audioSampleRate != nil {
                map["AudioSampleRate"] = self.audioSampleRate!
            }
            if self.frameFillType != nil {
                map["FrameFillType"] = self.frameFillType!
            }
            if self.videoBitrate != nil {
                map["VideoBitrate"] = self.videoBitrate!
            }
            if self.videoCodec != nil {
                map["VideoCodec"] = self.videoCodec!
            }
            if self.videoFramerate != nil {
                map["VideoFramerate"] = self.videoFramerate!
            }
            if self.videoGop != nil {
                map["VideoGop"] = self.videoGop!
            }
            if self.videoHeight != nil {
                map["VideoHeight"] = self.videoHeight!
            }
            if self.videoWidth != nil {
                map["VideoWidth"] = self.videoWidth!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AudioBitrate"] as? Int64 {
                self.audioBitrate = value
            }
            if let value = dict["AudioChannels"] as? Int32 {
                self.audioChannels = value
            }
            if let value = dict["AudioSampleRate"] as? Int64 {
                self.audioSampleRate = value
            }
            if let value = dict["FrameFillType"] as? Int32 {
                self.frameFillType = value
            }
            if let value = dict["VideoBitrate"] as? Int32 {
                self.videoBitrate = value
            }
            if let value = dict["VideoCodec"] as? String {
                self.videoCodec = value
            }
            if let value = dict["VideoFramerate"] as? Int32 {
                self.videoFramerate = value
            }
            if let value = dict["VideoGop"] as? Int32 {
                self.videoGop = value
            }
            if let value = dict["VideoHeight"] as? Int32 {
                self.videoHeight = value
            }
            if let value = dict["VideoWidth"] as? Int32 {
                self.videoWidth = value
            }
        }
    }
    public class RecordParams : Tea.TeaModel {
        public var maxFileDuration: Int64?

        public var recordMode: Int32?

        public var streamType: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxFileDuration != nil {
                map["MaxFileDuration"] = self.maxFileDuration!
            }
            if self.recordMode != nil {
                map["RecordMode"] = self.recordMode!
            }
            if self.streamType != nil {
                map["StreamType"] = self.streamType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxFileDuration"] as? Int64 {
                self.maxFileDuration = value
            }
            if let value = dict["RecordMode"] as? Int32 {
                self.recordMode = value
            }
            if let value = dict["StreamType"] as? Int32 {
                self.streamType = value
            }
        }
    }
    public class StorageParams : Tea.TeaModel {
        public class FileInfo : Tea.TeaModel {
            public var fileNamePattern: String?

            public var filePathPrefix: [String]?

            public var format: String?

            public var sliceDuration: Int64?

            public var sliceNamePattern: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileNamePattern != nil {
                    map["FileNamePattern"] = self.fileNamePattern!
                }
                if self.filePathPrefix != nil {
                    map["FilePathPrefix"] = self.filePathPrefix!
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.sliceDuration != nil {
                    map["SliceDuration"] = self.sliceDuration!
                }
                if self.sliceNamePattern != nil {
                    map["SliceNamePattern"] = self.sliceNamePattern!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FileNamePattern"] as? String {
                    self.fileNamePattern = value
                }
                if let value = dict["FilePathPrefix"] as? [String] {
                    self.filePathPrefix = value
                }
                if let value = dict["Format"] as? String {
                    self.format = value
                }
                if let value = dict["SliceDuration"] as? Int64 {
                    self.sliceDuration = value
                }
                if let value = dict["SliceNamePattern"] as? String {
                    self.sliceNamePattern = value
                }
            }
        }
        public class OSSParams : Tea.TeaModel {
            public var OSSBucket: String?

            public var OSSEndpoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.OSSBucket != nil {
                    map["OSSBucket"] = self.OSSBucket!
                }
                if self.OSSEndpoint != nil {
                    map["OSSEndpoint"] = self.OSSEndpoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OSSBucket"] as? String {
                    self.OSSBucket = value
                }
                if let value = dict["OSSEndpoint"] as? String {
                    self.OSSEndpoint = value
                }
            }
        }
        public class VodParams : Tea.TeaModel {
            public var autoCompose: Int32?

            public var composeVodTranscodeGroupId: String?

            public var storageLocation: String?

            public var vodTranscodeGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoCompose != nil {
                    map["AutoCompose"] = self.autoCompose!
                }
                if self.composeVodTranscodeGroupId != nil {
                    map["ComposeVodTranscodeGroupId"] = self.composeVodTranscodeGroupId!
                }
                if self.storageLocation != nil {
                    map["StorageLocation"] = self.storageLocation!
                }
                if self.vodTranscodeGroupId != nil {
                    map["VodTranscodeGroupId"] = self.vodTranscodeGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoCompose"] as? Int32 {
                    self.autoCompose = value
                }
                if let value = dict["ComposeVodTranscodeGroupId"] as? String {
                    self.composeVodTranscodeGroupId = value
                }
                if let value = dict["StorageLocation"] as? String {
                    self.storageLocation = value
                }
                if let value = dict["VodTranscodeGroupId"] as? String {
                    self.vodTranscodeGroupId = value
                }
            }
        }
        public var fileInfo: [StartRtcCloudRecordingRequest.StorageParams.FileInfo]?

        public var OSSParams: StartRtcCloudRecordingRequest.StorageParams.OSSParams?

        public var storageType: Int32?

        public var vodParams: StartRtcCloudRecordingRequest.StorageParams.VodParams?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.OSSParams?.validate()
            try self.vodParams?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileInfo != nil {
                var tmp : [Any] = []
                for k in self.fileInfo! {
                    tmp.append(k.toMap())
                }
                map["FileInfo"] = tmp
            }
            if self.OSSParams != nil {
                map["OSSParams"] = self.OSSParams?.toMap()
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            if self.vodParams != nil {
                map["VodParams"] = self.vodParams?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FileInfo"] as? [Any?] {
                var tmp : [StartRtcCloudRecordingRequest.StorageParams.FileInfo] = []
                for v in value {
                    if v != nil {
                        var model = StartRtcCloudRecordingRequest.StorageParams.FileInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.fileInfo = tmp
            }
            if let value = dict["OSSParams"] as? [String: Any?] {
                var model = StartRtcCloudRecordingRequest.StorageParams.OSSParams()
                model.fromMap(value)
                self.OSSParams = model
            }
            if let value = dict["StorageType"] as? Int32 {
                self.storageType = value
            }
            if let value = dict["VodParams"] as? [String: Any?] {
                var model = StartRtcCloudRecordingRequest.StorageParams.VodParams()
                model.fromMap(value)
                self.vodParams = model
            }
        }
    }
    public class SubscribeParams : Tea.TeaModel {
        public class SubscribeUserIdList : Tea.TeaModel {
            public var sourceType: Int32?

            public var streamType: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SourceType"] as? Int32 {
                    self.sourceType = value
                }
                if let value = dict["StreamType"] as? Int32 {
                    self.streamType = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var subscribeUserIdList: [StartRtcCloudRecordingRequest.SubscribeParams.SubscribeUserIdList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subscribeUserIdList != nil {
                var tmp : [Any] = []
                for k in self.subscribeUserIdList! {
                    tmp.append(k.toMap())
                }
                map["SubscribeUserIdList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SubscribeUserIdList"] as? [Any?] {
                var tmp : [StartRtcCloudRecordingRequest.SubscribeParams.SubscribeUserIdList] = []
                for v in value {
                    if v != nil {
                        var model = StartRtcCloudRecordingRequest.SubscribeParams.SubscribeUserIdList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.subscribeUserIdList = tmp
            }
        }
    }
    public var appId: String?

    public var channelId: String?

    public var maxIdleTime: Int64?

    public var mixLayoutParams: StartRtcCloudRecordingRequest.MixLayoutParams?

    public var mixTranscodeParams: StartRtcCloudRecordingRequest.MixTranscodeParams?

    public var notifyAuthKey: String?

    public var notifyFileUploadedFormat: [String]?

    public var notifyUrl: String?

    public var recordParams: StartRtcCloudRecordingRequest.RecordParams?

    public var storageParams: StartRtcCloudRecordingRequest.StorageParams?

    public var subscribeParams: StartRtcCloudRecordingRequest.SubscribeParams?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mixLayoutParams?.validate()
        try self.mixTranscodeParams?.validate()
        try self.recordParams?.validate()
        try self.storageParams?.validate()
        try self.subscribeParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.maxIdleTime != nil {
            map["MaxIdleTime"] = self.maxIdleTime!
        }
        if self.mixLayoutParams != nil {
            map["MixLayoutParams"] = self.mixLayoutParams?.toMap()
        }
        if self.mixTranscodeParams != nil {
            map["MixTranscodeParams"] = self.mixTranscodeParams?.toMap()
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyFileUploadedFormat != nil {
            map["NotifyFileUploadedFormat"] = self.notifyFileUploadedFormat!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordParams != nil {
            map["RecordParams"] = self.recordParams?.toMap()
        }
        if self.storageParams != nil {
            map["StorageParams"] = self.storageParams?.toMap()
        }
        if self.subscribeParams != nil {
            map["SubscribeParams"] = self.subscribeParams?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["MaxIdleTime"] as? Int64 {
            self.maxIdleTime = value
        }
        if let value = dict["MixLayoutParams"] as? [String: Any?] {
            var model = StartRtcCloudRecordingRequest.MixLayoutParams()
            model.fromMap(value)
            self.mixLayoutParams = model
        }
        if let value = dict["MixTranscodeParams"] as? [String: Any?] {
            var model = StartRtcCloudRecordingRequest.MixTranscodeParams()
            model.fromMap(value)
            self.mixTranscodeParams = model
        }
        if let value = dict["NotifyAuthKey"] as? String {
            self.notifyAuthKey = value
        }
        if let value = dict["NotifyFileUploadedFormat"] as? [String] {
            self.notifyFileUploadedFormat = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["RecordParams"] as? [String: Any?] {
            var model = StartRtcCloudRecordingRequest.RecordParams()
            model.fromMap(value)
            self.recordParams = model
        }
        if let value = dict["StorageParams"] as? [String: Any?] {
            var model = StartRtcCloudRecordingRequest.StorageParams()
            model.fromMap(value)
            self.storageParams = model
        }
        if let value = dict["SubscribeParams"] as? [String: Any?] {
            var model = StartRtcCloudRecordingRequest.SubscribeParams()
            model.fromMap(value)
            self.subscribeParams = model
        }
    }
}

public class StartRtcCloudRecordingShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var maxIdleTime: Int64?

    public var mixLayoutParamsShrink: String?

    public var mixTranscodeParamsShrink: String?

    public var notifyAuthKey: String?

    public var notifyFileUploadedFormat: [String]?

    public var notifyUrl: String?

    public var recordParamsShrink: String?

    public var storageParamsShrink: String?

    public var subscribeParamsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.maxIdleTime != nil {
            map["MaxIdleTime"] = self.maxIdleTime!
        }
        if self.mixLayoutParamsShrink != nil {
            map["MixLayoutParams"] = self.mixLayoutParamsShrink!
        }
        if self.mixTranscodeParamsShrink != nil {
            map["MixTranscodeParams"] = self.mixTranscodeParamsShrink!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyFileUploadedFormat != nil {
            map["NotifyFileUploadedFormat"] = self.notifyFileUploadedFormat!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.recordParamsShrink != nil {
            map["RecordParams"] = self.recordParamsShrink!
        }
        if self.storageParamsShrink != nil {
            map["StorageParams"] = self.storageParamsShrink!
        }
        if self.subscribeParamsShrink != nil {
            map["SubscribeParams"] = self.subscribeParamsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["MaxIdleTime"] as? Int64 {
            self.maxIdleTime = value
        }
        if let value = dict["MixLayoutParams"] as? String {
            self.mixLayoutParamsShrink = value
        }
        if let value = dict["MixTranscodeParams"] as? String {
            self.mixTranscodeParamsShrink = value
        }
        if let value = dict["NotifyAuthKey"] as? String {
            self.notifyAuthKey = value
        }
        if let value = dict["NotifyFileUploadedFormat"] as? [String] {
            self.notifyFileUploadedFormat = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["RecordParams"] as? String {
            self.recordParamsShrink = value
        }
        if let value = dict["StorageParams"] as? String {
            self.storageParamsShrink = value
        }
        if let value = dict["SubscribeParams"] as? String {
            self.subscribeParamsShrink = value
        }
    }
}

public class StartRtcCloudRecordingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class StartRtcCloudRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartRtcCloudRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartRtcCloudRecordingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopCasterRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StopCasterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopCasterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopCasterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopCasterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopCasterSceneRequest : Tea.TeaModel {
    public var casterId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
    }
}

public class StopCasterSceneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopCasterSceneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopCasterSceneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopCasterSceneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopEdgeTranscodeJobRequest : Tea.TeaModel {
    public var clusterId: String?

    public var jobId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StopEdgeTranscodeJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopEdgeTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopEdgeTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopEdgeTranscodeJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopLiveDomainRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class StopLiveDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopLiveDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopLiveDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopLiveDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopLiveMPUTaskRequest : Tea.TeaModel {
    public var appId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class StopLiveMPUTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopLiveMPUTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopLiveMPUTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopLiveMPUTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopLivePullToPushRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class StopLivePullToPushResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class StopLivePullToPushResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopLivePullToPushResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopLivePullToPushResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopLiveStreamMonitorRequest : Tea.TeaModel {
    public var monitorId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MonitorId"] as? String {
            self.monitorId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StopLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopLiveStreamMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopPlaylistRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var programId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StopPlaylistResponseBody : Tea.TeaModel {
    public var programId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.programId != nil {
            map["ProgramId"] = self.programId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ProgramId"] as? String {
            self.programId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StopPlaylistResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopPlaylistResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopPlaylistResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopRtcAsrTaskRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class StopRtcAsrTaskResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var retCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetCode"] as? Int64 {
            self.retCode = value
        }
    }
}

public class StopRtcAsrTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopRtcAsrTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopRtcAsrTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopRtcCloudRecordingRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class StopRtcCloudRecordingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class StopRtcCloudRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopRtcCloudRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopRtcCloudRecordingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagLiveResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagLiveResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [TagLiveResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = TagLiveResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class TagLiveResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class TagLiveResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagLiveResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagLiveResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnTagLiveResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["All"] as? Bool {
            self.all = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKey"] as? [String] {
            self.tagKey = value
        }
    }
}

public class UnTagLiveResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnTagLiveResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnTagLiveResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnTagLiveResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnbanLiveMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var dataCenter: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.dataCenter != nil {
            map["DataCenter"] = self.dataCenter!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DataCenter"] as? String {
            self.dataCenter = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class UnbanLiveMessageGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnbanLiveMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbanLiveMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnbanLiveMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCasterResourceGroupRequest : Tea.TeaModel {
    public var casterId: String?

    public var newResourceGroupId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["NewResourceGroupId"] as? String {
            self.newResourceGroupId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class UpdateCasterResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateCasterResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCasterResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCasterResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCasterSceneAudioRequest : Tea.TeaModel {
    public class AudioLayer : Tea.TeaModel {
        public var filter: String?

        public var fixedDelayDuration: Int32?

        public var validChannel: String?

        public var volumeRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.filter != nil {
                map["Filter"] = self.filter!
            }
            if self.fixedDelayDuration != nil {
                map["FixedDelayDuration"] = self.fixedDelayDuration!
            }
            if self.validChannel != nil {
                map["ValidChannel"] = self.validChannel!
            }
            if self.volumeRate != nil {
                map["VolumeRate"] = self.volumeRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Filter"] as? String {
                self.filter = value
            }
            if let value = dict["FixedDelayDuration"] as? Int32 {
                self.fixedDelayDuration = value
            }
            if let value = dict["ValidChannel"] as? String {
                self.validChannel = value
            }
            if let value = dict["VolumeRate"] as? Double {
                self.volumeRate = value
            }
        }
    }
    public var audioLayer: [UpdateCasterSceneAudioRequest.AudioLayer]?

    public var casterId: String?

    public var followEnable: Int32?

    public var mixList: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioLayer != nil {
            var tmp : [Any] = []
            for k in self.audioLayer! {
                tmp.append(k.toMap())
            }
            map["AudioLayer"] = tmp
        }
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.followEnable != nil {
            map["FollowEnable"] = self.followEnable!
        }
        if self.mixList != nil {
            map["MixList"] = self.mixList!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AudioLayer"] as? [Any?] {
            var tmp : [UpdateCasterSceneAudioRequest.AudioLayer] = []
            for v in value {
                if v != nil {
                    var model = UpdateCasterSceneAudioRequest.AudioLayer()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.audioLayer = tmp
        }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["FollowEnable"] as? Int32 {
            self.followEnable = value
        }
        if let value = dict["MixList"] as? [String] {
            self.mixList = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
    }
}

public class UpdateCasterSceneAudioResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateCasterSceneAudioResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCasterSceneAudioResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCasterSceneAudioResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCasterSceneConfigRequest : Tea.TeaModel {
    public var casterId: String?

    public var componentId: [String]?

    public var layoutId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sceneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.casterId != nil {
            map["CasterId"] = self.casterId!
        }
        if self.componentId != nil {
            map["ComponentId"] = self.componentId!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sceneId != nil {
            map["SceneId"] = self.sceneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CasterId"] as? String {
            self.casterId = value
        }
        if let value = dict["ComponentId"] as? [String] {
            self.componentId = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SceneId"] as? String {
            self.sceneId = value
        }
    }
}

public class UpdateCasterSceneConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateCasterSceneConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCasterSceneConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCasterSceneConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCustomLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var audioBitrate: Int32?

    public var audioChannelNum: Int32?

    public var audioCodec: String?

    public var audioProfile: String?

    public var audioRate: Int32?

    public var bitrateWithSource: String?

    public var deInterlaced: Bool?

    public var domain: String?

    public var encryptParameters: String?

    public var extWithSource: String?

    public var FPS: Int32?

    public var fpsWithSource: String?

    public var gop: String?

    public var height: Int32?

    public var lazy_: String?

    public var ownerId: Int64?

    public var profile: Int32?

    public var regionId: String?

    public var resWithSource: String?

    public var template: String?

    public var templateType: String?

    public var videoBitrate: Int32?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.audioBitrate != nil {
            map["AudioBitrate"] = self.audioBitrate!
        }
        if self.audioChannelNum != nil {
            map["AudioChannelNum"] = self.audioChannelNum!
        }
        if self.audioCodec != nil {
            map["AudioCodec"] = self.audioCodec!
        }
        if self.audioProfile != nil {
            map["AudioProfile"] = self.audioProfile!
        }
        if self.audioRate != nil {
            map["AudioRate"] = self.audioRate!
        }
        if self.bitrateWithSource != nil {
            map["BitrateWithSource"] = self.bitrateWithSource!
        }
        if self.deInterlaced != nil {
            map["DeInterlaced"] = self.deInterlaced!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.encryptParameters != nil {
            map["EncryptParameters"] = self.encryptParameters!
        }
        if self.extWithSource != nil {
            map["ExtWithSource"] = self.extWithSource!
        }
        if self.FPS != nil {
            map["FPS"] = self.FPS!
        }
        if self.fpsWithSource != nil {
            map["FpsWithSource"] = self.fpsWithSource!
        }
        if self.gop != nil {
            map["Gop"] = self.gop!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.lazy_ != nil {
            map["Lazy"] = self.lazy_!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.profile != nil {
            map["Profile"] = self.profile!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resWithSource != nil {
            map["ResWithSource"] = self.resWithSource!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.videoBitrate != nil {
            map["VideoBitrate"] = self.videoBitrate!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["AudioBitrate"] as? Int32 {
            self.audioBitrate = value
        }
        if let value = dict["AudioChannelNum"] as? Int32 {
            self.audioChannelNum = value
        }
        if let value = dict["AudioCodec"] as? String {
            self.audioCodec = value
        }
        if let value = dict["AudioProfile"] as? String {
            self.audioProfile = value
        }
        if let value = dict["AudioRate"] as? Int32 {
            self.audioRate = value
        }
        if let value = dict["BitrateWithSource"] as? String {
            self.bitrateWithSource = value
        }
        if let value = dict["DeInterlaced"] as? Bool {
            self.deInterlaced = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["EncryptParameters"] as? String {
            self.encryptParameters = value
        }
        if let value = dict["ExtWithSource"] as? String {
            self.extWithSource = value
        }
        if let value = dict["FPS"] as? Int32 {
            self.FPS = value
        }
        if let value = dict["FpsWithSource"] as? String {
            self.fpsWithSource = value
        }
        if let value = dict["Gop"] as? String {
            self.gop = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["Lazy"] as? String {
            self.lazy_ = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Profile"] as? Int32 {
            self.profile = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResWithSource"] as? String {
            self.resWithSource = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
        if let value = dict["TemplateType"] as? String {
            self.templateType = value
        }
        if let value = dict["VideoBitrate"] as? Int32 {
            self.videoBitrate = value
        }
        if let value = dict["Width"] as? Int32 {
            self.width = value
        }
    }
}

public class UpdateCustomLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateCustomLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCustomLiveStreamTranscodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateEdgeTranscodeJobRequest : Tea.TeaModel {
    public var clusterId: String?

    public var jobId: String?

    public var name: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamInput: String?

    public var streamOutput: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamInput != nil {
            map["StreamInput"] = self.streamInput!
        }
        if self.streamOutput != nil {
            map["StreamOutput"] = self.streamOutput!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterId"] as? String {
            self.clusterId = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamInput"] as? String {
            self.streamInput = value
        }
        if let value = dict["StreamOutput"] as? String {
            self.streamOutput = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class UpdateEdgeTranscodeJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateEdgeTranscodeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEdgeTranscodeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateEdgeTranscodeJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateEventSubRequest : Tea.TeaModel {
    public var appId: String?

    public var callbackUrl: String?

    public var channelId: String?

    public var events: [String]?

    public var subscribeId: String?

    public var users: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.events != nil {
            map["Events"] = self.events!
        }
        if self.subscribeId != nil {
            map["SubscribeId"] = self.subscribeId!
        }
        if self.users != nil {
            map["Users"] = self.users!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["Events"] as? [String] {
            self.events = value
        }
        if let value = dict["SubscribeId"] as? String {
            self.subscribeId = value
        }
        if let value = dict["Users"] as? [String] {
            self.users = value
        }
    }
}

public class UpdateEventSubResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateEventSubResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEventSubResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateEventSubResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveAIProduceRulesRequest : Tea.TeaModel {
    public var app: String?

    public var description_: String?

    public var domain: String?

    public var isLazy: Bool?

    public var liveTemplate: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var rulesId: String?

    public var studioName: String?

    public var subtitleId: String?

    public var subtitleName: String?

    public var suffix: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.isLazy != nil {
            map["IsLazy"] = self.isLazy!
        }
        if self.liveTemplate != nil {
            map["LiveTemplate"] = self.liveTemplate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rulesId != nil {
            map["RulesId"] = self.rulesId!
        }
        if self.studioName != nil {
            map["StudioName"] = self.studioName!
        }
        if self.subtitleId != nil {
            map["SubtitleId"] = self.subtitleId!
        }
        if self.subtitleName != nil {
            map["SubtitleName"] = self.subtitleName!
        }
        if self.suffix != nil {
            map["Suffix"] = self.suffix!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["IsLazy"] as? Bool {
            self.isLazy = value
        }
        if let value = dict["LiveTemplate"] as? String {
            self.liveTemplate = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RulesId"] as? String {
            self.rulesId = value
        }
        if let value = dict["StudioName"] as? String {
            self.studioName = value
        }
        if let value = dict["SubtitleId"] as? String {
            self.subtitleId = value
        }
        if let value = dict["SubtitleName"] as? String {
            self.subtitleName = value
        }
        if let value = dict["Suffix"] as? String {
            self.suffix = value
        }
    }
}

public class UpdateLiveAIProduceRulesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveAIProduceRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveAIProduceRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveAIProduceRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveAISubtitleRequest : Tea.TeaModel {
    public var bgColor: String?

    public var bgWidthNormalized: Double?

    public var borderWidthNormalized: Double?

    public var description_: String?

    public var dstLanguage: String?

    public var fontColor: String?

    public var fontName: String?

    public var fontSizeNormalized: Double?

    public var height: String?

    public var maxLines: Int32?

    public var ownerId: Int64?

    public var positionNormalized: [Double]?

    public var regionId: String?

    public var showSourceLan: Bool?

    public var srcLanguage: String?

    public var subtitleId: String?

    public var subtitleName: String?

    public var width: String?

    public var wordPerLine: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgColor != nil {
            map["BgColor"] = self.bgColor!
        }
        if self.bgWidthNormalized != nil {
            map["BgWidthNormalized"] = self.bgWidthNormalized!
        }
        if self.borderWidthNormalized != nil {
            map["BorderWidthNormalized"] = self.borderWidthNormalized!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dstLanguage != nil {
            map["DstLanguage"] = self.dstLanguage!
        }
        if self.fontColor != nil {
            map["FontColor"] = self.fontColor!
        }
        if self.fontName != nil {
            map["FontName"] = self.fontName!
        }
        if self.fontSizeNormalized != nil {
            map["FontSizeNormalized"] = self.fontSizeNormalized!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.maxLines != nil {
            map["MaxLines"] = self.maxLines!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.positionNormalized != nil {
            map["PositionNormalized"] = self.positionNormalized!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showSourceLan != nil {
            map["ShowSourceLan"] = self.showSourceLan!
        }
        if self.srcLanguage != nil {
            map["SrcLanguage"] = self.srcLanguage!
        }
        if self.subtitleId != nil {
            map["SubtitleId"] = self.subtitleId!
        }
        if self.subtitleName != nil {
            map["SubtitleName"] = self.subtitleName!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        if self.wordPerLine != nil {
            map["WordPerLine"] = self.wordPerLine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgColor"] as? String {
            self.bgColor = value
        }
        if let value = dict["BgWidthNormalized"] as? Double {
            self.bgWidthNormalized = value
        }
        if let value = dict["BorderWidthNormalized"] as? Double {
            self.borderWidthNormalized = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DstLanguage"] as? String {
            self.dstLanguage = value
        }
        if let value = dict["FontColor"] as? String {
            self.fontColor = value
        }
        if let value = dict["FontName"] as? String {
            self.fontName = value
        }
        if let value = dict["FontSizeNormalized"] as? Double {
            self.fontSizeNormalized = value
        }
        if let value = dict["Height"] as? String {
            self.height = value
        }
        if let value = dict["MaxLines"] as? Int32 {
            self.maxLines = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PositionNormalized"] as? [Double] {
            self.positionNormalized = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowSourceLan"] as? Bool {
            self.showSourceLan = value
        }
        if let value = dict["SrcLanguage"] as? String {
            self.srcLanguage = value
        }
        if let value = dict["SubtitleId"] as? String {
            self.subtitleId = value
        }
        if let value = dict["SubtitleName"] as? String {
            self.subtitleName = value
        }
        if let value = dict["Width"] as? String {
            self.width = value
        }
        if let value = dict["WordPerLine"] as? Int32 {
            self.wordPerLine = value
        }
    }
}

public class UpdateLiveAISubtitleShrinkRequest : Tea.TeaModel {
    public var bgColor: String?

    public var bgWidthNormalized: Double?

    public var borderWidthNormalized: Double?

    public var description_: String?

    public var dstLanguage: String?

    public var fontColor: String?

    public var fontName: String?

    public var fontSizeNormalized: Double?

    public var height: String?

    public var maxLines: Int32?

    public var ownerId: Int64?

    public var positionNormalizedShrink: String?

    public var regionId: String?

    public var showSourceLan: Bool?

    public var srcLanguage: String?

    public var subtitleId: String?

    public var subtitleName: String?

    public var width: String?

    public var wordPerLine: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bgColor != nil {
            map["BgColor"] = self.bgColor!
        }
        if self.bgWidthNormalized != nil {
            map["BgWidthNormalized"] = self.bgWidthNormalized!
        }
        if self.borderWidthNormalized != nil {
            map["BorderWidthNormalized"] = self.borderWidthNormalized!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dstLanguage != nil {
            map["DstLanguage"] = self.dstLanguage!
        }
        if self.fontColor != nil {
            map["FontColor"] = self.fontColor!
        }
        if self.fontName != nil {
            map["FontName"] = self.fontName!
        }
        if self.fontSizeNormalized != nil {
            map["FontSizeNormalized"] = self.fontSizeNormalized!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.maxLines != nil {
            map["MaxLines"] = self.maxLines!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.positionNormalizedShrink != nil {
            map["PositionNormalized"] = self.positionNormalizedShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.showSourceLan != nil {
            map["ShowSourceLan"] = self.showSourceLan!
        }
        if self.srcLanguage != nil {
            map["SrcLanguage"] = self.srcLanguage!
        }
        if self.subtitleId != nil {
            map["SubtitleId"] = self.subtitleId!
        }
        if self.subtitleName != nil {
            map["SubtitleName"] = self.subtitleName!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        if self.wordPerLine != nil {
            map["WordPerLine"] = self.wordPerLine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BgColor"] as? String {
            self.bgColor = value
        }
        if let value = dict["BgWidthNormalized"] as? Double {
            self.bgWidthNormalized = value
        }
        if let value = dict["BorderWidthNormalized"] as? Double {
            self.borderWidthNormalized = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DstLanguage"] as? String {
            self.dstLanguage = value
        }
        if let value = dict["FontColor"] as? String {
            self.fontColor = value
        }
        if let value = dict["FontName"] as? String {
            self.fontName = value
        }
        if let value = dict["FontSizeNormalized"] as? Double {
            self.fontSizeNormalized = value
        }
        if let value = dict["Height"] as? String {
            self.height = value
        }
        if let value = dict["MaxLines"] as? Int32 {
            self.maxLines = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PositionNormalized"] as? String {
            self.positionNormalizedShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ShowSourceLan"] as? Bool {
            self.showSourceLan = value
        }
        if let value = dict["SrcLanguage"] as? String {
            self.srcLanguage = value
        }
        if let value = dict["SubtitleId"] as? String {
            self.subtitleId = value
        }
        if let value = dict["SubtitleName"] as? String {
            self.subtitleName = value
        }
        if let value = dict["Width"] as? String {
            self.width = value
        }
        if let value = dict["WordPerLine"] as? Int32 {
            self.wordPerLine = value
        }
    }
}

public class UpdateLiveAISubtitleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveAISubtitleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveAISubtitleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveAISubtitleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveAppRecordConfigRequest : Tea.TeaModel {
    public class RecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var sliceDuration: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CycleDuration"] as? Int32 {
                self.cycleDuration = value
            }
            if let value = dict["Format"] as? String {
                self.format = value
            }
            if let value = dict["SliceDuration"] as? Int32 {
                self.sliceDuration = value
            }
        }
    }
    public class TranscodeRecordFormat : Tea.TeaModel {
        public var cycleDuration: Int32?

        public var format: String?

        public var sliceDuration: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cycleDuration != nil {
                map["CycleDuration"] = self.cycleDuration!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.sliceDuration != nil {
                map["SliceDuration"] = self.sliceDuration!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CycleDuration"] as? Int32 {
                self.cycleDuration = value
            }
            if let value = dict["Format"] as? String {
                self.format = value
            }
            if let value = dict["SliceDuration"] as? Int32 {
                self.sliceDuration = value
            }
        }
    }
    public var appName: String?

    public var delayTime: Int32?

    public var domainName: String?

    public var endTime: String?

    public var onDemand: Int32?

    public var ossEndpoint: String?

    public var ownerId: Int64?

    public var recordFormat: [UpdateLiveAppRecordConfigRequest.RecordFormat]?

    public var securityToken: String?

    public var startTime: String?

    public var streamName: String?

    public var transcodeRecordFormat: [UpdateLiveAppRecordConfigRequest.TranscodeRecordFormat]?

    public var transcodeTemplates: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.delayTime != nil {
            map["DelayTime"] = self.delayTime!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.onDemand != nil {
            map["OnDemand"] = self.onDemand!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.recordFormat != nil {
            var tmp : [Any] = []
            for k in self.recordFormat! {
                tmp.append(k.toMap())
            }
            map["RecordFormat"] = tmp
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.transcodeRecordFormat != nil {
            var tmp : [Any] = []
            for k in self.transcodeRecordFormat! {
                tmp.append(k.toMap())
            }
            map["TranscodeRecordFormat"] = tmp
        }
        if self.transcodeTemplates != nil {
            map["TranscodeTemplates"] = self.transcodeTemplates!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DelayTime"] as? Int32 {
            self.delayTime = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OnDemand"] as? Int32 {
            self.onDemand = value
        }
        if let value = dict["OssEndpoint"] as? String {
            self.ossEndpoint = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RecordFormat"] as? [Any?] {
            var tmp : [UpdateLiveAppRecordConfigRequest.RecordFormat] = []
            for v in value {
                if v != nil {
                    var model = UpdateLiveAppRecordConfigRequest.RecordFormat()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.recordFormat = tmp
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["TranscodeRecordFormat"] as? [Any?] {
            var tmp : [UpdateLiveAppRecordConfigRequest.TranscodeRecordFormat] = []
            for v in value {
                if v != nil {
                    var model = UpdateLiveAppRecordConfigRequest.TranscodeRecordFormat()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.transcodeRecordFormat = tmp
        }
        if let value = dict["TranscodeTemplates"] as? [String] {
            self.transcodeTemplates = value
        }
    }
}

public class UpdateLiveAppRecordConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveAppRecordConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveAppRecordConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveAppRecordConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveAppSnapshotConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var callback: String?

    public var domainName: String?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var overwriteOssObject: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public var sequenceOssObject: String?

    public var timeInterval: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.callback != nil {
            map["Callback"] = self.callback!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.overwriteOssObject != nil {
            map["OverwriteOssObject"] = self.overwriteOssObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sequenceOssObject != nil {
            map["SequenceOssObject"] = self.sequenceOssObject!
        }
        if self.timeInterval != nil {
            map["TimeInterval"] = self.timeInterval!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Callback"] as? String {
            self.callback = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OssBucket"] as? String {
            self.ossBucket = value
        }
        if let value = dict["OssEndpoint"] as? String {
            self.ossEndpoint = value
        }
        if let value = dict["OverwriteOssObject"] as? String {
            self.overwriteOssObject = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
        if let value = dict["SequenceOssObject"] as? String {
            self.sequenceOssObject = value
        }
        if let value = dict["TimeInterval"] as? Int32 {
            self.timeInterval = value
        }
    }
}

public class UpdateLiveAppSnapshotConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveAppSnapshotConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveAppSnapshotConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveAppSnapshotConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveAudioAuditConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var bizType: String?

    public var domainName: String?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["BizType"] as? String {
            self.bizType = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OssBucket"] as? String {
            self.ossBucket = value
        }
        if let value = dict["OssEndpoint"] as? String {
            self.ossEndpoint = value
        }
        if let value = dict["OssObject"] as? String {
            self.ossObject = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class UpdateLiveAudioAuditConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveAudioAuditConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveAudioAuditConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveAudioAuditConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveAudioAuditNotifyConfigRequest : Tea.TeaModel {
    public var callback: String?

    public var callbackTemplate: String?

    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callback != nil {
            map["Callback"] = self.callback!
        }
        if self.callbackTemplate != nil {
            map["CallbackTemplate"] = self.callbackTemplate!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Callback"] as? String {
            self.callback = value
        }
        if let value = dict["CallbackTemplate"] as? String {
            self.callbackTemplate = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class UpdateLiveAudioAuditNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveAudioAuditNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveAudioAuditNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveAudioAuditNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveCenterTransferRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var dstUrl: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var startTime: String?

    public var streamName: String?

    public var transferArgs: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.dstUrl != nil {
            map["DstUrl"] = self.dstUrl!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.transferArgs != nil {
            map["TransferArgs"] = self.transferArgs!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["DstUrl"] as? String {
            self.dstUrl = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["TransferArgs"] as? String {
            self.transferArgs = value
        }
    }
}

public class UpdateLiveCenterTransferResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveCenterTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveCenterTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveCenterTransferResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveDelayConfigRequest : Tea.TeaModel {
    public var app: String?

    public var delayTime: Int32?

    public var domain: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var stream: String?

    public var taskTriggerMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.delayTime != nil {
            map["DelayTime"] = self.delayTime!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        if self.taskTriggerMode != nil {
            map["TaskTriggerMode"] = self.taskTriggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["DelayTime"] as? Int32 {
            self.delayTime = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
        if let value = dict["TaskTriggerMode"] as? String {
            self.taskTriggerMode = value
        }
    }
}

public class UpdateLiveDelayConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveDelayConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveDelayConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveDelayConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveDetectNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class UpdateLiveDetectNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveDetectNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveDetectNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveDetectNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveMPUTaskRequest : Tea.TeaModel {
    public class MultiStreamURL : Tea.TeaModel {
        public var isAliCdn: Bool?

        public var URL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.isAliCdn != nil {
                map["IsAliCdn"] = self.isAliCdn!
            }
            if self.URL != nil {
                map["URL"] = self.URL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IsAliCdn"] as? Bool {
                self.isAliCdn = value
            }
            if let value = dict["URL"] as? String {
                self.URL = value
            }
        }
    }
    public class SeiParams : Tea.TeaModel {
        public class LayoutVolume : Tea.TeaModel {
            public var followIdr: String?

            public var interval: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.followIdr != nil {
                    map["FollowIdr"] = self.followIdr!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FollowIdr"] as? String {
                    self.followIdr = value
                }
                if let value = dict["Interval"] as? String {
                    self.interval = value
                }
            }
        }
        public class PassThrough : Tea.TeaModel {
            public var followIdr: String?

            public var interval: String?

            public var payloadContent: String?

            public var payloadContentKey: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.followIdr != nil {
                    map["FollowIdr"] = self.followIdr!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.payloadContent != nil {
                    map["PayloadContent"] = self.payloadContent!
                }
                if self.payloadContentKey != nil {
                    map["PayloadContentKey"] = self.payloadContentKey!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FollowIdr"] as? String {
                    self.followIdr = value
                }
                if let value = dict["Interval"] as? String {
                    self.interval = value
                }
                if let value = dict["PayloadContent"] as? String {
                    self.payloadContent = value
                }
                if let value = dict["PayloadContentKey"] as? String {
                    self.payloadContentKey = value
                }
            }
        }
        public var layoutVolume: UpdateLiveMPUTaskRequest.SeiParams.LayoutVolume?

        public var passThrough: UpdateLiveMPUTaskRequest.SeiParams.PassThrough?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.layoutVolume?.validate()
            try self.passThrough?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.layoutVolume != nil {
                map["LayoutVolume"] = self.layoutVolume?.toMap()
            }
            if self.passThrough != nil {
                map["PassThrough"] = self.passThrough?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LayoutVolume"] as? [String: Any?] {
                var model = UpdateLiveMPUTaskRequest.SeiParams.LayoutVolume()
                model.fromMap(value)
                self.layoutVolume = model
            }
            if let value = dict["PassThrough"] as? [String: Any?] {
                var model = UpdateLiveMPUTaskRequest.SeiParams.PassThrough()
                model.fromMap(value)
                self.passThrough = model
            }
        }
    }
    public class SingleSubParams : Tea.TeaModel {
        public var sourceType: String?

        public var streamType: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceType != nil {
                map["SourceType"] = self.sourceType!
            }
            if self.streamType != nil {
                map["StreamType"] = self.streamType!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["StreamType"] as? String {
                self.streamType = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public class TranscodeParams : Tea.TeaModel {
        public class Background : Tea.TeaModel {
            public var renderMode: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.renderMode != nil {
                    map["RenderMode"] = self.renderMode!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RenderMode"] as? String {
                    self.renderMode = value
                }
                if let value = dict["URL"] as? String {
                    self.URL = value
                }
            }
        }
        public class EncodeParams : Tea.TeaModel {
            public var audioBitrate: String?

            public var audioChannels: String?

            public var audioOnly: String?

            public var audioSampleRate: String?

            public var enhancedParam: String?

            public var videoBitrate: String?

            public var videoCodec: String?

            public var videoFramerate: String?

            public var videoGop: String?

            public var videoHeight: String?

            public var videoWidth: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioBitrate != nil {
                    map["AudioBitrate"] = self.audioBitrate!
                }
                if self.audioChannels != nil {
                    map["AudioChannels"] = self.audioChannels!
                }
                if self.audioOnly != nil {
                    map["AudioOnly"] = self.audioOnly!
                }
                if self.audioSampleRate != nil {
                    map["AudioSampleRate"] = self.audioSampleRate!
                }
                if self.enhancedParam != nil {
                    map["EnhancedParam"] = self.enhancedParam!
                }
                if self.videoBitrate != nil {
                    map["VideoBitrate"] = self.videoBitrate!
                }
                if self.videoCodec != nil {
                    map["VideoCodec"] = self.videoCodec!
                }
                if self.videoFramerate != nil {
                    map["VideoFramerate"] = self.videoFramerate!
                }
                if self.videoGop != nil {
                    map["VideoGop"] = self.videoGop!
                }
                if self.videoHeight != nil {
                    map["VideoHeight"] = self.videoHeight!
                }
                if self.videoWidth != nil {
                    map["VideoWidth"] = self.videoWidth!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AudioBitrate"] as? String {
                    self.audioBitrate = value
                }
                if let value = dict["AudioChannels"] as? String {
                    self.audioChannels = value
                }
                if let value = dict["AudioOnly"] as? String {
                    self.audioOnly = value
                }
                if let value = dict["AudioSampleRate"] as? String {
                    self.audioSampleRate = value
                }
                if let value = dict["EnhancedParam"] as? String {
                    self.enhancedParam = value
                }
                if let value = dict["VideoBitrate"] as? String {
                    self.videoBitrate = value
                }
                if let value = dict["VideoCodec"] as? String {
                    self.videoCodec = value
                }
                if let value = dict["VideoFramerate"] as? String {
                    self.videoFramerate = value
                }
                if let value = dict["VideoGop"] as? String {
                    self.videoGop = value
                }
                if let value = dict["VideoHeight"] as? String {
                    self.videoHeight = value
                }
                if let value = dict["VideoWidth"] as? String {
                    self.videoWidth = value
                }
            }
        }
        public class Layout : Tea.TeaModel {
            public class UserPanes : Tea.TeaModel {
                public class UserInfo : Tea.TeaModel {
                    public var channelId: String?

                    public var sourceType: String?

                    public var userId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.channelId != nil {
                            map["ChannelId"] = self.channelId!
                        }
                        if self.sourceType != nil {
                            map["SourceType"] = self.sourceType!
                        }
                        if self.userId != nil {
                            map["UserId"] = self.userId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ChannelId"] as? String {
                            self.channelId = value
                        }
                        if let value = dict["SourceType"] as? String {
                            self.sourceType = value
                        }
                        if let value = dict["UserId"] as? String {
                            self.userId = value
                        }
                    }
                }
                public var backgroundImageUrl: String?

                public var height: String?

                public var renderMode: String?

                public var userInfo: UpdateLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes.UserInfo?

                public var width: String?

                public var x: String?

                public var y: String?

                public var ZOrder: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.userInfo?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.backgroundImageUrl != nil {
                        map["BackgroundImageUrl"] = self.backgroundImageUrl!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.renderMode != nil {
                        map["RenderMode"] = self.renderMode!
                    }
                    if self.userInfo != nil {
                        map["UserInfo"] = self.userInfo?.toMap()
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    if self.x != nil {
                        map["X"] = self.x!
                    }
                    if self.y != nil {
                        map["Y"] = self.y!
                    }
                    if self.ZOrder != nil {
                        map["ZOrder"] = self.ZOrder!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BackgroundImageUrl"] as? String {
                        self.backgroundImageUrl = value
                    }
                    if let value = dict["Height"] as? String {
                        self.height = value
                    }
                    if let value = dict["RenderMode"] as? String {
                        self.renderMode = value
                    }
                    if let value = dict["UserInfo"] as? [String: Any?] {
                        var model = UpdateLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes.UserInfo()
                        model.fromMap(value)
                        self.userInfo = model
                    }
                    if let value = dict["Width"] as? String {
                        self.width = value
                    }
                    if let value = dict["X"] as? String {
                        self.x = value
                    }
                    if let value = dict["Y"] as? String {
                        self.y = value
                    }
                    if let value = dict["ZOrder"] as? String {
                        self.ZOrder = value
                    }
                }
            }
            public var userPanes: [UpdateLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.userPanes != nil {
                    var tmp : [Any] = []
                    for k in self.userPanes! {
                        tmp.append(k.toMap())
                    }
                    map["UserPanes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["UserPanes"] as? [Any?] {
                    var tmp : [UpdateLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateLiveMPUTaskRequest.TranscodeParams.Layout.UserPanes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.userPanes = tmp
                }
            }
        }
        public class UserInfos : Tea.TeaModel {
            public var channelId: String?

            public var sourceType: String?

            public var streamType: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ChannelId"] as? String {
                    self.channelId = value
                }
                if let value = dict["SourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["StreamType"] as? String {
                    self.streamType = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var background: UpdateLiveMPUTaskRequest.TranscodeParams.Background?

        public var encodeParams: UpdateLiveMPUTaskRequest.TranscodeParams.EncodeParams?

        public var layout: UpdateLiveMPUTaskRequest.TranscodeParams.Layout?

        public var userInfos: [UpdateLiveMPUTaskRequest.TranscodeParams.UserInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.background?.validate()
            try self.encodeParams?.validate()
            try self.layout?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.background != nil {
                map["Background"] = self.background?.toMap()
            }
            if self.encodeParams != nil {
                map["EncodeParams"] = self.encodeParams?.toMap()
            }
            if self.layout != nil {
                map["Layout"] = self.layout?.toMap()
            }
            if self.userInfos != nil {
                var tmp : [Any] = []
                for k in self.userInfos! {
                    tmp.append(k.toMap())
                }
                map["UserInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Background"] as? [String: Any?] {
                var model = UpdateLiveMPUTaskRequest.TranscodeParams.Background()
                model.fromMap(value)
                self.background = model
            }
            if let value = dict["EncodeParams"] as? [String: Any?] {
                var model = UpdateLiveMPUTaskRequest.TranscodeParams.EncodeParams()
                model.fromMap(value)
                self.encodeParams = model
            }
            if let value = dict["Layout"] as? [String: Any?] {
                var model = UpdateLiveMPUTaskRequest.TranscodeParams.Layout()
                model.fromMap(value)
                self.layout = model
            }
            if let value = dict["UserInfos"] as? [Any?] {
                var tmp : [UpdateLiveMPUTaskRequest.TranscodeParams.UserInfos] = []
                for v in value {
                    if v != nil {
                        var model = UpdateLiveMPUTaskRequest.TranscodeParams.UserInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.userInfos = tmp
            }
        }
    }
    public var appId: String?

    public var channelId: String?

    public var mixMode: String?

    public var multiStreamURL: [UpdateLiveMPUTaskRequest.MultiStreamURL]?

    public var seiParams: UpdateLiveMPUTaskRequest.SeiParams?

    public var singleSubParams: UpdateLiveMPUTaskRequest.SingleSubParams?

    public var streamURL: String?

    public var taskId: String?

    public var transcodeParams: UpdateLiveMPUTaskRequest.TranscodeParams?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.seiParams?.validate()
        try self.singleSubParams?.validate()
        try self.transcodeParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.mixMode != nil {
            map["MixMode"] = self.mixMode!
        }
        if self.multiStreamURL != nil {
            var tmp : [Any] = []
            for k in self.multiStreamURL! {
                tmp.append(k.toMap())
            }
            map["MultiStreamURL"] = tmp
        }
        if self.seiParams != nil {
            map["SeiParams"] = self.seiParams?.toMap()
        }
        if self.singleSubParams != nil {
            map["SingleSubParams"] = self.singleSubParams?.toMap()
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.transcodeParams != nil {
            map["TranscodeParams"] = self.transcodeParams?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["MixMode"] as? String {
            self.mixMode = value
        }
        if let value = dict["MultiStreamURL"] as? [Any?] {
            var tmp : [UpdateLiveMPUTaskRequest.MultiStreamURL] = []
            for v in value {
                if v != nil {
                    var model = UpdateLiveMPUTaskRequest.MultiStreamURL()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.multiStreamURL = tmp
        }
        if let value = dict["SeiParams"] as? [String: Any?] {
            var model = UpdateLiveMPUTaskRequest.SeiParams()
            model.fromMap(value)
            self.seiParams = model
        }
        if let value = dict["SingleSubParams"] as? [String: Any?] {
            var model = UpdateLiveMPUTaskRequest.SingleSubParams()
            model.fromMap(value)
            self.singleSubParams = model
        }
        if let value = dict["StreamURL"] as? String {
            self.streamURL = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TranscodeParams"] as? [String: Any?] {
            var model = UpdateLiveMPUTaskRequest.TranscodeParams()
            model.fromMap(value)
            self.transcodeParams = model
        }
    }
}

public class UpdateLiveMPUTaskShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var channelId: String?

    public var mixMode: String?

    public var multiStreamURLShrink: String?

    public var seiParamsShrink: String?

    public var singleSubParamsShrink: String?

    public var streamURL: String?

    public var taskId: String?

    public var transcodeParamsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.mixMode != nil {
            map["MixMode"] = self.mixMode!
        }
        if self.multiStreamURLShrink != nil {
            map["MultiStreamURL"] = self.multiStreamURLShrink!
        }
        if self.seiParamsShrink != nil {
            map["SeiParams"] = self.seiParamsShrink!
        }
        if self.singleSubParamsShrink != nil {
            map["SingleSubParams"] = self.singleSubParamsShrink!
        }
        if self.streamURL != nil {
            map["StreamURL"] = self.streamURL!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.transcodeParamsShrink != nil {
            map["TranscodeParams"] = self.transcodeParamsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ChannelId"] as? String {
            self.channelId = value
        }
        if let value = dict["MixMode"] as? String {
            self.mixMode = value
        }
        if let value = dict["MultiStreamURL"] as? String {
            self.multiStreamURLShrink = value
        }
        if let value = dict["SeiParams"] as? String {
            self.seiParamsShrink = value
        }
        if let value = dict["SingleSubParams"] as? String {
            self.singleSubParamsShrink = value
        }
        if let value = dict["StreamURL"] as? String {
            self.streamURL = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
        if let value = dict["TranscodeParams"] as? String {
            self.transcodeParamsShrink = value
        }
    }
}

public class UpdateLiveMPUTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveMPUTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveMPUTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveMPUTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLivePackageConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var ignoreTranscode: Bool?

    public var ownerId: Int64?

    public var partDuration: Int32?

    public var protocol_: String?

    public var regionId: String?

    public var segmentDuration: Int32?

    public var segmentNum: Int32?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ignoreTranscode != nil {
            map["IgnoreTranscode"] = self.ignoreTranscode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.partDuration != nil {
            map["PartDuration"] = self.partDuration!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.segmentDuration != nil {
            map["SegmentDuration"] = self.segmentDuration!
        }
        if self.segmentNum != nil {
            map["SegmentNum"] = self.segmentNum!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["IgnoreTranscode"] as? Bool {
            self.ignoreTranscode = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PartDuration"] as? Int32 {
            self.partDuration = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SegmentDuration"] as? Int32 {
            self.segmentDuration = value
        }
        if let value = dict["SegmentNum"] as? Int32 {
            self.segmentNum = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class UpdateLivePackageConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLivePackageConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLivePackageConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLivePackageConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLivePullStreamInfoConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var endTime: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var sourceUrl: String?

    public var startTime: String?

    public var streamName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sourceUrl != nil {
            map["SourceUrl"] = self.sourceUrl!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SourceUrl"] as? String {
            self.sourceUrl = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
    }
}

public class UpdateLivePullStreamInfoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLivePullStreamInfoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLivePullStreamInfoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLivePullStreamInfoConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLivePullToPushRequest : Tea.TeaModel {
    public var callbackUrl: String?

    public var endTime: String?

    public var fileIndex: Int32?

    public var offset: Int32?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var repeatNumber: Int32?

    public var sourceUrls: [String]?

    public var startTime: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.fileIndex != nil {
            map["FileIndex"] = self.fileIndex!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatNumber != nil {
            map["RepeatNumber"] = self.repeatNumber!
        }
        if self.sourceUrls != nil {
            map["SourceUrls"] = self.sourceUrls!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FileIndex"] as? Int32 {
            self.fileIndex = value
        }
        if let value = dict["Offset"] as? Int32 {
            self.offset = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatNumber"] as? Int32 {
            self.repeatNumber = value
        }
        if let value = dict["SourceUrls"] as? [String] {
            self.sourceUrls = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class UpdateLivePullToPushShrinkRequest : Tea.TeaModel {
    public var callbackUrl: String?

    public var endTime: String?

    public var fileIndex: Int32?

    public var offset: Int32?

    public var ownerId: Int64?

    public var region: String?

    public var regionId: String?

    public var repeatNumber: Int32?

    public var sourceUrlsShrink: String?

    public var startTime: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.fileIndex != nil {
            map["FileIndex"] = self.fileIndex!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatNumber != nil {
            map["RepeatNumber"] = self.repeatNumber!
        }
        if self.sourceUrlsShrink != nil {
            map["SourceUrls"] = self.sourceUrlsShrink!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FileIndex"] as? Int32 {
            self.fileIndex = value
        }
        if let value = dict["Offset"] as? Int32 {
            self.offset = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Region"] as? String {
            self.region = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RepeatNumber"] as? Int32 {
            self.repeatNumber = value
        }
        if let value = dict["SourceUrls"] as? String {
            self.sourceUrlsShrink = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class UpdateLivePullToPushResponseBody : Tea.TeaModel {
    public var description_: String?

    public var requestId: String?

    public var retCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retCode != nil {
            map["RetCode"] = self.retCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["RetCode"] as? Int32 {
            self.retCode = value
        }
    }
}

public class UpdateLivePullToPushResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLivePullToPushResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLivePullToPushResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveRecordNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var needStatusNotify: Bool?

    public var notifyAuthKey: String?

    public var notifyReqAuth: Bool?

    public var notifyUrl: String?

    public var onDemandUrl: String?

    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.needStatusNotify != nil {
            map["NeedStatusNotify"] = self.needStatusNotify!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.onDemandUrl != nil {
            map["OnDemandUrl"] = self.onDemandUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["NeedStatusNotify"] as? Bool {
            self.needStatusNotify = value
        }
        if let value = dict["NotifyAuthKey"] as? String {
            self.notifyAuthKey = value
        }
        if let value = dict["NotifyReqAuth"] as? Bool {
            self.notifyReqAuth = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["OnDemandUrl"] as? String {
            self.onDemandUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class UpdateLiveRecordNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveRecordNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveRecordNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveRecordNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveRecordVodConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var autoCompose: String?

    public var composeVodTranscodeGroupId: String?

    public var cycleDuration: Int32?

    public var domainName: String?

    public var onDemand: Int32?

    public var ownerId: Int64?

    public var regionId: String?

    public var streamName: String?

    public var vodTranscodeGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.autoCompose != nil {
            map["AutoCompose"] = self.autoCompose!
        }
        if self.composeVodTranscodeGroupId != nil {
            map["ComposeVodTranscodeGroupId"] = self.composeVodTranscodeGroupId!
        }
        if self.cycleDuration != nil {
            map["CycleDuration"] = self.cycleDuration!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.onDemand != nil {
            map["OnDemand"] = self.onDemand!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.streamName != nil {
            map["StreamName"] = self.streamName!
        }
        if self.vodTranscodeGroupId != nil {
            map["VodTranscodeGroupId"] = self.vodTranscodeGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AutoCompose"] as? String {
            self.autoCompose = value
        }
        if let value = dict["ComposeVodTranscodeGroupId"] as? String {
            self.composeVodTranscodeGroupId = value
        }
        if let value = dict["CycleDuration"] as? Int32 {
            self.cycleDuration = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OnDemand"] as? Int32 {
            self.onDemand = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StreamName"] as? String {
            self.streamName = value
        }
        if let value = dict["VodTranscodeGroupId"] as? String {
            self.vodTranscodeGroupId = value
        }
    }
}

public class UpdateLiveRecordVodConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveRecordVodConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveRecordVodConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveRecordVodConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveSnapshotDetectPornConfigRequest : Tea.TeaModel {
    public var appName: String?

    public var domainName: String?

    public var interval: Int32?

    public var ossBucket: String?

    public var ossEndpoint: String?

    public var ossObject: String?

    public var ownerId: Int64?

    public var scene: [String]?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossEndpoint != nil {
            map["OssEndpoint"] = self.ossEndpoint!
        }
        if self.ossObject != nil {
            map["OssObject"] = self.ossObject!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Interval"] as? Int32 {
            self.interval = value
        }
        if let value = dict["OssBucket"] as? String {
            self.ossBucket = value
        }
        if let value = dict["OssEndpoint"] as? String {
            self.ossEndpoint = value
        }
        if let value = dict["OssObject"] as? String {
            self.ossObject = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Scene"] as? [String] {
            self.scene = value
        }
        if let value = dict["SecurityToken"] as? String {
            self.securityToken = value
        }
    }
}

public class UpdateLiveSnapshotDetectPornConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveSnapshotDetectPornConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveSnapshotDetectPornConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveSnapshotDetectPornConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveSnapshotNotifyConfigRequest : Tea.TeaModel {
    public var domainName: String?

    public var notifyAuthKey: String?

    public var notifyReqAuth: String?

    public var notifyUrl: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.notifyAuthKey != nil {
            map["NotifyAuthKey"] = self.notifyAuthKey!
        }
        if self.notifyReqAuth != nil {
            map["NotifyReqAuth"] = self.notifyReqAuth!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["NotifyAuthKey"] as? String {
            self.notifyAuthKey = value
        }
        if let value = dict["NotifyReqAuth"] as? String {
            self.notifyReqAuth = value
        }
        if let value = dict["NotifyUrl"] as? String {
            self.notifyUrl = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class UpdateLiveSnapshotNotifyConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveSnapshotNotifyConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveSnapshotNotifyConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveSnapshotNotifyConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveStreamMonitorRequest : Tea.TeaModel {
    public var app: String?

    public var callbackUrl: String?

    public var dingTalkWebHookUrl: String?

    public var domain: String?

    public var inputList: String?

    public var monitorConfig: String?

    public var monitorId: String?

    public var monitorName: String?

    public var outputTemplate: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var stream: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.dingTalkWebHookUrl != nil {
            map["DingTalkWebHookUrl"] = self.dingTalkWebHookUrl!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.inputList != nil {
            map["InputList"] = self.inputList!
        }
        if self.monitorConfig != nil {
            map["MonitorConfig"] = self.monitorConfig!
        }
        if self.monitorId != nil {
            map["MonitorId"] = self.monitorId!
        }
        if self.monitorName != nil {
            map["MonitorName"] = self.monitorName!
        }
        if self.outputTemplate != nil {
            map["OutputTemplate"] = self.outputTemplate!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.stream != nil {
            map["Stream"] = self.stream!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["DingTalkWebHookUrl"] as? String {
            self.dingTalkWebHookUrl = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["InputList"] as? String {
            self.inputList = value
        }
        if let value = dict["MonitorConfig"] as? String {
            self.monitorConfig = value
        }
        if let value = dict["MonitorId"] as? String {
            self.monitorId = value
        }
        if let value = dict["MonitorName"] as? String {
            self.monitorName = value
        }
        if let value = dict["OutputTemplate"] as? String {
            self.outputTemplate = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Stream"] as? String {
            self.stream = value
        }
    }
}

public class UpdateLiveStreamMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveStreamMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveStreamMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveStreamMonitorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var domain: String?

    public var encryptParameters: String?

    public var lazy_: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var template: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.encryptParameters != nil {
            map["EncryptParameters"] = self.encryptParameters!
        }
        if self.lazy_ != nil {
            map["Lazy"] = self.lazy_!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["EncryptParameters"] as? String {
            self.encryptParameters = value
        }
        if let value = dict["Lazy"] as? String {
            self.lazy_ = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
    }
}

public class UpdateLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveStreamTranscodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveStreamWatermarkRequest : Tea.TeaModel {
    public var description_: String?

    public var height: Int32?

    public var name: String?

    public var offsetCorner: String?

    public var ownerId: Int64?

    public var pictureUrl: String?

    public var refHeight: Int32?

    public var refWidth: Int32?

    public var regionId: String?

    public var templateId: String?

    public var transparency: Int32?

    public var XOffset: Double?

    public var YOffset: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.offsetCorner != nil {
            map["OffsetCorner"] = self.offsetCorner!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pictureUrl != nil {
            map["PictureUrl"] = self.pictureUrl!
        }
        if self.refHeight != nil {
            map["RefHeight"] = self.refHeight!
        }
        if self.refWidth != nil {
            map["RefWidth"] = self.refWidth!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.transparency != nil {
            map["Transparency"] = self.transparency!
        }
        if self.XOffset != nil {
            map["XOffset"] = self.XOffset!
        }
        if self.YOffset != nil {
            map["YOffset"] = self.YOffset!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OffsetCorner"] as? String {
            self.offsetCorner = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PictureUrl"] as? String {
            self.pictureUrl = value
        }
        if let value = dict["RefHeight"] as? Int32 {
            self.refHeight = value
        }
        if let value = dict["RefWidth"] as? Int32 {
            self.refWidth = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
        if let value = dict["Transparency"] as? Int32 {
            self.transparency = value
        }
        if let value = dict["XOffset"] as? Double {
            self.XOffset = value
        }
        if let value = dict["YOffset"] as? Double {
            self.YOffset = value
        }
    }
}

public class UpdateLiveStreamWatermarkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveStreamWatermarkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveStreamWatermarkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveStreamWatermarkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLiveStreamWatermarkRuleRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var ruleId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.ruleId != nil {
            map["RuleId"] = self.ruleId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["RuleId"] as? String {
            self.ruleId = value
        }
        if let value = dict["TemplateId"] as? String {
            self.templateId = value
        }
    }
}

public class UpdateLiveStreamWatermarkRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLiveStreamWatermarkRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLiveStreamWatermarkRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLiveStreamWatermarkRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMessageAppRequest : Tea.TeaModel {
    public var appConfig: [String: String]?

    public var appId: String?

    public var appName: String?

    public var extension_: [String: String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appConfig != nil {
            map["AppConfig"] = self.appConfig!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppConfig"] as? [String: String] {
            self.appConfig = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Extension"] as? [String: String] {
            self.extension_ = value
        }
    }
}

public class UpdateMessageAppShrinkRequest : Tea.TeaModel {
    public var appConfigShrink: String?

    public var appId: String?

    public var appName: String?

    public var extensionShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appConfigShrink != nil {
            map["AppConfig"] = self.appConfigShrink!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.extensionShrink != nil {
            map["Extension"] = self.extensionShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppConfig"] as? String {
            self.appConfigShrink = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["Extension"] as? String {
            self.extensionShrink = value
        }
    }
}

public class UpdateMessageAppResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdateMessageAppResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateMessageAppResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateMessageAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMessageAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMessageAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMessageGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var extension_: [String: String]?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Extension"] as? [String: String] {
            self.extension_ = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class UpdateMessageGroupShrinkRequest : Tea.TeaModel {
    public var appId: String?

    public var extensionShrink: String?

    public var groupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.extensionShrink != nil {
            map["Extension"] = self.extensionShrink!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Extension"] as? String {
            self.extensionShrink = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
    }
}

public class UpdateMessageGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Success"] as? Bool {
                self.success = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdateMessageGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateMessageGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateMessageGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMessageGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMessageGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateMixStreamRequest : Tea.TeaModel {
    public var domainName: String?

    public var inputStreamList: String?

    public var layoutId: String?

    public var mixStreamId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.inputStreamList != nil {
            map["InputStreamList"] = self.inputStreamList!
        }
        if self.layoutId != nil {
            map["LayoutId"] = self.layoutId!
        }
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["InputStreamList"] as? String {
            self.inputStreamList = value
        }
        if let value = dict["LayoutId"] as? String {
            self.layoutId = value
        }
        if let value = dict["MixStreamId"] as? String {
            self.mixStreamId = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class UpdateMixStreamResponseBody : Tea.TeaModel {
    public var mixStreamId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixStreamId != nil {
            map["MixStreamId"] = self.mixStreamId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MixStreamId"] as? String {
            self.mixStreamId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateMixStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMixStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateMixStreamResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRtcCloudRecordingRequest : Tea.TeaModel {
    public class MixLayoutParams : Tea.TeaModel {
        public class MixBackground : Tea.TeaModel {
            public var renderMode: Int32?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.renderMode != nil {
                    map["RenderMode"] = self.renderMode!
                }
                if self.url != nil {
                    map["Url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["RenderMode"] as? Int32 {
                    self.renderMode = value
                }
                if let value = dict["Url"] as? String {
                    self.url = value
                }
            }
        }
        public class UserPanes : Tea.TeaModel {
            public class SubBackground : Tea.TeaModel {
                public var renderMode: Int32?

                public var url: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.renderMode != nil {
                        map["RenderMode"] = self.renderMode!
                    }
                    if self.url != nil {
                        map["Url"] = self.url!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RenderMode"] as? Int32 {
                        self.renderMode = value
                    }
                    if let value = dict["Url"] as? String {
                        self.url = value
                    }
                }
            }
            public var height: String?

            public var sourceType: Int32?

            public var subBackground: UpdateRtcCloudRecordingRequest.MixLayoutParams.UserPanes.SubBackground?

            public var userId: String?

            public var width: String?

            public var x: String?

            public var y: String?

            public var ZOrder: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.subBackground?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.subBackground != nil {
                    map["SubBackground"] = self.subBackground?.toMap()
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                if self.x != nil {
                    map["X"] = self.x!
                }
                if self.y != nil {
                    map["Y"] = self.y!
                }
                if self.ZOrder != nil {
                    map["ZOrder"] = self.ZOrder!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Height"] as? String {
                    self.height = value
                }
                if let value = dict["SourceType"] as? Int32 {
                    self.sourceType = value
                }
                if let value = dict["SubBackground"] as? [String: Any?] {
                    var model = UpdateRtcCloudRecordingRequest.MixLayoutParams.UserPanes.SubBackground()
                    model.fromMap(value)
                    self.subBackground = model
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
                if let value = dict["Width"] as? String {
                    self.width = value
                }
                if let value = dict["X"] as? String {
                    self.x = value
                }
                if let value = dict["Y"] as? String {
                    self.y = value
                }
                if let value = dict["ZOrder"] as? Int32 {
                    self.ZOrder = value
                }
            }
        }
        public var mixBackground: UpdateRtcCloudRecordingRequest.MixLayoutParams.MixBackground?

        public var userPanes: [UpdateRtcCloudRecordingRequest.MixLayoutParams.UserPanes]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.mixBackground?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mixBackground != nil {
                map["MixBackground"] = self.mixBackground?.toMap()
            }
            if self.userPanes != nil {
                var tmp : [Any] = []
                for k in self.userPanes! {
                    tmp.append(k.toMap())
                }
                map["UserPanes"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MixBackground"] as? [String: Any?] {
                var model = UpdateRtcCloudRecordingRequest.MixLayoutParams.MixBackground()
                model.fromMap(value)
                self.mixBackground = model
            }
            if let value = dict["UserPanes"] as? [Any?] {
                var tmp : [UpdateRtcCloudRecordingRequest.MixLayoutParams.UserPanes] = []
                for v in value {
                    if v != nil {
                        var model = UpdateRtcCloudRecordingRequest.MixLayoutParams.UserPanes()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.userPanes = tmp
            }
        }
    }
    public class SubscribeParams : Tea.TeaModel {
        public class SubscribeUserIdList : Tea.TeaModel {
            public var sourceType: Int32?

            public var streamType: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.streamType != nil {
                    map["StreamType"] = self.streamType!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SourceType"] as? Int32 {
                    self.sourceType = value
                }
                if let value = dict["StreamType"] as? Int32 {
                    self.streamType = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var subscribeUserIdList: [UpdateRtcCloudRecordingRequest.SubscribeParams.SubscribeUserIdList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.subscribeUserIdList != nil {
                var tmp : [Any] = []
                for k in self.subscribeUserIdList! {
                    tmp.append(k.toMap())
                }
                map["SubscribeUserIdList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SubscribeUserIdList"] as? [Any?] {
                var tmp : [UpdateRtcCloudRecordingRequest.SubscribeParams.SubscribeUserIdList] = []
                for v in value {
                    if v != nil {
                        var model = UpdateRtcCloudRecordingRequest.SubscribeParams.SubscribeUserIdList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.subscribeUserIdList = tmp
            }
        }
    }
    public var mixLayoutParams: UpdateRtcCloudRecordingRequest.MixLayoutParams?

    public var subscribeParams: UpdateRtcCloudRecordingRequest.SubscribeParams?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mixLayoutParams?.validate()
        try self.subscribeParams?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixLayoutParams != nil {
            map["MixLayoutParams"] = self.mixLayoutParams?.toMap()
        }
        if self.subscribeParams != nil {
            map["SubscribeParams"] = self.subscribeParams?.toMap()
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MixLayoutParams"] as? [String: Any?] {
            var model = UpdateRtcCloudRecordingRequest.MixLayoutParams()
            model.fromMap(value)
            self.mixLayoutParams = model
        }
        if let value = dict["SubscribeParams"] as? [String: Any?] {
            var model = UpdateRtcCloudRecordingRequest.SubscribeParams()
            model.fromMap(value)
            self.subscribeParams = model
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class UpdateRtcCloudRecordingShrinkRequest : Tea.TeaModel {
    public var mixLayoutParamsShrink: String?

    public var subscribeParamsShrink: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mixLayoutParamsShrink != nil {
            map["MixLayoutParams"] = self.mixLayoutParamsShrink!
        }
        if self.subscribeParamsShrink != nil {
            map["SubscribeParams"] = self.subscribeParamsShrink!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MixLayoutParams"] as? String {
            self.mixLayoutParamsShrink = value
        }
        if let value = dict["SubscribeParams"] as? String {
            self.subscribeParamsShrink = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class UpdateRtcCloudRecordingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class UpdateRtcCloudRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRtcCloudRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRtcCloudRecordingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRtcMPUEventSubRequest : Tea.TeaModel {
    public var appId: String?

    public var callbackUrl: String?

    public var channelIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.callbackUrl != nil {
            map["CallbackUrl"] = self.callbackUrl!
        }
        if self.channelIds != nil {
            map["ChannelIds"] = self.channelIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CallbackUrl"] as? String {
            self.callbackUrl = value
        }
        if let value = dict["ChannelIds"] as? String {
            self.channelIds = value
        }
    }
}

public class UpdateRtcMPUEventSubResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRtcMPUEventSubResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRtcMPUEventSubResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRtcMPUEventSubResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateRtsLiveStreamTranscodeRequest : Tea.TeaModel {
    public var app: String?

    public var audioBitrate: Int32?

    public var audioChannelNum: Int32?

    public var audioCodec: String?

    public var audioProfile: String?

    public var audioRate: Int32?

    public var deleteBframes: Bool?

    public var domain: String?

    public var FPS: Int32?

    public var gop: String?

    public var height: Int32?

    public var lazy_: String?

    public var opus: Bool?

    public var ownerId: Int64?

    public var profile: Int32?

    public var regionId: String?

    public var template: String?

    public var templateType: String?

    public var videoBitrate: Int32?

    public var width: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.app != nil {
            map["App"] = self.app!
        }
        if self.audioBitrate != nil {
            map["AudioBitrate"] = self.audioBitrate!
        }
        if self.audioChannelNum != nil {
            map["AudioChannelNum"] = self.audioChannelNum!
        }
        if self.audioCodec != nil {
            map["AudioCodec"] = self.audioCodec!
        }
        if self.audioProfile != nil {
            map["AudioProfile"] = self.audioProfile!
        }
        if self.audioRate != nil {
            map["AudioRate"] = self.audioRate!
        }
        if self.deleteBframes != nil {
            map["DeleteBframes"] = self.deleteBframes!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.FPS != nil {
            map["FPS"] = self.FPS!
        }
        if self.gop != nil {
            map["Gop"] = self.gop!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.lazy_ != nil {
            map["Lazy"] = self.lazy_!
        }
        if self.opus != nil {
            map["Opus"] = self.opus!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.profile != nil {
            map["Profile"] = self.profile!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.template != nil {
            map["Template"] = self.template!
        }
        if self.templateType != nil {
            map["TemplateType"] = self.templateType!
        }
        if self.videoBitrate != nil {
            map["VideoBitrate"] = self.videoBitrate!
        }
        if self.width != nil {
            map["Width"] = self.width!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["App"] as? String {
            self.app = value
        }
        if let value = dict["AudioBitrate"] as? Int32 {
            self.audioBitrate = value
        }
        if let value = dict["AudioChannelNum"] as? Int32 {
            self.audioChannelNum = value
        }
        if let value = dict["AudioCodec"] as? String {
            self.audioCodec = value
        }
        if let value = dict["AudioProfile"] as? String {
            self.audioProfile = value
        }
        if let value = dict["AudioRate"] as? Int32 {
            self.audioRate = value
        }
        if let value = dict["DeleteBframes"] as? Bool {
            self.deleteBframes = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["FPS"] as? Int32 {
            self.FPS = value
        }
        if let value = dict["Gop"] as? String {
            self.gop = value
        }
        if let value = dict["Height"] as? Int32 {
            self.height = value
        }
        if let value = dict["Lazy"] as? String {
            self.lazy_ = value
        }
        if let value = dict["Opus"] as? Bool {
            self.opus = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Profile"] as? Int32 {
            self.profile = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Template"] as? String {
            self.template = value
        }
        if let value = dict["TemplateType"] as? String {
            self.templateType = value
        }
        if let value = dict["VideoBitrate"] as? Int32 {
            self.videoBitrate = value
        }
        if let value = dict["Width"] as? Int32 {
            self.width = value
        }
    }
}

public class UpdateRtsLiveStreamTranscodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateRtsLiveStreamTranscodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateRtsLiveStreamTranscodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateRtsLiveStreamTranscodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class VerifyLiveDomainOwnerRequest : Tea.TeaModel {
    public var domainName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var verifyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.verifyType != nil {
            map["VerifyType"] = self.verifyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["VerifyType"] as? String {
            self.verifyType = value
        }
    }
}

public class VerifyLiveDomainOwnerResponseBody : Tea.TeaModel {
    public var content: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class VerifyLiveDomainOwnerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: VerifyLiveDomainOwnerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = VerifyLiveDomainOwnerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
